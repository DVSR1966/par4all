/* 
 * Command line: opannotate hyantes-static-99_accel --source 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: Intel Core/i7, speed 2933.3 MHz (estimated)
 * Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (No unit mask) count 100000
 */
/* 
 * Total samples for file : "/home/janice/par4all/examples/P4A/Hyantes/hyantes-static-99.p4a.c"
 * 
 *  31654 99.9968
 */


               :/* Use the Par4All accelerator run time: */
               :#include <p4a_accel.h>
               :/*
               : * file for hyantes-static-99.c
               : */
               :/* For more information about this application excerpt, look at:
               :
               :   http://hyantes.gforge.inria.fr
               :
               :   Hyantes is a library to compute neighbourhood population potential with
               :   scale control. It is developed by the Mescal team from the Laboratoire
               :   Informatique de Grenoble, as a part of Hypercarte project. The
               :   Hypercarte project aims to develop new methods for the cartographic
               :   representation of human distributions (population density, population
               :   increase, etc.) with various smoothing functions and opportunities for
               :   time-scale animations of maps. Hyantes provides one of the smoothing
               :   methods related to multiscalar neighbourhood density estimation. It is
               :   a C library that takes sets of geographic data as inputs and computes a
               :   smoothed representation of this data taking account of neighbourhood's
               :   influence.
               :*/
               :
               :#include <stdio.h>
               :#include <stdlib.h>
               :#include <math.h>
               :typedef double data_t;
               :typedef struct {
               :   data_t latitude;
               :   data_t longitude;
               :   data_t stock;
               :} town;
               :typedef struct {
               :   size_t n;
               :   town *data;
               :} towns;
               :
               :towns read_towns(const  char fname[]);
               :
               :
               :void run(data_t xmin, data_t ymin, data_t xmax, data_t ymax, data_t step, data_t range, town pt[290][299], town t[2878]);
               :
               :void display(town pt[290][299]);
               :
               :int main(int argc, char *argv[]);
               ://PIPS generated variable
               :void p4a_launcher_run(town pt[290][299], data_t range, data_t step, town t[2878], data_t xmin, data_t ymin), P4A_accel_malloc(void **address, size_t size), P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, const void *host_address, void *accel_address), P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, const void *host_address, void *accel_address), P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, const void *accel_address), P4A_accel_free(void *address);
               ://PIPS generated variable
               :P4A_accel_kernel_wrapper p4a_wrapper_run(size_t i, size_t j, town *pt, data_t range, data_t step, town *t, data_t xmin, data_t ymin);
               ://PIPS generated variable
               :P4A_accel_kernel p4a_kernel_run(size_t i, size_t j, town *pt, data_t range, data_t step, town *t, data_t xmin, data_t ymin);
               :P4A_accel_kernel_wrapper p4a_wrapper_run(size_t i, size_t j, town *pt, data_t range, data_t step, town *t, data_t xmin, data_t ymin)
     1  0.0032 :{ /* p4a_wrapper_run total:      3  0.0095 */
               :   // Index has been replaced by P4A_vp_1:
               :   i = P4A_vp_1;
               :   // Index has been replaced by P4A_vp_0:
               :   j = P4A_vp_0;
               :   // Loop nest P4A end
     1  0.0032 :   p4a_kernel_run(i, j, (town *) pt, range, step, t, xmin, ymin);
     1  0.0032 :}
  2508  7.9229 :P4A_accel_kernel p4a_kernel_run(size_t i, size_t j, town *pt, data_t range, data_t step, town *t, data_t xmin, data_t ymin)
     2  0.0063 :{ /* p4a_kernel_run total:  31634 99.9337 */
               :   //PIPS generated variable
               :   size_t k;
               :   // Loop nest P4A end
     4  0.0126 :   if (i<=289&&j<=298) {
    23  0.0727 :      (*(pt+299*i+j)).latitude = (xmin+step*i)*180/3.14159265358979323846;
    20  0.0632 :      (*(pt+299*i+j)).longitude = (ymin+step*j)*180/3.14159265358979323846;
               :      (*(pt+299*i+j)).stock = 0.;
   184  0.5813 :      for(k = 0; k <= 2877; k += 1) {
 20609 65.1050 :         data_t tmp = 6368.*acos(cos(xmin+step*i)*cos((*(t+k)).latitude)*cos(ymin+step*j-(*(t+k)).longitude)+sin(xmin+step*i)*sin((*(t+k)).latitude));
  2414  7.6260 :         if (tmp<range)
  5868 18.5374 :            (*(pt+299*i+j)).stock += (*(t+k)).stock/(1+tmp);
               :      }
               :   }
     2  0.0063 :}
               :void p4a_launcher_run(town pt[290][299], data_t range, data_t step, town t[2878], data_t xmin, data_t ymin)
               :{
               :   //PIPS generated variable
               :   size_t i, j, k;
    16  0.0505 :   P4A_call_accel_kernel_2d(p4a_wrapper_run, 299, 290, i, j, (town *) pt, range, step, t, xmin, ymin); /* p4a_launcher_run.omp_fn.0 total:     16  0.0505 */
               :}
               :towns read_towns(const  char fname[])
               :{
               :   FILE *fd = fopen(fname, "r");
               :   size_t curr = 0;
               :   char c;
               :   towns the_towns = {1, (town *) malloc(sizeof(town))};
               :   fprintf(stderr, "begin parsing ...\n");
               :
               :   while (!feof(fd)) {
               :      if (the_towns.n==curr) {
               :         the_towns.n *= 2;
               :
               :         the_towns.data = (town *) realloc(the_towns.data, the_towns.n*sizeof(town));
               :      }
               :      if (fscanf(fd, "%lf%*[ \t]%lf%*[ \t]%lf", &(the_towns.data)[curr].latitude, &(the_towns.data)[curr].longitude, &(the_towns.data)[curr].stock)!=3) {
               :l99999:         ;
               :         if (!!feof(fd)) goto break_2;
               :         c = (char) fgetc(fd);
               :         if (c=='\n'||c=='\r') {
               :         }
               :         else {
               :            goto l99999;
               :         }
               :break_2:         ;
               :      }
               :      else {
               :         (the_towns.data)[curr].latitude *= 3.14159265358979323846/180;
               :         (the_towns.data)[curr].longitude *= 3.14159265358979323846/180;
               :         ++curr;
               :      }
               :   }
               :   fclose(fd);
               :   the_towns.data = (town *) realloc(the_towns.data, curr*sizeof(town));
               :   the_towns.n = curr;
               :   fprintf(stderr, "parsed %zu towns\n", curr);
               :   /*
               :       for(curr=0;curr<the_towns.nb;curr++)
               :           fprintf(stderr,OUTPUT_FORMAT,the_towns.data[curr][0],the_towns.data[curr][1],the_towns.data[curr][2]);
               :       */
               :   return the_towns;
               :}
               :void run(data_t xmin, data_t ymin, data_t xmax, data_t ymax, data_t step, data_t range, town pt[290][299], town t[2878])
               :{
               :   size_t i, j, k;
               :
               :   fprintf(stderr, "begin computation ...\n");
               :   {
               :      //PIPS generated variable
               :      town (*P4A_var_t0)[2878] = (town (*)[2878]) 0, (*P4A_var_pt0)[290][299] = (town (*)[290][299]) 0;
               :      P4A_accel_malloc((void **) &P4A_var_pt0, sizeof(pt[0][0])*86710);
               :      P4A_accel_malloc((void **) &P4A_var_t0, sizeof(t[0])*2878);
               :      P4A_copy_to_accel_2d(sizeof(pt[0][0]), 290, 299, 290, 299, 0, 0, &pt[0][0], *P4A_var_pt0);
               :      P4A_copy_to_accel_1d(sizeof(t[0]), 2878, 2878, 0, &t[0], *P4A_var_t0);
               :
               :
               :      p4a_launcher_run(*P4A_var_pt0, range, step, *P4A_var_t0, xmin, ymin);
               :      P4A_copy_from_accel_2d(sizeof(pt[0][0]), 290, 299, 290, 299, 0, 0, &pt[0][0], *P4A_var_pt0);
               :      P4A_accel_free(P4A_var_pt0);
               :      P4A_accel_free(P4A_var_t0);
               :   }
               :   fprintf(stderr, "end computation ...\n");
               :}
               :void display(town pt[290][299])
               :{ /* display total:      2  0.0063 */
               :   size_t i, j;
               :   for(i = 0; i <= 289; i += 1) {
     1  0.0032 :      for(j = 0; j <= 298; j += 1)
               :         printf("%lf %lf %lf\n", pt[i][j].latitude, pt[i][j].longitude, pt[i][j].stock);
               :      printf("\n");
               :   }
               :}
               :int main(int argc, char *argv[])
               :{
               :   P4A_init_accel;
               :   if (argc!=8)
               :      return 1;
               :   {
               :      town pt[290][299];
               :      towns t = read_towns(argv[1]);
               :      
               :      
               :      
               :      
               :      
               :      data_t xmin = atof(argv[2])*3.14159265358979323846/180., ymin = atof(argv[3])*3.14159265358979323846/180., xmax = atof(argv[4])*3.14159265358979323846/180., ymax = atof(argv[5])*3.14159265358979323846/180., step = atof(argv[6])*3.14159265358979323846/180., range = atof(argv[7]);
               :      run(xmin, ymin, xmax, ymax, step, range, pt, t.data);
               :      display(pt);
               :   }
               :   return 0;
               :}
/* 
 * Total samples for file : "/usr/include/bits/stdio2.h"
 * 
 *      1  0.0032
 */


               :/* Checking macros for stdio functions.
               :   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
               :   This file is part of the GNU C Library.
               :
               :   The GNU C Library is free software; you can redistribute it and/or
               :   modify it under the terms of the GNU Lesser General Public
               :   License as published by the Free Software Foundation; either
               :   version 2.1 of the License, or (at your option) any later version.
               :
               :   The GNU C Library is distributed in the hope that it will be useful,
               :   but WITHOUT ANY WARRANTY; without even the implied warranty of
               :   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
               :   Lesser General Public License for more details.
               :
               :   You should have received a copy of the GNU Lesser General Public
               :   License along with the GNU C Library; if not, write to the Free
               :   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
               :   02111-1307 USA.  */
               :
               :#ifndef _STDIO_H
               :# error "Never include <bits/stdio2.h> directly; use <stdio.h> instead."
               :#endif
               :
               :extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
               :			  __const char *__restrict __format, ...) __THROW;
               :extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
               :			   __const char *__restrict __format,
               :			   _G_va_list __ap) __THROW;
               :
               :#ifdef __va_arg_pack
               :__extern_always_inline int
               :__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
               :{
               :  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
               :				  __bos (__s), __fmt, __va_arg_pack ());
               :}
               :#elif !defined __cplusplus
               :# define sprintf(str, ...) \
               :  __builtin___sprintf_chk (str, __USE_FORTIFY_LEVEL - 1, __bos (str), \
               :			   __VA_ARGS__)
               :#endif
               :
               :__extern_always_inline int
               :__NTH (vsprintf (char *__restrict __s, __const char *__restrict __fmt,
               :		 _G_va_list __ap))
               :{
               :  return __builtin___vsprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
               :				   __bos (__s), __fmt, __ap);
               :}
               :
               :#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
               :
               :extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
               :			   size_t __slen, __const char *__restrict __format,
               :			   ...) __THROW;
               :extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
               :			    size_t __slen, __const char *__restrict __format,
               :			    _G_va_list __ap) __THROW;
               :
               :# ifdef __va_arg_pack
               :__extern_always_inline int
               :__NTH (snprintf (char *__restrict __s, size_t __n,
               :		 __const char *__restrict __fmt, ...))
               :{
               :  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
               :				   __bos (__s), __fmt, __va_arg_pack ());
               :}
               :# elif !defined __cplusplus
               :#  define snprintf(str, len, ...) \
               :  __builtin___snprintf_chk (str, len, __USE_FORTIFY_LEVEL - 1, __bos (str), \
               :			    __VA_ARGS__)
               :# endif
               :
               :__extern_always_inline int
               :__NTH (vsnprintf (char *__restrict __s, size_t __n,
               :		  __const char *__restrict __fmt, _G_va_list __ap))
               :{
               :  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
               :				    __bos (__s), __fmt, __ap);
               :}
               :
               :#endif
               :
               :#if __USE_FORTIFY_LEVEL > 1
               :
               :extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
               :			  __const char *__restrict __format, ...);
               :extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
               :extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
               :			   __const char *__restrict __format, _G_va_list __ap);
               :extern int __vprintf_chk (int __flag, __const char *__restrict __format,
               :			  _G_va_list __ap);
               :
               :# ifdef __va_arg_pack
               :__extern_always_inline int
               :fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
               :{
               :  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
               :			__va_arg_pack ());
               :}
               :
               :__extern_always_inline int
               :printf (__const char *__restrict __fmt, ...)
               :{
     1  0.0032 :  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
               :}
               :# elif !defined __cplusplus
               :#  define printf(...) \
               :  __printf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :#  define fprintf(stream, ...) \
               :  __fprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :# endif
               :
               :__extern_always_inline int
               :vprintf (__const char *__restrict __fmt, _G_va_list __ap)
               :{
               :#ifdef __USE_EXTERN_INLINES
               :  return __vfprintf_chk (stdout, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
               :#else
               :  return __vprintf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __ap);
               :#endif
               :}
               :
               :__extern_always_inline int
               :vfprintf (FILE *__restrict __stream,
               :	  __const char *__restrict __fmt, _G_va_list __ap)
               :{
               :  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
               :}
               :
               :# ifdef __USE_GNU
               :
               :extern int __asprintf_chk (char **__restrict __ptr, int __flag,
               :			   __const char *__restrict __fmt, ...)
               :     __THROW __attribute__ ((__format__ (__printf__, 3, 4))) __wur;
               :extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
               :			    __const char *__restrict __fmt, _G_va_list __arg)
               :     __THROW __attribute__ ((__format__ (__printf__, 3, 0))) __wur;
               :extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
               :			  ...) __attribute__ ((__format__ (__printf__, 3, 4)));
               :extern int __vdprintf_chk (int __fd, int __flag,
               :			   __const char *__restrict __fmt, _G_va_list __arg)
               :     __attribute__ ((__format__ (__printf__, 3, 0)));
               :extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
               :				 int __flag, __const char *__restrict __format,
               :				 ...)
               :     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));
               :extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
               :				  int __flag,
               :				  __const char *__restrict __format,
               :				  _G_va_list __args)
               :     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
               :
               :#  ifdef __va_arg_pack
               :__extern_always_inline int
               :__NTH (asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...))
               :{
               :  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
               :			 __va_arg_pack ());
               :}
               :
               :__extern_always_inline int
               :__NTH (__asprintf (char **__restrict __ptr, __const char *__restrict __fmt,
               :		   ...))
               :{
               :  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
               :			 __va_arg_pack ());
               :}
               :
               :__extern_always_inline int
               :dprintf (int __fd, __const char *__restrict __fmt, ...)
               :{
               :  return __dprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt,
               :			__va_arg_pack ());
               :}
               :
               :__extern_always_inline int
               :__NTH (obstack_printf (struct obstack *__restrict __obstack,
               :		       __const char *__restrict __fmt, ...))
               :{
               :  return __obstack_printf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
               :			       __va_arg_pack ());
               :}
               :#  elif !defined __cplusplus
               :#   define asprintf(ptr, ...) \
               :  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :#   define __asprintf(ptr, ...) \
               :  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :#   define dprintf(fd, ...) \
               :  __dprintf_chk (fd, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :#   define obstack_printf(obstack, ...) \
               :  __obstack_printf_chk (obstack, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
               :#  endif
               :
               :__extern_always_inline int
               :__NTH (vasprintf (char **__restrict __ptr, __const char *__restrict __fmt,
               :		  _G_va_list __ap))
               :{
               :  return __vasprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
               :}
               :
               :__extern_always_inline int
               :vdprintf (int __fd, __const char *__restrict __fmt, _G_va_list __ap)
               :{
               :  return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
               :}
               :
               :__extern_always_inline int
               :__NTH (obstack_vprintf (struct obstack *__restrict __obstack,
               :			__const char *__restrict __fmt, _G_va_list __ap))
               :{
               :  return __obstack_vprintf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
               :				__ap);
               :}
               :
               :# endif
               :
               :#endif
               :
               :extern char *__gets_chk (char *__str, size_t) __wur;
               :extern char *__REDIRECT (__gets_warn, (char *__str), gets)
               :     __wur __warnattr ("please use fgets or getline instead, gets can't "
               :		       "specify buffer size");
               :
               :__extern_always_inline __wur char *
               :gets (char *__str)
               :{
               :  if (__bos (__str) != (size_t) -1)
               :    return __gets_chk (__str, __bos (__str));
               :  return __gets_warn (__str);
               :}
               :
               :extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
               :			  FILE *__restrict __stream) __wur;
               :extern char *__REDIRECT (__fgets_alias,
               :			 (char *__restrict __s, int __n,
               :			  FILE *__restrict __stream), fgets) __wur;
               :extern char *__REDIRECT (__fgets_chk_warn,
               :			 (char *__restrict __s, size_t __size, int __n,
               :			  FILE *__restrict __stream), __fgets_chk)
               :     __wur __warnattr ("fgets called with bigger size than length "
               :		       "of destination buffer");
               :
               :__extern_always_inline __wur char *
               :fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
               :{
               :  if (__bos (__s) != (size_t) -1)
               :    {
               :      if (!__builtin_constant_p (__n) || __n <= 0)
               :	return __fgets_chk (__s, __bos (__s), __n, __stream);
               :
               :      if ((size_t) __n > __bos (__s))
               :	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
               :    }
               :  return __fgets_alias (__s, __n, __stream);
               :}
               :
               :extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
               :			   size_t __size, size_t __n,
               :			   FILE *__restrict __stream) __wur;
               :extern size_t __REDIRECT (__fread_alias,
               :			  (void *__restrict __ptr, size_t __size,
               :			   size_t __n, FILE *__restrict __stream),
               :			  fread) __wur;
               :extern size_t __REDIRECT (__fread_chk_warn,
               :			  (void *__restrict __ptr, size_t __ptrlen,
               :			   size_t __size, size_t __n,
               :			   FILE *__restrict __stream),
               :			  __fread_chk)
               :     __wur __warnattr ("fread called with bigger size * nmemb than length "
               :		       "of destination buffer");
               :
               :__extern_always_inline __wur size_t
               :fread (void *__restrict __ptr, size_t __size, size_t __n,
               :       FILE *__restrict __stream)
               :{
               :  if (__bos0 (__ptr) != (size_t) -1)
               :    {
               :      if (!__builtin_constant_p (__size)
               :	  || !__builtin_constant_p (__n)
               :	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
               :	return __fread_chk (__ptr, __bos0 (__ptr), __size, __n, __stream);
               :
               :      if (__size * __n > __bos0 (__ptr))
               :	return __fread_chk_warn (__ptr, __bos0 (__ptr), __size, __n, __stream);
               :    }
               :  return __fread_alias (__ptr, __size, __n, __stream);
               :}
               :
               :#ifdef __USE_GNU
               :extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
               :				   int __n, FILE *__restrict __stream) __wur;
               :extern char *__REDIRECT (__fgets_unlocked_alias,
               :			 (char *__restrict __s, int __n,
               :			  FILE *__restrict __stream), fgets_unlocked) __wur;
               :extern char *__REDIRECT (__fgets_unlocked_chk_warn,
               :			 (char *__restrict __s, size_t __size, int __n,
               :			  FILE *__restrict __stream), __fgets_unlocked_chk)
               :     __wur __warnattr ("fgets_unlocked called with bigger size than length "
               :		       "of destination buffer");
               :
               :__extern_always_inline __wur char *
               :fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
               :{
               :  if (__bos (__s) != (size_t) -1)
               :    {
               :      if (!__builtin_constant_p (__n) || __n <= 0)
               :	return __fgets_unlocked_chk (__s, __bos (__s), __n, __stream);
               :
               :      if ((size_t) __n > __bos (__s))
               :	return __fgets_unlocked_chk_warn (__s, __bos (__s), __n, __stream);
               :    }
               :  return __fgets_unlocked_alias (__s, __n, __stream);
               :}
               :#endif
               :
               :#ifdef __USE_MISC
               :# undef fread_unlocked
               :extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
               :				    size_t __size, size_t __n,
               :				    FILE *__restrict __stream) __wur;
               :extern size_t __REDIRECT (__fread_unlocked_alias,
               :			  (void *__restrict __ptr, size_t __size,
               :			   size_t __n, FILE *__restrict __stream),
               :			  fread_unlocked) __wur;
               :extern size_t __REDIRECT (__fread_unlocked_chk_warn,
               :			  (void *__restrict __ptr, size_t __ptrlen,
               :			   size_t __size, size_t __n,
               :			   FILE *__restrict __stream),
               :			  __fread_unlocked_chk)
               :     __wur __warnattr ("fread_unlocked called with bigger size * nmemb than "
               :		       "length of destination buffer");
               :
               :__extern_always_inline __wur size_t
               :fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
               :		FILE *__restrict __stream)
               :{
               :  if (__bos0 (__ptr) != (size_t) -1)
               :    {
               :      if (!__builtin_constant_p (__size)
               :	  || !__builtin_constant_p (__n)
               :	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
               :	return __fread_unlocked_chk (__ptr, __bos0 (__ptr), __size, __n,
               :				     __stream);
               :
               :      if (__size * __n > __bos0 (__ptr))
               :	return __fread_unlocked_chk_warn (__ptr, __bos0 (__ptr), __size, __n,
               :					  __stream);
               :    }
               :
               :# ifdef __USE_EXTERN_INLINES
               :  if (__builtin_constant_p (__size)
               :      && __builtin_constant_p (__n)
               :      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
               :      && __size * __n <= 8)
               :    {
               :      size_t __cnt = __size * __n;
               :      char *__cptr = (char *) __ptr;
               :      if (__cnt == 0)
               :	return 0;
               :
               :      for (; __cnt > 0; --__cnt)
               :	{
               :	  int __c = _IO_getc_unlocked (__stream);
               :	  if (__c == EOF)
               :	    break;
               :	  *__cptr++ = __c;
               :	}
               :      return (__cptr - (char *) __ptr) / __size;
               :    }
               :# endif
               :  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
               :}
               :#endif
