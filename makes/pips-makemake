#! /bin/sh
# for debug, try: /bin/sh -vx
#
# $RCSfile: pips-makemake,v $ ($Date: 1995/09/25 13:04:49 $, )
# version $Revision$
#
# Automatic generation of Makefile for the PIPS project
#
# Remi Triolet, Bruno Baron
# Fabien Coelho, 08/95
#

SCRIPT=`basename $0`
USAGE="$SCRIPT [-h (HELP!)] [-l|p|s|r|i|n] [-D|P] [-c|a] (default -c)"

MAKEFILE=Makefile
CONFIG_FILE=config.makefile

help()
{
  cat <<-END_OF_HELP
	$USAGE
	version $Revision$
	Builds $MAKEFILE from $CONFIG_FILE for PIPS.
	  -l|p|s|r|i|n: libraries|passes|scripts|runtime|linear|newgen
	  -D|P: for Development|Production directories
	  -c|a: for the current|all directory(ies)
	  -h: this help
	  contextual defaults for first and second options.
	Usefull macros in $CONFIG_FILE:
	 - libraries: LIB_{CFILES,HEADERS,OBJECTS}
	   and maybe DERIVED_{HEADERS,CFILES,FILES}
	 - passes: TARGET_{CFILES,HEADERS,OBJECTS,LIBS}
	 - scripts: SCRIPTS, FILES, SFILES, RFILES
	 - runtime: SOURCES, INSTALL_{FILES,LIBS,EXE}
	 - c3/linear: 
	 - newgen:
	Many default macros are defined and may be overwritten.
	Many rules are also defined.
	END_OF_HELP
}

usage()
{
  echo "usage: $USAGE" >&2
  [ "$2" ] && echo "error: $2" >&2
  exit ${1:-1}
}

warning()
{
  echo "$SCRIPT: warning, $@" >&2 
}

#
# what is to be done...

DIRSIDE=''
DIRTYPE=''
DIRS='.'
ALL=''
ALL_RULE_TARGET=''

while getopts lpsrinDPcah opt
do
  case $opt in
    l) DIRTYPE='Lib' ;;
    p) DIRTYPE='Passes' ;;
    s) DIRTYPE='Scripts' ;;
    r) DIRTYPE='Runtime' ;;
    i) DIRTYPE='Linear' ;;
    n) DIRTYPE='Newgen' ;;
    D) DIRSIDE="$PIPS_DEVEDIR" ;;
    P) DIRSIDE="$PIPS_SRCDIR" ;;
    c) DIRS='.';;
    a) ALL='1' ;;
    h) help ; exit 0 ;;
    *) usage 2 "invalid option ($opt)" ;;
  esac
done
shift `expr $OPTIND - 1`

[ $# -eq 0 ] || usage 3 "$# remaining parameters"

current_directory=`pwd`
cd_dirname=`dirname $current_directory`

# set defaults if necessary

[ "${DIRTYPE}" ] || DIRTYPE=`basename $cd_dirname`
[ "${DIRSIDE}" ] || 
{
  if [ "`echo $cd_dirname | sed 's,^.*/Production/.*$,,'`" ]
  then
    DIRSIDE="$PIPS_DEVEDIR" 
  else
    DIRSIDE="$PIPS_SRCDIR"
  fi
}

# delayed here to ensure that DIRTYPE is available

[ "$ALL" ] && DIRS=${DIRSIDE}/${DIRTYPE}/*

# directories for quick-install:
#
# install_file_dir for usual files
# install_lib_dir for library files
# install_exe_dir for executable files

PART=PIPS
install_file_dir='$(PIPS_INCLUDEDIR)'
install_lib_dir='$(PIPS_LIBDIR)'
install_exe_dir='$(PIPS_BINDIR)'

case $DIRTYPE in
  Lib) ALL_RULE_TARGET='lib$(TARGET).a' ;;
  Passes)  ALL_RULE_TARGET='$(TARGET)' ;;
  Scripts) ALL_RULE_TARGET='.runable' ;
           install_file_dir='$(PIPS_UTILDIR)' ;
           install_lib_dir='$(PIPS_UTILDIR)' ;
           install_exe_dir='$(PIPS_UTILDIR)' ;;
  Runtime) ALL_RULE_TARGET='' ;
           install_file_dir='$(PIPS_EXTEDIR)' ;
           install_exe_dir='$(PIPS_EXTEDIR)' ;
           install_lib_dir='$(PIPS_EXTEDIR)' ;;
  Linear)  ALL_RULE_TARGET='' ;
           PART=LINEAR ;
           install_file_dir='$(PIPS_EXTEDIR)' ;
           install_exe_dir='$(PIPS_EXTEDIR)' ;
           install_lib_dir='$(PIPS_EXTEDIR)' ;;
  Newgen)  ALL_RULE_TARGET='' ;
           PART=NEWGEN ;
           install_file_dir='$(PIPS_EXTEDIR)' ;
           install_exe_dir='$(PIPS_EXTEDIR)' ;
           install_lib_dir='$(PIPS_EXTEDIR)' ;;
  *) usage 5 "unexpected directory type $DIRTYPE"
esac

### main loop
for dir in $DIRS
do
  [ -d $dir ] || continue
  cd $current_directory
  cd $dir
  
  [ -f $CONFIG_FILE ] || usage 6 "no $CONFIG_FILE in $dir" ;

  # needed because of f.. - in directory names...
  dir_real_name=`basename \`pwd\``
  dir_simple_name=`echo $dir_real_name | tr '-' '_'`
    
  echo making $DIRTYPE $MAKEFILE in $dir_real_name

  [ -f $MAKEFILE ] && 
  {
    rm -f $MAKEFILE.old ;
    mv $MAKEFILE $MAKEFILE.old;
  }
    
  [ -f $CONFIG_FILE ] || warning "no local $CONFIG_FILE"

  cat >> $MAKEFILE <<%
#	---------------------------------------------------------------
#	---------------------------------------------------------------
#
#				    WARNING
#
#		  This makefile has been automatically generated
#
#                        ($RCSfile: pips-makemake,v $ version $Revision$)
#
#			       Do not modify it
#
#        You can modify the file $CONFIG_FILE in the same directory
#
#	---------------------------------------------------------------
#	---------------------------------------------------------------
#
# Copyright (C) Ecole des Mines De Paris
#               Centre d'Automatique et Informatique
#               Section Informatique
#
# This file is part of PIPS
#
# PIPS is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY.  No author or distributor accepts responsibility to anyone for
# the consequences of using it or for whether it serves any particular
# purpose or works at all, unless he says so in writing.
#
# DEFAULTS, may be overwritten by the $CONFIG_FILE content.
#
TARGET=		${dir_real_name}
TARGETDIR=	$(PIPS_SRCDIR)/${DIRTYPE}/$(TARGET)
#
# installation directories for quick-install
#
INSTALL_FILE_DIR= ${install_file_dir}
INSTALL_LIB_DIR=  ${install_lib_dir}
INSTALL_EXE_DIR=  ${install_exe_dir}
# (obsolete?)
MAIN=		main
#
AR=             $(${PART}_AR)
ARFLAGS=        $(${PART}_ARFLAGS)
CC=             $(${PART}_CC)
CFLAGS=         $(${PART}_CFLAGS)
CPPFLAGS=       $(${PART}_CPPFLAGS)
LD=             $(${PART}_LD)
LDFLAGS=        $(${PART}_LDFLAGS)
LEX=            $(${PART}_LEX)
LFLAGS=         $(${PART}_LFLAGS)
LINT=           $(${PART}_LINT)
LINTFLAGS=      $(${PART}_LINTFLAGS)
YACC=           $(${PART}_YACC)
YFLAGS=         $(${PART}_YFLAGS)
TAR=		$(${PART}_TAR)
ZIP=		$(${PART}_ZIP)
DIFF= 		$(${PART}_DIFF)
M4=		$(${PART}_M4)
PROTO=		$(${PART}_PROTOIZE)
# 
#
CONFIG_FILE=	${CONFIG_FILE}
MAKEFILE=	${MAKEFILE}
SHELL=		/bin/sh

#
all: $ALL_RULE_TARGET
recompile: depend header all
# to override sun's default rule
.SCCS_GET:
.INIT: $(MAKEFILE)
check_install:
#
# begin of $CONFIG_FILE inclusion
#
include $CONFIG_FILE
#
# end of $CONFIG_FILE inclusion
#
%

[ $DIRTYPE = 'Lib' -o $DIRTYPE = 'Passes' ] && cat >> $MAKEFILE <<% 
#
PREPROC=	$(CC) -E $(CPPFLAGS) $(TARGET_ARCH)
COMPILE=	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
LINK=		$(LD) $(LDFLAGS) -o
SCAN=		$(LEX) $(LFLAGS) -t
TYPECHECK=      $(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH) $(LINT_LIBS)
PARSE=		$(YACC) $(YFLAGS)
ARCHIVE=	$(AR) $(ARFLAGS)
PROTOIZE=	$(PROTO) -e -E "$(PREPROC)"
#
LIB_TARGET=	lib$(TARGET).a
BIN_TARGET=	$(TARGET)
INC_TARGET=	$(TARGET).h
#
INSTALL_FILE=	$(INC_TARGET)
INSTALL_LIB=	$(LIB_TARGET)
INSTALL_EXE=	`if [ $DIRTYPE = 'Passes' ] ; then echo '$(BIN_TARGET)' ; fi`
#

.PRECIOUS: $(LIB_TARGET) $(BIN_TARGET)

.INIT: check_os

check_install:
	@if test \`echo *.a | wc -w\` -gt 1 ; \\
	then \\
	  echo "install failed: additional local libraries prevent it" >&2;\\
	  exit 1;\\
	fi

$(LIB_TARGET): $(LIB_OBJECTS) $(TARGET_OBJECTS)
	$(RM) $(LIB_TARGET)
	$(ARCHIVE) $(LIB_TARGET) $(LIB_OBJECTS) $(TARGET_OBJECTS)
	ranlib $(LIB_TARGET)

%

[ $DIRTYPE = 'Scripts' ] && cat >> $MAKEFILE <<%

all: $(RFILES)

SOURCES=	$(SCRIPTS) $(FILES) $(SFILES) $(CONFIG_FILE)
INSTALL_FILE=	$(FILES)
INSTALL_LIB=
INSTALL_EXE=	$(SCRIPTS) $(RFILES)

.runable: $(SCRIPTS)
	-[ "$(SCRIPTS)" ] && chmod a+x $(SCRIPTS)
	touch .runable

.quick-install: .runable $(RFILES)

%

[ $DIRTYPE = 'Lib' ] && cat >> $MAKEFILE <<% 
#
CFILES=		$(MAIN).c $(LIB_CFILES)
OBJECTS=	$(MAIN).o $(LIB_OBJECTS)
INCLUDES=	$(LIB_HEADERS)
SOURCES= 	$(CONFIG_FILE) $(INCLUDES) $(CFILES)
#

test: $(LIB_TARGET)
	$(LINK) pips -lpips $(PIPS_LIBS)
	@echo 

wtest: $(LIB_TARGET) 
	$(LINK) wpips $(WPIPS_ADDED_LDFLAGS) -lwpips \\
		$(PIPS_LIBS) $(WPIPS_ADDED_LIBS)
	@echo 

ttest: $(LIB_TARGET)
	$(LINK) tpips -ltpips $(PIPS_LIBS) $(TPIPS_ADDED_LIBS)
	@echo 

# obsolete rule I guess. test is better. FC.
$(BIN_TARGET): $(LIB_TARGET) $(MAIN).o
	$(LINK) $(TARGET) $(MAIN).o $(LIB_TARGET) $(PIPS_LIBS)
	@echo 

clean:
	-$(RM) TAGS $(OBJECTS) $(INC_TARGET) $(LIB_TARGET) \\
		$(BIN_TARGET) $(DERIVED_HEADERS) $(DERIVED_CFILES) \\
		$(DERIVED_FILES) *.~[0-9]~ $(LIB_IFILES)

clobber: clean
	-Delete *.database

INC_CFILES = $(LIB_CFILES)

%

[ $DIRTYPE = 'Passes' ] && cat >> $MAKEFILE <<% 
#
# a little bit rough...
#
$(TARGET): $(PIPS_LIBDIR)/*.a
#
CFILES=		$(TARGET_CFILES)
OBJECTS=	$(TARGET_OBJECTS)
INCLUDES=	$(TARGET_HEADERS)
SOURCES= 	$(CONFIG_FILE) $(INCLUDES) $(CFILES)
#
# TARGETDIR=	$(PIPS_BINSRCDIR)/$(TARGET)
#

$(PIPS_BINDIR):
	mkdir $(PIPS_BINDIR)

$(BIN_TARGET): $(INC_TARGET) $(LIB_TARGET)
	$(LINK) $(BIN_TARGET) $(LIB_TARGET) $(TARGET_LIBS)
	@echo 

clean:
	-$(RM) TAGS $(OBJECTS) $(BIN_TARGET) $(LIB_TARGET) \\
		$(INC_TARGET) $(DERIVED_HEADERS) $(DERIVED_CFILES) \\
		$(DERIVED_FILES) *.~[0-9]~

INC_CFILES = $(TARGET_CFILES)

%

[ \( $DIRTYPE = 'Passes' -o $DIRTYPE = 'Lib' \) -a $DIRSIDE = $PIPS_SRCDIR ] &&
cat >> $MAKEFILE <<%

.PRECIOUS: $(PIPS_LIBDIR)/$(LIB_TARGET) $(PIPS_BINDIR)/$(BIN_TARGET)

$(PIPS_INCLUDEDIR)/$(TARGET).h: header
	@pips_install_file -f $(PIPS_INCLUDEDIR) $(TARGET).h

$(PIPS_LIBDIR)/$(LIB_TARGET): $(LIB_TARGET) 
	cp $(LIB_TARGET) $(PIPS_LIBDIR)
	ranlib $(PIPS_LIBDIR)/$(LIB_TARGET)

$(LIB_OBJECTS): $(TARGET).h

recompile: $(PIPS_INCLUDEDIR)/$(TARGET).h $(PIPS_LIBDIR)/$(LIB_TARGET) 

%

[ $DIRTYPE = 'Passes' -a $DIRSIDE = $PIPS_SRCDIR ] &&
cat >> $MAKEFILE <<%

$(TARGET_OBJECTS): $(TARGET).h

$(PIPS_BINDIR)/$(BIN_TARGET): $(BIN_TARGET) $(PIPS_BINDIR)
	cp $(BIN_TARGET) $(PIPS_BINDIR)

recompile: $(PIPS_BINDIR)/$(BIN_TARGET)

%

###
#
# Common to all: installation and Makefile generation
#

cat >> $MAKEFILE <<%

$(TARGETDIR):
	mkdir $(TARGETDIR)

check_os:
	@if test -n "$(PIPS_CHECK_OS)"; \\
	then echo "Cannot run make under this OS release"; \\
	     echo "$(PIPS_CHECK_OS)"; exit 1; \\
	fi

.quick-install: $(INSTALL_FILE) $(INSTALL_LIB) $(INSTALL_EXE)
	@pips_install_file -f $(INSTALL_FILE_DIR) $(INSTALL_FILE)
	@pips_install_file -l $(INSTALL_LIB_DIR) $(INSTALL_LIB)
	@pips_install_file -x $(INSTALL_EXE_DIR) $(INSTALL_EXE)
	touch .quick-install

tar:
	$(TAR) cf $(TARGET).tar $(SOURCES) Makefile
	$(ZIP) $(TARGET).tar

quick-install: .quick-install

$MAKEFILE: 
	-@[ -x $(PIPS_UTILDIR)/pips-makemake ] && $(MAKE) .makefile

.makefile: $(PIPS_UTILDIR)/pips-makemake
	$(PIPS_UTILDIR)/pips-makemake
	touch .makefile

count:
	@wc -l $(SOURCES)

%

#
# partie specifique a Development

[ $DIRSIDE = $PIPS_DEVEDIR ] && cat >> $MAKEFILE <<%

# install installs sources, so depends on sources. FC
# to insure the library is compiled before hand, a make is added.
.install: $(SOURCES) 
	$(MAKE) check_install all $(TARGETDIR)
	@echo ""; echo; echo -n "Description of changes: " ; \\
	read comments ; \\
	install_pips_sources \\
		-v -s \`pwd\` -t $(TARGETDIR) -y "\$\$comments" \\
		$(SOURCES)
	-@cd $(TARGETDIR) ; pips-makemake
	touch .install
	$(MAKE) quick-install

install:  .install

#
# diff between dev and prod sources:

diff:
	-@for f in $(SOURCES) ; \\
	do \\
	  echo "DIFFERENCES BETWEEN DEV AND PROD FOR \$\$f:" ; \\
	  $(DIFF) \$\$f $(TARGETDIR)/\$\$f ; \\
	done

%

#
# La partie commune aux bibliotheques et aux passes :

[ $DIRTYPE = 'Lib' -o $DIRTYPE = 'Passes' ] && cat >> $MAKEFILE <<%
#

$(PIPS_LIBDIR):
	mkdir $(PIPS_LIBDIR)

lint:
	$(TYPECHECK) $(CFILES) | 
		sed '/possible pointer alignment/d;/gen_alloc/d'

TAGS: $(INCLUDES) $(CFILES)
	etags $(INCLUDES) $(CFILES)
	ctags $(INCLUDES) $(CFILES)

$(TARGET)-local.h:
	[ -f $(TARGET)-local.h ] || touch $(TARGET)-local.h

# headers are not generated automatically, bacause it should be
# done each time a c file is touched, which is too much...
# thus it does depend only of the -local.h.
# header file reconstruction should be required explicitely
# with the header rule.

$(INC_TARGET): $(TARGET)-local.h 
	$(MAKE) header
	
.header: $(TARGET)-local.h $(DERIVED_HEADERS) $(INC_CFILES)
	{ \\
	echo "#ifndef ${dir_simple_name}_header_included";\\
	echo "#define ${dir_simple_name}_header_included";\\
	cat $(TARGET)-local.h;\\
	$(PROTOIZE)  $(INC_CFILES);\\
	echo "#endif /* ${dir_simple_name}_header_included */";\\
	} > $(INC_TARGET).tmp
	mv $(INC_TARGET).tmp $(INC_TARGET)
	touch .header

# checks for the header file, and build if necessary...
header: .header
	-[ -f $(TARGET).h ] || { $(RM) .header ; $(MAKE) .header ; }

# indirect depend bacause I do not trust make for the inclusion of
# Makefile.depend if that very file does not exist.

.depend: $(CFILES)
	$(PREPROC) -M $(CFILES) > $(MAKEFILE).depend
	touch .depend

depend: $(INC_TARGET) $(MAKEFILE) .depend

#
# dependences are stored in another file which is simply included.
include $MAKEFILE.depend
%

touch .makefile

### generates the dependences...

[ $DIRTYPE = 'Lib' -o $DIRTYPE = 'Passes' ] &&
{
  touch $MAKEFILE.depend
  rm -f .depend
  make -f $MAKEFILE depend
}

### end good case

echo

### end main loop
done

