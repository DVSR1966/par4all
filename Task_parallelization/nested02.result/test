void main(int argc, char *argv[])
{
   //PIPS generated variable
   double b, a, C[10], B[10], A[10];
   //PIPS generated variable
   unsigned int N, i;
   barrier(
   spawn(0,
   N = 10;
   )
   )
   barrier(
   spawn(0,
   for(i = 0; i < N; i += 1) {
      barrier(
      spawn(1,
      B[i] = 3;
      )
      spawn(2,
      A[i] = 5;
      )
      )
   }
   )
   )
   barrier(
   spawn(0,
   for(i = 0; i < N; i += 1) {
      barrier(
      spawn(2,
      A[i] = A[i]*a;
      )
      spawn(3,
      C[i] = 0;
      )
      )
   }
   )
   spawn(1,
   for(i = 0; i < N; i += 1)
      B[i] = B[i]*b;
   )
   )
   barrier(
   spawn(0,
   for(i = 0; i < N; i += 1)
      C[i] += A[i]+B[i];
   )
   )
}
void main(int argc, char *argv[])
{
   //PIPS generated variable
   double b, a, C[10], B[10], A[10];
   //PIPS generated variable
   unsigned int N, i;
   barrier(
   spawn(0,
   N = 10;
   send(1, 1, N);
   )
   )
   barrier(
   spawn(0,
   for(i = 0; i < N; i += 1) {
      send(2, 1, N, 1, i);
      send(1, 1, N, 1, i);
      barrier(
      spawn(1,
      recv(0, 1, N, 1, i);
      B[i] = 3;
      send(0, 1, B[PHI1]);
      )
      spawn(2,
      recv(0, 1, N, 1, i);
      A[i] = 5;
      send(0, 1, A[PHI1]);
      )
      )
      recv(2, 1, A[PHI1]);
      recv(1, 1, B[PHI1]);
   }
   send(1, 10, B);
   )
   )
   barrier(
   spawn(0,
   for(i = 0; i < N; i += 1) {
      send(3, 1, N, 1, i);
      send(2, 1, N, 1, A[PHI1], 1, i, 1, a);
      barrier(
      spawn(2,
      recv(0, 1, N, 1, A[PHI1], 1, i, 1, a);
      A[i] = A[i]*a;
      send(0, 1, A[PHI1]);
      )
      spawn(3,
      recv(0, 1, N, 1, i);
      C[i] = 0;
      send(0, 1, C[PHI1]);
      )
      )
      recv(3, 1, C[PHI1]);
      recv(2, 1, A[PHI1]);
   }
   )
   spawn(1,
   recv(0, 10, B, 1, N);
   for(i = 0; i < N; i += 1)
      B[i] = B[i]*b;
   send(0, 10, B);
   )
   )
   barrier(
   spawn(0,
   recv(1, 10, B);
   for(i = 0; i < N; i += 1)
      C[i] += A[i]+B[i];
   )
   )
}
hierarchical MPI not implemented yet; this will generate a flat MPI
void main(int argc, char *argv[])
{
   {
      //PIPS generated variable
      int rank0;
      //PIPS generated variable
      MPI_Status status0;
      //PIPS generated variable
      MPI_Request request0;
      MPI_Init(&argc, &argv);
      MPI_Comm_rank(MPI_COMM_WORLD, &rank0);
      //PIPS generated variable
      double b, a, C[10], B[10], A[10];
      //PIPS generated variable
      unsigned int N, i;
      if (rank0==0) {
         N = 10;
         MPI_Isend(N, 1, MPI_INT, 1, MPI_ANY_TAG, MPI_COMM_WORLD, &request0);
      }
      MPI_Barrier(MPI_COMM_WORLD);
      if (rank0==0) {
         for(i = 0; i < N; i += 1) {



            B[i] = 3;


            A[i] = 5;



         }
         MPI_Isend(B, 10, MPI_FLOAT, 1, MPI_ANY_TAG, MPI_COMM_WORLD, &request0);
      }
      MPI_Barrier(MPI_COMM_WORLD);
      if (rank0==0)
         for(i = 0; i < N; i += 1) {



            A[i] = A[i]*a;


            C[i] = 0;



         }
      if (rank0==1) {
         MPI_Recv(B, 10, MPI_FLOAT, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status0);
         MPI_Recv(N, 1, MPI_INT, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status0);
         for(i = 0; i < N; i += 1)
            B[i] = B[i]*b;
         MPI_Isend(B, 10, MPI_FLOAT, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &request0);
      }
      MPI_Barrier(MPI_COMM_WORLD);
      if (rank0==0) {
         MPI_Recv(B, 10, MPI_FLOAT, 1, MPI_ANY_TAG, MPI_COMM_WORLD, &status0);
         for(i = 0; i < N; i += 1)
            C[i] += A[i]+B[i];
      }
      MPI_Barrier(MPI_COMM_WORLD);
   }
   MPI_Finalize();
}
// OMP style
void main(int argc, char *argv[])
{
   //PIPS generated variable
   double b, a, C[10], B[10], A[10];
   //PIPS generated variable
   unsigned int N, i;
#pragma omp parallel default(shared) 
#pragma omp single
   {
      N = 10;

   }
#pragma omp single
   {
      for(i = 0; i < N; i += 1) {


#pragma omp task
         {

            B[i] = 3;

         }
#pragma omp task
         {

            A[i] = 5;

         }
#pragma omp taskwait 



      }

   }
#pragma omp single
   {
#pragma omp task
      {
         for(i = 0; i < N; i += 1) {


#pragma omp task
            {

               A[i] = A[i]*a;

            }
#pragma omp task
            {

               C[i] = 0;

            }
#pragma omp taskwait 



         }
      }
#pragma omp task
      {

         for(i = 0; i < N; i += 1)
            B[i] = B[i]*b;

      }
   }
#pragma omp single
   {

      for(i = 0; i < N; i += 1)
         C[i] += A[i]+B[i];
   }
}
