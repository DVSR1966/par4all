int main()
{
   int i;

#pragma omp parallel for 
   for(i = 0; i <= 9999; i += 1)
      a[i] = b[i]+c[i];

   return 0;
}
void P4A_accel_free(void *ptr)
{
   free(ptr);
}
void P4A_accel_malloc(void **ptr, size_t n)
{
   if (n)
      *ptr = malloc(n);
   else
      *ptr = (void *) 0;
}
void P4A_copy_from_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = host_address;
   char *csrc = accel_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = d1_offset*element_size+(char *) host_address;
   char *csrc = accel_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = d2_offset*element_size+(char *) host_address;
   char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)
         cdest[(i+d1_offset)*element_size*d2_size+j] = csrc[i*element_size*d2_block_size+j];
}
void P4A_copy_to_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = host_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = d1_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = (char *) accel_address;
   char *csrc = d2_offset*element_size+(char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)

         cdest[i*element_size*d2_block_size+j] = csrc[(i+d1_offset)*element_size*d2_size+j];
}
int main()
{
   int i;

   p4a_kernel_launcher_0(N, a, b, c);

   return 0;
}
void p4a_kernel_0(int N, double a[N], double b[N], double c[N], int i)
{
   a[i] = b[i]+c[i];
}
void p4a_kernel_launcher_0(int N, double a[N], double b[N], double c[N])
{
   //PIPS generated variable
   int i;

   for(i = 0; i <= 9999; i += 1)
      // To be assigned to a call to P4A_vp_0: i
      p4a_kernel_wrapper_0(N, a, b, c, i);
}
void p4a_kernel_wrapper_0(int N, double a[N], double b[N], double c[N], int i)
{
   // To be assigned to a call to P4A_vp_0: i
   p4a_kernel_0(N, a, b, c, i);
}
void P4A_accel_free(void *ptr)
{
   free(ptr);
}
void P4A_accel_malloc(void **ptr, size_t n)
{
   if (n)
      *ptr = malloc(n);
   else
      *ptr = (void *) 0;
}
void P4A_copy_from_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = host_address;
   char *csrc = accel_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = d1_offset*element_size+(char *) host_address;
   char *csrc = accel_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = d2_offset*element_size+(char *) host_address;
   char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)
         cdest[(i+d1_offset)*element_size*d2_size+j] = csrc[i*element_size*d2_block_size+j];
}
void P4A_copy_to_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = host_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = d1_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = (char *) accel_address;
   char *csrc = d2_offset*element_size+(char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)

         cdest[i*element_size*d2_block_size+j] = csrc[(i+d1_offset)*element_size*d2_size+j];
}
int main()
{
   int i;

   p4a_kernel_launcher_0(N, a, b, c);

   return 0;
}
void p4a_kernel_0(int N, double a[N], double b[N], double c[N], int i)
{
   a[i] = b[i]+c[i];
}
void p4a_kernel_launcher_0(int N, double a[N], double b[N], double c[N])
{
   //PIPS generated variable
   int i;

   for(i = 0; i <= 9999; i += 1)
      // To be assigned to a call to P4A_vp_0: i
      p4a_kernel_wrapper_0(N, a, b, c, i);
}
void p4a_kernel_wrapper_0(int N, double a[N], double b[N], double c[N], int i)
{
   // To be assigned to a call to P4A_vp_0: i
   p4a_kernel_0(N, a, b, c, i);
}
[after unsplit and recovering]
/*
 * file for p4a_stubs.c
 */
#include <stdlib.h>

/* A small implementation of the runtime used by the code generated by the
   kernel_load_store and isolate_statement
*/


/* To copy scalars */
void P4A_copy_from_accel(size_t element_size, void *host_address, void *accel_address);


void P4A_copy_to_accel(size_t element_size, void *host_address, void *accel_address);


/* To copy parts of 1D arrays */
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address);


void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address);


/* To copy parts of 2D arrays */
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address);


void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address);

/* Allocate memory on the accelerator */
void P4A_accel_malloc(void **ptr, size_t n);

/* Deallocate memory on the accelerator */
void P4A_accel_free(void *ptr);
void P4A_copy_from_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = host_address;
   char *csrc = accel_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = host_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = d1_offset*element_size+(char *) host_address;
   char *csrc = accel_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = d1_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = d2_offset*element_size+(char *) host_address;
   char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)
         cdest[(i+d1_offset)*element_size*d2_size+j] = csrc[i*element_size*d2_block_size+j];
}
void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = (char *) accel_address;
   char *csrc = d2_offset*element_size+(char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)

         cdest[i*element_size*d2_block_size+j] = csrc[(i+d1_offset)*element_size*d2_size+j];
}
void P4A_accel_malloc(void **ptr, size_t n)
{
   if (n)
      *ptr = malloc(n);
   else
      *ptr = (void *) 0;
}
void P4A_accel_free(void *ptr)
{
   free(ptr);
}
/*
 * file for simple_loop.c
 */
enum {N=10000};

double a[N], b[N], c[N];

int main();
//PIPS generated variable
void p4a_kernel_0(int N, double a[N], double b[N], double c[N], int i), p4a_kernel_wrapper_0(int N, double a[N], double b[N], double c[N], int i), p4a_kernel_launcher_0(int N, double a[N], double b[N], double c[N]);
void p4a_kernel_launcher_0(int N, double a[N], double b[N], double c[N])
{
   //PIPS generated variable
   int i;

   for(i = 0; i <= 9999; i += 1)
      // To be assigned to a call to P4A_vp_0: i
      p4a_kernel_wrapper_0(N, a, b, c, i);
}
void p4a_kernel_wrapper_0(int N, double a[N], double b[N], double c[N], int i)
{
   // To be assigned to a call to P4A_vp_0: i
   p4a_kernel_0(N, a, b, c, i);
}
void p4a_kernel_0(int N, double a[N], double b[N], double c[N], int i)
{
   a[i] = b[i]+c[i];
}
int main()
{
   int i;

   p4a_kernel_launcher_0(N, a, b, c);

   return 0;
}
