
Module rkqc!



/*
 * Copyright 99/07/29 Sun Microsystems, Inc.  All Rights Reserved.
 */




#pragma ident	"@(#)math.h	2.10	99/07/29 SMI"

/*
 * Copyright 99/07/30 Sun Microsystems, Inc.  All Rights Reserved.
 */




#pragma ident	"@(#)math_iso.h	1.1	99/07/30 SMI"







typedef union _h_val {
	unsigned long _i[sizeof(double) / sizeof(unsigned long)];
	double _d;
} _h_val;


extern const _h_val __huge_val;






extern double acos  (double)  ;
extern double asin  (double)  ;
extern double atan  (double)  ;
extern double atan2  (double, double)  ;
extern double cos  (double)  ;
extern double sin  (double)  ;
extern double tan  (double)  ;

extern double cosh  (double)  ;
extern double sinh  (double)  ;
extern double tanh  (double)  ;

extern double exp  (double)  ;
extern double frexp  (double, int *)  ;
extern double ldexp  (double, int)  ;
extern double log  (double)  ;
extern double log10  (double)  ;
extern double modf  (double, double *)  ;

extern double pow  (double, double)  ;
extern double sqrt  (double)  ;

extern double ceil  (double)  ;
extern double fabs  (double)  ;
extern double floor  (double)  ;
extern double fmod  (double, double)  ;









/* _ISO_MATH_ISO_H */













/*
 * SVID & X/Open
 */














extern int signgam;




/*
 * SVID
 */
enum version {libm_ieee = -1, c_issue_4, ansi_1, strict_ansi};


extern const enum version _lib_version;


struct exception {
	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};























/* defined(__EXTENSIONS__) || !defined(_XOPEN_SOURCE) */
/* defined(__EXTENSIONS__) || __STDC__ - 0 == 0 && ... */


/*
 * SVID & X/Open
 */
extern double erf  (double)  ;
extern double erfc  (double)  ;
extern double gamma  (double)  ;
extern double hypot  (double, double)  ;
extern int isnan  (double)  ;
extern double j0  (double)  ;
extern double j1  (double)  ;
extern double jn  (int, double)  ;
extern double lgamma  (double)  ;
extern double y0  (double)  ;
extern double y1  (double)  ;
extern double yn  (int, double)  ;



/*
 * SVID & XPG 4.2/5
 */
extern double acosh  (double)  ;
extern double asinh  (double)  ;
extern double atanh  (double)  ;
extern double cbrt  (double)  ;
extern double logb  (double)  ;
extern double nextafter  (double, double)  ;
extern double remainder  (double, double)  ;
extern double scalb  (double, double)  ;


/*
 * XPG 4.2/5
 */
extern double expm1  (double)  ;
extern int ilogb  (double)  ;
extern double log1p  (double)  ;
extern double rint  (double)  ;


/* defined(__EXTENSIONS__) || !defined(_XOPEN_SOURCE) || ... */


/*
 * SVID
 */
extern int matherr  (struct exception *)  ;

/*
 * IEEE Test Vector
 */
extern double significand  (double)  ;

/*
 * Functions callable from C, intended to support IEEE arithmetic.
 */
extern double copysign  (double, double)  ;
extern double scalbn  (double, int)  ;


/*
 * Reentrant version of gamma & lgamma; passes signgam back by reference
 * as the second argument; user must allocate space for signgam.
 */


/*
 * Orphan(s); frexp, ldexp, modf and modff are part of libc nowadays.
 */
extern float modff  (float, float *)  ;



/*	Copyright (C) 1989 AT&T					*/
/*	  All Rights Reserved  					*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/




#pragma ident	"@(#)floatingpoint.h	2.5	99/06/22 SMI"


/*
 * Copyright (c) 1998 by Sun Microsystems, Inc.
 * All rights reserved.
 */




#pragma ident	"@(#)stdio_tag.h	1.3	98/04/20 SMI"







typedef struct __FILE  __FILE;




/* _STDIO_TAG_H */


/*
 * Copyright 10/29/99 Sun Microsystems, Inc.  All Rights Reserved.
 */




#pragma ident	"@(#)ieeefp.h	2.8 99/10/29"



/*
 * Sun types for IEEE floating point.
 */

enum fp_direction_type {	/* rounding direction */
	fp_nearest	= 0,
	fp_tozero	= 1,
	fp_positive	= 2,
	fp_negative	= 3
};

enum fp_precision_type {	/* extended rounding precision */
	fp_extended	= 0,
	fp_single	= 1,
	fp_double	= 2,
	fp_precision_3	= 3
};

enum fp_exception_type {	/* exceptions according to bit number */
	fp_inexact	= 0,
	fp_division	= 1,
	fp_underflow	= 2,
	fp_overflow	= 3,
	fp_invalid	= 4
};

enum fp_trap_enable_type {	/* trap enable bits according to bit number */
	fp_trap_inexact	= 0,
	fp_trap_division	= 1,
	fp_trap_underflow	= 2,
	fp_trap_overflow	= 3,
	fp_trap_invalid	= 4
};
/* defined(sparc) || defined(__sparc) */

/* defined(i386) || defined(__i386) || defined(__ia64) */

/* defined(__ppc) */

enum fp_class_type {		/* floating-point classes */
	fp_zero		= 0,
	fp_subnormal	= 1,
	fp_normal	= 2,
	fp_infinity   	= 3,
	fp_quiet	= 4,
	fp_signaling	= 5
};



/* !defined(_SYS_IEEEFP_H) */




/*
 *	@(#)floatingpoint.h	2.5 99/06/22 ICL version  2.2	(88/11/03)
 *		Copyright ICL 1988
 */

/*
 * Copyright 99/06/22 Sun Microsystems, Inc.  All Rights Reserved.
 *
 * <floatingpoint.h> contains definitions for constants, types, variables,
 * and functions for:
 *	IEEE floating-point arithmetic base conversion;
 *	IEEE floating-point arithmetic modes;
 *	IEEE floating-point arithmetic exception handling.
 */





typedef	__FILE FILE;



/* Number of floating-point exceptions. */

typedef int sigfpe_code_type;	/* Type of SIGFPE code. */

typedef void (*sigfpe_handler_type)();	/* Pointer to exception handler */

/* default exception handling */
/* ignore this exception or code */
/* force abort on exception */

extern sigfpe_handler_type sigfpe  (sigfpe_code_type, sigfpe_handler_type)  ;

/*
 * Types for IEEE floating point.
 */
typedef float single;			



typedef unsigned extended[3];


typedef long double quadruple;	/* Quadruple-precision type. */

typedef unsigned fp_exception_field_type;
				/*
				 * A field containing fp_exceptions OR'ed
				 * together.
				 */
/*
 * Definitions for base conversion.
 */
/* Size of buffer in decimal_record. */

typedef char decimal_string[512 ];	
				/* Decimal significand. */

typedef struct {
	enum fp_class_type fpclass;
	int	sign;
	int	exponent;
	decimal_string ds;	/* Significand - each char contains an ascii
				   digit, except the string-terminating
				   ascii null. */
	int	more;		/* On conversion from decimal to binary, != 0
				   indicates more non-zero digits following
				   ds. */
	int 	ndigits;	/* On fixed_form conversion from binary to
				   decimal, contains number of digits required
				   for ds. */
} decimal_record;

enum decimal_form {
	fixed_form,		/* Fortran F format: ndigits specifies number of
				   digits after point; if negative, specifies
				   rounding to occur to left of point. */
	floating_form		/* Fortran E format: ndigits specifies number of
				   significant digits. */
};

typedef struct {
	enum fp_direction_type rd;	
				/* Rounding direction. */
	enum decimal_form df;	/* Format for conversion from
				   binary to decimal. */
	int ndigits;		/* Number of digits for conversion. */
} decimal_mode;

enum decimal_string_form {	/* Valid decimal number string formats. */
	invalid_form,		/* Not a valid decimal string format. */
	whitespace_form,	/* All white space - valid in Fortran! */
	fixed_int_form,		/* <digs> 		*/
	fixed_intdot_form,	/* <digs>. 		*/
	fixed_dotfrac_form,	/* .<digs>		*/
	fixed_intdotfrac_form,	/* <digs>.<frac>	*/
	floating_int_form,	/* <digs><exp>		*/	
	floating_intdot_form,	/* <digs>.<exp>		*/
	floating_dotfrac_form,	/* .<digs><exp>		*/
	floating_intdotfrac_form,/* <digs>.<digs><exp>	*/
	inf_form,		/* inf			*/
	infinity_form,		/* infinity		*/
	nan_form,		/* nan			*/
	nanstring_form		/* nan(string)		*/
};

extern void single_to_decimal  (single *, decimal_mode *, decimal_record *,
				fp_exception_field_type *)  ;
extern void double_to_decimal  (double *, decimal_mode *, decimal_record *,
				fp_exception_field_type *)  ;
extern void extended_to_decimal  (extended *, decimal_mode *,
				decimal_record *, fp_exception_field_type *)  ;
extern void quadruple_to_decimal  (quadruple *, decimal_mode *,
				decimal_record *, fp_exception_field_type *)  ;

extern void decimal_to_single  (single *, decimal_mode *, decimal_record *,
				fp_exception_field_type *)  ;
extern void decimal_to_double  (double *, decimal_mode *, decimal_record *,
				fp_exception_field_type *)  ;
extern void decimal_to_extended  (extended *, decimal_mode *,
				decimal_record *, fp_exception_field_type *)  ;
extern void decimal_to_quadruple  (quadruple *, decimal_mode *,
				decimal_record *, fp_exception_field_type *)  ;

extern void string_to_decimal  (char **, int, int, decimal_record *,
				enum decimal_string_form *, char **)  ;
extern void func_to_decimal  (char **, int, int, decimal_record *,
				enum decimal_string_form *, char **,
				int (*)(void), int *, int (*)(int))  ;
extern void file_to_decimal  (char **, int, int, decimal_record *,
				enum decimal_string_form *, char **,
				FILE *, int *)  ;

extern char *seconvert  (single *, int, int *, int *, char *)  ;
extern char *sfconvert  (single *, int, int *, int *, char *)  ;
extern char *sgconvert  (single *, int, int, char *)  ;
extern char *econvert  (double, int, int *, int *, char *)  ;
extern char *fconvert  (double, int, int *, int *, char *)  ;
extern char *gconvert  (double, int, int, char *)  ;
extern char *qeconvert  (quadruple *, int, int *, int *, char *)  ;
extern char *qfconvert  (quadruple *, int, int *, int *, char *)  ;
extern char *qgconvert  (quadruple *, int, int, char *)  ;

extern char *ecvt  (double, int, int *, int *)  ;
extern char *fcvt  (double, int, int *, int *)  ;
extern char *gcvt  (double, int, char *)  ;

/*
 * ANSI C Standard says the following entry points should be
 * prototyped in <stdlib.h>.  They are now, but weren't before.
 */
extern double atof  (const char *)  ;
extern double strtod  (const char *, char **)  ;



/* _FLOATINGPOINT_H */


/* defined(__EXTENSIONS__) || !defined(_XOPEN_SOURCE) */
/* defined(__EXTENSIONS__) || __STDC__ - 0 == 0 && ... */



/* _MATH_H */



/* _MATH_H_WRAPPER */




/* 1.0/15.0 */



extern void rkqc();

Module rkqc

void rkqc(y,dydx,n,x,htry,eps,yscal,hdid,hnext,derivs)
float y[],dydx[],*x,htry,eps,yscal[],*hdid,*hnext;
void (*derivs)();	/* ANSI: void (*derivs)(float,float *,float *); */
int n;
{
	int i;
	float xsav,hh,h,temp,errmax;
	float *dysav,*ysav,*ytemp,*vector();
	void rk4(),nrerror(),free_vector();

	dysav=vector(1,n);
	ysav=vector(1,n);
	ytemp=vector(1,n);
	xsav=(*x);
	for (i=1;i<=n;i++) {
		ysav[i]=y[i];
		dysav[i]=dydx[i];
	}
	h=htry;
	for (;;) {
		hh=0.5*h;
		rk4(ysav,dysav,n,xsav,hh,ytemp,derivs);
		*x=xsav+hh;
		(*derivs)(*x,ytemp,dydx);
		rk4(ytemp,dydx,n,*x,hh,y,derivs);
		*x=xsav+h;
		if (*x == xsav) nrerror("Step size too small in routine RKQC");
		rk4(ysav,dysav,n,xsav,h,ytemp,derivs);
		errmax=0.0;
		for (i=1;i<=n;i++) {
			ytemp[i]=y[i]-ytemp[i];
			temp=fabs(ytemp[i]/yscal[i]);
			if (errmax < temp) errmax=temp;
		}
		errmax /= eps;
		if (errmax <= 1.0) {
			*hdid=h;
			*hnext=(errmax > 6.0e-4  ?
				0.9 *h*exp(-0.20 *log(errmax)) : 4.0*h);
			break;
		}
		h= 0.9 *h*exp(-0.25 *log(errmax));
	}
	for (i=1;i<=n;i++) y[i] += ytemp[i]* 0.06666666 ;
	free_vector(ytemp,1,n);
	free_vector(dysav,1,n);
	free_vector(ysav,1,n);
}
