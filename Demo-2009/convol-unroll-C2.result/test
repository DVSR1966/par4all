
Inital code

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], int ksi, int ksj, float kernel[ksi][ksj])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l400:
   for(i = ksi/2; i <= isi-ksi/2-1; i += 1)
l300:
      for(j = ksj/2; j <= isj-ksj/2-1; j += 1) {
         new_image[i][j] = 0.;
l200:
         for(ki = 0; ki <= ksi-1; ki += 1)
l100:
            for(kj = 0; kj <= ksj-1; kj += 1)
               
               
               new_image[i][j] = new_image[i][j]+image[i+ki-ksi/2][j+kj-ksj/2]*kernel[ki][kj];
         new_image[i][j] = new_image[i][j]/(ksi*ksj);
      }
}

After partial evaluation:

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], int ksi, int ksj, float kernel[ksi][ksj])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l400:
   for(i = 1; i <= 510; i += 1)
l300:
      for(j = 1; j <= 510; j += 1) {
         new_image[i][j] = 0.;
l200:
         for(ki = 0; ki <= 2; ki += 1)
l100:
            for(kj = 0; kj <= 2; kj += 1)
               
               
               new_image[i][j] = new_image[i][j]+image[i+ki-1][j+kj-1]*kernel[ki][kj];
         new_image[i][j] = new_image[i][j]/9;
      }
}

after privatization


after paralellization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], int ksi, int ksj, float kernel[ksi][ksj])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

#pragma omp parallel for private(j)
   for(i = 0; i <= 511; i += 1)
#pragma omp parallel for 
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l400:   launch_microcode1(isi, isj, ksi, ksj, image, kernel, new_image);
}
