
PROPER  EFFECTS 

void test(int n, int m, int a[n][m])
{
   int i, j;
   //PIPS generated variable
   int I_0;
   {
      //PIPS generated variable
//             <    is read   >: N n
//             <    is written>: I_3
      int I_3 = (n-1)/N;
//             <    is read   >: I_3
//             <    is written>: I_0
      for(I_0 = 0; I_0 <= I_3; I_0 += 1) {
         //PIPS generated variable
//             <    is read   >: I_0 N n
//             <    is written>: I_1 I_2
         int I_1 = MIN(n-1, I_0*N+(N-1)), I_2 = I_0*N;
//             <    is read   >: I_1 I_2 I_3
//             <    is written>: i
         for(i = I_2; i <= I_1; i += 1)
//             <    is read   >: I_1 I_2 I_3 m
//             <    is written>: j
            for(j = 0; j <= m-1; j += 1)
//             <    is read   >: I_1 I_2 I_3 i j m
//             <    is written>: a[i][j]
               a[i][j] = 0;
      }
   }
}

POINTS-TO


// Points To IN: none


// Points To OUT: none

void test(int n, int m, int a[n][m])
{

// Points To: none

   int i, j;
   //PIPS generated variable

// Points To: none

   int I_0;
   {
      //PIPS generated variable

// Points To: none

      int I_3 = (n-1)/N;

// Points To: none

      for(I_0 = 0; I_0 <= I_3; I_0 += 1) {
         //PIPS generated variable

// Points To: none

         int I_1 = MIN(n-1, I_0*N+(N-1)), I_2 = I_0*N;

// Points To: none

         for(i = I_2; i <= I_1; i += 1)

// Points To: none

            for(j = 0; j <= m-1; j += 1)

// Points To: none

               a[i][j] = 0;
      }
   }
}

PROPER  EFFECTS WITH POINTS TO

void test(int n, int m, int a[n][m])
{
   int i, j;
   //PIPS generated variable
   int I_0;
   {
      //PIPS generated variable
//             <    is read   >: N n
//             <    is written>: I_3
      int I_3 = (n-1)/N;
//             <    is read   >: I_3
//             <    is written>: I_0
      for(I_0 = 0; I_0 <= I_3; I_0 += 1) {
         //PIPS generated variable
//             <    is read   >: I_0 N n
//             <    is written>: I_1 I_2
         int I_1 = MIN(n-1, I_0*N+(N-1)), I_2 = I_0*N;
//             <    is read   >: I_1 I_2 I_3
//             <    is written>: i
         for(i = I_2; i <= I_1; i += 1)
//             <    is read   >: I_1 I_2 I_3 m
//             <    is written>: j
            for(j = 0; j <= m-1; j += 1)
//             <    is read   >: I_1 I_2 I_3 i j m
//             <    is written>: a[i][j]
               a[i][j] = 0;
      }
   }
}

 *********************** Use-Def Chains *********************

	12 --> 13 with conflicts
		from <I_3-W-EXACT> to <I_3-R-EXACT>
	12 --> 16 with conflicts
		from <I_3-W-EXACT> to <I_3-R-EXACT>
	12 --> 17 with conflicts
		from <I_3-W-EXACT> to <I_3-R-EXACT>
	12 --> 18 with conflicts
		from <I_3-W-EXACT> to <I_3-R-EXACT>
	15 --> 15 with conflicts
		from <I_2-W-EXACT> to <I_2-W-EXACT>
		from <I_1-W-EXACT> to <I_1-W-EXACT>
	15 --> 16 with conflicts
		from <I_2-W-EXACT> to <I_2-R-EXACT>
		from <I_1-W-EXACT> to <I_1-R-EXACT>
	15 --> 17 with conflicts
		from <I_2-W-EXACT> to <I_2-R-EXACT>
		from <I_1-W-EXACT> to <I_1-R-EXACT>
	15 --> 18 with conflicts
		from <I_2-W-EXACT> to <I_2-R-EXACT>
		from <I_1-W-EXACT> to <I_1-R-EXACT>
	16 --> 15 with conflicts
		from <I_2-R-EXACT> to <I_2-W-EXACT>
		from <I_1-R-EXACT> to <I_1-W-EXACT>
	16 --> 16 with conflicts
		from <i-W-EXACT> to <i-W-EXACT>
	17 --> 15 with conflicts
		from <I_2-R-EXACT> to <I_2-W-EXACT>
		from <I_1-R-EXACT> to <I_1-W-EXACT>
	17 --> 17 with conflicts
		from <j-W-EXACT> to <j-W-EXACT>
	18 --> 15 with conflicts
		from <I_2-R-EXACT> to <I_2-W-EXACT>
		from <I_1-R-EXACT> to <I_1-W-EXACT>
	18 --> 16 with conflicts
		from <i-R-EXACT> to <i-W-EXACT>
	18 --> 17 with conflicts
		from <j-R-EXACT> to <j-W-EXACT>
	18 --> 18 with conflicts
		from <a[i][j]-W-EXACT> to <a[i][j]-W-EXACT>

****************** End of Dependence Graph ******************
