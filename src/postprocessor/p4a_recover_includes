#! /usr/bin/env python3.1

# -*- coding: utf-8 -*-

"""
Recover #include into PIPS C output

Ronan.Keryell@hpc-project.com
"""

#import string, re, sys, os, types, optparse

import re, optparse, pickle

#from pyps import *

# The #include files we want to analyse:
header_file_names = [
    "dirent.h",
    "fcntl.h",
    "grp.h",
    "limits.h",
    "pwd.h",
    "signal.h",
    "stdio.h",
    "stdlib.h",
    "sys/stat.h",
    "sys/times.h",
    "termios.h"
    ]
header_file_names = [
    "stdio.h"
   ]

# The file name used for #include parsing:
tmp_header_file_name = "header.c"

# File name to use for persistance of information about headers and definition
header_information_file_name = "header_information.pickle"


verbose = False
declaration_to_header = {}


def save_header_information():
    "Save the descriptions of the parsed structures in a file for later use"
    p = open(header_information_file_name, mode = 'bw')
    pickle.dump(declaration_to_header, p)
    p.close()
    #print (declaration_to_header)


def load_header_information():
    "Load the descriptions of the parsed structures from the file generated by the previous header analysis"
    global declaration_to_header
    p = open(header_information_file_name, mode = 'br')
    declaration_to_header = pickle.load(p)
    p.close()
    #print (declaration_to_header)


def add_to_map_of_sets(d, key, value):
    """Associate to a key in a dictionnary d a set with a value
    d is a map of set of values
    """

    # Get the set associated to this key, if any:
    s = d.get(key)

    if not s:
        # Create a set for the key since there was nothing for this key:
        s = set()
        d[key] = s

    # Add the value to the set associated to the key:
    s.add(value)


# Match stuff from the begin of a line up to the first ';' found at an end
# of line:
declarations_re = re.compile('^.*?;$', re.MULTILINE|re.DOTALL)


def parse_declarations(header_name, file_name):
    "Keep track of all the declarations generated by this header file digested by PIPS"
    f = open(file_name)
    # First skip the PIPS-generated header that is 7 line long:
    for i in range(7):
        f.readline()
    # slurp all the file in a string:
    content = f.read()
    f.close()

    for m in declarations_re.finditer(content):
        if verbose:
            print()
            print(">>>>>>>>>>>>>")
            print(m.group(0))
        # Note that this declaration is to be found in this header_name.
        add_to_map_of_sets(declaration_to_header, m.group(0) + '\n', header_name)


def init_headers():
    "Read classical header files to construct index tables"

    for n in header_file_names:
        # Create a .c file that includes this header file:
        f = open(tmp_header_file_name, mode = 'w')
        #print('#include <' + n + '>', file = f)
        print('#include <' + n + '>', file = f)
        #print >> f, 'void main() {}'
        f.close()
        #w = workspace(tmp_header_file_name);
        #print w
        #parse_declarations(n, 'a.database/header!/header!.pre.c')
        parse_declarations(n, 'pips_c2openmp16086.database/Src/header.c')


def recover_header(file_name):
    """Replace CPP-inlined stuff from previous #include <something.h> by
    the #include <something.h> itself"""

    # To store the set of found headers:
    found_headers = set()

    f = open(file_name)
    # slurp all the file in a string:
    content = f.read()
    f.close()
    #print(declaration_to_header)
    for d, h in declaration_to_header.items():
        #print(h, d)
        if content.find(d) != -1:
            # Add the header name to the found names
            found_headers |= h
            if verbose:
                print(h)
                print(d)
            # Replace the header generated content:
            # Since we will use it as a regex later, protect all the special
            # characters in it before using them:
            # This could have been done at save/pickle time for
            # efficiency, but we stress debugability here...
            hgc = re.escape(d);
            (content, n_substitutions) = re.subn(hgc, '', content)
            #if verbose and n_substitutions > 0:
            if n_substitutions > 0:
                print('Found', n_substitutions, 'substitutions for:')
                #print(hgc)
            #print(content)
            #exit(0)
    print('Found headers:', found_headers)
    #print(content)
    f = open("apres.c", mode = 'w')
    print(content, file = f)
    f.close()


def main():
    global verbose

    parser = optparse.OptionParser(usage = "usage: %prog [options] <files>",
                                   version = "$Id")

    parser.add_option("-i",  "--init",
                     action = "store_true", dest = "init", default = False,
                     help = "Initialize #include tables")

    group = optparse.OptionGroup(parser, "Debug options")

    group.add_option("-v",  "--verbose",
                     action = "store_true", dest = "verbose", default = False,
                     help = "Run in verbose mode")

    group.add_option("-q",  "--quiet",
                     action = "store_false", dest = "verbose",
                     help = "Run in quiet mode [default]")

    parser.add_option_group(group)

    (options, args) = parser.parse_args()

    verbose = options.verbose

    if options.init:
        init_headers()
        save_header_information()
    else:
        load_header_information()
        for file_name in args:
            #init_headers()
            recover_header(file_name)


# If this programm is independent it is executed:
if __name__ == "__main__":
    main()
