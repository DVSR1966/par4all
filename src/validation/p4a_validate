#! /usr/bin/env python3.1

# -*- coding: utf-8 -*-

"""
Validation utility for Par4All

Add object oriented organization above PIPS validation.

Introduce the concept of validation class, not that far from CfEngine one.

Ronan.Keryell@hpc-project.com
"""

import re, optparse, pickle, os, shutil, subprocess, functools

verbose = False

def from_file_to_string(file_name):
    "Read a file and return its content as a string"

    # Open the file:
    f = open(file_name)
    # slurp all the file in a string:
    content = f.read()
    f.close()
    return content


class Validation:
    "Abstract the PIPS validation concepts"

    @staticmethod
    def basic_name(s):
        "Get the basic validation name from a file name found in a validation output"

        # Remove the extension (.f, .tpips...)
        (root, ext) = os.path.splitext(s)
        return root


    @staticmethod
    def diff_filename(s, output_dir = None):
        "Get the file name containing the differences associated to a validation case"

        # Replace all the "/" by a "_"
        d = Validation.basic_name(s).replace('/', '_') + '.diff'

        if not output_dir:
            output_dir = 'RESULTS'
        return os.path.join(output_dir, d)


    @staticmethod
    def reference_directory_name(s):
        """For a given validation name, return the reference output
        validation directory name"""

        # Remove the extension (.f, .tpips...) if any, add the directory
        # extension:
        return Validation.basic_name(s) + ".result"


    @staticmethod
    def reference_file_name(s):
        """For a given validation name, return the reference output
        validation file name"""

        # This is the "test" file in the validation directory:
        return os.path.join(Validation.reference_directory_name(s), "test")


    @staticmethod
    def output_file_name(s):

        """For a given validation name, return the reference output
        validation file name"""

        # This is the "out" file in the validation directory:
        return os.path.join(Validation.reference_directory_name(s), "out")


    @staticmethod
    def accept(s):
        "Accept the output of this validation case as a reference"

        shutil.move(Validation.output_file_name(s),
                    Validation.reference_file_name(s))


    @staticmethod
    def git_add(s):
        "Add with git the validation reference"

        subprocess.call(["git", "add", Validation.reference_file_name(s)])


class ValidationElement:

    CHANGED = 'changed'
    FAILED = 'failed'
    SKIPPED = 'skipped'

    def __init__(self, name, attribute = None):
        "Create an element with an optional attribute (changed,failed,skipped)"

        if verbose:
            print('Creating ValidationElement', name, attribute)

        self.name = name
        self.attribute = attribute

    def __str__(self):
        return str(self.attribute) + ': ' + str(self.name)


class ValidationClass:
    """Implement the concept of PIPS validation classes"""

    # Match a changed information:
    changed_re = re.compile("^> changed: (.*)$", re.MULTILINE)


    #def __init__(self, *diff_file, *diff_string):
    def __init__(self, vc = None, elements = None):
        # The dictionary of validation elements of this class, the value
        # is the status string
        self.elements = {}
        # The date of the validation
        self.date = None
        # The output directory of the validation
        self.output_directory = None
        # The running directory of the validation
        self.running_directory = None

        if vc:
            self.elements.update(vc.elements)
            self.date = vc.date
            self.output_directory = vc.output_directory
            self.running_directory = vc.running_directory
        elif elements:
            self.elements.update(elements)


    def __str__(self):
        "Give a string representation of a ValidationClass"

        if self.running_directory:
            print('output directory:', self.output_directory)
        if self.output_directory:
            print('running directory:', self.output_directory)
        if self.date:
            print('date:', self.date)
            print('')

        # Concatenate elements in a line-oriented way:
        return functools.reduce(lambda x, y: '\n'.join([x,y]),
                                map(lambda k: self.element_str(k),
                                    self.ordered_list()), '').lstrip()


    def element_str(self, key):
        'Return a string representation of an element'
        if self.elements[key]:
            s = self.elements[key] + ': '
        else:
            s = ''

        s += key
        return s


    def ordered_list(self):
        "Return the ordered elements of this class"

        l = list(self.elements.keys())
        l.sort()
        return l


    def add(self, element, value = None):
        "Adding an element to the validation class"

        self.elements[element] = value


    def __or__(self, vc):
        "Implement | : add with another ValidationClass"

        n = ValidationClass(vc = self)
        n |= vc
        return n


    def __ior__(self, vc):
        "Implement |= : add with another ValidationClass"

        self.elements.update(vc.elements)
        return self


    def __sub__(self, vc):
        "Implement - : subtract another ValidationClass"

        n = ValidationClass(vc = self)
        n -= vc
        return n


    def __isub__(self, vc):
        "Implement -= : subtract another ValidationClass"

        for k in vc.elements.keys():
            if k in self.elements:
                del self.elements[k]
        return self


    def from_string(self, string):
        "Add the elements from a line-oriented string"

        # Try to guess the format of the file that can be a mail output, a
        # simple file of one result per line (with a status or not), a
        # validation output:
        first_line = True
        validation_output = False
        for line in string.splitlines():
            args = line.split()
            if len(args) == 0:
                # Blank line
                continue
            if first_line:
                if len(args) > 2:
                    # It is a validation output, in file or mail format:
                    validation_output = True
                first_line = False
            if validation_output:
                # Skip the header that ends with a 'date:' field:
                if args[0] == 'date:':
                    # Record the date
                    self.date = ' '.join(args[1:])
                    # Switch back to normal mode:
                    validation_output = False
                elif args[0] == 'output':
                    self.output_directory = args[2]
                elif args[0] == 'running':
                    self.running_directory = args[2]
                # See next line:
                continue
            # Should be in normal mode now:
            if len(args) == 2:
                # We are in a 'skipped/failed/changed:
                # Syntax/common2.tpips' form:
                attribute = args[0].rstrip(':')
                self.add(args[1], attribute)
            elif len(args) == 1:
                # Just a line with a validation name:
                self.add(args[0])
            # Else, blank lines for example


    def from_file(self, file_name):
        "Add the elements from a line-oriented file"

        self.from_string(from_file_to_string(file_name))
        return self


    def add_changed_from_diff(self, file_name = None, string = None):
        """Add difference lines as elements"""

        if verbose:
            print('add_changed_from_diff from string', string)
            print('add_changed_from_diff from file_name', file_name)
        if string:
            # A string is given to this method:
            for m in ValidationClass.changed_re.finditer(string):
                changed = m.group(1)
                if verbose:
                    print(changed)
                # Add the change to the current set:
                self.elements.add(changed)
        if file_name:
            # A file name is given to this method, so open the file:
            f = open(file_name)
            # slurp all the file in a string:
            content = f.read()
            f.close()
            # Call again this method with the read string:
            self.add_changed_from_diff(string = content)
        # To ease chaining of operations:
        return self


    def show_diff_files(self):
        "Display the differences associated to the elements"

        for n in self.ordered_list():
            if verbose:
                print('Reading', n)
            f = open(Validation.diff_filename(n, self.output_directory))
            # slurp all the file in a string:
            content = f.read()
            f.close()
            print (content)


    def accept(self):
        "Accept the validation files of the class"

        for e in self.elements:
            Validation.accept(e)


    def git_add(self):
        "Add with git the validation reference of this class"

        for e in self.elements:
            Validation.git_add(e)


    def git_commit(self, message):
        "Commit with git the current validation with the message"

        subprocess.call(["git", "commit", "-m", message])


    def re_filter(self, res):
        "Only keep the validation elements matching this regex string"

        regex = re.compile(res)
        to_keep = set()
        for e in self.elements:
            if regex.match(e):
                # Remove an element with a matching name:
                to_keep.add(e)
        self.elements = to_keep


    def re_filter_out(self, res):
        "Remove the validation elements matching this regex string"

        regex = re.compile(res)
        to_remove = set()
        for e in self.elements:
            if regex.match(e):
                # Remove an element with a matching name:
                to_remove.add(e)
        self.elements -= to_remove


def main():
    "The function called when this program is executed by its own"

    global verbose

    parser = optparse.OptionParser(usage = "usage: %prog [options] [<files>]",
                                   version = "$Id")

    parser.add_option("--file", dest="simple_file_name",
                      help = "Initialize a validation class from a plain line-oriented file of validation case names",
                      metavar="FILE")

    parser.add_option("-l", "--list",
                      action = "store_true", dest = "list_elements", default = False,
                      help = "List the elements of the validation class")

    parser.add_option("--changed-file", dest="changed_file_name",
                      help = "Initialize a validation class from the 'changed' found in a validation output file",
                      metavar="FILE")

    parser.add_option("--failed-file", dest="failed_file_name",
                      help = "Initialize a validation class from the 'failed' found in a validation output file",
                      metavar="FILE")

    parser.add_option("--skipped-file", dest="skipped_file_name",
                      help = "Initialize a validation class from the 'skipped' found in a validation output file",
                      metavar="FILE")

    parser.add_option("-d",  "--diff-file", dest="diff_file_name",
                      help = "Initialize a validation class from a new difference found in a validation diff file",
                      metavar="FILE")

    parser.add_option("-f",  "--filter", dest="filter",
                      help = "Filter the current class by applying a regex on the file names",
                      metavar="REGULAR-EXPRESSION")

    parser.add_option("-s",  "--show",
                      action = "store_true", dest = "show", default = False,
                      help = "Show the output differences for the current class")

    parser.add_option("-a",  "--accept",
                      action = "store_true", dest = "accept", default = False,
                      help = "Accept for the current validation class")

    parser.add_option("-c",  "--commit", dest="message",
                      help = "Commit in git the accepted modifications with the given message",
                      metavar="MESSAGE")

    group = optparse.OptionGroup(parser, "Debug options")

    group.add_option("-v",  "--verbose",
                     action = "store_true", dest = "verbose", default = False,
                     help = "Run in verbose mode")

    group.add_option("-q",  "--quiet",
                     action = "store_false", dest = "verbose",
                     help = "Run in quiet mode [default]")

    parser.add_option_group(group)

    (options, args) = parser.parse_args()

    verbose = options.verbose

    if options.simple_file_name:
        vc = ValidationClass().from_file(options.simple_file_name)

    if options.changed_file_name:
        vc = validation_class_from_file(options.changed_file_name, 'changed')

    if options.failed_file_name:
        vc = validation_class_from_file(options.failed_file_name, 'failed')

    if options.skipped_file_name:
        vc = validation_class_from_file(options.skipped_file_name, 'skipped')

    if options.diff_file_name:
        vc = ValidationClass(vc = vc).add_changed_from_diff(file_name = options.diff_file_name)
        #vc = ValidationClass(diff_file = options.diff_file_name)

    if options.filter:
        vc.re_filter(options.filter)

    if options.show:
        vc.show_diff_files()

    if options.accept:
        vc.accept()

    if options.message:
        vc.git_add()
        vc.git_commit(options.message)

    if options.list_elements:
        print(vc)


# If this programm is independent it is executed:
if __name__ == "__main__":
    main()


# Some Emacs stuff:
### Local Variables:
### mode: python
### mode: flyspell
### ispell-local-dictionary: "american"
### End:
