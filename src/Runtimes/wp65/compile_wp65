#! /bin/sh
#
# $RCSfile: compile_wp65,v $ (version $Revision$)
# $Date: 1995/09/20 10:18:14 $, 
#
# from csh to sh, FC 19/09/95
#

unset erreur target
noise=silent
script=`basename $0`

usage()
{
  cat >&2 <<-EOF
	$script (version $Revision$) [-svh] [-t name] files.{f,bank,wp65}
	  compile and link a program generated by WP65
	  -t name: target name for the pvm executable (a default is provided)
	  -s: silent (default)
	  -v: verbose
	  -h: help
	EOF
  exit ${1:-1}
}

# 

while getopts svht: opt
do
  case $opt in
    t) target=$OPTARG ;;
    s) noise='silent' ;;
    v) noise='verbose' ;;
    h) usage 0 ;;
    *) usage ;;
  esac
done

shift `expr $OPTIND - 1`

#
# Ronan checks that everything is okay! (I agree:-)
# He could have written everything in English instead of French...

[ $# -eq 0 ] && usage 2

[ $noise = verbose -a "$PVM_ROOT" ] ||
{
  cat << USAGE

  Penser à initialiser la variable PVM_ROOT avant de lancer
  le programme compilé...

USAGE
  erreur=1
}

[ $noise = verbose -a "$PVM_ARCH" ] ||
{
  cat << USAGE

  Avez-vous fait un « source \$PVM_ROOT/lib/cshrc.stub » 
  dans votre environnement ?
  Pensez à mettre aussi « \$PVM_ROOT/lib » dans votre chemin d'accès
  si ce n'est pas déjà fait.

USAGE
  erreur=1
}

[ "$erreur" ] && exit 1

[ -f model.rc ] || echo "$script: warning, no local model.rc" >&2

#
# Let's compile
#
# find some name for the target...

[ "$target" ] ||
{
  basef=`basename $1 .f`
  baseb=`basename $basef .bank`
  basew=`basename $baseb .wp65`
  target=basew
}

TMP=wp65_tmp_$$

sed 's,DOALL ,DO ,' "$@" > $TMP.f
make -f $PIPS_EXTEDIR/Makefile.compile_wp65 SOURCES.f="$TMP.f" CIBLE="$target"
status=$?

rm -f $TMP.f $TMP.o

[ $noise = verbose -a "$status" -eq 0 ] ||
{
  cat << USAGE

Vous pouvez lancer pvm dans une fenêtre si ce n'est pas déjà fait 
et lancer votre programme « `echo $1 | sed 's/.f\$//'` ».

Dans le shell pvm,
 - « add » permet de rajouter une liste une machines ;
 - « conf » affiche les machines utilisées ;
 - « ps -a » affiche les processus en cours ;
 - « reset » arrête les processus en cours ;
 - « quit » sort du shell pvm mais laisse pvmd tourner ainsi que
   les processus. On y revient en relançant pvm.
 - « halt » fait le ménage complet.

 Pour mettre au point, utilisez la variable LANCEWP65_DEBUG_LEVEL
 avec comme valeur :
   2 : affiche les tids des processus lancés ;
   3 : ouvre autant de xterm avec gdb que de processus ;
   4 : affiche les messages échangés entre bancs et PEs ;
   5 : idem que 4 avec les tids en plus et les morceaux de message.
USAGE
}
