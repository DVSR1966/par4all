#
# $RCSfile: hpfc_Makefile_init,v $ version $Revision$
# ($Date: 1996/10/19 11:40:43 $, )
#
# This is the initial makefile for HPFC compilation
# a TARGET entry is expected somewhere...
# Makefile for PVM and HPFC, Fabien COELHO, 08/06/94

SHELL=/bin/sh
PVM=pvm

ifndef PIPS_ARCH
PIPS_ARCH=.
endif

# the RT architecture relies both on PVM and PIPS architectures,
# because of obscure issues related to naming conventions...

ifeq ($(PIPS_ARCH),.)
RT_ARCH=$(PVM_ARCH)
else
RT_ARCH=$(PVM_ARCH)-$(PIPS_ARCH)
endif

# default target
all:

ifdef HPFC_RUNTIME
RT_DIR=	$(HPFC_RUNTIME)
else
RT_DIR= $(PIPS_ROOT)/Runtime/hpfc
endif

# the default is to use the same compilers and options as the library.
include $(RT_DIR)/$(RT_ARCH)/compilers.make

#
# special options driven by defines:
# USE_PVMe
# USE_GNU

ifdef _HPFC_USE_PVMe_
all:	$(TARGET).cmd
PVM=pvme
endif

#
# PVM arch dependent settings

ifeq ($(PVM_ARCH),CM5)
MIMD = 1
CMLD = cmmd-ld
# CMLD_FLAGS = -v
CMLD_FLAGS =
endif

ifeq ($(PVM_ARCH),PGON)
MIMD = 1
PVM_HLIB	+= -lrpc
PVM_NLIB	+= -lnx -lrpc
ALL_NLIBS	+= $(PVMHOST)
endif

ifeq ($(PVM_ARCH),SUN4)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),SUN4SOL2)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),SUNMP)
NETWORK = 1
RUNTIME_LIBS     += -lnsl -lsocket -lthread
endif

ifeq ($(PVM_ARCH),ALPHA)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),RS6K)
NETWORK = 1
# bsd helps with signals (e.g. if xpomp is used)
FFLAGS	+= -lbsd
endif

#
# Directories... 
# libraries...

pvmbin 	= $(HOME)/pvm3/bin/$(PVM_ARCH)
pvmlib	= $(PVM_ROOT)/lib/$(PVM_ARCH)
pvminc	= $(PVM_ROOT)/include

LIBS_DIR	+= -L. -L$(pvmlib) -L$(RT_DIR)/$(RT_ARCH)

PVM_FLIB 	+= -lfpvm3
PVM_GLIB 	+= -lgpvm3
PVM_HLIB 	+= -lpvm3

ifdef _HPFC_USE_PVMe_
pvmlib		= $(PVM_ROOT)/lib
pvminc		= $(PVM_ROOT)/lib
PVM_GLIB	=
#
# two possible protocols: less efficient one used by default:-)
# US (dedicated, 40MB/s) or IP (sharable, 15MB/s)
# LIBS_DIR	+= -L/usr/lpp/ssp/css/libus
LIBS_DIR	+= -L/usr/lpp/ssp/css/libip
COMMON_LIBS	+= -lmpci -bI:$(pvmlib)/pvm3e.exp
#
# LoadLeveller...
$(TARGET).cmd:;	$(RT_DIR)/hpfc_llcmd -n $(TARGET)
endif

ifdef MIMD
PVMHOST = $(pvmlib)/pvmhost.o
PVM_NLIB 	+= -lpvm3pe
endif

ifdef NETWORK
PVM_NLIB 	+= -lpvm3
endif

ifeq ($(PVM_ARCH),CRAY)
#
# the CRAY T3D does not require any library
#
PVM_FLIB =
PVM_GLIB =
PVM_HLIB =
PVM_NLIB =
endif

RUNTIME_LIBS	+= -lhpfcruntime

COMMON_LIBS	+= $(RUNTIME_LIBS) $(PVM_FLIB) $(PVM_GLIB) 

HOST_LIBS	+= $(PVM_HLIB)
NODE_LIBS 	+= $(PVM_NLIB) 

#
# Other tools

STRIP	=	strip
COPY 	= 	cp

#
# Files (the wildcards are GNU make extensions:-)

PVM_HEADERS 	= 	pvm3.h fpvm3.h
HEADERS 	=	$(wildcard hpfc_*.h) $(PVM_HEADERS)

COMMON_FFILES	=	param_init.f hpfc_check.f
HOST_FFILES 	=	$(wildcard [A-Z]*_host.f)
NODE_FFILES 	= 	$(wildcard [A-Z]*_node.f)

COMMON_OFILES	=	$(COMMON_FFILES:.f=.o) 
HOST_OFILES 	= 	$(HOST_FFILES:.f=.o) 
NODE_OFILES 	= 	$(NODE_FFILES:.f=.o)

FTEST	=	$(TARGET).f
OTEST	=	$(TARGET).o

#
# Executables

RTEST	=	$(TARGET)_out
HOST 	= 	$(TARGET)_host
NODE 	= 	$(TARGET)_node
MAIN	=	$(TARGET)_main

RUNABLES = $(HOST) $(NODE) $(RTEST) $(MAIN)
DEDUCED = $(PVM_HEADERS) param_init.f

#
# Rules

all:	$(DEDUCED)

.SUFFIXES:	.f .o .m4

#
# make is the target asked for by pipsmake for HPFC_MAKE

make: all install pvm

.INIT: hpfc_files

#
# PVM quick control

pvm:
	# starting pvm daemon if needed...
	@if [ -f /tmp/pvmd.$(shell id -u) ] ; \
	then echo "PVM already running..." ; \
	else echo quit | $(PVM) ; fi

reset:
	@echo "resetting PVM"
	@echo reset | $(PVM)

#
# Installation to run

$(pvmbin):; mkdir -p $(pvmbin)

$(pvmbin)/%: % $(pvmbin)
	$(COPY) $< $@

hostnode: host node
host: $(pvmbin)/$(HOST) 
node: $(pvmbin)/$(NODE)
main: $(pvmbin)/$(MAIN)
out: $(RTEST)

install: $(pvmbin)/$(HOST) $(pvmbin)/$(NODE) $(pvmbin)/$(MAIN)
	@echo files installed
	@echo 

run: install pvm
	$(pvmbin)/$(HOST)

diff: $(RUNABLES) install pvm
	$(pvmbin)/$(HOST) > parallel.out 2> parallel.err
	$(RTEST) > sequential.out 2> sequential.err
	@if cmp -s parallel.out sequential.out ; \
	then echo "DIFF ON STDOUT: none!" ; \
	else echo "DIFF ON STDOUT:" ; diff parallel.out sequential.out ; fi
	@# make is stopped at the diff if different...
	$(RM) parallel.out parallel.err sequential.out sequential.err

#
# Headers

hpfc_files:
	$(COPY) $(RT_DIR)/hpfc_*.h .

pvm3.h:	$(pvminc)/pvm3.h
	$(COPY) $(pvminc)/pvm3.h .

fpvm3.h:$(pvminc)/fpvm3.h
	$(COPY) $(pvminc)/fpvm3.h .

#
# Compilation

param_init.m4:;	$(RT_DIR)/hpfc_generate_init -n $(TARGET) .

param_init.f: param_init.m4
	$(M4) -D PVM_ARCH=$(PVM_ARCH) param_init.m4 > param_init.f

%.o: %.f
	$(FC) $(FFLAGS) $(FOPT) -c $< 

#
# Link

# also insures that a directive is there only once? 
# should be ok?
# what about continuations?
# LD IO: Link eDitor I/O (host & source)
# LD PURE: Link eDitor PURE (all)

LDF:=$(shell echo $(shell \
	sed -n 's,^[Cc!\*][Ff][Cc][Dd]$$[ 	][ 	]*[Ll][Dd],ld,p' \
		$(TARGET).f) | sort -u)

LDIO:=$(shell echo $(LDF) | sed -n 's,^ld[ 	]*[Ii][Oo],,p')
LDPURE:=$(shell echo $(LDF) | sed -n 's,^ld[ 	]*[Pp][Uu][Rr][Ee],,p')

$(HOST):  $(HEADERS) hpfc_main_host.o $(COMMON_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main_host.o \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(HOST_LIBS) \
		$(LDIO) $(LDPURE)
	$(STRIP) $@

$(NODE):  $(HEADERS) hpfc_main_node.o $(COMMON_OFILES) $(NODE_OFILES) 
	$(FC) $(FFLAGS) $(FOPT) -o $@ hpfc_main_node.o \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(NODE_LIBS) \
		$(LDPURE)
	$(STRIP) $@

$(MAIN): $(HEADERS) hpfc_main.o $(COMMON_OFILES) $(NODE_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main.o \
		$(HOST_OFILES) \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(NODE_LIBS)\
		$(LDIO) $(LDPURE)
	$(STRIP) $@

ifeq ($(PVM_ARCH),CM5)
$(NODE): $(HOST_OFILES)
	$(CMLD) $(CMLD_FLAGS) \
	   -comp $(FC) -o $(NODE) \
	   -host \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(PVMHOST) \
	 	$(LIBS_DIR) \
		$(ALL_HLIBS) \
	   -node \
		$(NODE_OFILES) 
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(ALL_NLIBS)
	$(STRIP) $(NODE)
endif

$(RTEST):  $(FTEST)
	$(FC) $(FFLAGS) -o $(RTEST) $(FTEST) $(LDIO) $(LDPURE)
	$(STRIP) $(RTEST)

#
# Cleaning

clean:;	$(RM) *.o *~ *.trace $(DEDUCED) core
clobber: clean; $(RM) $(RUNABLES) $(pvmbin)/$(HOST) $(pvmbin)/$(NODE)

echo:; @echo $(ECHO)

# that is all
#
