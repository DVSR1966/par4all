#
# $Id$
# 
# $Log: hpfc_Makefile_init,v $
# Revision 1.62  1997/06/09 09:53:06  coelho
# *** empty log message ***
#
# Revision 1.60  1997/05/16 14:26:36  coelho
# LINUX case added.
#
# Revision 1.59  1997/05/03 17:10:23  coelho
# diff does not need host and node executables, main and out are enough.
#
# Revision 1.54  1997/03/19 17:05:25  coelho
# _both.f files considered as common files for host and node.
#
#
# This is the initial makefile for HPFC compilation
# a NAME macro is expected somewhere... could be derived automatically?
# Makefile for PVM and HPFC, Fabien COELHO, 08/06/94

SHELL=/bin/sh

#
# usual default target is to build and install the seq and par versions
all: out main install
	#
	# $(NAME)_out sequential version compiled
	# $(NAME)_main parallel version compiled and installed
	#

#
# help target
help:
	#
	# SOME HELP!
	#
	# NOTE: this make file should be run with GNU make (gmake)
	#
	# Possible targets of high interest: out main install run
	#
	# COMPILATION and INSTALLATION
	#
	#   out: generates $(NAME)_out sequential executable 
	#   main: generates $(NAME)_main paralle PVM executable 
	#     (one SPMD executable which insures both I/O and computations)
	#   install: insures that $(NAME)_main is copied in the PVM directory
	#   hostnode: generates $(NAME)_{host,node} PVM executables
	#     (two executables, one for I/Os and a SPMD one for the nodes)
	#
	# OTHERS
	#
	#   all: out main install
	#   diff: compares sequential and parallel stdouts!
	#   clean: removes deducable files
	#   clobber: also removes executables files.
	#   reset: reset pvm
	#   install_{main,hostnode}: 
	#     copies executables to the pvm directory (where spawn find them)
	#

#
# Other tools

STRIP	=	strip
COPY 	= 	cp

#
# PVM interactive command

PVM=pvm

#
# architecture

ifndef PIPS_ARCH
PIPS_ARCH=.
endif

# the RT architecture relies both on PVM and PIPS architectures,
# because of obscure issues related to naming conventions when g77 is used...

RT_ARCH=$(PIPS_ARCH)/$(PVM_ARCH)

ifdef HPFC_RUNTIME
RT_DIR=	$(HPFC_RUNTIME)
else
RT_DIR= $(PIPS_ROOT)/Runtime/hpfc
endif

# source files from the runtime needed to compile a spmd program
RT_SRC_FILES =	hpfc_check.f \
		hpfc_*.h \
		hpfc_main.f \
		hpfc_main_host.f \
		hpfc_main_node.f \
		hpfc_architecture_m4_macros

# the default is to use the same compilers and options as the library.
include $(RT_DIR)/$(RT_ARCH)/compilers.make

#
# PVM architexture dependent settings

ifeq ($(PVM_ARCH),CM5)
MIMD = 1
CMLD = cmmd-ld
# CMLD_FLAGS = -v
CMLD_FLAGS =
endif

ifeq ($(PVM_ARCH),PGON)
MIMD = 1
PVM_HLIB	+= -lrpc
PVM_NLIB	+= -lnx -lrpc
ALL_NLIBS	+= $(PVMHOST)
endif

ifeq ($(PVM_ARCH),SUN4)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),SUN4SOL2)
NETWORK = 1
RUNTIME_LIBS	+= -lnsl -lsocket
endif

ifeq ($(PVM_ARCH),SUNMP)
NETWORK = 1
RUNTIME_LIBS     += -lnsl -lsocket -lthread
endif

ifeq ($(PVM_ARCH),ALPHA)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),RS6K)
NETWORK = 1
# bsd helps with signals (e.g. if xpomp is used)
FFLAGS	+= -lbsd
endif

ifeq ($(PVM_ARCH),LINUX)
NETWORK = 1
endif

#
# Directories... 
# libraries...

pvmbin 	= $(HOME)/pvm3/bin/$(PVM_ARCH)
pvmlib	= $(PVM_ROOT)/lib/$(PVM_ARCH)
pvminc	= $(PVM_ROOT)/include

LIBS_DIR	+= -L. -L$(pvmlib) -L$(RT_DIR)/$(RT_ARCH)

PVM_FLIB 	+= -lfpvm3
PVM_GLIB 	+= -lgpvm3
PVM_HLIB 	+= -lpvm3

ifdef _HPFC_USE_PVMe_
# we're using pvme, that's sure!
PVM=pvme
# for requesting nodes on the SP2: pvmd3e -ip -share cpu 8 &
# load leveller command files:
all:	$(NAME).cmd
# the directory organization is fun with IBM: 
# e.g. headers are in /lib (I guess this is IBM standard:-)
pvmlib		= $(PVM_ROOT)/lib
pvminc		= $(PVM_ROOT)/lib
PVM_GLIB	=
#
# two possible protocols: less efficient one used by default:-)
# US (dedicated, 40MB/s) or IP (sharable, 15MB/s)
# LIBS_DIR	+= -L/usr/lpp/ssp/css/libus
LIBS_DIR	+= -L/usr/lpp/ssp/css/libip
COMMON_LIBS	+= -lmpci -bI:$(pvmlib)/pvm3e.exp
endif

ifdef MIMD
PVMHOST = $(pvmlib)/pvmhost.o
PVM_NLIB 	+= -lpvm3pe
endif

ifdef NETWORK
PVM_NLIB 	+= -lpvm3
endif

ifeq ($(PVM_ARCH),CRAY)
#
# the CRAY T3D does not require any library... 
#
PVM_FLIB =
PVM_GLIB =
PVM_HLIB =
PVM_NLIB =
# 
pvminc  = /usr/include/mpp
pvmlib	= .
#
# cannot strip MPP executables?
#
STRIP	= :
#
# QSUB...
#
all:	$(NAME).qsub
main:	$(NAME).qsub
endif

# LoadLeveller...
$(NAME).cmd:;	$(RT_DIR)/hpfc_llcmd -n $(NAME)
# QNS...
$(NAME).qsub:; $(RT_DIR)/hpfc_qsub $(NAME) > $@

RUNTIME_LIBS	+= -lhpfcruntime
HPFC_PVM_LIB	+= -lhpfcpvm
HPFC_PMI_LIB	+= -lhpfcmpi

COMMON_LIBS	+= $(RUNTIME_LIBS) 
COMMON_PVM_LIBS	+= $(HPFC_PVM_LIB) $(PVM_FLIB) $(PVM_GLIB) 

HOST_LIBS	+= $(PVM_HLIB)
NODE_LIBS 	+= $(PVM_NLIB) 

#
# Files (the wildcards are GNU make extensions:-)

PVM_HEADERS 	= 	pvm3.h fpvm3.h
HEADERS 	=	$(wildcard hpfc_*.h) $(PVM_HEADERS)

RT_INIT		= 	hpfc_initialize_runtime.f

COMMON_FFILES	=	$(RT_INIT) hpfc_check.f $(wildcard [A-Z]*_both.f)
HOST_FFILES 	=	$(wildcard [A-Z]*_host.f)
NODE_FFILES 	= 	$(wildcard [A-Z]*_node.f)

COMMON_OFILES	=	$(COMMON_FFILES:.f=.o) 
HOST_OFILES 	= 	$(HOST_FFILES:.f=.o) 
NODE_OFILES 	= 	$(NODE_FFILES:.f=.o)

FTEST	=	$(NAME).f
OTEST	=	$(NAME).o

#
# Executables

RTEST	=	$(NAME)_out
HOST 	= 	$(NAME)_host
NODE 	= 	$(NAME)_node
MAIN	=	$(NAME)_main

RUNABLES = $(HOST) $(NODE) $(RTEST) $(MAIN)
DEDUCED = $(PVM_HEADERS) $(RT_INIT) $(RT_SRC_FILES)

#
# Rules

# all:	$(DEDUCED) 

.SUFFIXES:	.f .o .m4

#
# make is the target asked for by pipsmake for HPFC_MAKE

make: $(DEDUCED) all pvm

#
# PVM quick control

pvm:
	# starting pvm daemon if needed...
	@if [ -f /tmp/pvmd.$(shell id -u) ] ; \
	then echo "PVM already running..." ; \
	else echo quit | $(PVM) ; fi

reset:
	@echo "resetting PVM"
	@echo reset | $(PVM)

#
# Installation to run

$(pvmbin):; mkdir -p $(pvmbin)
$(pvmbin)/%: % $(pvmbin); $(COPY) $< $@

hostnode: host node
host: $(HOST) 
node: $(NODE)
main: $(MAIN)
out: $(RTEST)

install_main: $(pvmbin)/$(MAIN)
install_hostnode: install_node install_host
install_host: $(pvmbin)/$(HOST)
install_node: $(pvmbin)/$(NODE)

install_main_forced:; $(RM) $(pvmbin)/$(MAIN); $(MAKE) install_main;

# install in PVM directory what can be
install:
	-test -f $(MAIN) && $(MAKE) install_main_forced
	-test -f $(HOST) && $(MAKE) install_hostnode

run: install pvm
	$(pvmbin)/$(HOST)

diff: $(MAIN) $(RTEST) install pvm
	$(pvmbin)/$(MAIN) > parallel.out 2> parallel.err
	$(RTEST) > sequential.out 2> sequential.err
	@if cmp -s parallel.out sequential.out ; \
	then echo "DIFF ON STDOUT: none!" ; \
	else echo "DIFF ON STDOUT:" ; diff parallel.out sequential.out ; fi
	@# make is stopped at the diff if different...
	$(RM) parallel.out parallel.err sequential.out sequential.err

#
# Headers

$(RT_SRC_FILES):
	$(COPY) $(addprefix $(RT_DIR)/,$(RT_SRC_FILES)) .

pvm3.h:	$(pvminc)/pvm3.h
	$(COPY) $(pvminc)/pvm3.h .

fpvm3.h:$(pvminc)/fpvm3.h
	$(COPY) $(pvminc)/fpvm3.h .

#
# Compilation

$(RT_INIT:.f=.m4):;	$(RT_DIR)/hpfc_generate_init -n $(NAME) .

$(RT_INIT): $(RT_INIT:.f=.m4)
	$(M4) -D PVM_ARCH=$(PVM_ARCH) $< > $@

%.o: %.f; $(FC) $(FFLAGS) $(FOPT) -c $< 

#
# Link

# also insures that a directive is there only once? 
# should be ok?
# what about continuations?
# LD IO: Link eDitor I/O (host & source)
# LD PURE: Link eDitor PURE (all)

LDIO:=$(shell \
  sed -n 's,^[Cc!\*][Ff][Cc][Dd]$$[ 	][ 	]*[Ll][Dd][ 	]*[Ii][Oo],,p'\
		$(NAME).f | sort -u)
LDPURE:=$(shell \
  sed -n 's,^[Cc!\*][Ff][Cc][Dd]$$[ 	][ 	]*[Ll][Dd][ 	]*[Pp][Uu][Rr][Ee],,p'\
		$(NAME).f | sort -u)

$(HOST):  $(HEADERS) hpfc_main_host.o $(COMMON_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main_host.o \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(COMMON_PVM_LIBS) \
		$(HOST_LIBS) \
		$(LDIO) $(LDPURE)
	$(STRIP) $@

$(NODE):  $(HEADERS) hpfc_main_node.o $(COMMON_OFILES) $(NODE_OFILES) 
	$(FC) $(FFLAGS) $(FOPT) -o $@ hpfc_main_node.o \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(COMMON_PVM_LIBS) \
		$(NODE_LIBS) \
		$(LDPURE)
	$(STRIP) $@

$(MAIN): $(HEADERS) hpfc_main.o $(COMMON_OFILES) $(NODE_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main.o \
		$(HOST_OFILES) \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(COMMON_PVM_LIBS) \
		$(NODE_LIBS)\
		$(LDIO) $(LDPURE)
	$(STRIP) $@

ifeq ($(PVM_ARCH),CM5)
$(NODE): $(HOST_OFILES)
	$(CMLD) $(CMLD_FLAGS) \
	   -comp $(FC) -o $(NODE) \
	   -host \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(PVMHOST) \
	 	$(LIBS_DIR) \
		$(ALL_HLIBS) \
	   -node \
		$(NODE_OFILES) 
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(ALL_NLIBS)
	$(STRIP) $(NODE)
endif

$(RTEST):  $(FTEST)
	$(FC) $(FFLAGS) -o $(RTEST) $(FTEST) $(LDIO) $(LDPURE)
	$(STRIP) $(RTEST)

#
# Cleaning

clean:;	$(RM) *.o *~ *.trace $(RT_INIT:.f=.m4) $(DEDUCED) core mppcore
clobber: clean; $(RM) $(RUNABLES) $(pvmbin)/$(HOST) $(pvmbin)/$(NODE) \
	run.out run.err $(NAME).qsub 

echo:; @echo $(ECHO)

#
# Taring

TAR =	tar
ZIP =	gzip -v9

tar: clean
	# taring the sources, maybe for export
	cd .. ;\
	$(TAR) cf $(NAME).tar $(NAME).hpfc ;\
	$(ZIP) $(NAME).tar


# that is all
#
