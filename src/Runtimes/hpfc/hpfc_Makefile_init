#
# $RCSfile: hpfc_Makefile_init,v $ version $Revision$
# ($Date: 1996/12/27 13:38:56 $, )
#
# This is the initial makefile for HPFC compilation
# a TARGET macro is expected somewhere...
# Makefile for PVM and HPFC, Fabien COELHO, 08/06/94

SHELL=/bin/sh

# default target
help:
	#
	# SOME HELP!
	#
	# NOTE: this make file should be run with GNU make (gmake)
	#
	# Possible targets of high interest: out main install run
	#
	# COMPILATION and INSTALLATION
	#
	#   out: generates $(TARGET)_out sequential executable 
	#   main: generates $(TARGET)_main paralle PVM executable 
	#     (one SPMD executable which insures both I/O and computations)
	#   install: insures that $(TARGET)_main is copied in the PVM directory
	#   hostnode: generates $(TARGET)_{host,node} PVM executables
	#     (two executables, one for I/Os and a SPMD one for the nodes)
	#
	# OTHERS
	#
	#   diff: compares sequential and parallel stdouts!
	#   clean: removes deducable files
	#   clobber: also removes executables files.
	#   reset: reset pvm
	#   install_{main,hostnode}: 
	#     copies executables to the pvm directory (where spawn find them)
	#

#
# Other tools

STRIP	=	strip
COPY 	= 	cp

#
# PVM interactive command

PVM=pvm

#
# architecture

ifndef PIPS_ARCH
PIPS_ARCH=.
endif

# the RT architecture relies both on PVM and PIPS architectures,
# because of obscure issues related to naming conventions when g77 is used...

ifeq ($(PIPS_ARCH),.)
RT_ARCH=$(PVM_ARCH)
else
RT_ARCH=$(PVM_ARCH)-$(PIPS_ARCH)
endif

ifdef HPFC_RUNTIME
RT_DIR=	$(HPFC_RUNTIME)
else
RT_DIR= $(PIPS_ROOT)/Runtime/hpfc
endif

# source files from the runtime needed to compile a spmd program
RT_SRC_FILES =	hpfc_check.f \
		hpfc_*.h \
		hpfc_main.f \
		hpfc_main_host.f \
		hpfc_main_node.f \
		hpfc_architecture_m4_macros

# the default is to use the same compilers and options as the library.
include $(RT_DIR)/$(RT_ARCH)/compilers.make

#
# PVM arch dependent settings

ifeq ($(PVM_ARCH),CM5)
MIMD = 1
CMLD = cmmd-ld
# CMLD_FLAGS = -v
CMLD_FLAGS =
endif

ifeq ($(PVM_ARCH),PGON)
MIMD = 1
PVM_HLIB	+= -lrpc
PVM_NLIB	+= -lnx -lrpc
ALL_NLIBS	+= $(PVMHOST)
endif

ifeq ($(PVM_ARCH),SUN4)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),SUN4SOL2)
NETWORK = 1
RUNTIME_LIBS	+= -lnsl -lsocket
endif

ifeq ($(PVM_ARCH),SUNMP)
NETWORK = 1
RUNTIME_LIBS     += -lnsl -lsocket -lthread
endif

ifeq ($(PVM_ARCH),ALPHA)
NETWORK = 1
endif

ifeq ($(PVM_ARCH),RS6K)
NETWORK = 1
# bsd helps with signals (e.g. if xpomp is used)
FFLAGS	+= -lbsd
endif

#
# Directories... 
# libraries...

pvmbin 	= $(HOME)/pvm3/bin/$(PVM_ARCH)
pvmlib	= $(PVM_ROOT)/lib/$(PVM_ARCH)
pvminc	= $(PVM_ROOT)/include

LIBS_DIR	+= -L. -L$(pvmlib) -L$(RT_DIR)/$(RT_ARCH)

PVM_FLIB 	+= -lfpvm3
PVM_GLIB 	+= -lgpvm3
PVM_HLIB 	+= -lpvm3

ifdef _HPFC_USE_PVMe_
# we're using pvme, that's sure!
PVM=pvme
# for requesting nodes on the SP2: pvmd3e -ip -share cpu 8 &
# load leveller command files:
all:	$(TARGET).cmd
# the directory organization is fun with IBM: 
# e.g. headers are in /lib (I guess this is IBM standard:-)
pvmlib		= $(PVM_ROOT)/lib
pvminc		= $(PVM_ROOT)/lib
PVM_GLIB	=
#
# two possible protocols: less efficient one used by default:-)
# US (dedicated, 40MB/s) or IP (sharable, 15MB/s)
# LIBS_DIR	+= -L/usr/lpp/ssp/css/libus
LIBS_DIR	+= -L/usr/lpp/ssp/css/libip
COMMON_LIBS	+= -lmpci -bI:$(pvmlib)/pvm3e.exp
#
# LoadLeveller...
$(TARGET).cmd:;	$(RT_DIR)/hpfc_llcmd -n $(TARGET)
endif

ifdef MIMD
PVMHOST = $(pvmlib)/pvmhost.o
PVM_NLIB 	+= -lpvm3pe
endif

ifdef NETWORK
PVM_NLIB 	+= -lpvm3
endif

ifeq ($(PVM_ARCH),CRAY)
#
# the CRAY T3D does not require any library... 
#
PVM_FLIB =
PVM_GLIB =
PVM_HLIB =
PVM_NLIB =
# 
pvminc  = /usr/include/mpp
pvmlib	=
#
# cannot strip MPP executables?
#
STRIP	= :
endif

RUNTIME_LIBS	+= -lhpfcruntime

COMMON_LIBS	+= $(RUNTIME_LIBS) $(PVM_FLIB) $(PVM_GLIB) 

HOST_LIBS	+= $(PVM_HLIB)
NODE_LIBS 	+= $(PVM_NLIB) 

#
# Files (the wildcards are GNU make extensions:-)

PVM_HEADERS 	= 	pvm3.h fpvm3.h
HEADERS 	=	$(wildcard hpfc_*.h) $(PVM_HEADERS)

COMMON_FFILES	=	param_init.f hpfc_check.f
HOST_FFILES 	=	$(wildcard [A-Z]*_host.f)
NODE_FFILES 	= 	$(wildcard [A-Z]*_node.f)

COMMON_OFILES	=	$(COMMON_FFILES:.f=.o) 
HOST_OFILES 	= 	$(HOST_FFILES:.f=.o) 
NODE_OFILES 	= 	$(NODE_FFILES:.f=.o)

FTEST	=	$(TARGET).f
OTEST	=	$(TARGET).o

#
# Executables

RTEST	=	$(TARGET)_out
HOST 	= 	$(TARGET)_host
NODE 	= 	$(TARGET)_node
MAIN	=	$(TARGET)_main

RUNABLES = $(HOST) $(NODE) $(RTEST) $(MAIN)
DEDUCED = $(PVM_HEADERS) param_init.f $(RT_SRC_FILES)

#
# Rules

all:	$(DEDUCED) 

.SUFFIXES:	.f .o .m4

#
# make is the target asked for by pipsmake for HPFC_MAKE

make: all install pvm

#
# PVM quick control

pvm:
	# starting pvm daemon if needed...
	@if [ -f /tmp/pvmd.$(shell id -u) ] ; \
	then echo "PVM already running..." ; \
	else echo quit | $(PVM) ; fi

reset:
	@echo "resetting PVM"
	@echo reset | $(PVM)

#
# Installation to run

$(pvmbin):; mkdir -p $(pvmbin)
$(pvmbin)/%: % $(pvmbin); $(COPY) $< $@

hostnode: host node
host: $(HOST) 
node: $(NODE)
main: $(MAIN)
out: $(RTEST)

install_main: $(pvmbin)/$(MAIN)
install_hostnode: install_node install_host
install_host: $(pvmbin)/$(HOST)
install_node: $(pvmbin)/$(NODE)

install:; $(RM) $(pvmbin)/$(MAIN); $(MAKE) install_main;

run: install pvm
	$(pvmbin)/$(HOST)

diff: $(RUNABLES) install pvm
	$(pvmbin)/$(MAIN) > parallel.out 2> parallel.err
	$(RTEST) > sequential.out 2> sequential.err
	@if cmp -s parallel.out sequential.out ; \
	then echo "DIFF ON STDOUT: none!" ; \
	else echo "DIFF ON STDOUT:" ; diff parallel.out sequential.out ; fi
	@# make is stopped at the diff if different...
	$(RM) parallel.out parallel.err sequential.out sequential.err

#
# Headers

$(RT_SRC_FILES):
	$(COPY) $(addprefix $(RT_DIR)/,$(RT_SRC_FILES)) .

pvm3.h:	$(pvminc)/pvm3.h
	$(COPY) $(pvminc)/pvm3.h .

fpvm3.h:$(pvminc)/fpvm3.h
	$(COPY) $(pvminc)/fpvm3.h .

#
# Compilation

param_init.m4:;	$(RT_DIR)/hpfc_generate_init -n $(TARGET) .

param_init.f: param_init.m4
	$(M4) -D PVM_ARCH=$(PVM_ARCH) param_init.m4 > param_init.f

%.o: %.f; $(FC) $(FFLAGS) $(FOPT) -c $< 

#
# Link

# also insures that a directive is there only once? 
# should be ok?
# what about continuations?
# LD IO: Link eDitor I/O (host & source)
# LD PURE: Link eDitor PURE (all)

LDIO:=$(shell \
  sed -n 's,^[Cc!\*][Ff][Cc][Dd]$$[ 	][ 	]*[Ll][Dd][ 	]*[Ii][Oo],,p'\
		$(TARGET).f | sort -u)
LDPURE:=$(shell \
  sed -n 's,^[Cc!\*][Ff][Cc][Dd]$$[ 	][ 	]*[Ll][Dd][ 	]*[Pp][Uu][Rr][Ee],,p'\
		$(TARGET).f | sort -u)

$(HOST):  $(HEADERS) hpfc_main_host.o $(COMMON_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main_host.o \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(HOST_LIBS) \
		$(LDIO) $(LDPURE)
	$(STRIP) $@

$(NODE):  $(HEADERS) hpfc_main_node.o $(COMMON_OFILES) $(NODE_OFILES) 
	$(FC) $(FFLAGS) $(FOPT) -o $@ hpfc_main_node.o \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(NODE_LIBS) \
		$(LDPURE)
	$(STRIP) $@

$(MAIN): $(HEADERS) hpfc_main.o $(COMMON_OFILES) $(NODE_OFILES) $(HOST_OFILES)
	$(FC) $(FFLAGS) -o $@ hpfc_main.o \
		$(HOST_OFILES) \
		$(NODE_OFILES) \
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(COMMON_LIBS) \
		$(NODE_LIBS)\
		$(LDIO) $(LDPURE)
	$(STRIP) $@

ifeq ($(PVM_ARCH),CM5)
$(NODE): $(HOST_OFILES)
	$(CMLD) $(CMLD_FLAGS) \
	   -comp $(FC) -o $(NODE) \
	   -host \
		$(HOST_OFILES) \
		$(COMMON_OFILES) \
		$(PVMHOST) \
	 	$(LIBS_DIR) \
		$(ALL_HLIBS) \
	   -node \
		$(NODE_OFILES) 
		$(COMMON_OFILES) \
		$(LIBS_DIR) \
		$(ALL_NLIBS)
	$(STRIP) $(NODE)
endif

$(RTEST):  $(FTEST)
	$(FC) $(FFLAGS) -o $(RTEST) $(FTEST) $(LDIO) $(LDPURE)
	$(STRIP) $(RTEST)

#
# Cleaning

clean:;	$(RM) *.o *~ *.trace $(DEDUCED) core
clobber: clean; $(RM) $(RUNABLES) $(pvmbin)/$(HOST) $(pvmbin)/$(NODE)

echo:; @echo $(ECHO)

#
# Taring

TAR =	tar
ZIP =	gzip -v9

tar: clean
	# taring the sources, maybe for export
	cd .. ;\
	$(TAR) cf $(TARGET).tar $(TARGET).hpfc ;\
	$(ZIP) $(TARGET).tar


# that is all
#
