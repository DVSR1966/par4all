c
c     Reductions management 
c
c $RCSfile: hpfc_reductions.m4f,v $ ($Date: 1994/12/21 16:20:13 $, )
c version $Revision$
c got on %D%, %T%
c $Id$
c
c     it is supposed that the reduction is computed on a full
c     array, which is nor replicated anyway. If used on a part,
c     should work, but I am not so sure.
c
c----------
c
c this could be computed statically, where it is used...
c
c
      integer function HPFC_PROCDIM(an, ad)
      include "hpfc_commons.h"
      integer an, ad
      integer tn, pn, i, it, ip
      tn = ATOT(an)
      pn = TTOP(tn)
      it = 0
      ip = 0
      do i=1, NODIMT(tn)
         if (ALIGN(an, i, 1).EQ.ad) it = i
      enddo
      if (it.NE.0) then
         do i=1, NODIMP(pn)
            if (DIST(tn, i, 1).EQ.it) ip = i
         enddo
      endif
      HPFC_PROCDIM = ip
      return
      end
c      
c----------
c
include(`hpfc_lib_m4_macros')dnl
c
c macros to generate the code
c
define(`REDUCTION_NODE_DECL',`
      integer ifelse(REDTYPE, logical, t$1`,') i$1, l$1, u$1, s$1, d$1')dnl
define(`COMPUTE_LOCALIND',`
      t$1 = HPFC_LOCALIND(an, $1, lo$1)')dnl
define(`LIST_DECL_BOUNDS',`
     & dl$1, du$1')dnl
define(`LIST_RED_BOUNDS',`
     & lo$1, up$1')dnl
define(`ARRAY_DECL',`dl$1:du$1')dnl
define(`LOWER_REF',`lo$1')dnl
define(`TEMPO_REF',`t$1')dnl
define(`INDEX_REF',`i$1')dnl
define(`ZERO_REF',`0')dnl
define(`LOOP_BOUNDS_COMPUTATION',`
      d$1 = HPFC_PROCDIM(an, $1)
      CALL HPFC_LOOP_BOUNDS(l$1, u$1, s$1, lo$1, up$1, an, d$1)')dnl
define(`DO_LOOP',`
      do i$1 = l$1, u$1')dnl
define(`ENDDO_LOOP',`
      enddo')dnl
define(`DISJUNCTION',
`ifelse(REDTYPE, logical, $1,
        REDTYPE, cumulate, $2,
        `errprint(m4: unexpected reduction type)')')dnl
c
c Generic reduction
c
c REDTYPE may be logical or cumulate
c NAME may be MIN, MAX, SUM, MULT
c LEVEL may be 1 to 7
c
define(`GENERIC_REDUCTION',`dnl
pushdef(`REDTYPE',$1)dnl
pushdef(`LEVEL',$2)dnl
pushdef(`TYPE',$3)dnl
pushdef(`PVMTYPE',$4)dnl
pushdef(`NAME',$5)dnl
pushdef(`OPERATOR',$6)dnl
c
c    REDTYPE REDUCTION NAME FOR TYPE, LEVEL DIMENSIONS
c
c     
c NODE PART
c
      TYPE function build_name(nred,LEVEL,PVMTYPE,NAME)(a, an, dnl
COMMA_REPLICATE(LEVEL, `LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL, `LIST_RED_BOUNDS')
     & )
      include "fpvm3.h"
_CM5(`      include "cmmd_fort.h"')
      include "hpfc_commons.h"
      include "hpfc_rtsupport.h"
      external HPFC_PROCDIM
      integer HPFC_PROCDIM
      TYPE 
     $ a(COMMA_REPLICATE(LEVEL, `ARRAY_DECL'))
      integer 
     &    an, dnl
COMMA_REPLICATE(LEVEL, `LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL, `LIST_RED_BOUNDS')
      TYPE result
SIMPLE_REPLICATE(LEVEL, `REDUCTION_NODE_DECL')
c
c initiate with a valid value
c
DISJUNCTION(``
      'CALL HPFC_CMPOWNERS(an, 
     $  COMMA_REPLICATE(LEVEL, `LOWER_REF'),
     $  COMMA_REPLICATE(TO7(LEVEL), `ZERO_REF'))
      if (HPFC_SENDERP()) then
SIMPLE_REPLICATE(LEVEL, `COMPUTE_LOCALIND')
         result = a(COMMA_REPLICATE(LEVEL, `TEMPO_REF'))
         call COM_PREFIX`'_SNDTO_A(PVMTYPE, result)
      else
         call COM_PREFIX`'_RCVFR_mCS(PVMTYPE, result)
      endif',``
      'result = ifelse(NAME, `SUM', 0, NAME, `MULT', 1, dnl
                      FATAL_ERROR(`unexpected name'))')
c
c compute the loop bounds
c
SIMPLE_REPLICATE(LEVEL, `LOOP_BOUNDS_COMPUTATION')
c
c local reduction
c
REVERSE_REPLICATE(LEVEL, `DO_LOOP')
DISJUNCTION(``
      'if (a(COMMA_REPLICATE(LEVEL, `INDEX_REF')) OPERATOR result) 
     &    result = a(COMMA_REPLICATE(LEVEL, `INDEX_REF'))',``
      'result = result OPERATOR  a(COMMA_REPLICATE(LEVEL, `INDEX_REF'))')
SIMPLE_REPLICATE(LEVEL, `ENDDO_LOOP')
c
c send partial result to host, and get the final result
c
ifelse(ARCHITECTURE,`CM5',`dnl
      if (0.ne.CMMD_send(
     $     CM_HOST_ID,
     $     HOSTCHANNEL,
     $     result,
     $     M4_PVM_LENGTH(PVMTYPE))) then
         print *, "hpfc reduction: send failed"
         stop
      endif
      HOSTCHANNEL = HOSTCHANNEL+2
      call CMMD_receive_bc_from_host(result, M4_PVM_LENGTH(PVMTYPE))',`
      call HPFC_SNDTO_H(PVMTYPE, result)
      call HPFC_RCVFR_mCH(PVMTYPE, result)')
      build_name(nred,LEVEL,PVMTYPE,NAME) = result
      return
      end
c
c HOST PART
c
      TYPE function build_name(hred,LEVEL,PVMTYPE,NAME)()
      include "fpvm3.h"
_CM5(`      include "cmmd_fort.h"')
      include "hpfc_commons.h"
      TYPE result(MAXMAXSIZEOFPROCS), final
      integer i
c
c get partial results
c
      do i=1, MAXSIZEOFPROCS
ifelse(ARCHITECTURE,`CM5',`dnl
         if (0.ne.CMMD_receive(
     $     CM_NODE_IDS(i),
     $     NODECHANNELS(i),
     $     result(i),
     $     M4_PVM_LENGTH(PVMTYPE))) then
            print *, "hpfc reduction: reveive failed"
         endif
         NODECHANNELS(i) = NODECHANNELS(i)+2',`dnl
         SENDERTID = NODETIDS(i)
         SLID = i
         CALL HPFC_RCVFR_S(PVMTYPE, result(i))')
      enddo
c
c compute final result
c
      final = result(1)
      do i=2, MAXSIZEOFPROCS
DISJUNCTION(``
      '  if (result(i) OPERATOR final) 
     &     final = result(i)',``
      '   final = final OPERATOR result(i)')
      enddo
c
c send final result to nodes 
c      
ifelse(ARCHITECTURE,`CM5',`dnl
      call CMMD_bc_from_host(final, M4_PVM_LENGTH(PVMTYPE))',`dnl 
      call HPFC_HSNDTO_A(PVMTYPE, final)')
      build_name(hred,LEVEL,PVMTYPE,NAME) = final
      return
      end
c
c------------
c
popdef(`REDTYPE')dnl
popdef(`LEVEL')dnl
popdef(`TYPE')dnl
popdef(`PVMTYPE')dnl
popdef(`NAME')dnl
popdef(`OPERATOR')dnl')dnl
c
define(`SEVEN_DIMENSION',`
GENERIC_REDUCTION($1, 1, $2, $3, $4, $5)
GENERIC_REDUCTION($1, 2, $2, $3, $4, $5)
GENERIC_REDUCTION($1, 3, $2, $3, $4, $5)
GENERIC_REDUCTION($1, 4, $2, $3, $4, $5)
c GENERIC _REDUCTION($1, 5, $2, $3, $4, $5)
c GENERIC _REDUCTION($1, 6, $2, $3, $4, $5)
c GENERIC _REDUCTION($1, 7, $2, $3, $4, $5)')dnl
define(`LOGICAL_REDUCTION',`SEVEN_DIMENSION(logical, $1, $2, $3, $4)')dnl
define(`LOGICAL_REDUCTIONS',`
LOGICAL_REDUCTION($1, $2, MIN, .LT.)
LOGICAL_REDUCTION($1, $2, MAX, .GT.)')dnl
define(`CUMULATE_REDUCTION',`SEVEN_DIMENSION(cumulate, $1, $2, $3, $4)')dnl
define(`CUMULATE_REDUCTIONS',`
CUMULATE_REDUCTION($1, $2, SUM, +)
CUMULATE_REDUCTION($1, $2, MULT, *)')dnl
define(`REDUCTIONS',`
LOGICAL_REDUCTIONS($1, $2)
CUMULATE_REDUCTIONS($1, $2)')dnl
c
c All the reductions:
c
c R EDUCTIONS(byte, BYTE1)
c R EDUCTIONS(integer*2, INTEGER2)
REDUCTIONS(integer*4, INTEGER4)
REDUCTIONS(real*4, REAL4)
REDUCTIONS(real*8, REAL8) 
c C UMULATE_REDUCTIONS(complex*8, COMPLEX8)
c C UMULATE_REDUCTIONS(complex*16, COMPLEX16)
c
c that is all
c
