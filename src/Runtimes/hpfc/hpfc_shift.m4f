c
c $RCSfile: hpfc_shift.m4f,v $ version $Revision$
c ($Date: 1995/09/25 17:45:23 $, )
c
c
      subroutine hpfc_tdim(array, dim, template, tdim)
      integer array, dim, template, tdim
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer i
c
      template = ATOT(dim)
      tdim = 0
      do i=1, NODIMT(template)
         if (ALIGN(array,i,1).eq.dim) tdim=i
      enddo
      debug(`print *, "hpfc_tdim ", array, dim, template, tdim')
      end
c
c
      subroutine hpfc_pdim(template, tdim, procs, pdim)
      integer template, tdim, procs, pdim
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer i
c
      procs = TTOP(template)
      pdim = 0
      do i=1, NODIMP(procs)
         if (DIST(template,i,1).eq.tdim) pdim=i
      enddo
      debug(`print *, "hpfc_pdim ", template, tdim, procs, pdim')
      end
c
c
      integer function hpfc_proc_dim(an, dim)
      integer an, dim
      integer template, tdim, procs, pdim
      call hpfc_tdim(an, dim, template, tdim)
      call hpfc_pdim(template, tdim, procs, pdim)
      hpfc_proc_dim=pdim
      end
c
c
      subroutine hpfc_template_cell
     $     (array, dim, index, template, tdim, cell)
      integer array, dim, index, template, tdim, cell
      include "hpfc_commons.h"
      include "hpfc_includes.h"
c
      call hpfc_tdim(array, dim, template, tdim)
      if (tdim.eq.INTFLAG) stop
      if (tdim.eq.0) then
         cell = ALIGN(array,tdim,3)
      else
         cell = ALIGN(array,tdim,2)*index+ALIGN(array,tdim,3)
      endif
      end
c
c
      subroutine hpfc_procs_n(template, tdim, cell, procs, pdim, n)
      integer template, tdim, cell, procs, pdim, n
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer param
c
      call hpfc_pdim(template, tdim, procs, pdim)
      if (pdim.eq.INTFLAG) stop
      param = DIST(template, pdim, 2)
      if (param.gt.0) then
c BLOCK distribution
         n = ((cell-RANGET(template, tdim, 1)) / param) 
     $        + RANGEP(procs, pdim, 1)
      else
c CYCLIC distribution
         param = -param
         n = MOD(((cell-RANGET(template, tdim, 1))/param),
     $             RANGEP(procs, pdim, 3)) + RANGEP(procs, pdim, 1)
      endif
      end
c
c ARRAY TO PROCESSORS
c
      subroutine hpfc_array_to_procs
     $     (array, dim, index, procs, pdim, n)
      integer array, dim, index, procs, pdim, n
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer template, tdim, cell
      call hpfc_template_cell(array, dim, index, template, tdim, cell)
      call hpfc_procs_n(template, tdim, cell, procs, pdim, n)
      end
c
c Assumes a block distribution and a positive (?) alignment
c
      subroutine hpfc_last_local_item
     $     (procs, pdim, n, array, dim, last)
      integer procs, pdim, n, array, dim, last
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer template, tdim
c
      call hpfc_tdim(array, dim, template, tdim)
      last = (DIST(template, pdim, 2)
     $     * (n-RANGEP(procs, pdim, 1)+1) - 1
     $     + RANGET(template, tdim, 1)
     $     - ALIGN(array, tdim,  3)) / ALIGN(array, tdim, 2)
      debug(`print *, procs, "[", pdim, "](", n,  ") last ", last')
      end
c
c computes the relative lid 
c
      subroutine hpfc_cmp_lid(procs, pdim, n, lid)
      integer procs, pdim, n
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      logical replicated
      integer indp(7), i, lid
      do i=1, NODIMP(procs)
         indp(i)=MYPOS(i, procs)
      enddo
      indp(pdim)=n
      call HPFC_PROCLID(indp, procs, lid, replicated)
      end
c
c Considering array(DIM=dim lb:ub) the accessed area, with shift
c to be performed, computes the processes to be sent data and
c the area to be touched, as expressed in local addresses.
c 
c The dual use is to compute the area written and the relative senders.
c
c If one of the delta processes is zero, it means that the shift is local.
c
      subroutine hpfc_shift(array, dim, lb, ub, sh, 
     $                      lb1, ub1, lid1, lb2, ub2, lid2)
      integer array, dim, lb, ub, sh,
     $     lb1, ub1, lid1, lb2, ub2, lid2
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer nlb, nub, llb, pdim, procs, tdim, template
      integer glb, gub, glbd, gubd, p1, p2, last
c
      debug(`print *, "hpfc_shift array/dim/area: ", array, dim, lb, ub')
      call hpfc_tdim(array, dim, template, tdim)
      call hpfc_pdim(template, tdim, procs, pdim)
      call hpfc_loop_bounds(nlb, nub, llb, lb, ub, array, pdim)
c
c empty
c
      if (nlb.gt.nub) then
         lb1=1
         ub1=0
         lid1=-1
         lb2=1
         ub2=0
         lid2=-1
         debug(`print *, "hpfc_shift, nothing for ", MYLID')
         return
      endif
      glb = llb+1
      glbd = glb+sh
      gub = glb + nub-nlb
      gubd = gub+sh
c
c now array(DIM=dim glb:gub) is the accessed area for the current process
c and array(DIM=dim glbd:gubd) is the target area
c
      call hpfc_array_to_procs(array, dim, glbd, procs, pdim, p1)
      call hpfc_array_to_procs(array, dim, gubd, procs, pdim, p2)
      
      if (p1.eq.p2) then
c only one target
         lb1=nlb
         ub1=nub
         call hpfc_cmp_lid(procs, pdim, p1, lid1)
         lb2=1
         ub2=0
         lid2=-1
      else
         lb1=nlb
         call hpfc_last_local_item(procs, pdim, p1, array, dim, last)
         ub1 = last-glbd+lb1
         call hpfc_cmp_lid(procs, pdim, p1, lid1)
         lb2=ub1+1
         ub2=nub
         call hpfc_cmp_lid(procs, pdim, p2, lid2)
      endif
      debug(`print *, "hpfc_shift, for ", MYLID,
     $     ": ", lb1, ub1, lid1, lb2, ub2, lid2')
      end
c
c after packing functions
c 
define(`LIST_DECL_BOUNDS',`
     $ dl$1, du$1')dnl
define(`LIST_SECTION',`
     $ rl$1, ru$1')dnl
define(`LIST_NEW_SECTION',`
     $ l($1), u($1), 1')dnl
define(`DO_LOOP',`
      do i$1 = l($1), u($1)')dnl
define(`ENDDO_LOOP',`
      enddo')dnl
define(`ARRAY_DECL',`dl$1:du$1')dnl
define(`INDEX_REF',`i$1')dnl
define(`INDEX_REFSH',`i$1+s($1)')
define(`INIT_TABLE',`dnl
      il($1)=rl$1
      iu($1)=ru$1
')dnl
c
define(`GENERIC_SHIFT',`dnl
pushdef(`LEVEL',$1)dnl
pushdef(`PVMTYPE',$2)dnl
pushdef(`TYPE',m4_type_name(PVMTYPE))dnl
      subroutine build_name(HPFC_SHIFT,PVMTYPE,LEVEL)(
     $  array, an, dim, sh, dnl
COMMA_REPLICATE(LEVEL, `LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL, `LIST_SECTION')
     $)
      integer
     $     an, dim, sh, dnl
COMMA_REPLICATE(LEVEL, `LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL, `LIST_SECTION')
      TYPE
     $ array(COMMA_REPLICATE(LEVEL, `ARRAY_DECL'))
      include "fpvm3.h"
      include "hpfc_commons.h"
      include "hpfc_includes.h"
      integer COMMA_REPLICATE(LEVEL, `INDEX_REF')
      integer info, tmp, i, lid(2), j, bufid
      integer l(LEVEL), u(LEVEL), lp, up, il(LEVEL), iu(LEVEL)
      integer s(LEVEL)
SIMPLE_REPLICATE(LEVEL,`INIT_TABLE')dnl      
c
c TO
c      
      do i=1, LEVEL
         if (dim.ne.i) then
            call HPFC_LOOP_BOUNDS
     $           (l(i), u(i), tmp, il(i), iu(i), 
     $            an, hpfc_proc_dim(an, i))
            debug(`print *, MYLID, " dim ", i, " bounds: ",
     $           l(i), u(i)')
         else
            call hpfc_shift
     $           (an, dim, il(i), iu(i), sh,
     $            l(i), u(i), lid(1),
     $            lp, up, lid(2))
         endif
      enddo
      do i=1, LEVEL
         if (dim.ne.i) then
            s(i)=0
         else
            s(i)=sh
         endif
      enddo
      do j=1, 2
         if (lid(j).eq.MYLID) then
            debug(`print *, MYLID, " copying shift"')
c
c the SHIFT is local
c         
REVERSE_REPLICATE(LEVEL,`DO_LOOP')
      array(COMMA_REPLICATE(LEVEL,`INDEX_REFSH'))=
     $       array(COMMA_REPLICATE(LEVEL,`INDEX_REF'))
SIMPLE_REPLICATE(LEVEL,`ENDDO_LOOP')
         else
            if (lid(j).gt.0) then
               debug(`print *, MYLID, " sending shift to ", lid(j)')
c
c the SHIFT is to another processor
c
               call pvmfinitsend(PVMDATARAW, bufid)
               call build_name(HPFC_PACK,PVMTYPE,LEVEL)
     $            (array, dnl
COMMA_REPLICATE(LEVEL,`LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL,`LIST_NEW_SECTION'))
               call pvmfsend(NODETIDS(lid(j)),SENDCHANNELS(lid(j)),info)
               SENDCHANNELS(lid(j))=SENDCHANNELS(lid(j))+2
            endif
         endif
         l(dim)=lp
         u(dim)=up
      enddo
c
c FROM
c      
      il(dim)=il(dim)+sh
      iu(dim)=iu(dim)+sh
      call hpfc_shift
     $     (an, dim, il(dim), iu(dim), -sh,
     $      l(dim), u(dim), lid(1),
     $      lp, up, lid(2))
c
       do j=1, 2
          if (lid(j).gt.0.and.lid(j).ne.MYLID) then
             debug(`print *, MYLID, " receiving shift from ", lid(j)')
c
c the SHIFT is to another processor
c
             call pvmfrecv(NODETIDS(lid(j)),RECVCHANNELS(lid(j)),info)
             RECVCHANNELS(lid(j))=RECVCHANNELS(lid(j))+2
             call build_name(HPFC_UNPACK,PVMTYPE,LEVEL)
     $            (array, dnl
COMMA_REPLICATE(LEVEL,`LIST_DECL_BOUNDS'),dnl
COMMA_REPLICATE(LEVEL,`LIST_NEW_SECTION'))
         endif
         l(dim)=lp
         u(dim)=up
      enddo
      end
c     
popdef(`LEVEL')dnl
popdef(`TYPE')dnl
popdef(`PVMTYPE')dnl')dnl
c
c
define(`ALL_SHIFT',`dnl
GENERIC_SHIFT(1,$1)
GENERIC_SHIFT(2,$1)
GENERIC_SHIFT(3,$1)
dnl GENERIC_SHIFT(4,$1)
dnl GENERIC_SHIFT(5,$1)
dnl GENERIC_SHIFT(6,$1)
dnl GENERIC_SHIFT(7,$1)')dnl
c
ALL_SHIFT(INTEGER4)
ALL_SHIFT(REAL4)
ALL_SHIFT(REAL8)
dnl ALL_SHIFT(BYTE1)
dnl ALL_SHIFT(INTEGER2)
dnl ALL_SHIFT(COMPLEX8)
dnl ALL_SHIFT(COMPLEX16)
c
c That is all
c
