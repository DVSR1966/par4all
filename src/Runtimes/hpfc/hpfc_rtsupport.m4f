!
! Runtime Support Functions for the High Performance Fortran Compiler
! by Fabien COELHO.
!
! $RCSfile: hpfc_rtsupport.m4f,v $ version $Revision$
! ($Date: 1996/09/07 15:24:13 $, )
!
!-----------------
!
! HPFC_TEMPLATE
!
! this subroutine computes the coordonates of array number an 
! on the template tn
!
      subroutine HPFC_TEMPLATE(inda, an, indt, tn)
      integer inda(7), an, indt(7), tn
      include "hpfc_commons.h"
      integer i, adim
      do i=1, NODIMT(tn)
         adim = ALIGN(an, i, 1)
         if (adim.EQ.INTFLAG) then
!
! no alignment
!
            indt(i) = INTFLAG
         else
            if (adim.EQ.0) then
!
! constant alignment
!
               indt(i) = ALIGN(an, i, 3)
            else
!
! linear alignment
!
               indt(i) = (ALIGN(an, i, 2) * inda(adim)) 
     $              + ALIGN(an, i, 3)
            endif
         endif
      enddo
      end
!
!-----------------
!
! HPFC_PROCESSORS
!
! this subroutine computes on which processor a template element is mapped
!
      subroutine HPFC_PROCESSORS(indt, tn, indp, pn, replicated)
      integer indt(7), tn, indp(7), pn
      logical replicated
      include "hpfc_commons.h"
      integer i, tdim, param
      replicated = .FALSE.
      do i=1, NODIMP(pn)
         tdim = DIST(tn, i, 1)
!
! replicated if a non specified template dimension is distributed
!
         if (indt(tdim).EQ.INTFLAG) then
            replicated = .TRUE.
            indp(i) = INTFLAG
         else
            param = DIST(tn, i, 2)
            if (param.GT.0) then
!
! here the distribution is BLOCK
!
               indp(i) = (((indt(tdim) - RANGET(tn, tdim, 1)) / param) 
     $              + RANGEP(pn, i, 1))
            else
!
! here the distribution is CYCLIC
!
               param = - param
               indp(i) = ( (MOD((indt(tdim) 
     $              - RANGET(tn, tdim, 1)), (param*RANGEP(pn, i, 3))) 
     $              / param) + RANGEP(pn, i, 1) )
            endif
         endif
      enddo
      end
!
!-----------------
!
! HPFC_PROCLID
!
      subroutine HPFC_PROCLID(indp, pn, lid, replicated)
      integer indp(7), pn, lid
      logical replicated
      include "hpfc_commons.h"
      integer i, t
      if (replicated) then
         lid = INTFLAG
      else
         if (NODIMP(pn).EQ.0) then
            lid = 1
         else
            t = indp(1) - RANGEP(pn, 1, 1)
            do i=2, NODIMP(pn)
               t = (t * RANGEP(pn, i, 3))
     $              + (indp(i) - RANGEP(pn, i, 1))
            enddo
            lid = t+1
         endif
      endif
      end
!
!-----------------
!
! HPFC_CMPLID
!
      integer function HPFC_CMPLID(pn, p1, p2, p3, p4, p5, p6, p7)
      integer pn, p1, p2, p3, p4, p5, p6, p7
      include "hpfc_commons.h"
      integer lid, indp(7)
      indp(1)=p1
      indp(2)=p2
      indp(2)=p3
      indp(4)=p4
      indp(5)=p5
      indp(6)=p6
      indp(7)=p7
      call HPFC_PROCLID(indp, pn, lid, .FALSE.)
      HPFC_CMPLID=lid
      end
!
!-----------------
!
! HPFC_CMPPOS
!
! returns the vector of indices of lid in pn.
!
      subroutine HPFC_CMPPOS(pn, lid, indp)
      integer pn, lid, indp(7)
      include "hpfc_commons.h"
      integer ndim, i, t, dim, size
      ndim = NODIMP(pn)
      t = lid-1
      do i=0, ndim-1
         dim = ndim-i
         size = RANGEP(pn, dim, 3)
         indp(dim) = MOD(t, size) + RANGEP(pn, dim, 1)
         t = t / size
      enddo
      end
!
!-----------------
!
! true if dimension dim of processor arrangement pn 
! is a distributed dimension for array an.
!
      logical function HPFC_DIST_P(an, dim)
      integer an, dim
      include "hpfc_commons.h"
      HPFC_DIST_P = ALIGN(an, DIST(ATOT(an), dim, 1), 1).ne.INTFLAG 
      end
!
!-----------------
!
! true if lid and the current pe are twins (hold same data) 
! on processor arrangement of array an.
! most of the information computed here could be precomputed and store
! once at the initialization phase of the runtime. 
!
      logical function HPFC_TWIN_P(an, lid)
      integer an, lid
      include "hpfc_commons.h"
      external HPFC_DIST_P
      logical HPFC_DIST_P
      integer ip(7), pn, dim
      pn = TTOP(ATOT(an))
      call HPFC_CMPPOS(pn, lid, ip)
      do dim=1, NODIMP(pn)
         if (HPFC_DIST_P(an, dim).and.ip(dim).ne.MYPOS(dim,pn)) then
            HPFC_TWIN_P = .FALSE.
            return
         endif
      enddo
!
! now the pe id on pn maybe differs ONLY on replicated dimensions
!
      HPFC_TWIN_P = .TRUE.
      end
!
!-----------------
!
! HPFC_CMPOWNERS
!
      subroutine HPFC_CMPOWNERS(an, i1, i2, i3, i4, i5, i6, i7)
      integer an, i1, i2, i3, i4, i5, i6, i7
      include "hpfc_commons.h"
      integer inda(7), indt(7), indp(7), tn, i
      inda(1) = i1
      inda(2) = i2
      inda(3) = i3
      inda(4) = i4
      inda(5) = i5
      inda(6) = i6
      inda(7) = i7
      tn  = ATOT(an)
      OPN = TTOP(tn)
      call HPFC_TEMPLATE(inda, an, indt, tn)
      call HPFC_PROCESSORS(indt, tn, OINDP, OPN, OREPLICATED)
      if (OREPLICATED) then
         OLID = INTFLAG
         OWNERTID = INTFLAG
         do i=1, NODIMP(OPN)
            if (OINDP(i).EQ.INTFLAG) then
               indp(i) = RANGEP(OPN, i, 1)
            else
               indp(i) = OINDP(i)
            endif
         enddo
         call HPFC_PROCLID(indp, OPN, SLID, .FALSE.)
         SENDERTID  = NODETIDS(SLID)
      else
         call HPFC_PROCLID(OINDP, OPN, OLID, OREPLICATED)
         OWNERTID  = NODETIDS(OLID)
         SENDERTID = OWNERTID
         SLID = OLID
      endif
      end
!
!-----------------
!
! HPFC_CMPCOMPUTER
!
      subroutine HPFC_CMPCOMPUTER(an, i1, i2, i3, i4, i5, i6, i7)
      integer an, i1, i2, i3, i4, i5, i6, i7
      include "hpfc_commons.h"
      integer inda(7), indt(7), tn, i
      logical replicated
      inda(1) = i1
      inda(2) = i2
      inda(3) = i3
      inda(4) = i4
      inda(5) = i5
      inda(6) = i6
      inda(7) = i7
      tn  = ATOT(an)
      CPN = TTOP(tn)
      call HPFC_TEMPLATE(inda, an, indt, tn)
      call HPFC_PROCESSORS(indt, tn, CINDP, CPN, replicated)
      if (replicated) then
         do i=1, NODIMP(CPN)
            if (CINDP(i).EQ.INTFLAG) 
     $           CINDP(i) = RANGEP(CPN, i, 1)
         enddo
         replicated = .FALSE.
      endif
      call HPFC_PROCLID(CINDP, CPN, CLID, replicated)
      COMPUTERTID  = NODETIDS(CLID)
      CPOSCOMPUTED = .FALSE.
      end
!
!-----------------
!
! HPFC_CMPNEIGHBOUR
!
! this function computes the neighbour tid of the current process,
! given the delta switch in the linearised processors representation.
!
      subroutine HPFC_CMPNEIGHBOUR(delta)
      integer delta
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid
      NLID = MYLID + DELTA
      NTID = NODETIDS(NLID)
!
! where should I put it?
!
      call pvmfinitsend(PVMRAW, bufid)
      end
!
!-----------------
!
! HPFC_OWNERP
!
!
      logical function HPFC_OWNERP()
      include "hpfc_commons.h"
      logical result
      integer i
      if (OREPLICATED) then
         result = .TRUE.
         do i=1, NODIMP(OPN)
            if (OINDP(i).NE.INTFLAG) 
     $           result = result.AND.(OINDP(i).EQ.MYPOS(i, OPN))
         enddo
      else
         result = MYLID.EQ.OLID
      endif
      HPFC_OWNERP = result
      end
!
!-----------------
!
! HPFC_SENDERP
!
!
      logical function HPFC_SENDERP()
      include "hpfc_commons.h"
      HPFC_SENDERP = MYLID.EQ.SLID
      end
!
!-----------------
!
! HPFC_COMPUTERP
!
!
      logical function HPFC_COMPUTERP()
      include "hpfc_commons.h"
      HPFC_COMPUTERP = MYLID.EQ.CLID
      end
!
!-----------------
!
! HPFC_COMPUTERINOWNERSP
!
!
      logical function HPFC_COMPUTERINOWNERSP()
      include "hpfc_commons.h"
      logical result
      integer i
      if (OREPLICATED) then
         result = .TRUE.
         if (OPN.EQ.CPN) then
!
! both owners and computer are set on the same processors.
!
            do i=1, NODIMP(OPN)
               if (OINDP(i).NE.INTFLAG)
     $              result = result.AND.(OINDP(i).EQ.CINDP(i))
            enddo
         else
!
! the processors are different, we have to compute the computer
! position on the owners processors, if it has not been done.
!
            if ((.NOT.CPOSCOMPUTED).OR.(CPOSPN.NE.OPN)) then
               call HPFC_CMPPOS(OPN, CLID, CPOS)
               CPOSPN = OPN
               CPOSCOMPUTED = .TRUE.
            endif
            do i=1, NODIMP(OPN)
               if (OINDP(i).NE.INTFLAG)
     $              result = result.AND.(OINDP(i).EQ.CPOS(i))
            enddo
         endif
      else
         result = CLID.EQ.OLID
      endif
      HPFC_COMPUTERINOWNERSP = result
      end

!
!-----------------
!
! HPFC_SNDTO_C
! send to computer
!
      subroutine HPFC_SNDTO_C(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(COMPUTERTID, SENDCHANNELS(CLID), info)
      SENDCHANNELS(CLID) = SENDCHANNELS(CLID) + 2
      end
!
!-----------------
!
! HPFC_SNDTO_H
!
! send to host
!
      subroutine HPFC_SNDTO_H(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(HOSTTID, HOSTCHANNEL, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      end
!
!-----------------
!
! HPFC_SNDTO_O
!
! send to owner, when there is just one
!
      subroutine HPFC_SNDTO_O(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "sending to ", OLID)
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfsend(OWNERTID, SENDCHANNELS(OLID), info)
      SENDCHANNELS(OLID) = SENDCHANNELS(OLID) + 2
      end
!
!-----------------
!
! HPFC_SNDTO_A
!
! send to all nodes
!
      subroutine HPFC_SNDTO_A(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      if (MYLID.GT.1)
     $     call pvmfmcast(
     $     MYLID-1, 
     $     NODETIDS, 
     $     MCASTNODES, 
     $     info)
      if (MYLID.LT.NBOFTASKS)
     $     call pvmfmcast(
     $     NBOFTASKS-MYLID, 
     $     NODETIDS(MYLID+1), 
     $     MCASTNODES, 
     $     info)
      MCASTNODES = MCASTNODES + 2
      end
!
!-----------------
!
! HPFC_PVMLENGTH
!
      integer function HPFC_PVMLENGTH(what)
      integer what
      include "fpvm3.h"
      if (what.eq.INTEGER4.or.what.eq.REAL4) then
         HPFC_PVMLENGTH=4
         return
      endif
      if (what.eq.REAL8.or.what.eq.COMPLEX8) then
         HPFC_PVMLENGTH=8
         return
      endif
      if (what.eq.BYTE1) then
         HPFC_PVMLENGTH=1
         return
      endif
      if (what.eq.INTEGER2) then
         HPFC_PVMLENGTH=2
         return
      endif
      if (what.eq.COMPLEX16) then
         HPFC_PVMLENGTH=16
         return
      endif
      write (unit=0,fmt=*) "[HPFC_PVMLENGTH] unexpected tag ", what
      stop
      end
!
_CM5(
!-----------------
!
! CM_SNDTO_A
!
! send to all nodes, cmmd version
!
      subroutine CM_SNDTO_A(what, val)
      integer what, val
      include "cmmd_fort.h"
      include "hpfc_commons.h"
      external HPFC_PVMLENGTH
      integer HPFC_PVMLENGTH
      integer i, len
      len = HPFC_PVMLENGTH(what)
      do i=1, NBOFTASKS
         if (i.ne.MYLID) then
            if (0.ne.CMMD_send(
     $           CM_NODE_IDS(i),
     $           MCASTNODES,
     $           val,
     $           len)) then
               write (unit=0,fmt=*)
     $              "[CM_SNDTO_A] send error ", MYLID, " to ", i
            endif
         endif
      enddo
      MCASTNODES = MCASTNODES + 2
      end
!
!-----------------
!
! CM_RCVFR_mCS
!
      subroutine CM_RCVFR_mCS(what, goal)
      integer what, goal
      include "cmmd_fort.h"
      include "hpfc_commons.h"
      external HPFC_PVMLENGTH
      integer HPFC_PVMLENGTH
      integer len
      len = HPFC_PVMLENGTH(what)
      if (0.ne.CMMD_receive(
     $     CM_NODE_IDS(SLID),
     $     MCASTNODES,
     $     goal,
     $     len)) then
         write (unit=0,fmt=*) "[CM_RCVFR_mCS] receive error on ", MYLID
      endif
      MCASTNODES = MCASTNODES + 2
      end
!)
!-----------------
!
! HPFC_HSNDTO_A
!
! host send to all nodes
!
      subroutine HPFC_HSNDTO_A(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "sending to all nodes")
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, MCASTHOST, info)
      MCASTHOST = MCASTHOST + 2
      debug(write (unit=0,fmt=*) "sent!")
      end
!
!-----------------
!
! HPFC_SNDTO_HA
!
! send to host and all nodes, but not the sender.
!
      subroutine HPFC_SNDTO_HA(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      if (MYLID.GT.1)
     $     call pvmfmcast(
     $     MYLID-1, 
     $     NODETIDS, 
     $     MCASTNODES, 
     $     info)
      if (MYLID.LT.NBOFTASKS)
     $     call pvmfmcast(
     $     NBOFTASKS-MYLID, 
     $     NODETIDS(MYLID+1), 
     $     MCASTNODES, 
     $     info)
      MCASTNODES = MCASTNODES + 2
      call pvmfsend(HOSTTID, HOSTCHANNEL, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      end
!
!-----------------
!
! HPFC_SNDTO_OS
!
! send to owners, by someone who is not in owners
!
      subroutine HPFC_SNDTO_OS(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, i
      integer i1, i2, i3, i4, i5, i6, i7
      integer lb(7), ub(7), indp(7), lid
      if (OREPLICATED) then
         do i=1, NODIMP(OPN)
            debug(write (unit=0,fmt=*) "i = ", i, " index is ", OINDP(i))
            if (OINDP(i).EQ.INTFLAG) then
               lb(i) = RANGEP(OPN, i, 1)
               ub(i) = RANGEP(OPN, i, 2)
            else
               lb(i) = OINDP(i)
               ub(i) = OINDP(i)
            endif
            debug(write (unit=0,fmt=*) "bounds ", lb(i), ub(i))
         enddo
         do i=(NODIMP(OPN)+1), 7
            lb(i) = 1
            ub(i) = 1
         enddo
         call pvmfinitsend(PVMRAW, bufid)
         call pvmfpack(what, val, 1, 1, info)
         do i7=lb(7), ub(7)
            indp(7) = i7
            do i6=lb(6), ub(6)
               indp(6) = i6
               do i5=lb(5), ub(5)
                  indp(5) = i5
                  do i4=lb(4), ub(4)
                     indp(4) = i4
                     do i3=lb(3), ub(3)
                        indp(3) = i3
                        do i2=lb(2), ub(2)
                           indp(2) = i2
                           do i1=lb(1), ub(1)
                              indp(1) = i1
!     
! too much computation is made inside this call, and some 
! factorisation could be made out of the inner loop, but I don t
! have time for that...
!
                              call HPFC_PROCLID(
     $                             indp, OPN, lid, .FALSE.)
                              call pvmfsend(
     $                             NODETIDS(lid), 
     $                             SENDCHANNELS(lid), 
     $                             info)
                              SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
                              debug(write (unit=0,fmt=*) "sending to ", lid)
                           enddo
                        enddo
                     enddo
                  enddo
               enddo
            enddo
         enddo
      else
         call HPFC_SNDTO_O(what, val)
      endif
      end
!
!-----------------
!
! HPFC_SNDTO_OOS
!
! send to other owners, if any
!
      subroutine HPFC_SNDTO_OOS(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info,  i
      integer i1, i2, i3, i4, i5, i6, i7
      integer lb(7), ub(7), indp(7), lid
      do i=1, NODIMP(OPN)
         debug(write (unit=0,fmt=*) "i = ", i, " index is ", OINDP(i))
         if (OINDP(i).EQ.INTFLAG) then
            lb(i) = RANGEP(OPN, i, 1)
            ub(i) = RANGEP(OPN, i, 2)
         else
            lb(i) = OINDP(i)
            ub(i) = OINDP(i)
         endif
         debug(write (unit=0,fmt=*) "bounds ", lb(i), ub(i))
      enddo
      do i=(NODIMP(OPN)+1), 7
         lb(i) = 1
         ub(i) = 1
      enddo
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      do i7=lb(7), ub(7)
         indp(7) = i7
         do i6=lb(6), ub(6)
            indp(6) = i6
            do i5=lb(5), ub(5)
               indp(5) = i5
               do i4=lb(4), ub(4)
                  indp(4) = i4
                  do i3=lb(3), ub(3)
                     indp(3) = i3
                     do i2=lb(2), ub(2)
                        indp(2) = i2
                        do i1=lb(1), ub(1)
                           indp(1) = i1
!
! too much computation is made inside this call, and some 
! factorisation could be made out of the inner loop, but I don t
! have time for that...
!
                           call HPFC_PROCLID(indp, OPN, lid, .FALSE.)
                           if (lid.NE.CLID) then
                              call pvmfsend(
     $                             NODETIDS(lid), 
     $                             SENDCHANNELS(lid), 
     $                             info)
                              SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
                           endif
                        enddo
                     enddo
                  enddo
               enddo
            enddo
         enddo
      enddo
      end
!
!-----------------
!
! HPFC_SNDTO_NO
!
! send to not owners, when replicated...
!
      subroutine HPFC_SNDTO_NO(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, i, indp(7), ndim, lid
      logical result
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(what, val, 1, 1, info)
      ndim = NODIMP(OPN)
      do lid=1, NBOFTASKS
!
! this leads to much much stupid computation, but all I need is the function
! done, and not the performances... however I think a better job could be done
!
! is lid in owners ?
!         
         call HPFC_CMPPOS(OPN, lid, indp)
         result = .TRUE.
         do i=1, ndim
            if (OINDP(i).NE.INTFLAG)
     $           result = result.AND.(OINDP(i).EQ.indp(i))
         enddo
         if (.NOT.result) then
            call pvmfsend(NODETIDS(lid), SENDCHANNELS(lid), info)
            SENDCHANNELS(lid) = SENDCHANNELS(lid) + 2
         endif
      enddo
      end
!     
!-----------------
!
! HPFC_SNDTO_HNO
!
! send to host and not owners, when replicated
!
      subroutine HPFC_SNDTO_HNO(what, val)
      integer what, val
      include "fpvm3.h"
      include "hpfc_commons.h"
      call HPFC_SNDTO_H(what, val)
      call HPFC_SNDTO_NO(what, val)
      end
!
!-----------------
!
! HPFC_RCVFR_S
!
      subroutine HPFC_RCVFR_S(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(SENDERTID, RECVCHANNELS(SLID), bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      RECVCHANNELS(SLID) = RECVCHANNELS(SLID) + 2
      end
!
!-----------------
!
! HPFC_RCVFR_C
!
      subroutine HPFC_RCVFR_C(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(COMPUTERTID, RECVCHANNELS(CLID), bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      RECVCHANNELS(CLID) = RECVCHANNELS(CLID) + 2
      end
!
!-----------------
!
! HPFC_RCVFR_H
!
      subroutine HPFC_RCVFR_H(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(HOSTTID, HOSTCHANNEL, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      HOSTCHANNEL = HOSTCHANNEL + 2
      debug(write (unit=0,fmt=*) MYLID, " receiving from host")
      end
!
!-----------------
!
! HPFC_RCVFR_mCS
!
      subroutine HPFC_RCVFR_mCS(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      call pvmfrecv(SENDERTID, MCASTNODES, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      MCASTNODES = MCASTNODES + 2
      end
!
!-----------------
!
! HPFC_RCVFR_mCH
!
      subroutine HPFC_RCVFR_mCH(what, goal)
      integer what, goal
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info
      debug(write (unit=0,fmt=*) "receiving from host")
      call pvmfrecv(HOSTTID, MCASTHOST, bufid)
      call pvmfunpack(what, goal, 1, 1, info)
      MCASTHOST = MCASTHOST + 2
      debug(write (unit=0,fmt=*) "received!")
      end
!
!-----------------
!
! HPFC_LOCALINDGAMMA
!
! computation of the gamma function for local indice access
!
!
      integer function HPFC_LOCALINDGAMMA(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
      integer n, sc, no, bmtm
      integer t, nc, ni
!
! static parameters for the computation
!
      n    = RANGEA(an, dim, 5)
      sc   = RANGEA(an, dim, 6)
      no   = RANGEA(an, dim, 7)
      bmtm = RANGEA(an, dim, 8)
!
! the computation
!
      t    = indice + bmtm
      nc   = t / sc
      ni   = MOD(t, n)
      HPFC_LOCALINDGAMMA = n*(nc-no) + ni + 1
      end
!
!-----------------
!
! HPFC_LOCALINDDELTA
!
! computation of the delta function for local indice access
!
!
      integer function HPFC_LOCALINDDELTA(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
      integer n, sc, no, bmtm, rate, chsz
      integer t, nc, ni
!
! static parameters for the computation
!
      n    = RANGEA(an, dim, 5)
      sc   = RANGEA(an, dim, 6)
      no   = RANGEA(an, dim, 7)
      bmtm = RANGEA(an, dim, 8)
      rate = RANGEA(an, dim, 9)
      chsz = RANGEA(an, dim, 10)
!
! the computation
!
      t    = rate*indice + bmtm
      nc   = t / sc
      ni   = MOD(t, n) / abs(rate)
      HPFC_LOCALINDDELTA = chsz*(nc - no) + ni + 1
      end
!
!-----------------
!
! HPFC_LOCALIND
!
!
      integer function HPFC_LOCALIND(an, dim, indice)
      integer an, dim, indice
      include "hpfc_commons.h"
!
! I cannot include the .h because of the external declaration of the 
! function itself...
!
      external HPFC_LOCALINDGAMMA
      integer HPFC_LOCALINDGAMMA
      external HPFC_LOCALINDDELTA
      integer HPFC_LOCALINDDELTA
      integer newdecl, rate
      newdecl = RANGEA(an, dim, 4)
      if (newdecl.EQ.0) then
! no new declaration
         HPFC_LOCALIND = indice
         return
      else
      if (newdecl.EQ.1) then
! alpha new declaration
         HPFC_LOCALIND = indice - RANGEA(an, dim, 5)
         return
      else
      if (newdecl.EQ.2) then
! beta new declaration
         rate = RANGEA(an, dim, 6)
         HPFC_LOCALIND = 1 +
     &        (MOD(rate*indice+RANGEA(an, dim, 7), 
     &             RANGEA(an, dim, 5)) / ABS(RANGEA(an, dim, 6)))
         return
      else
      if (newdecl.EQ.3) then
! gamma new declaration
         HPFC_LOCALIND = HPFC_LOCALINDGAMMA(an, dim, indice)
         return
      else
         HPFC_LOCALIND = HPFC_LOCALINDDELTA(an, dim, indice)
         return
      endif
      endif
      endif
      endif
      end
!
!-----------------
!
! HPFC_INIT_MAIN
!
! entry point in the library for a non differentiated host/node program.
! 
      subroutine HPFC_INIT_MAIN()

      include "fpvm3.h"
      include "hpfc_commons.h"
      
      _CRAYT3D(integer my rank)
      integer info, inum
      logical host known

!
! GLOBAL INITS
! 
      call HPFC_CHECK

      HOST NODE MODEL = .false.
      SPAWN PERFORMED = .false.
      OUTSIDE SPAWN   = .false.

      NB OF TASKS = MAX SIZE OF PROCS

      call HPFC_INIT_COMMON_PARAM_LIB

      host known = .false.

      call pvmfmytid(MY TID)

      _getpe(
! the CRAY T3D does not have spawn, but the spawning is automatic!
      call pvmfgetpe(MY TID, my rank)
      SPAWN PERFORMED = .true.
      OUTSIDE SPAWN = .true.
      host known = .true.
      if (my rank.eq.0) then
         MY LID = 0
         HOST TID = MY TID
      end if)
      
      call pvmfjoingroup(HPFC_GROUP_NAME, inum)
      if (inum.lt.0) then
         call pvmfperror("while joining group in HPFC_INIT_MAIN", info)
         call pvmfexit(info)
         stop
      end if

      if (.not. host known) then
! decide which process is the host
         if (inum.eq.0) then
            MY LID = 0
            HOST TID = MY TID
         else
! the host is not know, but i am its child!
            SPAWN PERFORMED = .true.
            call pvmfparent(HOST TID)
         end if
         host known = .true.
      end if
 
      _spawn(
      debug(print *, "spawning ", MAIN_PROGRAM_NAME)
      if (.not. SPAWN PERFORMED) then
         call pvmfspawn(
     $        MAIN_PROGRAM_NAME,
     $        PVM ARCH,
     $        NODE_ARCHITECTURE,
     $        NB OF TASKS,
     $        NODE TIDS,
     $        info)

! may think of an external spawning?
         SPAWN PERFORMED = .true.
         
      end if)

      end
! 
!-----------------
!
! HPFC_INIT_HOST_NODE
!
      subroutine HPFC_INIT_HOST_NODE
      include "fpvm3.h"
      include "hpfc_commons.h"

      integer info, inum

      call HPFC_CHECK

      HOST NODE MODEL = .true.
      SPAWN PERFORMED = .false.
      OUTSIDE SPAWN = .false.
      
      NB OF TASKS = MAX SIZE OF PROCS

      call HPFC_INIT_COMMON_PARAM_LIB

      call pvmfmytid(MYTID)

!
! done before the spawn so host is (group, 0)
!
      call pvmfjoingroup(HPFC_GROUP_NAME, inum)
      if (inum.lt.0) then
         call pvmfperror("while joining group", info)
         call pvmfexit(info)
         stop
      endif

      end
!
!-----------------
!
! HPFC_INIT_NODE
!
! this is the entry point in the hpfc runtime library for a node.
!
      subroutine HPFC_INIT_NODE()
      _CM5(include "cmmd_fort.h")
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer i, bufid, info, inum

      if (.not.OUTSIDE SPAWN) then
         call pvmfparent(HOST TID)
      end if

      _direct(call HPFC_DIRECT_ROUTE_IF_POSSIBLE)

      call HPFC_INIT_COMMON_PROCS
      call HPFC_INIT_COMMON_BUFFER

! receive from host global informations about the nodes implicated
! in this run.
      call pvmfrecv(HOST TID, 1, bufid)
      call pvmfunpack(INTEGER4, NODE TIDS, NB OF TASKS, 1, info)
      do i=1, NB OF TASKS
         if (NODE TIDS(i).EQ.MYTID)
     $        MYLID = i
      enddo

      do i=1, NB OF PROCESSORS
         call HPFC_CMPPOS(i, MY LID, MY POS(1, i))
      enddo

      debug(write (unit=0,fmt=*) "lid: ", MYLID, " tid: ", MYTID)

!
! 1 sends node version key to host
!
      if (MY LID.eq.1) then
         call pvmfinitsend(PVMRAW, info)
         call pvmfpack(STRING, hpfc_key, 64, 1, info)
         call pvmfsend(HOSTTID, 1, info)
      endif

_CM5(
!
! cm5 related id initializations
!
      CM_HOST_ID = cmmd_host_node()
      CM_MY_ID   = cmmd_self_address()
      CM_SIZE    = cmmd_partition_size()
!
      call pvmfinitsend(PVMRAW, info)
      call pvmfpack(INTEGER4, CM_MY_ID, 1, 1, info)
      call pvmfsend(HOSTTID, 1, info)
!
      call pvmfrecv(HOSTTID, 1, bufid)
      call pvmfunpack(INTEGER4, CM_NODE_IDS, NBOFTASKS, 1, info)
!
! end of cm5 related initializations
!)

!
! insures that all nodes joined the group and are there
!
      call HPFC_SYNCHRO
      end
!
!-----------------
!
! HPFC_INIT_COMMON_PROCS
!
      subroutine HPFC_INIT_COMMON_PROCS()
      include "hpfc_commons.h"
      integer i
      do i=1, NBOFTASKS
         SENDCHANNELS(i) = 2
      enddo
      do i=1, NBOFTASKS
         RECVCHANNELS(i) = 2
      enddo
      MCASTNODES = 1
      MCASTHOST  = 3
      OPN = 0
      CPOSPN = 0
      HOSTCHANNEL = 2
      end
!-----------------
!
! HPFC_INIT_COMMON_BUFFER
      subroutine HPFC_INIT_COMMON_BUFFER
      include "hpfc_commons.h"
      BYTE1_BUFFSIZE = SIZEOFBUFFER
      INTEGER2_BUFFSIZE = SIZEOFBUFFER/2
      INTEGER4_BUFFSIZE = SIZEOFBUFFER/4
      REAL4_BUFFSIZE = SIZEOFBUFFER/4
      REAL8_BUFFSIZE = SIZEOFBUFFER/8
      COMPLEX8_BUFFSIZE = SIZEOFBUFFER/8
      COMPLEX16_BUFFSIZE = SIZEOFBUFFER/16
      SEND_NOT_INITIALIZED = .TRUE.
      RECEIVED_NOT_PERFORMED = .TRUE.
      end
!
!-----------------
!
! HPFC_INIT_COMMON_PARAM_LIB
!
      subroutine HPFC_INIT_COMMON_PARAM_LIB
      include "hpfc_commons.h"
      integer i
      do i=1, MAXNBOFARRAYS
         LIVEMAPPING(i) = .FALSE.
      enddo
!
! the next routine is compiler generated
!
      call HPFC_INIT_COMMON_PARAM
      end
!
!-----------------
!
! HPFC_DIRECT_ROUTE_IF_POSSIBLE
!
_direct(`'
      subroutine HPFC_DIRECT_ROUTE_IF_POSSIBLE
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer nhost, narch, dtid, speed, info
      character host(50), arch(20)
      call pvmfconfig(nhost, narch, dtid, host, arch, speed, info)
      if (nhost.ge.NBOFTASKS) then
         call pvmfsetopt(PVMROUTE, PVMROUTEDIRECT, info)
      else
         if (HOSTTID.eq.MYTID) write (unit=0,fmt=*)
     $        "Warning: no direct route (not enough processors)..."
      endif
      end
)dnl
!
!
!-----------------
!
! HPFC_INIT_HOST
!
! this is the entry point in the hpfc runtime library for a program.
!
      subroutine HPFC_INIT_HOST()
      _CM5(include "cmmd_fort.h")
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer bufid, info, inum, i
      character*64 node_key

      MYLID = 0
      HOSTTID = MYTID

      _direct(call HPFC_DIRECT_ROUTE_IF_POSSIBLE)

      _spawn(
      debug(write (unit=0,fmt=*) "spawning ", NODE_PROGRAM_NAME
      write (unit=0,fmt=*) "   on ", NBOFTASKS, " ", NODE_ARCHITECTURE)

      call pvmfspawn(
     $     NODE_PROGRAM_NAME, 
     $     PVMARCH, 
     $     NODE_ARCHITECTURE, 
     $     NBOFTASKS, 
     $     NODETIDS, 
     $     info)

      if (info.lt.0) then
         call pvmfperror("initial spawning", info)
         call pvmfexit(info)
         stop
      endif

      if (info.ne.NBOFTASKS) then
         call pvmfperror("not spawned", 0)
         call pvmfexit(0)
         stop
      endif)

      _getpe(
! rather specific to CRAY T3D
      do i=1, NB OF TASKS
         NODE TIDS(i)=i
      end do)
      
      demo(
      call print_host_info
      if (HOST NODE MODEL) then 
         write (unit=0,fmt=*) " -- host node model"
      else
         write (unit=0,fmt=*) " -- single main program"
      end if
      call print_task_info(NBOFTASKS, NODETIDS, HOSTTID))

      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(INTEGER4, NODETIDS, NBOFTASKS, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, 1, info)

      debug(if (info.lt.0) then
         call pvmfperror("initial broadcast", info)
         call pvmfexit(info)
         stop
      endif)

      call HPFC_INIT_COMMON_PROCS
      call HPFC_INIT_COMMON_BUFFER
!
! check version of host and node
! to insure that both host and node where generated together...
!
      call pvmfrecv(NODETIDS(1), 1, bufid)
      call pvmfunpack(STRING, node_key, 64, 1, info)
      if (node_key.ne.hpfc_key) then
         print *, "*** incompatible version keys!"
         print *, "*** host: ", hpfc_key
         print *, "*** node: ", node_key
         do i=1, NBOFTASKS
            call pvmfkill(NODETIDS(i), info)
         enddo
         call pvmfexit(info)
         stop
      endif

_CM5(
!
! cm5 related id initializations
!
      CM_HOST_ID = cmmd_self_address()
      CM_MY_ID   = CM_HOST_ID
      CM_SIZE    = cmmd_partition_size()
!
      do i=1, NBOFTASKS
         call pvmfrecv(NODETIDS(i), 1, info)
         call pvmfunpack(INTEGER4, CM_NODE_IDS(i), 1, 1, info)
      enddo
!
      call pvmfinitsend(PVMRAW, bufid)
      call pvmfpack(INTEGER4, CM_NODE_IDS, NBOFTASKS, 1, info)
      call pvmfmcast(NBOFTASKS, NODETIDS, 1, info)
!
! end of cm5 related initializations
!)

!
! insures that all nodes joined the group...
!
      call HPFC_SYNCHRO

      end
!
!-----------------
!
! HPFC_HOST_END
!
      subroutine HPFC_HOST_END()
      integer info
      sync_exit(call HPFC_SYNCHRO)
      call pvmfexit(info)
      stop
      end
!
!-----------------
!
! HPFC_NODE_END
!
      subroutine HPFC_NODE_END()
      integer info
      sync_exit(call HPFC_SYNCHRO)
      call pvmfexit(info)
      stop
      end
!
!-----------------
!
! HPFC_RCVFR_N
!
      subroutine HPFC_RCVFR_N()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      call pvmfrecv(NTID, RECVCHANNELS(NLID), info)
      end
!
!-----------------
!
! HPFC_SNDTO_N
!
      subroutine HPFC_SNDTO_N()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      call pvmfsend(NTID, SENDCHANNELS(NLID), info)
      end
!
!-----------------
!
! HPFC_REMOTE_LOOP_BOUNDS
!
      subroutine HPFC_REMOTE_LOOP_BOUNDS
     $     (nlb, nub, llb, lb, ub, an, dp, pos)
      integer nlb, nub, llb, lb, ub, an, dp, pos
      include "hpfc_commons.h"
      integer d, n, tn, pn, b, dt, da
      if (dp.EQ.0) then
         nlb = lb
         nub = ub
         llb = lb-1
         return
      endif 
      tn = ATOT(an)
      pn = TTOP(tn)
      dt = DIST(tn, dp, 1)
      n  = DIST(tn, dp, 2)
      da = ALIGN(an, dt, 1)
      b  = ALIGN(an, dt, 3)
!
! d is the first template cell of the considered dimension that
! is mapped onto the given processors cell:
!
      d  = n*(pos-RANGEP(pn, dp, 1)) + RANGET(tn, dt, 1)
      llb = MAX(lb, d-b)-1
      nlb = llb+b-d+2
      nub = MIN(ub+b, d+n-1)-d+1
      end
!
!-----------------
!
!
! HPFC_LOOP_BOUNDS
!
! Computation of the local loop bounds:
! nlb (new lower bound) and nub (new upper bound)
! and llb, the local lower bound in the former global loop,
! with lb (initial lower bound) and ub (initial upper bound)
! that access dimension of array da of array number an, mapped
! onto dimension of processors dp of processors number pn.
! 
      subroutine HPFC_LOOP_BOUNDS(nlb, nub, llb, lb, ub, an, dp)
      integer nlb, nub, llb, lb, ub, an, dp
      include "hpfc_commons.h"
      debug(write (unit=0,fmt=*) 
     $     "HPFC_LOOP_BOUNDS ", lb, ub, " array ", an, dp)
      call HPFC_REMOTE_LOOP_BOUNDS
     $     (nlb, nub, llb, lb, ub, an, dp, MYPOS(dp, TTOP(ATOT(an))))
      debug(write (unit=0,fmt=*) 
     $     "init lb: ", llb, " new lb: ", nlb, " new ub: ", nub)
      end
!
!-----------------
!
! HPFC_SYNCHRO
!
      subroutine HPFC_SYNCHRO()
      include "fpvm3.h"
      include "hpfc_commons.h"
      integer info
      debug(write (unit=0,fmt=*) 
     $     "[hpfc_synchro] ", MYLID, " waiting ", NBOFTASKS+1)
      call pvmfbarrier(HPFC_GROUP_NAME, NBOFTASKS+1, info)
      if (info.lt.0) then
         call pvmfperror("hpfc_synchro", info)
         call pvmfexit(info)
         stop
      endif
      debug(write (unit=0,fmt=*) "[hpfc_synchro] done")
      end
!
!-----------------
!
! HPFC_HTIMEON
!
      subroutine HPFC_HTIMEON()
      call HPFC_SYNCHRO()
      call HPFC_TIMEON()
      call HPFC_SYNCHRO()
      end
!
!-----------------
!
! HPFC_NTIMEON
!
      subroutine HPFC_NTIMEON()
      call HPFC_SYNCHRO()
      call HPFC_SYNCHRO()
      end
!
!-----------------
!
! HPFC_HTIMEOFF
!
      subroutine HPFC_HTIMEOFF(comment)
      character comment*(*)
      call HPFC_SYNCHRO()
      call HPFC_TIMEOFF(comment)
      end
!
!-----------------
!
! HPFC_NTIMEOFF
!
      subroutine HPFC_NTIMEOFF(comment)
      character comment*(*)
      call HPFC_SYNCHRO()
      end
!
!-----------------
!
! HPFC_DIVIDE
!
      integer function HPFC_DIVIDE(i, j)
      integer i,j
      if (i.ge.0) then
         HPFC_DIVIDE = i/j
      else
         HPFC_DIVIDE = -(-i+j-1)/j
      endif
      end
!
!----------
!
! HPFC_PROCDIM
!
! this could be computed statically, where it is used...
! used for the reductions...
!
      integer function HPFC_PROCDIM(an, ad)
      include "hpfc_commons.h"
      integer an, ad
      integer tn, pn, i, it, ip
      tn = ATOT(an)
      pn = TTOP(tn)
      it = 0
      ip = 0
      do i=1, NODIMT(tn)
         if (ALIGN(an, i, 1).EQ.ad) it = i
      enddo
      if (it.NE.0) then
         do i=1, NODIMP(pn)
            if (DIST(tn, i, 1).EQ.it) ip = i
         enddo
      endif
      HPFC_PROCDIM = ip
      return
      end
!
!-----------------
