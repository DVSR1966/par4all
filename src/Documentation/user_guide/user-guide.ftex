%	Rapport dret144
%	Manuel Utilisateur du Paralle'liseur
%	Version 1.0
%	rendue le 07.01.91
%	Version 1.1
%	preparee a partir du 15.03.91 (apres la recette)
%
% Il faudra faire evoluer ce manuel en tenant compte des remarques des
% utilisateurs et au fur et a mesure de l'evolution de PIPS.
% Les corrections les plus urgentes sont specifiees en commentaire
% commencant par %%


\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS \\
		Manuel Utilisateur du Paralle'liseur Batch (Version 2.1)}
\newcommand{\auteur}{
		Bruno BARON \\
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT\\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}
\renewcommand{\docdate}{13 Juillet 1992}
\newcommand{\numero}{E144}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\section*{Introduction}

Le Paralle'liseur Interproce'dural de Programmes Scientifiques PIPS est
un compilateur-restructureur {\em source a` source} qui transforme du
code Fortran se'quentiel en du code Fortran paralle`le. La version
actuelle de PIPS ne vise pas une machine particulie`re. L'objectif est
simplement de de'tecter autant de paralle'lisme que possible.

Cette notice s'adresse a` l'utilisateur averti qui a de bonnes
connaissances en programmation et en paralle'lisation automatique. Il
convient de porter son attention directement sur les exemples, en
re'servant la compre'hension de toutes les explications a` une lecture
poste'rieure. Elle est restreinte a` la version {\em batch} de PIPS.
La version multifene^tre de PIPS, {\tt wpips}, n'est pas pre'sente'e.
 
Nous pre'sentons tout d'abord les principes et le vocabulaire de base.
Nous montrons ensuite comment initialiser l'espace de travail qui va
permettre de conserver les nouvelles versions du programme et les
informations qui y sont attache'es. 

Nous de'taillons ensuite la commande {\em Display} qui permet d'afficher
directement des re'sultats a` l'e'cran. Une utilisation plus comple`te
des fonctionalite's de PIPS ne'cessite l'utilisation d'autres commandes
comme {\em Select} qui permet de choisir des options de compilation ou
d'analyse, {\em Build} qui permet de calculer des informations ou de
transformer le programme sans afficher les re'sultats et {\em Perform}
qui permet d'effectuer des transformations de programme explicitement.
La commande {\em Pips}, a` laquelle fait appel chacune des commandes
ci-desssus, permet d'effectuer toutes les transformations et analyses
ne'cessaires a` la paralle'lisation d'un programme.

Nous donnons ensuite la liste des analyses et des transformations de programme
qui peuvent e^tre effectue'es avec PIPS.

\section{Principes du fonctionnement}

%est de'crite par le schema 1.

Pour pre'server les
fichiers sources, pour permettre le de'veloppement de plusieurs versions
et pour regrouper en un unique endroit l'ensemble des fichiers qui sont
cre'e's au cours de la compilation d'un programme, l'analyse et les
transformations de programme sont re'alise'es dans le cadre d'un {\bf
workspace} (espace de travail) qui n'est qu'un sous-re'pertoire du
re'pertoire courant.

A cet espace de travail est associe'e une base de donne'es qui indique
a` chaque instant quelles sont les informations disponibles et quelles
sont les options choisies.  Chaque {\bf phase} du compilateur va ajouter
dans le {\em workspace} de nouveaux fichiers, appele's {\bf ressources}
dans la terminologie PIPS.  Plusieurs {\em phases} sont ge'ne'ralement
enchai^ne'es pour satisfaire une seule reque^te de l'utilisateur.

Afin d'assurer la cohe'rence de cet enchai^nement, toutes les reque^tes
de l'utilisateur sont effectue'es par {\bf Display}, {\bf Select}, {\bf
Build}, {\bf Perform} ou {\em Pips}. Ces commandes calculent
l'enchai^nement ne'cessaire a` la construction cohe'rente de la
ressource demande'e ou a` l'application correcte d'une re`gle.

A un programme source donne' peuvent naturellement correspondre plusieurs
espaces de travail, contenant chacun des versions paralle'lise'es diffe'rentes,
obtenues par la se'lection d'options de compilation diffe'rentes ou
par l'application explicite de diverses transformations de programmes.

\subsection{Notion de workspace}

% programme ressource

Pour travailler sur un code source, il faut donc commencer par cre'er un {\bf
workspace}, compose' de {\bf modules}. Plusieurs {\em workspaces}
peuvent e^tre cre'e's a` partir des me^mes fichiers sources, afin d'obtenir
plusieurs versions d'analyses et de transformations d'un programme. Un
{\bf module} correspond a` une proce'dure du programme associe' au workspace.

\subsection{Notion de ressource et de reque^te}

% pipsdbm, ressources, actions (ex cre'ation d'une ressource)

Les {\bf ressources} sont des objets type's, qui correspondent a` des
structures de donne'es. Chacune d'entre elles est stocke'e d'une
manie`re permanente dans un fichier portant le me^me nom. Elles sont
entie`rement ge're'es par le {\em contro^leur de ressources}, qui permet
de disposer des ressources sur disque comme en me'moire. Les ressources
de chaque type sont produites lors de l'exe'cution d'une {\bf phase}
particulie`re de PIPS, et sont relatives soit au programme tout entier,
soit a` un module particulier, qu'il s'agisse du programme principal,
d'une proce'dure ou d'une fonction.

% a une entite' du {\em workspace} (dite {\em
% owner}): PROGRAM pour le {\em programme}, MODULE pour le {\em module},
% CALLERS pour les modules {\em appelants} le module courant ou CALLEES
% pour les modules {\em appele's} par le module courant.

% Gestion de la base (ne rien faire en dehors de pips)

Les ressources sont cre'e'es directement par une reque^te explicite de
l'utilisateur, ou indirectement parce qu'elles s'ave`rent ne'cessaires
au calcul d'une autre ressource demande'e, elle, explicitement.

On peut conside'rer les reque^tes essentielles comme une action sur la
base de ressources. Afin de pre'server la cohe'rence de cette base de
ressources, il ne faut manipuler ces ressources qu'avec les utilitaires
PIPS de'crits dans cette notice: {\tt Display}, {\tt Select}, {\tt
Build}, {\tt Perform}, {\tt Pips} ainsi que {\tt Delete}.

\subsection{Manipulations du workspace. Contro^leur de ressources}

%% Etre explicite sur le controleur de ressources
%% Donner dans Build et Perform l'explication de:
%% Request: Build RESOURCE for module MODULE...
%% Request: Perform RULE for module MODULE...

Afin de minimiser le temps de calcul et de rendre PIPS interactif
malgre' son caracte`re interproce'dural, les ressources ne sont
construites qu'a` la demande. A l'inte'rieur de {\tt Display}, {\tt
Build}, {\tt Perform}, et {\tt Pips} des me'canismes de type {\em
make} enchai^nent re'cursivement l'exe'cution de chaque re`gle (ie.
chaque phase) requise au moment ou` les ressources dont elle a besoin
ont e'te' produites. Ces me'canismes s'appellent dans PIPS les
contro^leurs de ressources (pipsmake). Cela assure aussi la
re'utilisation des ressources, dans la mesure ou` pour chaque re`gle les
ressources produites sont poste'rieures aux ressources requises.

\subsection{Analyses et Transformations}
De nombreuses phases d'analyse et de transformation du programme peuvent
e^tre applique'es successivement, sans souci de la cohe'rence des
enchai^nements, qui est prise en charge par le contro^leur de
ressources. Ainsi l'utilisateur peut-il se concentrer sur le travail ou`
sa connaissance du programme est re'ellement utile.


\section{Cre'ation d'un workspace: Init}

\subsection{Environnement de PIPS}

% repertoire, source lu seulement


Pour utiliser PIPS, il faut pouvoir exe'cuter {\tt Init}, {\tt Build},
{\tt Perform}, {\tt Select} et {\tt Pips}. Il convient d'ajouter a` son
path la directory ou` se trouvent ces shell-scripts et de de'finir
quelques variables d'environnement. Pour cela, il suffit d'exe'cuter
l'un des shell-scripts (selon votre shell usuel) fourni avec PIPS: 

{\tt \$ . Pips/pipsrc.sh} (shell sh ou ksh) ou 

{\tt \$ source Pips/pipsrc.csh} (shell csh ou tcsh). 

Si vous utilisez PIPS plusieurs fois, cette commande devrait e^tre
place'e dans votre fichier d'initialisation du shell.

Toutes ces commandes seront appele'es depuis le re'pertoire ou` sont
situe's les fichiers sources du programme que vous voulez paralle'liser.

PIPS ne'cessite beaucoup de place a` la fois en me'moire et sur disque.
Assurez-vous que vous disposez d'une capacite' suffisante avant de
commencer une nouvelle session... 

\subsection{Init}

% Utilisation, resultats

\begin{description}

\item Usage: {\bf Init [-f file1.f] [-f file2.f] ... [-d] workspace \\
ou  Init [-f "file1.f file2.f ..."] [-d] workspace}


Pour cre'er un workspace de nom {\tt wspace} en vue de  paralle'liser les
fichiers sources Fortran {\tt src1.f} et {\tt src2.f}, exe'cuter:\\
{\tt \$ Init -f src1.f -f src2.f wspace ou  \$ Init -f "src1.f src2.f"
wspace}.  

Si le workspace  de nom {\tt wspace} existe pre'alablement, utiliser
l'option {\tt d}:\\ {\tt \$ Init -f "src1.f src2.f" -d wspace}

Si le nom du workspace n'est pas spe'cifie', le nom du workspace
pre'ce'demment se'lectionne' est repris. 
Si vous n'e^tes pas seul a` travailler dans un me^me re'pertoire, il
faut spe'cifier votre workspace a` chaque commande.

La commande  {\tt \$ Init wspace} permet de  revenir a` un workspace
de'ja` existant. 


\end{description}

Un re'pertoire {\em wspace.database} est cre'e'; il  contiendra 
la base des  ressources. Le fichier {\em wspace.database/schema}
de'crit cette base, chaque ressource est  un fichier. La base des
ressources  est initialise'e avec les 
SOURCE\_FILE, correspondant au  source de chacunes des proce'dures du
programme (ou {\em modules}) 
choisi. Ces SOURCE\_FILEs sont de'rive's a` partir de vos
fichiers sources, a` l'aide de l'utilitaire {\em fsplit}. 

Vos propres fichiers  sont conside're's aussi comme des ressources,
dites USER\_FILE, qui sont exceptionnellement en dehors du  re'pertoire
{\em wspace.database} et qui ne seront jamais modifie's. 

Chaque fichier SOURCE\_FILE ne contient qu'un unique module et prend
comme nom le nom de ce module. Le fichier {\em wspace.database/modules}
contient la liste de ces modules. 

Toutes les informations propres a` l'environnement de travail
(re`gles de production des ressources) sont conserve'es dans le
fichier {\em wspace.database/pipsmake}.


\subsection{Exemple}
Soit le fichier matmul.f qui comprend les proce'dures mm et saxpy. Pour
cre'er l'espace de travail mm1 a` partir de ce fichier, placez-vous sous un
re'pertoire qui contient matmul.f et tapez la commande:

{\tt \$ Init -f matmul.f mm1}

Les messages qui notifient l'activite' de PIPS sont nombreux, ils
permettent de suivre les calculs re'alise's. Remarquer simplement parmi
ceux de la commande Init:
\begin{verbatim}
Spliting file    matmul.f
  Module         MM
  Module         SAXPY
\end{verbatim}
Ils pre'cisent que les modules de mm1 sont MM et SAXPY (ces derniers peuvent
e^tre donne's en lettres minuscules dans les commandes suivantes).

Les fichiers cre'e's sous le re'pertoire {\tt mm1.database} sont {\tt
schema}, {\tt mm.f}, {\tt saxpy.f}, {\tt modules} et {\tt pipsmake}.

\subsection{Destruction d'un workspace: Delete}

Afin de supprimer un workspace de nom wspace, il suffit de faire:\\
{\tt \$ Delete wspace}

Noter que les sources re'els du programme (ressources USER\_FILE) ne sont pas
efface's par {\tt Delete}.


\section{Affichage des re'sultats: Display}

\subsection{Principe}

Les re'sultats des analyses et des transformations de programme,
construits avec les re`gles ade'quates, sont lisibles dans l'une des
ressources PRINTED\_FILE, PARALLELPRINTED\_FILE, CALLGRAPH\_FILE,
ICFG\_FILE, DG\_FILE, WP65\_COMPUTE\_FILE ou encore WP65\_BANK\_FILE.
Les transformations de code y sont  effectue'es, et les 
re'sultats des analyses  sont visibles en commentaire de ces fichiers
Fortran. La fabrication des ressources et leur affichage sont
automatiquement re'alise's par la commande {\tt Display}, qui exe'cute
un appel a` {\tt Pips}. 

\subsection{Display}
\begin{description}

\item Usage: {\bf Display [-w wspace] [-m module] [-v] [pretty-print]}

ou` les valeurs possibles de pretty-print sont: {\tt  para77 para90 cray
code tran prec comp regi prop cumu cg icfg icfgl icfgc dg wp65 flint}. 
La valeur par de'faut est {\tt para77}. 

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

L'option {\tt v} permet l'affichage des messages de'crivant les
diffe'rentes ope'rations qui sont effectue'es.

\end{description}

{\bf pretty-print} est une cle' a` laquelle sont associe's des
traitements PIPS qui aboutissent a` la fabrication d'une ressource
parmi: PRINTED\_FILE, PARALLELPRINTED\_FILE, CALLGRAPH\_FILE,
ICFG\_FILE, DG\_FILE, WP65\_COMPUTE\_FILE ou encore WP65\_BANK\_FILE;
ces ressources sont des fichiers de texte qui 
permettent d'afficher les analyses et transformations de programme qui
ont e'te' effectue'es. 

\paragraph{PRINTED\_FILE} construit avec:
\begin{itemize}
\item{\tt code} donne le pretty-print de la repre'sentation interme'diaire
du module qu'utilise PIPS;
\item{\tt tran} donne en plus l'analyse se'mantique des transformers en
commentaire;
\item{\tt prec} fait de me^me avec les pre'conditions;
\item{\tt comp} fait de me^me avec les complexite's;
\item{\tt regi} fait de me^me avec les re'gions;
\item{\tt prop} fait de me^me avec les effets propres;
\item{\tt cumu} fait de me^me avec les effets cumules.
\end{itemize}

\paragraph{CALLGRAPH\_FILE} construit avec:
\begin{itemize}
\item{\tt cg} affiche le graphe des appels
\end{itemize}

\paragraph{ICFG\_FILE} construit avec:
\begin{itemize}
\item{\tt icfg} affiche le graphe de contro^le
\item{\tt icfgl} donne en plus les boucles qui comprennent des appels
\item{\tt icfgc} fait de me^me avec les structures de contro^le.
\end{itemize}

\paragraph{DG\_FILE} construit avec:
\begin{itemize}
\item{\tt dg} affiche le graphe de de'pendences.
\end{itemize}

\paragraph{PARALLELPRINTED\_FILE} construit avec:
\begin{itemize}
\item{\tt para77} donne le pretty-print du code paralle`le;
\item{\tt para90} donne aussi le pretty-print du code paralle`le, mais avec
la notation Fortran 90;
\item{\tt cray} donne le pretty-print du code paralle`le sous le format cray.
\end{itemize}


\paragraph{WP65\_COMPUTE\_FILE et WP65\_BANK\_FILE} construits avec:
\begin{itemize}
\item {\tt wp65} ge'ne're une version distribue'e du programme pour
multiprocesseur a` me'moire distribue'e (une me'moire
partage'e est e'mule'e).  Le code complet est compose' des deux
ressources WP65\_COMPUTE\_FILE (code exe'cute' par les processeurs de
calcul) et WP65\_BANK\_FILE (code exe'cute' par les processeurs e'mulant la
me'moire partage'e). 
\end{itemize}	


\paragraph{FLINTED\_FILE} construit avec:
\begin{itemize}
\item {\tt flint} affiche le re'sultat de la ve'rification de 
cohe'rence  d'un module. 
\end{itemize}	


La ressource construite est affiche'e sur le fichier de sortie standard
stdout, alors que les messages informatifs sortent sur le fichier
d'erreur standard stderr.

\subsection{Exemple}
Pour visualiser la version paralle`le du module MM de mm1, taper:

{\tt \$ Display -m mm}

Toutes les phases doivent s'enchai^ner pour construire la ressource
\newline PARALLELPRINTED\_FILE du module MM. Finalement, on obtient:

\begin{verbatim}
Display of file mm1.database/MM.parf
C
C     MATRIX MULTIPLICATION - VERSION WITH CALL TO SAXPY
C
C     PARALLELIZATION OF LOOPS INCLUDING CALLS TO PROCEDURE
C
      SUBROUTINE MM(N, A, B, C)
C
      REAL*8 A(N,N), B(N,N), C(N,N), XAUX(0:127)
C
      DOALL I = 1,N,1
         PRIVATE I
         DOALL J = 1,N,1
            PRIVATE J
            C(I,J) = 0.0                                          0006
         ENDDO
      ENDDO
C
      DOALL J = 1,N,1
         PRIVATE J
         DO K = 1,N,1
            PRIVATE K
            CALL SAXPY(N, C(1,J), A(1,K), B(K,J))                 0011
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

Pour conserver dans le fichier mm1.mm.prec les pre'conditions de ce module,
faire: 

{\tt \$ Display prec > mm1.mm.prec}

Il faut noter que malgre' sa grande utilite', la commande {\tt Display}
ne permet pas de be'ne'ficier de toute la puissance de PIPS. Aussi
faut-il savoir recourir a` {\tt Select} , {\tt Perform}, {\tt
Build} ou {\tt Pips}.


\section{Choix des options: Select}

% Makefile reconfigurable

Pour initialiser un {\em workspace}, il faut spe'cifier quelles sont les
re`gles de construction des ressources. Une phase est une exe'cution
d'une re`gle, et a` chaque ressource est associe'e au moins une re`gle de
production. Un exemple de re`gle par de'faut est fourni dans le fichier
{\tt \$LIBDIR/pipsmake.rc}

\subsection{Fichier pipsmake.rc}

Au premier appel de {\tt Build}, {\tt Perform}, {\tt
Select} ou {\tt Pips}  un fichier {\tt pipsmake.rc} est lu pour apprendre a`
PIPS les re`gles de production des ressources: celui du re'pertoire
courant s'il existe, celui de {\tt \$LIBDIR} a` de'faut. Aussi
pouvez-vous cre'er votre propre fichier d'initialisation de PIPS en
copiant  {\tt pipsmake.rc} et en le modifiant (voir la syntaxe de ce
fichier en annexe {\em pipsmake}).

Lorsque plusieurs re`gles sont disponibles dans {\tt pipsmake.rc} pour
cre'er une me^me ressource, la premie`re d'entre elles est
se'lectionne'e. Une autre re`gle pourra e^tre se'lectionne'e a` la place
de la premie`re au moyen de la commande {\tt Select}.

Une re`gle se'lectionne'e sera au besoin utilise'e pour une phase afin
de calculer une ressource requise. C'est la` le principe du {\em make}.

Une fois que {\tt pipsmake.rc} a e'te' lu, il ne sera plus jamais
utilise' pour ce workspace, puisqu'une repre'sentation interne du
pipsmake est conserve'e et tenue a` jour pour chaque workspace. Elle est
stocke'e dans le fichier {\tt wspace/pipsmake}.

\subsection{Select}
\begin{description}

\item Usage: {\bf Select [-w wspace] rule [rule] ...}

Le workspace courant est utilise' a` moins qu'un nom ne soit spe'cifie'
par l'option {\tt -w}.

Les re`gles a` se'lectionner peuvent e^tre spe'cifie'es  soit par un nom
interne a` PIPS \newline (ex. {\tt rice\_full\_dependence\_graph}), soit
par un alias ge're' par le shell-script {\tt Pips} (ex. {\tt rfulldg}).
Voir l'annexe {\em alias}.
\end{description}

La commande {\tt Select} permet de choisir parmi les diffe'rents
algorithmes propose's celui que vous de'sirez effectuer pour transformer
ou analyser un programme.

\subsection{Exemple}
Soit le programme {\tt choles.f}. Montrons qu'il est ne'cessaire de
se'lectionner la re`gle \newline {\tt rice\_full\_dependence\_graph}
pour le paralle'liser:

{\tt \$ Init c2 choles.f}

Un seul module: CHOLES.

{\tt \$ Perform -m choles privatizer}

Ainsi sont privatise'es les variables pour lesquelles cette
transformation est licite.

{\tt \$ Display para >c2.para}
%%on pourrait faire 2>/dev/null (...) mais ne marche pas sous csh ni tcsh

Mais ce pretty-print n'est pas paralle`le:
\begin{verbatim} 
$ cat c2.para
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1,N,1
         PRIVATE I,KK,J,K,X
         X = A(I,I)                                              0004
         DO K = 1,(I-1),1
            PRIVATE K
            X = (X-(A(I,K)*A(I,K)))                              0007
         ENDDO
         P(I) = (1.0/SQRT(X))                                    0008
         DO J = (I+1),N,1
            PRIVATE J,KK,X
            X = A(I,J)                                           0011
            DO KK = 1,(I-1),1
               PRIVATE KK
               X = (X-(A(I,J)*A(I,KK)))                          0014
            ENDDO
            A(J,I) = (X*P(I))                                    0015
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}
Donc il convient de choisir une re`gle qui imple'mente un algorithme qui
tienne compte des pre'conditions:

{\tt \$ Select rfulldg}

Ainsi la re`gle RICE\_FULL\_DEPENDENCE\_GRAPH est se'lectionne'e.

{\tt \$ Display para >c2.para}

Qui calcule une version effectivement paralle`le:
\begin{verbatim} 
$ cat c2.para
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1,N,1
         PRIVATE I,KK,J,K,X
         X = A(I,I)                                                    0004
         DO K = 1,(I-1),1
            PRIVATE K
            X = (X-(A(I,K)*A(I,K)))                                    0007
         ENDDO
         P(I) = (1.0/SQRT(X))                                          0008
         DOALL J = (I+1),N,1
            PRIVATE J,KK,X
            X = A(I,J)                                                 0011
            DO KK = 1,(I-1),1
               PRIVATE KK
               X = (X-(A(I,J)*A(I,KK)))                                0014
            ENDDO
            A(J,I) = (X*P(I))                                          0015
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

\subsection{Avertissement}

Comme nous le constatons sur l'exemple pre'ce'dent, certaines re`gles ne
doivent pas e^tre se'lectionne'es, mais applique'es. L'application
consiste a` demander l'exe'cution {\em imme'diate} d'une re`gle
spe'cifique; elle est toujours licite. Par contre, la se'lection
consiste a` choisir la re`gle qui sera utilise'e {\em ulte'rieurement}
par de'faut pour produire une ressource d'un certain type.

Toutes les re`gles ne peuvent pas e^tre se'lectionne'es, afin de ne pas
introduire de cycle dans l'enchai^nement des re`gles. Par exemple,
la re`gle de nom {\tt distributer}, qui effectue la distribution de
boucles, et la re`gle {\tt privatizer}, qui privatise les variables
scalaires dans 
les boucles, produisent toutes deux la ressource {\tt CODE} a` partir
d'une ressource {\tt CODE} qui doit e^tre de'ja` disponible pour le
me^me module. Il faut donc que reste se'lectionne'e une autre re`gle qui
produise initialement {\tt CODE} ({\tt link} par de'faut). Cela ne
serait plus vrai si l'on se'lectionnait {\tt distributer} ou {\tt
privatizer} (cf. section {\em Application d'une re`gle: Perform}).


\section{Demande d'une ressource: Build}

\subsection{Build}
\begin{description}

\item Usage: {\bf Build [-w wspace] [-m module] resource}

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

La ressource peut e^tre spe'cifie'e par son vrai nom
ou par un alias. Les noms sont ge'ne'ralement plus explicites mais
aussi plus longs.

\end{description}


Vous souhaitez une ressource qui ne soit pas visualisable a` l'e'cran
comme les effets d'une proce'dure ou un graphe de de'pendance (cf. annexe
{\em Base de ressources}). Pour l'obtenir, vous devez alors utiliser
Build. Cela est utile a` des fins de debug ou bien pour re'cupe'rer des
re'sultats partiels a` l'intention d'un autre logiciel. Le graphe de
de'pendance pourrait ainsi e^tre re'utilise' pour faire de l'ordonnancement
d'instructions.


\section{Application d'une re`gle: Perform}

\subsection{Perform}
\begin{description}
\item Usage: {\bf Perform [-w wspace] [-m module] [-v] rule}

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

La re`gle rule peut e^tre spe'cifie'e par son nom vrai ou par son nom
d'alias.

L'option {\tt v} permet l'affichage des messages de'crivant les
diffe'rentes ope'rations qui sont effectue'es.
\end{description}

Il est ne'cessaire d'appliquer explicitement les re`gles qui ne
produisent pas directement une ressource mais qui la modifie.  C'est
notamment le cas de {\tt distributer} et {\tt privatizer} pour la
production de CODE.

\section{Pips}

\begin{description}
\item Usage: Pips [-w wspace] [-f source\_file[,source\_file]...]"
     "                        [-s selected\_rule[,selected\_rule]...]"
     "                        [-m module] [-p performed\_rule]"
     "                                    [-b build\_resource]"


Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt w} (resp. {\tt m}).

La re`gles et la ressource peuvent e^tre spe'cifie'es par leur vrai nom
ou par un alias. Les alias sont ge'ne'ralement moins explicites mais
aussi moins longs.
\end{description}

Les re`gles {\tt selected\_rule} e'ventuellement spe'cifie'es avec
l'option {\tt s} sont se'lectionne'es (cf. {\em Select}).

Ensuite la re`gle {\tt performed\_rule} e'ventuellement spe'cifie'e avec
l'option {\tt p} est applique'e (cf. {\em Perform}).

Pour finir, la ressource {\tt build\_resource} est calcule'e (build), a`
moins que ce ne soit une chai^ne vide, auquel cas seuls le Select et le
Perform sont effectue's.

Display, Select, Perform et Build  font un appel
a` Pips qui effectue les conversions et ve'rifications requises puis
appelle les binaires ne'cessaires. Les alias doivent e^tre modifie's
dans Pips  pour valoir pour les autres shell-scripts (cf. annexe {\em
Alias}). 


\section{Analyses}
% chains et dg lost

Pour chacune des phases d'analyse: (1) calcul des pre'dicats (les
transformers et les pre'conditions), (2) calcul du graphe de
de'pendance, (3)  calcul des {\em use-def chains} et (4) calcul du
graphe de conro^le, plusieurs algorithmes ont e'te' de'veloppe's. Il est 
possible de choisir le type d'algorithme que vous  de'sirez
utiliser pour effectuer une analyse en utilisant {\em
Select}. Cf. rapport EMP-CAI-I E/137 pour plus de de'tails.

\subsection{Transformers}
Quatre algorithmes sont disponibles et leur distinction se fait sur deux
crite`res: Ils sont plus ou moins pre'cis et intra ou inter-proce'duraux.

Les re`gles associe'es a` ces algorithmes sont: TransFormers\_intra\_fast
(alias tf), TransFormers\_intra\_FULL (alias tffull),
TransFormers\_INTER\_fast (alias tfinter) TransFormers\_INTER\_FULL
(alias tfinterfull). 

\subsection{Pre'conditions}
De manie`re similaire, les re`gles sont: PreConditions\_intra (alias
pc),\newline PreConditions\_INTER\_fast (alias pcinter),
PreConditions\_INTER\_FULL (alias pcinterfull).

\subsection{Graphe de de'pendance}
Trois algorithmes sont disponibles:  (1) Rice\_fast\_Dependence\_Graph (alias
rdg),  le plus rapide mais aussi le moins pre'cis, (2) \newline
Rice\_FULL\_Dependence\_Graph (alias rfulldg) qui prend en compte les
bornes de boucles et (3) \newline Rice\_Semantics\_Dependence\_Graph
(alias rsdg)  qui prend en compte les pre'conditions. 

\subsection {Use-Def chains}

Deux algorithmes sont propose's pour calculer les {\em use-def et
def-use chains} . L'algorithme classique peut e^tre apllique' en
utilisant  Atomic\_CHains.  Le second, est
base' sur le calcul des re'gions et est  donc plus pre'cis; il est
appliquable par  Region\_CHains. 

\subsection {ICFG}

Trois algorithmes permettent d'obtenir le graphe de contro^le, du moins
au plus pre'cis, sont propose's: (1) PRint\_ICFG (alias pricfg), (2)
PRint\_ICFG\_with\_Loops (alias pricfgl) qui donne les appels et les boucles 
imbrique'es, et (3) PRint\_ICFG\_with\_Control (alias pricfgc) qui donne
en plus les tests de contro^le.  

\subsection {Paralle'lisation}

Plusieurs options de paralle'lisation sont disponibles suivant le
type  des de'pendences dont vous de'sirez tenir compte lors de la
paralle'lisation: RICE\_All\_dependence (alias ricea) ou
RICE\_data\_dependence (alias ricetrue), ou que vous de'sirez ge'ne'rer
du code approprie' au Cray: rice\_cray (alias ricec).  

\section{Transformations du programme}

\subsection{Privatisation de variables}
Celle-ci est toujours re'alise'e pour les indices de boucle sans qu'elle
soit demande'e. Par contre il faut appliquer la re`gle {\tt PRIVatizer}
(alias {\tt priv}) pour privatiser toutes les variables qui peuvent
l'e^tre, avant de demander la paralle'lisation, naturellement.

\subsection{Distribution de boucles}
Elle est re'alise'e en appliquant la re`gle {\tt DISTributer} 
(alias {\tt dist}). 

\subsection{Evaluation Partielle}

La re`gle  Partial\_EVal (alias pev)  ge'ne`re le code ou` les expressions constantes
ont e'te' remplace'es par leur valeur. 


\subsection{De'roulage de boucle}

Le {\em de'roulage de boucle}  de'roule {\tt n} ite'rations d'une boucle. Le
label de la boucle ainsi que le nombre  {\tt n} doivent e^tre donne's au
moment de  l'exe'cution par l'utilisateur. La transformation est tre`s
ge'ne'rale et il est inte'ressant d'effectuer une {\em e'valuation
partielle} du code apre`s cette transformation. Cette transformation est
applique'e gra^ce a` {\tt UNRoll} (alias unr). L'option {\tt v} doit
e^tre utilise'e. 


\subsection{Strip\_mine}

Un label de boucle ainsi que: soit une taille de bloc ou un nombre de
blocs sont demande's a` l'utilisateur. Le {\em strip-minig} de la boucle
est effectue'e en utilisant: Strip\_Mine (alias sm). L'option {\tt v}
doit e^tre utilise'e. 



\subsection{Echange de boucles}

L'e'change de boucle e'change la boucle dont le label est donne' par
l'utilisateur avec la boucle la plus interne du me^me nid de boucles.
Elle est appliquable avec la re`gle:  Loop\_Interchange  (alias li).
L'option {\tt v} doit e^tre utilise'e. 


\subsection {Re'ductions}

Pour de'tecter les re'ductions utiliser: {\tt REDuctions} (alias red).


\subsection{Paralle'lisation de nid de boucles}

C'est la transformation de programme par de'faut; elle est obtenue en
demandant {\tt Display [para]}, qui construit la ressource 
PARALLELPRINTED\_FILE.
A la diffe'rence des transformations pre'ce'dentes, celle-ci est
e'labore'e a` partir de la ressource PARALLELIZED\_CODE distincte de la
ressource CODE a` partir de laquelle elle a e'te' construite. Elle peut
donc e^tre demande'e implicitement.

Ainsi, la paralle'lisation interproce'durale d'un module \verb+foo+ d'un
programme Fortran \verb+bar+ contenu dans le fichier \verb+source.f+ se
re'sume a`:
\begin{verbatim}
$ Init bar-v1 source.f
$ Display -m foo
\end{verbatim}
ou` \verb+bar-v1+ est la zone contenant la premie`re version
paralle'lise'e du programme \verb+bar+. Une deuxie`me proce'dure,
\verb+foofoo+, peut e^tre ensuite traite'e par une unique commande dans
le me^me espace de travail \verb+bar-v1+:
\begin{verbatim}
$ Display -m foofoo 
\end{verbatim}
a` condition, bien su^r, que son code se soit trouve' dans votre
fichier Fortran \verb+source.f+.

\newpage

\section*{Conclusion}

PIPS est un paralle'liseur interproce'dural expe'rimental. La version
de'crite dans ce rapport est la premie`re qui soit mise entre les mains
d'utilisateurs exte'rieurs a` l'Ecole des Mines. Il est vraisemblable que
de nombreuses erreurs subsistent et nous vous sommes d'avance reconnaissant
de nous les signaler (e-mail: \verb+<pipsgroup@ensmp.fr>+). Ne'anmoins nous
espe'rons que PIPS vous permettra d'obtenir des re'sultats inte'ressants
en paralle'lisation interproce'durale.

%\section{Re'cupe'ration d'erreurs}


%\section{Debug}

\newpage

\section*{Annexe 1: Installation de PIPS}

La version initiale de PIPS est fournie pour stations et serveurs SUN4,
exploite's sous SUNOS~4.0.3. PIPS fonctionne avec 8~Mo de me'moire physique
et 14~Mo d'espace {\em swap} pour de petits programmes, mais il faut disposer
de plus d'espace de swap pour des programmes de plusieurs milliers de lignes,
et si possible de plus de me'moire. La configuration utilise'e a` l'Ecole
des Mines consiste en un SUN~4/260, 32~Mo de me'moire et 50~Mo d'espace
de swap.

Il faut:
\begin{enumerate}

  \item choisir un re'pertoire, un proprie'taire et un groupe pour la
sous-arborescence PIPS; nous avons choisi de de'finir au CRI un compte
{\em pips} qui se trouve dans le groupe {\em staff} comme les chercheurs;

  \item effectuer un \verb+tar x Pips+ dans le re'pertoire ou` Pips doit e^tre
installe'; ce re'pertoire est au CRI {\em /home/users/pips}

  \item mettre a` jour le proprie'taire, le groupe et les droits pour
cette sous-arborescence; ge'ne'ralement {\tt chmod} a une option re'cursive;
sinon, il faut utiliser find;

  \item mettre a` jour les variables shell PIPSDIR, LINEARDIR, NEWGENDIR,
TMPDIR et e'ventuellement OPENWINHOME dans le fichier {\tt
Pips/pipsrc.sh} en fonction du re'pertoire qui a e'te' 
choisi pour l'installation; il est pre'fe'rable de donner des noms
absolus a` ces variables; au CRI, {\tt PIPSDIR=/home/users/pips/Pips}.
Le fichier {\tt Pips/pipsrc.csh} doit alors e^tre mis a` jour en
executant la commande {\tt Pips/make-pipsrc.csh}.

  \item exe'cuter directement celui de ces deux fichiers qui correspond
a` l'analyseur de commande retenu (cf. section {\em Environnement de
PIPS}); avec le Bourne Shell ou le Korn Shell:
\begin{quote}
{\tt . pipsrc.sh}
\end{quote}
avec le C Shell ou le TC Shell:
\begin{quote}
{\tt source pipsrc.csh}
\end{quote}

  \item pour continuer l'installation suivre les instructions du fichier
\verb+$UTILDIR/install-pips-src+.

  \item Pour installer le {\tt man} (dans {\tt /usr/man/manl}:\\
\verb+ cd $DOCDIR
make man+

\end{enumerate}

%%Preciser la structure de la cassette

\newpage

\section*{Annexe 2: Fortran PIPS}

Le compilateur PIPS n'accepte pas l'ensemble du langage Fortran tel
qu'il est de'fini dans la norme Fortran-77. Les restrictions et
extensions qui lui ont e'te' apporte'es sont de'finies et justifie'es en
de'tail dans le rapport EMP-CAI-I~E/103.

Les restrictions essentielles au langage sont les suivantes:
\begin{enumerate}

  \item ENTRY 

  \item BLOCKDATA

  \item ASSIGN et GOTO assigne'

  \item RETURN multiple

  \item GOTO calcule'

  \item ope'rateur substring ``:''

  \item initialisation de chai^nes de caracte`res de type Hollerith \\
(par exemple \verb+DATA A /8HOPERATIN,8HG POINT /+ doit e^tre
transforme' en \verb+DATA A /'OPERATIN','G POINT '/+)

  \item le caracte`re {\em double quote} est prohibe' comme dans la
norme bien que de nombreux compilateurs acceptent un jeu de caracte`res
plus grand que celui qui est spe'cifie' dans la norme;

  \item les fonctions formules ne sont pas traite'es;

  \item les constantes complexes doivent e^tre remplace'es par un appel
a` \verb+CMPLX+;

  \item les de'clarations de COMMONs doivent apparai^tre apre`s
	toutes les de'clarations de type.

\end{enumerate}

Ces restrictions peuvent e^tre contourne'es en modifiant {\em
syntaxiquement} le programme (voir le rapport EMP-CAI-I~E/103). Les
me'canismes fondamentaux de Fortran sont bien tous traite's par PIPS.

Il est aussi a` noter que les restrictions 1 (M.V.13), 2 (M.III.4,
M.V.17), 3 (M.III.6), 4 (M.V.12, M.V.16) et 7 (M.VI.15) )font partie des
constructions qu'il est conseille' d'e'viter dans:
\begin{quote}
FORTRAN 77 - Guide pour l'e'criture de programmes portables \\
Franc,oise Ficheux-Vapne'\\
(annexe B)
\end{quote}
D'autres conseils donne's dans cet ouvrage permettront d'ame'liorer
les re'sultats donne's par PIPS:
\begin{itemize}
  \item utilisation de \verb+END+ sans \verb+STOP+ ni \verb+RETURN+
	pour terminer les unite's de programme (M.IV.3, M.V.1, M.V.8, M.V.14);
  \item de'finition uniforme des \verb+COMMONs+ dans tout un programme
	(M.V.21)
\end{itemize}

% Il n'est pas non plus possible d'utiliser la me^me chai^ne de
% caracte`res pour un symbole global comme un nom de module ou de common
% et pour un symbole local comme un nom de variable ou de parame`tre formel.
% Cette dernie`re restriction est une source d'erreurs quelques fois difficiles
% a` comprendre.

Il faut s'assurer que tous les modules sont explicitement nomme's par
une instruction \verb+PROGRAM+, \verb+SUBROUTINE+ ou \verb+FUNCTION+.
Cela veut dire qu'il faut ajouter l'instruction:
\begin{center}
\begin{verbatim}
PROGRAM MAIN
\end{verbatim}
\end{center}
aux programmes principaux qui ne comprennent pas d'instructions \verb+PROGRAM+.
Un nom plus e'vocateur que \verb+MAIN+ peut bien su^r e^tre choisi.

L'objectif n'e'tant pas d'e'crire un compilateur commercial, les
messages d'erreurs ne sont pas force'ment tre`s explicites. Il faut donc
s'assurer au pre'alable que le programme soumis a` PIPS est accepte' par
un compilateur conventionnel. Les options de compilation choisie devraient
e^tre aussi se've`res que possible de manie`re a` e'liminer au maximum
les extensions par rapport a` la norme Fortran-77.

Un des proble`mes rencontre's est la restriction des instructions aux colonnes
7 a 72. Avec les editeurs pleine page, il est parfois difficile de se rendre
compte qu'on a depasser cette limite. Les messages fournis par PIPS sont
alors impre'visibles et incompre'hensibles par celui qui regarde le source.

Pour minimiser les proble`mes, les de'clarations devraient avoir la structure
suivante:
\begin{enumerate}

  \item de'claration des arguments;

  \item ordre \verb+IMPLICIT+ optionnel;

  \item de'claration des types et dimensions des variables;

  \item de'claration des externes, l'ordre EXTERNAL pre'ce'dant la
	de'claration de type;

  \item de'claration des \verb+COMMON+s.

\end{enumerate}

\newpage

\section*{Annexe 3: Messages d'erreur}

De nombreux messages d'erreurs ou d'avertissement peuvent e^tre e'mis par PIPS
(fichier non existant, erreur de syntaxe, option inconnue, etc...).
Les erreurs propres au compilateur provoquent volontairement
un message {\em core dumped} de manie`re a` pouvoir analyser ce qui s'est
passe'.

Le non-fonctionnement de \verb+pips_make+, qui se traduit par des recalculs
inutiles ou par des absences de calculs utiles, est ge'ne'ralement du^
au fonctionnement de NFS. Il faut ve'rifier que la machine sur laquelle
tourne PIPS a exactement la me^me heure que la machine qui ge`re les
fichiers. Le test peut se faire avec une commande du genre:

\begin{verbatim}
date; echo bonjour >foo; ls -l foo;rm foo
\end{verbatim}

Les stations peuvent e^tre resynchronise'es sur le serveur NFS en
utilisant la commande \verb+rdate+.

\section*{Annexe 4: Erreurs connues}

% L'algorithme de paralle'lisation ne prend pas en compte les de'pendances
% portant sur les {\em bornes} de boucles. Une distribution de boucle
% malencontreuse est parfois applique'e a` des affectations de variables
% scalaires locales. Il faut essayer d'e'liminer ces variables scalaires
% en remplac,ant leurs occurences par leur expression d'initialisation.
% Le programme re'sultant est faux.

L'algorithme de calcul des {\em use-def chains} cre'e de fausses
de'pendances sur des indices de boucle. Elles sont dues a` l'utilisation
d'un indice identique dans un DO implicite ou dans une expression de bornes
d'autres boucles. Ce proble`me est facilement identifiable parce que
l'indice de la boucle non paralle'lise'e n'est pas de'clare' {\tt
PRIVATE.} Le programme re'sultant n'est pas optimal mais est correct.

% Ces deux comportements aberrants sont dus au calcul des effets des
% instructions. Nous n'avons pas encore trouve' une solution qui soit a`
% la fois correcte et efficace.

Les commentaires portant sur les instructions {\tt GOTO} et {\tt RETURN}
sont perdus. Ceci est du^ au traitement des {\tt RETURN} comme des {\tt
GOTO} vers la fin de la proce'dure courante et a` la conversion des {\tt
GOTO} en arcs du graphe de contro^le. Il n'a pas e'te' pre'vu de faire
porter des commentaires par ces arcs. 

L'impression des formats longs de plus d'une ligne se fait en un seul
enregistrement. Les lignes suites qui devraient e^tre cre'es ne le sont pas.
Le fichier re'sultant n'est pas compilable.

Les fonctions formelles sont reconnues par le parser mais elles ne sont
pas traite'es correctement par les phases d'analyse. Le parser
emet un message de type \verb+user_error+.

Dans les de'clarations, les informations de type et de dimension doivent
e^tre donne'es avant les de'clarations de commons. En cas d'inversion,
les adresses des variables dans les commons peuvent e^tre fausses ainsi que
les calculs de de'pendance qui porteront sur elles.

% L'ordre {\tt EXTERNAL} n'est pas reconnu par le parser.

Les STOPs apparaissant dans des sous-programmes et les exceptions en
ge'ne'ral ne sont pas correctement traite's.

Le caracte`re {\em double quote} est pas accepte' dans les chai^nes de
caracte`res (N.B. il ne fait pas partie du jeu de caracte`res standard
de Fortran). Mais il ne peut pas servir comme de'limiteur de constante
chai^ne de caracte`res.
% Il faudrait quand me^me le filtrer automatiquement. Le proble`me
% vient de NewGen et non de PIPS.

\newpage

\section*{Annexe 5: Base de ressources}

Les calculs effectue's, la ressource sera disponible dans le fichier 
\newline {\tt wspace.database/MODULE.extension}. extension est en
lettres majuscules s'il s'agit d'une ressource structure'e pour PIPS (et
correspond au nom de la ressource), et en lettres minuscules s'il s'agit
d'une ressource construite par un pretty-printer (qui ge'ne`re du code
plus des commentaires).

Les ressources structure'es pour PIPS ne sont pas lisibles, et ne
peuvent servir qu'a` de futurs calculs dans la base.

Parmi les pretty-prints, on aura les extensions {\tt f} pour le Fortran
du SOURCE\_FILE, {\tt pref} pour le pretty-print du Fortran se'quentiel,
{\tt parf} pour le pretty-print du Fortran paralle`le, {\tt pred} pour
le pretty-print des pre'dicats. Pourtant, il est pre'fe'rable d'utiliser
la commande Display qui fournit une version toujours mise a` jour du
pretty-print requis.

Les manipulation directes du workshpace sont a` prohiber parce qu'elles
risquent d'engendrer des incohe'rences entre la base et son sche'ma.

\newpage

\section*{Annexe 6: Contro^leur de ressources pipsmake}

La syntaxe d'une re`gle du fichier pipsmake.rc est la suivante:
\begin{verbatim}
rule		> OWNER.resource
		[> OWNER.resource]...
	[< OWNER.resource]...
\end{verbatim}

Ces re`gles ne doivent pas e^tre modifie'es, mais il est possible d'en
changer l'ordre. Cf. rapport EMP-CAI-I~E/133 pour plus de de'tails.

La manipulation directe du fichier \verb+pipsmake.rc+ est a` e'viter.
Il faut commencer par en faire une copie dans la directory courante.
Cette copie n'est prise en compte que pour les nouveaux workspaces.

Tous les re'sultats souhaitables doivent pouvoir e^tre obtenus a` l'aide
de la commande {\em Select}, sauf la modification des 
options par de'faut. Par exemple, le test de de'pendance rapide peut e^tre
remplace' par le test de de'pendance pre'cis en e'changeant les re`gles
\verb+rice_fast_dependence_graph+ et \verb+rice_full_dependence_graph+.

\newpage

\section*{Annexe 7: Alias}

Les alias sont utilisables pour les re`gles et les ressources,
dans chacun des arguments correspondants de Build, Perform et Select.
Pourtant leur usage n'est jamais ne'cessaire (les noms de re`gles ou les
ressources sont aussi valides).

Les alias sont imple'mente's dans le shell-script de Pips (pre'sent
dans {\tt \$UTILDIR/Pips}), au moyen de la commande {\tt sed} de la
fonction {\tt rename()}. Une ligne correspond a` un alias, et la syntaxe
est la suivante:

{\tt s/alias\_name/true\_name/;}

Lorsque l'alias\_name est une sous-chai^ne d'un autre alias, il faut
qu'il soit positionne' apre`s lui.

%% Autres regles a preciser

Chaque utilisateur peut donc rede'finir les alias, qui sont initialise's
ainsi:

% A chaque modification de la zone verbatim suivante, refaire M-x untabify
% sur la region.
\begin{verbatim}

# resources
        s/PPF/ParallelPrinted_File/; \
        s/CGF/CallGraph_File/; \
        s/PF/Printed_File/; \
        s/WPF/WP65_compute_File/; \
# rules for
    #dg
        s/rfulldg/Rice_FULL_Dependence_Graph/; \
        s/rsdg/Rice_Semantics_Dependence_Graph/; \
        s/rdg/Rice_fast_Dependence_Graph/; \
    #transformers
        s/tffull/TransFormers_intra_FULL/; \
        s/tfinterfull/TransFormers_INTER_FULL/; \
        s/tfinter/TransFormers_INTER_fast/; \
        s/tf/TransFormers_intra_fast/; \
    #preconditions
        s/pcinterfull/PreConditions_INTER_FULL/; \
        s/pcinter/PreConditions_INTER_fast/; \
        s/pc/PreConditions_intra/; \
    #callgraph_file
        s/prcg/PRint_Call_Graph/; \
    #use-def chains
        s/ach/Atomic_CHains/; \
        s/rgch/ReGion_CHains/; \
    #ICFG
        s/pricfgl/PRint_ICFG_with_Loops/; \
        s/pricfgc/PRint_ICFG_with_Control/; \
        s/pricfg/PRint_ICFG/; \
    #printed_file
        s/prct/PRint_Code_Transformers/; \
        s/prcpe/PRint_Code_Proper_Effects/; \
        s/prcce/PRint_Code_Cumulated_Effects/; \
        s/prcp/PRint_Code_Preconditions/; \
        s/prcc/PRint_Code_Complexities/; \
        s/prcr/PRint_Code_Regions/; \
        s/prc/PRint_Code/; \
    #parallelisation
	s/ricetrue/RICE_data_dependence/; \
	s/ricea/RICE_All_dependence/; \
	s/ricec/RICE_Cray/; \
#Transformations to perform:
        s/dist/DISTributer/; \
        s/priv/PRIVatizer/; \
        s/pev/Partial_EVal/; \
        s/unr/UNRoll/; \
        s/sm/Strip_Mine/; \
        s/li/Loop_Interchange/; \
        s/red/REDuctions/; \
\end{verbatim}

\end{document}
