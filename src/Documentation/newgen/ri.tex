\documentstyle[a4,psfig]{article}

% \input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\title{PIPS: Internal Representation of Fortran Code}
\author{Franc,ois Irigoin \\
        Pierre Jouvelot \\
    Ronan Keryell \\
        Re'mi Triolet\\
\\
        CRI, Ecole des Mines de Paris}

                                %\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{{#2}}}
      {
        \catcode `==\active
        \gdef\domain{\medskip\par\noindent
          \bgroup
          \catcode `_ \other
          \catcode `= \active
          \def={\em{\rm \string=}}
          \tt\em\vraidomain}
        \gdef\vraidomain#1{#1\egroup\medskip\par}
        }

% Correction de quelques erreurs. RK, 07/02/1994.

\renewcommand{\indexname}{Index}

\makeindex

\begin{document}
\maketitle
\sloppy

\section*{Introduction}

Ce document est utilise' directement et automatiquement par l'outil
de ge'nie logiciel NewGen pour ge'ne'rer les de'clarations des structures
de donne'es utilise'es dans le projet PIPS, ainsi que les routines de
base qui les manipulent. C'est pourquoi l'ordre des sections n'est pas
ne'cessairement naturel.

Apre`s une description rapide des structures de donne'es externes a` la
repre'sentation interne de Pips, nous pre'sentons successivement les
notions d'entite's, de code et d'expressions et la manie`re dont elles
sont utilise'es pour encoder un programme Fortran. Nous de'taillons
ensuite deux structures de donne'es supple'mentaires, les effets et les
{\em transformers} qui sont utilise's pour le calcul de de'pendance
interproce'dural et pour l'analyse syntaxique interproce'durale.

La manie`re dont les constructions de Fortran sont repre'sente'es est
de'crite dans une des sections du rapport EMP-CAII-E105. NewGen est
pre'sente' dans le rapport EMP-CRI-A191.

\section{External Data Structures}
\label{external}

\subsection{Vector}
\label{subsection-pvecteur}
\index{Pvecteur}

\domain{External Pvecteur}
{ Le domaine {\tt Pvecteur} est utilise' pour repre'senter les
expressions line'aires telles que {\tt 3I+2} (voir le domaine {\tt
normalized}) ou des contraintes line'aires telles que {\tt 3I + J <= 2}
ou {\tt 3I == J}. Ces contraintes sont utilise'es dans les syste`mes
line'aires (voir le domaine {\tt Psysteme}).

Un Pvecteur est une suite de mono^mes, un mono^me e'tant un couple
(coefficient,variable).  Le coefficient d'un tel couple est un entier,
positif ou ne'gatif. La variable est une entite', sauf dans le cas du
terme constant qui est repre'sente' par la variable pre'de'finie de nom
{\tt TCST}\footnote{Comme on rajoute le nom des modules devant les
noms de variables, il ne peut pas y avoir de conflict avec une
e'ventuelle variable {\tt TCST}.}.

Les expressions apparaissant dans le programme analyse' sont mises
sous cette forme quand c'est possible.

La structure de donne'es Pvecteur est importe'e de la bibliothe`que d'alge`bre
line'aire en nombres entiers du CAII.
}

\subsection{Set of Affine Constraints}
\label{subsection-psysteme}
\index{Psysteme}

\domain{External Psysteme}
{
Le domaine {\tt Psysteme} est utilise' pour repre'senter les syste`mes
d'e'quations et d'ine'quations line'aires qui apparaissent lors
de la phase d'analyse se'mantique (voir le domaine {\tt predicate}).

Les Psystemes sont aussi implicitement utilise's pour effectuer le
calcul de de'pendance.

Un Psysteme est forme' de six champs:
\begin{itemize}
  \item une liste d'e'galite's,
  \item le nombre des e'galite's,
  \item une liste d'ine'galite's,
  \item le nombre d'ine'galite's,
  \item la dimension de l'espace de re'fe'rence,
  \item une base de l'espace de re'fe'rence.
\end{itemize}

Comme le domaine Pvecteur, la structure de donne'es Psysteme est
importe'e de la bibliothe`que d'alge`bre line'aire en nombres entiers du
CAII.  }

\section{Entities: Variables, Functions, Operators, Constants, Labels...}
\label{entity}

\subsection{Entity}
\label{subsection-entity}
\index{Entity}

\domain{tabulated entity = name:string x type x storage x initial:value}
\domain{entity_int = entity->int}
{
Tout objet ayant un nom dans un programme Fortran est repre'sente' par
une \verb/entity/. Un tel objet peut e^tre un module, une variable, un
common, un ope'rateur, une constante, un label, etc. Pour chaque objet,
le sous-domaine \verb/name/ de l'entite' donne le nom de l'objet tel
qu'il apparai^t dans le texte source du programme pre'fixe' par le nom du
package dans lequel l'entite' est de'clare'e, le sous-domaine
\verb/type/ donne le type de l'entite', le sous-domaine \verb/storage/
le genre d'allocation me'moire utilise' pour l'entite', et finalement,
le sous-domaine \verb/initial/ donne la valeur initiale, si elle est
connue, de l'entite'. Le terme valeur initiale a ici un sens assez
large, puisqu'il s'agit par exemple du code pour les entite's
repre'sentant des modules.
}

\subsection{Type}
\label{subsection-type}
\index{Type}

\domain{Type = statement:unit + area + variable + functional + unknown:unit + void:unit}
{
Le domaine \verb/type/ repre'sente le type d'une entite'.  Le
sous-domaine \verb/statement/ est utilise' pour les labels
d'instruction.  Le sous-domaine \verb/area/ est utilise' pour les
commons.  Le sous-domaine \verb/variable/ est utilise' pour toutes les
variables, y compris les parame`tres formels et le re'sultat d'une
fonction.  Le sous-domaine \verb/functional/ est utilise' pour les
fonctions, pour les subroutines et pour le programme principal.  Le
sous-domaine \verb/void/ est utilise' pour le re'sultat d'une subroutine
ou d'un programme principal.
}

\subsubsection{Area Type}
\label{subsubsection-area}
\index{Area}

\domain{Area = size:int x layout:entity*}
{ Le domaine {\tt area} est utilise' pour repre'senter les aires de
stockage des variables telles que les commons et les aires statiques ou
dynamiques. Le sous-domaine {\tt size} donne la taille de l'aire
exprime'e en octets ({\em character storage unit} de la norme ANSI
X3.9-1978, \S~2.13), et le sous-domaine {\tt layout} donne la liste des
entite's stocke'es dans cette aire. L'ordre des de'clarations des
variables est respecte', ce qui permettrait de reproduire des programmes
sources fide`les a` ce qu'e'taient les programmes initiaux\footnote{Les
de'clarations sont en fait conserve'es sous forme textuelle pour
garantir une fide'lite' absolue.}.}

\subsubsection{Variable Type}
\label{subsubsection-variable}
\index{Variable}

\domain{Variable = basic x dimensions:dimension*}
{
Le domaine \verb/variable/ repre'sente le type d'une variable.  Le
sous-domaine \verb/basic/ donne le type Fortran de la variable.  Le
sous-domaine \verb/dimensions/ donne la liste des dimensions de la variable.
Un scalaire est un tableau de ze'ro dimension.

Chaque dimension est une expression, qui n'est pas ne'cessairement
constante dans le cas des tableaux formels. La constante pre'de'finie de
nom '*D*' est utilise'e pour les tableaux de taille non de'finie
(\verb/DIMENSION T(*)/).
}

\subsubsection{Basic Type}
\label{subsubsection-basic}
\index{Basic}

\domain{Basic = int:int + float:int + logical:int + overloaded:unit + complex:int + string:value}
{
Le domaine \verb/basic/ permet de repre'senter un type Fortran tel que
INTEGER ou REAL. La valeur de ce domaine donne la longueur en octets de
la zone me'moire occupe'e par une variable de ce type.
}

\subsubsection{Dimension}
\label{subsubsection-dimension}
\index{Dimension}

\domain{Dimension = lower:expression x upper:expression}
{
Le domaine \verb/dimension/ permet de repre'senter une dimension d'un
tableau, c'est-a`-dire un couple borne infe'rieure -- sous-domaine
\verb/lower/ -- borne supe'rieure -- sous-domaine \verb/upper/.
}

\subsubsection{Functional Type}
\label{subsubsection-functional}
\index{Functional}

\domain{Functional = parameters:parameter* x result:type}
{ Le domaine \verb/functional/ repre'sente le type d'un module,
c'est-a`-dire une fonction, une subroutine ou un programme principal. Le
sous-domaine \verb/parameters/ donne le type et le mode de passage de
chaque parame`tre, et le sous-domaine \verb/result/ donne le type du
re'sultat. Ce dernier type vaut \verb/void/ pour les subroutines et les
programmes principaux.

Il n'y a pas de moyens simples pour repre'senter les fonctions ou
sous-programmes a` nombre variable de parame`tres. Bien que ce soit
interdit pour les modules de'finis par le programmeur, de nombreux
intrinse`ques comme \verb+MIN0+ ou \verb+WRITE+ n'ont pas un profil
unique.  }

\subsubsection{Parameter Type and Mode}
\label{subsubsection-parameter}
\index{Parameter}

\domain{Parameter = type x mode}
{
Le domaine \verb/parameter/ repre'sente le type et le mode de passage d'un
parame`tre formel de module. 
}

\index{Mode}
\domain{Mode = value:unit + reference:unit}
{
Le domaine \verb/mode/ repre'sente le mode de passage d'un parame`tre
formel de module. Le domaine contient un objet du domaine \verb/value/
pour le mode de passage par valeur et \verb/reference/ pour le passage
par adresse.
}

\subsection{Storage}
\label{subsection-storage}
\index{Storage}

\domain{Storage = return:entity + ram + formal + rom:unit}
{
Le domaine \verb/storage/ permet de pre'ciser dans quelle zone de la
me'moire est stocke'e une entite'. Il y a plusieurs zones, qui ne
correspondent pas ne'cessairement a` la re'alite', c'est-a`-dire aux
zones de me'moire qui seraient affecte'es par un compilateur.

Le sous-domaine \verb/return/ permet de repre'senter les variables ayant
pour nom le nom d'une fonction et auxquelles on affecte la valeur que la
fonction doit retourner. L'entite' pointe'e par \verb/return/ est la
fonction concerne'e.

Le sous-domaine \verb/ram/ est reserve' aux variables ayant une adresse
en me'moire. Il permet de pre'ciser dans quelle fonction et
e'ventuellement dans quel common ces variables ont e'te' de'clare'es.

Le sous-domaine \verb/formal/ est re'serve' aux parame`tres formels des
modules.

Le sous-domaine \verb/rom/ est utilise' pour toutes les entite's dont la
valeur n'est pas modifiable, telles que les fonctions, les labels, les
ope'rateurs, etc.
}

\subsubsection{RAM Storage}
\label{subsubsection-ram}
\index{RAM}

\domain{Ram = function:entity x section:entity x offset:int x shared:entity*}
{
Le domaine \verb/ram/ permet de pre'ciser la de'claration d'une
variable. Le sous-domaine \verb/function/ indique dans quel module une
entite' est de'clare'e. Le sous-domaine \verb/section/ indique dans
quelle aire une entite' est stocke'e; il y a une aire par common
de'clare' et deux aires spe'ciales nomme'es \verb/STATIC/ et
\verb/DYNAMIC/ pour les entite's locales. Le sous-domaine \verb/offset/
donne l'adresse dans l'aire de la variable. Enfin, le sous-domaine {\tt
shared} donne la liste des entite's qui partagent statiquement un
morceau d'espace me'moire avec la variable concerne'. En Fortran, le
partage de me'moire vient des equivalences entre variables.  }

\subsubsection{Formal Parameter Storage}
\label{subsubsection-formal}
\index{Formal}

\domain{Formal = function:entity x offset:int}
{
Le domaine \verb/formal/ indique le module dans lequel un parame`tre formel
est de'clare' gra^ce au sous-domaine \verb/function/, et le rang de ce
parame`tre dans la liste des parame`tres gra^ce au sous-domaine
\verb/offset/.
Le premier parame`tre a un rang de 1 et non de 0.
}

\subsection{Entity Value}
\label{subsection-value}
\index{Value}

\domain{Value = code + symbolic + constant + intrinsic:unit + unknown:unit}
{
Le domaine \verb/value/ permet de repre'senter les
valeurs initiales des entite's. Le sous-domaine \verb/code/ est utilise'
pour les entite's modules. Le sous-domaine \verb/symbolic/ est utilise'
pour les entite's constantes symboliques. Le sous-domaine
\verb/constant/ est utilise' pour les entite's constantes. Le
sous-domaine \verb/intrinsic/ est utilise' pour toutes les entite's qui
ne de'pendent que du langage, telles que les intrinsics Fortran, les
ope'rateurs, les instructions, etc. Enfin le sous-domaine
\verb/unknown/ est utilise' pour les valeurs initiales inconnues.
}

\subsubsection{Symbolic Value}
\label{subsubsection-symbolic}
\index{Symbolic}

\domain{Symbolic = expression x constant}
{
Le domaine \verb/symbolic/ est utilise' pour repre'senter la valeur
initiale d'une entite' constante symbolique, c'est-a`-dire les PARAMETER
de Fortran ou les CONST de Pascal. Le sous-domaine \verb/expression/
permet de stocker l'expression qui a permis d'e'valuer la valeur
initiale contenue dans le sous-domaine \verb/constant/. Le sous-domaine
\verb/expression/ n'est utile qui si on cherche a` reproduire un texte
source fide`le.
}

\subsubsection{Constant Value}
\label{subsubsection-constant}
\index{Constant}

\domain{Constant = int + litteral:unit}
{
Le domaine \verb/constant/ est utilise' pour repre'senter la valeur
initiale des entite's constantes. Seules les entite's de type entier
nous inte'ressent, ce qui explique qu'une constante puisse e^tre soit un
\verb/int/ soit un \verb/litteral/ dont on ne garde pas la valeur (type unit).
}

\section{Code, Statements and Instructions}
\label{code}

\subsection{Module Code}
\label{subsection-code}
\index{Code}\index{Declarations}\index{Decls text}

\domain{Code = declarations:entity* x decls\_text:string}
{ 
Le domaine \verb/code/ est utilise'
pour stocker le corps des modules. Le sous-domaine \verb/declarations/
contient une liste d'entite's qui sont les variables locales,
parame`ters formels et commons de'clare's dans la fonction.

Le sous-domaine {\tt decls\_text} contient le texte exact de toutes les
de'clarations du module; ce texte est utilise' par de'faut par le
prettyprinter tant qu'il existe. Quand le code a e'te' fortement
transforme', le prettyprinter re'ge'ne`re des de'clarations
synthe'tiques.
}

\subsection{Callees}
\label{subsection-callees}
\index{Callees}

% Should be put somewhere else!

\domain{Callees = callees:string*}
{ Le domaine {\tt callees} sert a` porter des informations
interproce'durales, et sera enrichi dans le futur.  Le sous-domaine {\tt
callees} contient la liste des noms des sous-programmes et fonctions
directement appele's dans le code. Il contient une partie du callgraph.
}

\subsection{Statement}
\label{subsection-statement}
\index{Statement}

\domain{Statement = label:entity x number:int x ordering:int x comments:string x instruction}
{ 
Le
domaine \verb/statement/ permet de repe'rer les instructions d'un
module.  Le sous-domaine \verb/label/ contient une entite' qui de'finit
le label\footnote{Un statement dont l'instruction est un bloc n'a
jamais de label.}.

Le sous-domaine \verb/number/ contient un nume'ro permettant
de repe'rer le statement pour le debugging ou l'information de
l'utilisateur (valeur par defaut:
\verb+STATEMENT\_NUMBER\_UNDEFINED+). Ce nume'ro est de'fini par
l'utilisateur et n'est (en princpe) jamais modifie'. Apre`s de'roulage
de boucle, plusieurs \verb/statement/s peuvent avoir le me^me nume'ro.

Le sous-domaine \verb/ordering/ contient un entier caracte'ristique du
statement; il est forme' de la concate'nation du nume'ro de composante
dans le graphe de contro^le et du nume'ro de statement dans dans cette
composante; cet entier sert a` comparer l'ordre lexical des statements
et sa valeur par defaut est \verb+STATEMENT\_ORDERING\_UNDEFINED+. Il
est automatiquement recalcule' apre`s chaque transformation de
programme. Il est aussi utilise' comme nom absolu d'un \verb/statement/
quand des structures de donne'es comme les tables de hash-code sont
e'crites sur disque ou relues.

Le sous-domaine {\tt comments} contient le texte du commentaire associe'
a ce statement dans le programme initial; ce texte est utilise' par le
prettyprinter. Ce sont les commentaires qui pre'ce`dent le statement
qui s'y trouvent associe's. En l'absence de commentaires, ce champ
prend la valeur \verb/string\_undefined/.

Le sous-domaine \verb/instruction/ contient
l'instruction proprement dite.
}

\domain{Persistant_Statement_To_Statement = persistant statement -> persistant statement}
{
  Used for example in use_def_elimination() to store the eventual
  statement father of a statement. The persistance is needed to avoid
  freeing the statements when the mapping is freed.
}

\subsection{Instruction}
\label{subsection-instruction}
\index{Instruction}

\domain{Instruction = block:statement* + test + loop + goto:statement + call + unstructured}
{ 
Le domaine \verb/instruction/ permet de repre'senter les instructions
d'un module. Une instruction peut e^tre un sous-domaine \verb/block/,
c'est-a`-dire une liste de \verb/statement/, un sous-domaine \verb/test/
pour les instructions de test, un sous-domaine \verb/loop/ pour les
boucles se'quentielles, un sous-domaine \verb/goto/ pour les goto qui
contient le
\verb/statement/ vers lequel le goto se branche, un sous-domaine
\verb/call/ pour toutes les autres instructions (affectation, appel de
subroutine, entre'es-sorties, return, stop, etc) ou un sous-domaine de
\verb/unstructured/ dans le cas ou` l'on traite d'un graphe de contro^le
structure'. Toutes ces instructions 
sont repre'sente'es par des appels a` des fonctions pre'de'finies dont
nous e'tudierons la nature plus loin.
}

\subsubsection{Control Flow Graph (a.k.a. Unstructured)}
\label{subsubsection-unstructured}
\index{Unstructured}

\domain{Unstructured = control x exit:control}
{

Domain \verb/unstructured/ is used to represent unstructured parts of
the code in a structured manner which as a unique statement. The entry
node of the underlying CFG is in field \verb/control/, and the
unique exit node is in field \verb/exit/. The exit node should not be
modified by users of the unstructured\footnote{FI: I do not understand
why...}.  See Figure~\ref{figure-unstructured}.

The hierarchical structure is induced by the recursive nature of
statements.  Each control node points towards a statement which can also
contain an unstructured area of the code as well as structured
part. Unstructured parts of the code can thus be contained as much as
possible as well as be recursively decomposed.

For instance, the two DO loops in:
\begin{verbatim}
      DO 200 I = 1, N
100      CONTINUE
         DO 300 J = 1, M
            T(J) = T(J) + X
300      CONTINUE
         IF(X.GT.T(I)) GO TO 100
200   CONTINUE
\end{verbatim}
are preserved as DO loops in spite of the GO~TO statement (see
Figure~\ref{figure-hierarchical-control-flow-graph}).

\begin{figure}

\begin{center}

\unitlength 3pt

\begin{picture}(90,105)(0,0)
\put(40,70){\circle*{3}}
\put(50,70){DO 200}

\put(30,35){\circle*{3}}
\put(20,40){IF}
\put(40,45){\circle*{3}}
\put(50,45){100 CONTINUE}
\put(50,35){\circle*{3}}
\put(60,35){DO 300}

\put(50,10){\circle*{3}}
\put(60,10){T(J) = T(J) + X}

% link between structured and unstructured parts
\put(50,30){\line(0,-1){20}}
\put(40,60){\line(0,-1){15}}
\put(30,37){\line(1,3){8}}
\put(50,37){\line(-1,3){8}}

% control edges
\thicklines
\put(30,35){\vector(-1,0){15}}
\put(31,36){\vector(1,1){8}}
\put(41,44){\vector(1,-1){8}}
\put(50,35){\vector(-1,0){18}}
\thinlines

% Draw the planes
\multiput(0,0)(0,30){3}{\line(1,1){25}}
\multiput(0,0)(0,30){3}{\line(1,0){105}}
\end{picture}
\end{center}
\caption{Hierarchical Control Flow Graph}
\label{figure-hierarchical-control-flow-graph}
\end{figure}

}

\subsubsection{Conditional (a.k.a. Test)}
\label{subsubsection-test}
\index{Test}

\domain{Test = condition:expression x true:statement x false:statement}
{
Le domaine \verb/test/ permet de repre'senter toutes les instructions a` base
de contro^le. Le sous-domaine \verb/condition/ contient l'expression a`
tester, et les deux sous-domaines \verb/true/ et \verb/false/ contiennent les
instructions a` exe'cuter selon la valeur du test. 

Il faut noter que chaque instruction de contro^le de Fortran,
a` l'exception de l'instruction \verb/DO/, est
transforme'e en une combinaison se'mantiquement e'quivalente de \verb/test/s
et de \verb/goto/s.
}

\subsubsection{DO Loop, Sequential or Parallel}
\label{subsubsection-loop}
\index{Loop}

\domain{Loop = index:entity x range x body:statement x label:entity x execution x locals:entity*}
{
Le domaine \verb/loop/ permet de repre'senter les boucles du type DO Fortran
ou FOR Pascal. Le sous-domaine \verb/index/ contient l'entite' indice de
boucle, le sous-domaine \verb/range/ contient les bornes de la boucle, le
sous-domaine \verb/body/ contient le corps de la boucle, c'est-a`-dire un
\verb/statement/, le sous-domaine \verb/label/ contient le label de fin de boucle,
c'est-a`-dire une entite'. Le sous-domaine \verb/execution/ de'finit le
comportement dynamique d'une boucle. Les entite's pre'sentes dans
\verb/locals/ sont propres au corps de boucle (les effets sur elles sont
masque's quand on sort de la boucle).
}

\index{Execution}
\domain{Execution = sequential:unit + parallel:unit}
{
Le domain \verb/execution/ de'finit la se'mantique d'une boucle:
\verb/sequential/ correspond a` une boucle DO classique, \verb/parallel/
de'finit un boucle dont les instances d'ite'ration peuvent e^tre
exe'cute'es en paralle`le.
}

\label{range}
\index{Range}
\domain{Range = lower:expression x upper:expression x increment:expression}
{
Le domaine \verb/range/ permet de repre'senter les bornes des boucles DO
Fortran. Il y a trois sous-domaines \verb/lower/, \verb/upper/ et \verb/increment/ de
type \verb/expression/ qui sont respectivement la borne infe'rieure, la borne
supe'rieure et l'incre'ment.
}

\subsubsection{Function Call}
\label{subsubsection-call}
\index{Call}

\domain{Call = function:entity x arguments:expression*}
{

Le domaine \verb/call/ permet de repre'senter les commandes et les
appels de fonctions Fortran sous une forme unique pseudo-fonctionelle.
Ces pseudo-fonctions jouent un ro^le important dans notre
repre'sentation interme'diaire puisque les constantes, les ope'rateurs
comme + et *, les intrinse`ques comme {\tt MOD} ou {\tt SIN} et surtout
les commandes (i.e. instructions) Fortran, a` commencer par
l'assignation et en continuant avec {\tt READ, WRITE, RETURN, CALL}
etc..., sont repre'sente'es comme les appels de fonctions de'finies par
l'utilisateur. Le nombre d'arguments de chaque pseudo-fonction varie: 0
pour les constantes, 1 ou 2 pour les ope'rateurs, etc. Les commandes
Fortran, les ope'rateurs et les intrinse`ques sont caracte'rise's par
des pseudo-fonctions pre'de'finies. Cette convention permet de diminuer
conside'rablement la taille de la de'finition de la repre'sentation
ainsi que le volume de code ne'cessaire a` de nombreux algorithmes.

Le sous-domaine \verb/function/ est une entite' qui de'finit la fonction
appele'e. Le sous-domaine \verb/arguments/ est une liste de sous-domaines
\verb/expression/ qui repre'sente les arguments d'appel de la fonction.
}

\subsubsection{Control Flow Graph (cont.)}
\label{subsubsection-control}
\index{Control}

\domain{Control = statement x predecessors:control* x successors:control*}
\domain{Controlmap = persistant statement->control}
{ 

Domain \verb/control/ is the type of nodes used to implement the CFG
implied by an unstructured instruction (see Domain
\verb/unstructured/). Each node points towards a statement which can
represent an arbitrary large piece of structured code. GOTO statements
are eliminated and represented by arcs. Nodes are doubly linked. Each
node points towards its successors (at most 2) and towards its
predecessors. The hierarchical nature of
domain \verb/statement/ is used to hide local branches from higher and
lower level pieces of code. The whole unstructured area of the code is
seen as a unique atomic statement from above, and is entirely ignored
from under. This explains the mutual recursion between \verb/control/
and \verb/statement/ (via \verb/instruction/).

\begin{figure}
\begin{center}
\mbox{\psfig{file=unstructured.idraw,width=\hsize}}
\end{center}
\caption{Control Flow Graph}
\label{figure-unstructured}
\end{figure}

All statements but \verb/test/have only one successor. The first
successor of \verb/test/ is the successor when the test condition is
evaluated to true.  And the other way round for the second one. The exit
node (see domain \verb/unstructured/) has no successor. The entry node
as well as all other nodes may have an unlimited number of precedessors.

All nodes of a CFG can be visited in a meaningless order using the
\verb/CONTROL_MAP/ macros. Look for an example in library \verb/control/
because auxiliary data structures must be decraled and freed.

}

\domain{Persistant_Control_To_Statement = persistant statement -> persistant control}
{
  Used for example in use_def_elimination() to store the eventual control
  father of a statement in order to travel on the control graph
  associated to a statement. The persistance is needed to avoid
  freeing the control graph when the mapping is freed.
}

% \section{Repre'sentation des expressions}
\section{Expressions}
\label{expression}
\index{Expression}

\domain{Expression = syntax x normalized}
{ 
Le domaine \verb/expression/ permet de stocker les expressions.  Le
sous-domaine {\tt syntax} contient la description de l'expression telle
qu'elle apparai^t dans le texte source du programme. Le sous-domaine {\tt
normalized} contient une forme compile'e des expressions line'aires,
sous forme de Pvecteur.

Si le sous-domaine {\tt normalized} contient la valeur
{\tt normalized\_undefined}, cela signifie que la fonction de line'arisation
n'a pas e'te' appele'e pour cette expression; cela {\bf ne} signifie
{\bf pas}
que l'expression n'est pas line'aire.
}

\subsection{Abstract Tree of an Expression: Syntax}
\label{subsection-syntax}
\index{Syntax}

\domain{Syntax = reference + range + call}
{
Le domaine \verb/syntax/ permet de repre'senter les expressions telles
qu'elles apparaissent dans le texte source du programme. Un
\verb/syntax/ est soit une \verb/reference/ a` un e'le'ment de tableau
(on rappelle que les scalaires sont des tableaux a` 0 dimension) , soit
un \verb/call/ a` une fonction (les ope'rateurs sont repre'sente's par
des fonctions pre'-de'finies, y compris l'assignation; c'est pourquoi le
domaine {\tt call} est de'fini dans la section {\em Instructions}), soit
un \verb/range/, dans le cas des expressions bornes de boucles (le domaine
{\tt range} est pre'sente' au niveau des boucles, aussi dans la section
{\em Instructions}).
}

\subsubsection{Reference}
\label{subsubsection-reference}
\index{reference}

\domain{Reference = variable:entity x indices:expression*}
{
Le domaine \verb/reference/ est utilise' pour repre'senter une
re'fe'rence a` un e'le'ment de tableau\footnote{Les variables scalaires
e'tant repre'sente'es par des tableaux de dimension 0, les re'fe'rences
a des scalaires sont aussi prises en compte. Elles contiennent une liste
vide d'expressions d'indices.}.  Le sous-domaine \verb/variable/
contient une entite' de'finissant la variable re'fe'rence'e. Le
sous-domaine \verb/indices/ contient une liste {\tt expression}s qui sont les
indices de la re'fe'rence.
}

\subsubsection{Range}

See Section~\ref{range}.

\subsubsection{Function Call}

All operators, including assignment, are repreented as function calls
with side effect. See Section~\ref{subsubsection-call}.

\subsection{Affine Representation of an Expression}
\label{subsection-normalized}
\index{Normalized}

\domain{Normalized = linear:Pvecteur + complex:unit}
{ Le domaine {\tt normalized} permet de savoir si une expression est une
expression line'aire construite sur les variables simples entie`res
(sous-domaine {\tt linear}) ou non (sous-domaine {\tt complex}).

Le sous-domaine {\tt complex} est utilise' si l'expression n'est pas
line'aire (ex: {\tt I*J+4}) ou si elle est line'aire mais contient autre
chose que des re'fe'rences a` des scalaires entiers (ex: {\tt T(I-1) +
T(I) + T(I+1)}).

La forme normalise'e n'existe pas si l'expression n'a pas encore e'te'
examine'e. }

% \section{Effets des instructions}
\section{Memory Effects of Statements}
\label{effects}

\subsection{Effects}
\label{subsection-effects}
\index{Effects}

\domain{Effects =  effects:effect*}
{}

\subsection{Effect}
\label{subsection-effect}
\index{Effect}\index{Region}

\domain{Effect =  persistant reference x action x approximation x context:transformer}
{
Le domaine \verb/effect/ est utilise' pour repre'senter les effets d'un
statement sur les variables du module. Les effets des instructions sont
le point de de'part du calcul des Def-Use Chains, des de'pendances, des
Summary Data Flow Information, et des re'gions.

Le sous-domaine {\tt reference} indique sur quelle variable, scalaire ou
tableau, a lieu un effet, le sous-domaine {\tt action} pre'cise si la
re'fe'rence est lue ou e'crite, et le sous-domaine {\tt approximation}
permet de savoir si la re'fe'rence est lue ou e'crite a` coup su^r ou
non.

Le sous-domaine {\tt reference} est de pre'ciser qu'un effet n'a lieu
que sur un sous-tableau en utilisant un {\tt range} comme expression
d'indice. Ceci est utilise' lors de la traduction des effets cumule's
d'un proce'dure en les effets propres d'un call site.

Le sous-domaine {\tt context} n'est utilise' que pour les effets
cumule's. Le contexte indique quelles relations line'aires entre les
variables du programme sont ve'rifie'es au moment ou` l'instruction est
exe'cute'e.  Il permet de repre'senter les effets des instructions par
des re'gions (telles que de'finies par Re'mi Triolet).
}

\subsection{Nature of an Effect}
\label{subsection-action}
\index{Action}

\domain{Action = read:unit + write:unit}
{
Deux types d'effets sont utilise's dans les conditions de Bernstein
et dans les conditions propres a` chaque transformation de programme:
la lecture d'une variable et son e'criture.
}

\subsection{Approximation of an Effect}
\label{subsection-approximation}
\index{Approximation}

\domain{Approximation = may:unit + must:unit}
{
La pre'sence de tests et boucles ne permet pas de de'terminer en ge'ne'ral
si une variable est effectivement lue ou e'crite lors de l'exe'cution
d'un {\tt statement}. Il se peut me^me que certaines exe'cutions
y acce`dent et que d'autres n'y fassent pas re'fe'rence. Les effets
calcule's sont alors de type {\tt may}.

Dans quelques cas particuliers, comme une affectation simple {\tt I = 2},
l'effet est certain ({\em must}). Il peut alors e^tre utilise' dans
le calcul des {\em use-def chains} pour effectuer un {\em kill} sur les
variables scalaires. Un effet {\em must} sur un tableau ne signifie pas
que tout le tableau est lu ou e'crit mais qu'au moins un de ses
e'le'ments l'est.
}

\section{Analyse se'mantique}
\label{semantics}

\subsection{Transformer}
\label{subsection-transformer}
\index{Transformer}

\domain{Transformer = arguments:entity* x relation:predicate}
{
Le domaine {\tt transformer} de'finit une relation entre deux e'tats
me'moire. Cette relation
porte sur les valeurs des variables scalaires entie`res d'un module ou
des variables globales au programme.

Les variables qui apparaissent dans la liste des arguments sont celles
qui ont e'te' modifie'es entre les deux e'tats. Deux valeurs
sont donc associe'es a` chacune d'entre elles: la pre- et la
post-valeur.  Les post-valeurs sont porte'es par les entite's
elles-me^mes. Les pre'-valeurs sont porte'es par des entite's
spe'ciales. Les variables scalaires entie`res qui ne sont pas modifie'es
et qui n'apparaissent donc pas dans la liste des arguments n'ont qu'une
seule valeur, porte'e par l'entite' correspondant a` la variable.

La relation est de'finie par des e'galite's et des ine'galite's
line'aires entre valeurs.

Deux types de transformers sont utilise's. Le premier est propre a` un
{\tt statement} et donne une abstraction de son effet sur les variables
entie`res. Les variables qui apparaissent dans la liste des arguments
sont celles qui sont affecte'es lors de son exe'cution.  Le second,
aussi associe' a` un {\tt statement}, donne une relation entre l'e'tat
initial d'un module et l'e'tat pre'ce'dent l'exe'cution de ce {\tt statement}.

Les transformers ne sont de'finis qu'apre`s une phase d'analyse se'mantique.
}

\subsection{Predicate}
\label{subsection-predicate}
\index{Predicate}\index{Precondition}\index{Transformer}

\domain{Predicate = system:Psysteme}
{
Le domaine {\tt predicate} de'finit une relation entre valeurs de
variables scalaires entie`res. Son interpre'tation est fonction de
son utilisation. Il peut s'agir soit d'un pre'dicat valable en
un point du programme (i.e. un invariant), soit d'un pre'dicat
valable entre deux points du programme. Il s'agit alors d'une
abstraction d'une commande, c'est-a`-dire d'un {\tt transformer}.
}

\newpage

\section*{Annexe: re'capitulatif ri.newgen}

\begin{verbatim}
--         --------------------------------------------------------
--         --------------------------------------------------------
--
--                                  WARNING
--
--                THIS FILE HAS BEEN AUTOMATICALLY GENERATED
--
--                             DO NOT MODIFY IT
--
--         --------------------------------------------------------
--         --------------------------------------------------------

-- Imported domains
-- ----------------

-- External domains
-- ----------------
external Psysteme ;
external Pvecteur ;

-- Domains
-- -------
action = read:unit + write:unit ;
approximation = may:unit + must:unit ;
area = size:int x layout:entity* ;
basic = int:int + float:int + logical:int + overloaded:unit + complex:int + string:value ;
call = function:entity x arguments:expression* ;
callees = callees:string* ;
code = declarations:entity* x decls_text:string ;
constant = int + litteral:unit ;
control = statement x predecessors:control* x successors:control* ;
dimension = lower:expression x upper:expression ;
effect =  persistant reference x action x approximation x context:transformer ;
effects =  effects:effect* ;
execution = sequential:unit + parallel:unit ;
expression = syntax x normalized ;
formal = function:entity x offset:int ;
functional = parameters:parameter* x result:type ;
instruction = block:statement* + test + loop + goto:statement + call + unstructured ;
loop = index:entity x range x body:statement x label:entity x execution x locals:entity* ;
mode = value:unit + reference:unit ;
normalized = linear:Pvecteur + complex:unit ;
parameter = type x mode ;
predicate = system:Psysteme ;
ram = function:entity x section:entity x offset:int x shared:entity* ;
range = lower:expression x upper:expression x increment:expression ;
reference = variable:entity x indices:expression* ;
statement = label:entity x number:int x ordering:int x comments:string x instruction ;
storage = return:entity + ram + formal + rom:unit ;
symbolic = expression x constant ;
syntax = reference + range + call ;
tabulated entity = name:string x type x storage x initial:value ;
test = condition:expression x true:statement x false:statement ;
transformer = arguments:entity* x relation:predicate ;
type = statement:unit + area + variable + functional + unknown:unit + void:unit ;
unstructured = control x exit:control ;
value = code + symbolic + constant + intrinsic:unit + unknown:unit ;
variable = basic x dimensions:dimension* ;
\end{verbatim}

\newpage

% Cross-references for points and keywords

\input{ri.ind}

\end{document}
\end
