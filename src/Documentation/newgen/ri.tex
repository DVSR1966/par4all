\documentstyle[a4,psfig,html,verbatim]{article}

% \input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\title{PIPS: Internal Representation of Fortran Code}
\author{Franc,ois Irigoin \\
        Pierre Jouvelot \\
    Ronan Keryell \\
        Re'mi Triolet\\
\\
        CRI, Ecole des Mines de Paris}

                                %\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{{#2}}}
      {
        \catcode `==\active
        \gdef\domain{\medskip\par\noindent
          \bgroup
          \catcode `_ \other
          \catcode `= \active
          \def={\em{\rm \string=}}
          \tt\em\vraidomain}
        \gdef\vraidomain#1{#1\egroup\medskip\par}
        }

% Correction de quelques erreurs. RK, 07/02/1994.

\renewcommand{\indexname}{Index}

\makeindex

\begin{document}
\maketitle
\sloppy

\section*{Introduction}

This document contains the high-level description of data structures
used in PIPS as internal representations of programs. These data
structures are declared using the NewGen Data Definition Language, which
insulates them from a particular programming language. They currently
are translated into C or Common Lisp declarations and basic run-time
support routines, such as \verb+make+, \verb+free+,... A basic
understanding of Newgen declarations is assumed throughout this
document, but the notation is close enough to standard programming
language to be interpreted by newcommers. For more information about
NewGen see \cite{}\cite{}.

This document is part of PIPS documentation and is located in
\verb+$PIPS_DOCDIR/Newgen/ri.f.tex+ (\verb+ri+ stands for {\em
repre'sentation interne} in French). It is used to generate a PIPS
include file located in \verb+$PIPS_INCLUDEDIR/ri.h+. The functions
available to manipulate these data structures are grouped in
\verb+$PIPS_DEVEDIR/Lib/ri-util+. These functions are grouped in files
according to the {\em main} type in their signatures. The partial order
between types is described in ???.

\iffalse
Ce document est utilise' directement et automatiquement par l'outil
de ge'nie logiciel NewGen pour ge'ne'rer les de'clarations des structures
de donne'es utilise'es dans le projet PIPS, ainsi que les routines de
base qui les manipulent. C'est pourquoi l'ordre des sections n'est pas
ne'cessairement naturel.
\fi

Some external C data structures, used by the PIPS internal
representation, are described in Section~\ref{external}. They key data
structures \verb+entity+ (variables and functions), \verb+code+
(instructions) and \verb+expression+ are introduced in
Section~\ref{entity}, \ref{code} and \ref{expression}. The binding of
Fortran to these data structures is explained. Two additional data
structures, \verb+effect+ and \verb+transformer+, used for
interprocedural analyses but not by the internal representation, are
described in Section~\ref{effects} and in
Section~\ref{semantics}. Effects are used to represent variables read or
written by expression, statement and procedure. The \verb+transformer+
data structure is used to abstract the store transformations performed
by statement and procedure, as well as preconditions. These two domains
were part of PIPS initial main thrust, interprocedural parallelization
and analyses. 

\iffalse
Apre`s une description rapide des structures de donne'es externes a` la
repre'sentation interne de PIPS, nous pre'sentons successivement les
notions d'entite's, de code et d'expressions et la manie`re dont elles
sont utilise'es pour encoder un programme Fortran. Nous de'taillons
ensuite deux structures de donne'es supple'mentaires, les effets et les
{\em transformers} qui sont utilise's pour le calcul de de'pendance
interproce'dural et pour l'analyse syntaxique interproce'durale.
\fi

The binding of Fortran to the PIPS internal representation is covered in
greater details in Technical Report EMP-CAII-E105 (in French). The data
structure management tool NewGen is introduced in TR EMP-CRI-A191.

\iffalse
La manie`re dont les constructions de Fortran sont repre'sente'es est
de'crite dans une des sections du rapport EMP-CAII-E105. NewGen est
pre'sente' dans le rapport EMP-CRI-A191.
\fi

\section{External Data Structures}
\label{external}

Two external data types appear in PIPS internal representation:
\verb/Pvecteur/ and \verb/Psysteme/. Other types of C3 Linear Algebra
Library also appear in PIPS code: \verb/Pcontrainte/, which is a
component of \verb/Psysteme/, \verb/Ppolyedre/ for polyhedra, \verb/Psg/
for generating systems, \verb/Pmatrix/ for matrices, and \verb
/Ppolynome/, which is used for expressing program complexity (see
\htmladdnormallink{Complexity
Analysis}{http://www.cri.ensmp.fr/pips/pipsmake-rc.html}).

\subsection{Vector}
\label{subsection-pvecteur}
\index{Pvecteur}

\domain{External Pvecteur}
{}

Type {\tt Pvecteur} is used to represent affine expressions such as {\tt
3I+2} (see also type {\tt normalized} in Section~\ref{expression}) or
affine constraints such as {\tt 3I + J <= 2} or {\tt 3I == J}. The
representation is sparse and a special dimension, called {\tt
TCST}, is used for numerical constants. The constraints are used to
build systems of equations and inequalities. Such systems are of type
{\tt Psysteme}.

\iffalse
Le domaine {\tt Pvecteur} est utilise' pour repre'senter les
expressions line'aires telles que {\tt 3I+2} (voir le domaine {\tt
normalized}) ou des contraintes line'aires telles que {\tt 3I + J <= 2}
ou {\tt 3I == J}. Ces contraintes sont utilise'es dans les syste`mes
line'aires (voir le domaine {\tt Psysteme}).
\fi

An object of type {\tt Pvecteur} is a list of pairs $(c,v)$ where $c$ is
a numerical coefficient and $v$ is a variable. The coefficient is an
integer, strictly greater or lesser than zero, since zero components are
not part of a sparse representation. For objects of type {\tt Pvecteur}
used in PIPS, the variable must be either an {\tt entity} (see
Section~\ref{entity}) or a special predefined variable {\tt TCST}. Since
module names are used to prefix names of regular variables, no name
conflict with a program variable called {\tt TCST} can occur.

\iffalse
Un Pvecteur est une suite de mono^mes, un mono^me e'tant un couple
(coefficient,variable).  Le coefficient d'un tel couple est un entier,
positif ou ne'gatif. La variable est une entite', sauf dans le cas du
terme constant qui est repre'sente' par la variable pre'de'finie de nom
{\tt TCST}\footnote{Comme on rajoute le nom des modules devant les
noms de variables, il ne peut pas y avoir de conflict avec une
e'ventuelle variable {\tt TCST}.}.
\fi

Expressions in programs are stored as affine integer expressions,
wherever possible. This affine storage does not preclude the standard
storage and simply is a second representation. The consistency between
the two representations is hard to maintain, especially during program
transformations.

\iffalse
Les expressions apparaissant dans le programme analyse' sont mises
sous cette forme quand c'est possible.
\fi

The type {\tt Pvecteur} is imported from our Integer Linear Algebra
Library, also called C3 library because its development was funded by
the CNRS C3 program. See~??? for more details about this library and its
content.

\iffalse
La structure de donne'es Pvecteur est importe'e de la bibliothe`que d'alge`bre
line'aire en nombres entiers du CRI.
\fi

\subsection{Set of Affine Constraints}
\label{subsection-psysteme}
\index{Psysteme}

\domain{External Psysteme}
{}

Type {\tt Psystem} is used to store systems of affine equalities and
inequalities. They are used in many areas of PIPS such as semantics
analysis, region analysis, dependence testing, code generation,... They
appear here for the semantics analysis and are used by the {\tt
predicate} type (see Section~\ref{semantics}).

\iffalse
Le domaine {\tt Psysteme} est utilise' pour repre'senter les syste`mes
d'e'quations et d'ine'quations line'aires qui apparaissent lors
de la phase d'analyse se'mantique (voir le domaine {\tt predicate}).

Les Psystemes sont aussi implicitement utilise's pour effectuer le
calcul de de'pendance.
\fi

Objects of type {\tt Psysteme} contain six fields:

\begin{itemize}
  \item a list of equalities,
  \item the number of equalities,
  \item a list of inequalities,
  \item the number of inequalities,
  \item the dimension of the vector space,
  \item a basis of the vector space.
\end{itemize}

Redundant information is stored to accelerate frequent tests and
consistency must be insured carefully.

\iffalse
Un Psysteme est forme' de six champs:
\begin{itemize}
  \item une liste d'e'galite's,
  \item le nombre des e'galite's,
  \item une liste d'ine'galite's,
  \item le nombre d'ine'galite's,
  \item la dimension de l'espace de re'fe'rence,
  \item une base de l'espace de re'fe'rence.
\end{itemize}
\fi

Like the {\tt Pvecteur} type, data structure {\tt Psysteme} is imported
from our Integer Linear Algebra Library. This library contains an
extensive set of functions on Psystems. See ??? for more details.

\iffalse
Comme le domaine Pvecteur, la structure de donne'es Psysteme est
importe'e de la bibliothe`que d'alge`bre line'aire en nombres entiers du
CRI.
\fi

\section{Entities: Variables, Functions, Operators, Constants, Labels...}
\label{entity}

Data structure \verb/entity/ is a key PIPS data structure. Entities are
stored in a unique\footnote{Retrospectively, choosing a unique symbol
table was a mistake because it does not scale well for medium or large
size programs. However, having only one symbol table provides a uniform
access to information about entities, whether they are global, local or
meta variables.} hash table, the global symbol table. They can be
accessed by name.

\subsection{Entity}
\label{subsection-entity}
\index{Entity}

\domain{tabulated entity = name:string x type x storage x initial:value}

Any named object in a Fortran program is represented by an object of
type {\tt entity}. Such object could be a module (function or subroutine
or program), a variable, a common, an operator, an intrinsic, a
constant, a label,... Field {\tt name} contains the name of the object,
more or less as it appears in the source code, concatenated to a prefix
string and a special one-character separator, {\tt
MODULE_SEP_STRING}. The prefix string is the name of the package
defining the scope of the object. The package name may be a module name,
the reserved name {\tt TOP-LEVEL} for global objects, or some other
reserved names for objects specific to some analysis,
e.g. \verb+*SEMANTICS*+ for value names used in the semantics
analysis. Note the use of star, \verb+*+, to avoid name collision with
user defined name.

To sum up, an entity name is unique and known internally as a {\em
global} name. It is made of a {\em local} name and a {\em module} name.

Several other tricks are used to store information in names. To spot
main modules which cannot be distinguished from subroutines by the
typing information, their local names are prefixed by a constant
character, {\tt MAIN\_PREFIX}. Local names of labels also are prefixed
by one character, {\tt LABEL_PREFIX}.

As expected, field {\tt type} specifies the type of the object (see
Section~\ref{subsection-type}), field {\tt storage} defines the memory
allocation class (see Section~\ref{subsection-storage}) for the object
(e.g. dynamic, static,...).

The last field, {\tt initial}, contains the initial {\tt value} of the
object, it is known. A value can be anything that makes sense. For
instance, the value of a module is its {\tt code}.

\iffalse
Tout objet ayant un nom dans un programme Fortran est repre'sente' par
une \verb/entity/. Un tel objet peut e^tre un module, une variable, un
common, un ope'rateur, une constante, un label, etc. Pour chaque objet,
le sous-domaine \verb/name/ de l'entite' donne le nom de l'objet tel
qu'il apparai^t dans le texte source du programme pre'fixe' par le nom du
package dans lequel l'entite' est de'clare'e, le sous-domaine
\verb/type/ donne le type de l'entite', le sous-domaine \verb/storage/
le genre d'allocation me'moire utilise' pour l'entite', et finalement,
le sous-domaine \verb/initial/ donne la valeur initiale, si elle est
connue, de l'entite'. Le terme valeur initiale a ici un sens assez
large, puisqu'il s'agit par exemple du code pour les entite's
repre'sentant des modules.
\fi

\domain{entity_int = entity->int}

This domain is used to map entities towards integer. Any interpretation
of this integer is possible. It could be the value of a scalar integer
variable, the offset of a variable in a common, the lengths of commons,
etc...

\subsection{Type}
\label{subsection-type}
\index{Type}

\domain{Type = statement:unit + area + variable + functional + unknown:unit + void:unit}

Obviously, type {\tt type} is used to represent the type of an
entity. This type is defined as union to cover the needs of different
kinds of entities. Member {\tt statement} is used for statement
labels\index{label}, since a label points towards a statement. Member
{\tt area} is used for commons\index{common}. Two additional areas are
defined as implicit common, the static and the dynamic areas associated
to a module. Their specific names are defined in {\tt ri-util.h}.

Member {\tt variable} is used for all variables and symbolic
constants. It also is used for formal parameters and for results of
functions. Member {\tt functional} is used for modules which are
functions, subroutines and main programs. Member {\tt void} is used to
declare the functional types of subroutines and programs.

\iffalse
Le domaine \verb/type/ repre'sente le type d'une entite'.  Le
sous-domaine \verb/statement/ est utilise' pour les labels
d'instruction.  Le sous-domaine \verb/area/ est utilise' pour les
commons et pour les deux zones statique et dynamique associe'e a` chaque
module.  Le sous-domaine \verb/variable/ est utilise' pour toutes les
variables, y compris les parame`tres formels et le re'sultat d'une
fonction.  Le sous-domaine \verb/functional/ est utilise' pour les
fonctions, pour les subroutines et pour le programme principal.  Le
sous-domaine \verb/void/ est utilise' pour le re'sultat d'une subroutine
ou d'un programme principal.
\fi

\subsubsection{Area Type}
\label{subsubsection-area}
\index{Area}

\domain{Area = size:int x layout:entity*}

Type {\tt area} is used to represent storage sections for variables such
as commons or static or dynamic area. Areas are {\em global} objects in
the current implementation. The package name used in the corresponding
entity name must be \verb/TOP-LEVEL/, but this is not explictly
enforced. Dynamic commons defined by the Fortran standard are not
implemented, as is the case with most Fortran~77 compiler. Dynamic
commons cannot be statically identified because a dynamic binding is
used.

\iffalse
Le domaine {\tt area} est utilise' pour repre'senter les aires de
stockage des variables telles que les commons et les aires statiques ou
dynamiques. Ces aires sont des objets globaux et leur package de
rattachement est donc \verb/TOP-LEVEL/.
\fi

Field {\tt size} is the amount of memory space expressed in bytes, or
according to the Fortran standard in {\em character storage unit}
(X3.9-1978, \S~2.13), which is required to allocate the area in
memory. This space is the largest space encountered in all modules of a
program. At some stages, PIPS used to enforce a unique size for all
declarations of a common, but this is not true in the current version.

\iffalse
Le sous-domaine {\tt size} donne la taille de l'aire
exprime'e en octets ({\em character storage unit} de la norme ANSI
X3.9-1978, \S~2.13). Cette taille est la taille maximum rencontre'e
parmi les modules d'un programme. 
\fi

Field {\tt layout} is the list of variables declared allocated in the
area. These variables may have been declared in different modules, where
the common itself is declared. Their names are non-ambiguous because
PIPS entity names include a package name as prefix. Their offsets in the
common are stored in Type {\tt storage} (see
Section~\ref{subsubsection-ram}).

\iffalse
Le sous-domaine {\tt layout} donne la
liste des entite's stocke'es dans cette aire. Il s'agit des variables
de'clare'es dans ce common dans n'importe quel module.
\fi

As long as no program transformation has been applied, the textual ordre
for declarations is preserved in the layout list. This can be used to
regenerate declarations close to the programmer declarations. To provide
the best possible user-friendliness, programmer declarations are in fact
stored as a huge string which is used by prettyprinter as long as it is
consistent with the code.

\iffalse
L'ordre des de'clarations des variables est respecte', ce qui
permettrait de reproduire des programmes sources fide`les a` ce
qu'e'taient les programmes initiaux\footnote{Les de'clarations sont en
fait conserve'es sous forme textuelle pour garantir une fide'lite'
absolue.}.
\fi

\subsubsection{Variable Type}
\label{subsubsection-variable}
\index{Variable}

\domain{Variable = basic x dimensions:dimension*}{}

Type {\tt variable} represents the type of usual non-functional
variables. Field {\tt basic} is the underlying scalar type, e.g. {\tt
REAL*8} or {\tt INTEGER*4}. Field {\tt dimensions} is a list of lower
and upper bound pairs. Scalar variables are of dimension 0 and have an
empty dimension list.

\iffalse
Le domaine \verb/variable/ repre'sente le type d'une variable.  Le
sous-domaine \verb/basic/ donne le type Fortran de la variable.  Le
sous-domaine \verb/dimensions/ donne la liste des dimensions de la variable.
Un scalaire est un tableau de ze'ro dimension.
\fi

Each dimension is an expression, which is not always numerically
expressed or known. Constant parameter can be used to build symbolic
constant expressions. Formal parameters can be used to specify the
dimensions of other formal parameters. A special predefined constant
entity is used for arrays with no defined dimension which often are
declared in libraries such as (\verb/DIMENSION T(*)/). Its name is
'*D*'\footnote{In {\tt ri-util}, the unbounded dimension name is {\tt
UNBOUNDED-DIMENSION}.}.

\iffalse
Chaque dimension est une expression, qui n'est pas ne'cessairement
constante dans le cas des tableaux formels. La constante pre'de'finie de
nom '*D*' est utilise'e pour les tableaux de taille non de'finie
(\verb/DIMENSION T(*)/).
\fi

\subsubsection{Basic Type}
\label{subsubsection-basic}
\index{Basic}

\domain{Basic = int:int + float:int + logical:int + overloaded:unit + complex:int + string:value}{}

Type {\tt basic} is used to store basic type information such has {\tt
REAL} or {\tt INTEGER}. Each member includes a precision information,
namely the number of bytes required to store one scalar object of this
type. The precision information is numerically known for all basic types
but for {\tt string}.

\iffalse
Le domaine \verb/basic/ permet de repre'senter un type Fortran tel que
INTEGER ou REAL. La valeur de ce domaine donne la longueur en octets de
la zone me'moire occupe'e par une variable de ce type.
\fi

Note that no {\em default} type is provided. Untyped object are given
the current default type when they are first encountered. They only can
be typed explictly if they still have their default type when the type
declaration is encountered. PIPS parser is implemented in such a way
that {\tt IMPLICIT} statements should appear as early as possible in a
module declarations.

\subsubsection{Dimension}
\label{subsubsection-dimension}
\index{Dimension}

\domain{Dimension = lower:expression x upper:expression}{}

Type {\tt dimension} is used to represent intervals, with a lower and
an upper bounds. These bounds may not be numerically known at compile
time when they are used to define formal arrays.

\iffalse
Le domaine \verb/dimension/ permet de repre'senter une dimension d'un
tableau, c'est-a`-dire un couple borne infe'rieure -- sous-domaine
\verb/lower/ -- borne supe'rieure -- sous-domaine \verb/upper/.
\fi

\subsubsection{Functional Type}
\label{subsubsection-functional}
\index{Functional}

\domain{Functional = parameters:parameter* x result:type}{}

Type {\tt functional} is used for objects representing the explicit
syntactic type of a module, function, subroutine or main
program. Effects on global variables are not taken into account. Field
{\tt parameters} contains the type of each formal parameter, and the
in/out information. Field {\ttt result} contains the result type. Type
{\tt void} is used for subroutines and main programs.

\iffalse
Le domaine \verb/functional/ repre'sente le type d'un module,
c'est-a`-dire une fonction, une subroutine ou un programme principal. Le
sous-domaine \verb/parameters/ donne le type et le mode de passage de
chaque parame`tre, et le sous-domaine \verb/result/ donne le type du
re'sultat. Ce dernier type vaut \verb/void/ pour les subroutines et les
programmes principaux.
\fi

There is no provision to represent functions or subroutines with varying
number of formal parameters. This facility is not supported by Fortran
for programmer-defined modules, but it is used for intrinsics such as
\verb+MIN0+ which expects a {\em list} of integer parameters, and for
Fortran primitives\footnote{Fortran primitives are encoded like
intrinsics and called {\em intrinsics} in PIPS.} such as {\tt WRITE}
which is highly polymorphic.

\iffalse
Il n'y a pas de moyens simples pour repre'senter les fonctions ou
sous-programmes a` nombre variable de parame`tres. Bien que ce soit
interdit pour les modules de'finis par le programmeur, de nombreux
intrinse`ques comme \verb+MIN0+ ou \verb+WRITE+ n'ont pas un profil
unique.
\fi

\subsubsection{Parameter Type and Mode}
\label{subsubsection-parameter}
\index{Parameter}

\domain{Parameter = type x mode}{}

Objects of type {\tt parameter} represents type and inout information
for formal parameters.

\iffalse
Le domaine \verb/parameter/ repre'sente le type et le mode de passage d'un
parame`tre formel de module. 
fi

\index{Mode}
\domain{Mode = value:unit + reference:unit}{}

Type {\tt mode} is used to carry inout information for formal
parameters. Member {\tt value} is used for calling by value. Member {\tt
reference} is used for calling by reference. Fortran uses calls by reference.

\iffalse
Le domaine \verb/mode/ repre'sente le mode de passage d'un parame`tre
formel de module. Le domaine contient un objet du domaine \verb/value/
pour le mode de passage par valeur et \verb/reference/ pour le passage
par adresse.
\fi

\subsection{Storage}
\label{subsection-storage}
\index{Storage}

\domain{Storage = return:entity + ram + formal + rom:unit}
{
Le domaine \verb/storage/ permet de pre'ciser dans quelle zone de la
me'moire est stocke'e une entite'. Il y a plusieurs zones, qui ne
correspondent pas ne'cessairement a` la re'alite', c'est-a`-dire aux
zones de me'moire qui seraient affecte'es par un compilateur.

Le sous-domaine \verb/return/ permet de repre'senter les variables ayant
pour nom le nom d'une fonction et auxquelles on affecte la valeur que la
fonction doit retourner. L'entite' pointe'e par \verb/return/ est la
fonction concerne'e.

Le sous-domaine \verb/ram/ est reserve' aux variables ayant une adresse
en me'moire. Il permet de pre'ciser dans quelle fonction et
e'ventuellement dans quel common ces variables ont e'te' de'clare'es.

Le sous-domaine \verb/formal/ est re'serve' aux parame`tres formels des
modules.

Le sous-domaine \verb/rom/ est utilise' pour toutes les entite's dont la
valeur n'est pas modifiable, telles que les fonctions, les labels, les
ope'rateurs, etc.
}

\subsubsection{RAM Storage}
\label{subsubsection-ram}
\index{RAM}

\domain{Ram = function:entity x section:entity x offset:int x shared:entity*}
{
Le domaine \verb/ram/ permet de pre'ciser la de'claration d'une
variable. Le sous-domaine \verb/function/ indique dans quel module une
entite' est de'clare'e. Le sous-domaine \verb/section/ indique dans
quelle aire une entite' est stocke'e; il y a une aire par common
de'clare' et deux aires spe'ciales nomme'es \verb/STATIC/ et
\verb/DYNAMIC/ pour les entite's locales. Le sous-domaine \verb/offset/
donne l'adresse dans l'aire de la variable. Enfin, le sous-domaine {\tt
shared} donne la liste des entite's qui partagent statiquement un
morceau d'espace me'moire avec la variable concerne'. En Fortran, le
partage de me'moire vient des equivalences entre variables.  }

\subsubsection{Formal Parameter Storage}
\label{subsubsection-formal}
\index{Formal}

\domain{Formal = function:entity x offset:int}
{
Le domaine \verb/formal/ indique le module dans lequel un parame`tre formel
est de'clare' gra^ce au sous-domaine \verb/function/, et le rang de ce
parame`tre dans la liste des parame`tres gra^ce au sous-domaine
\verb/offset/.
Le premier parame`tre a un rang de 1 et non de 0.
}

\subsection{Entity Value}
\label{subsection-value}
\index{Value}

\domain{Value = code + symbolic + constant + intrinsic:unit + unknown:unit}
{
Le domaine \verb/value/ permet de repre'senter les
valeurs initiales des entite's. Le sous-domaine \verb/code/ est utilise'
pour les entite's modules. Le sous-domaine \verb/symbolic/ est utilise'
pour les entite's constantes symboliques. Le sous-domaine
\verb/constant/ est utilise' pour les entite's constantes. Le
sous-domaine \verb/intrinsic/ est utilise' pour toutes les entite's qui
ne de'pendent que du langage, telles que les intrinsics Fortran, les
ope'rateurs, les instructions, etc. Enfin le sous-domaine
\verb/unknown/ est utilise' pour les valeurs initiales inconnues.

Additional value kinds would be necessary to encode the initial value of
an area, if the overloading of the \verb+unknown+ kind becomes a
problem. Pierre Jouvelot suggested to give \verb+COMMON+ themselves as
initial value since a common represented an address.
}

\subsubsection{Symbolic Value}
\label{subsubsection-symbolic}
\index{Symbolic}

\domain{Symbolic = expression x constant}
{
Le domaine \verb/symbolic/ est utilise' pour repre'senter la valeur
initiale d'une entite' constante symbolique, c'est-a`-dire les PARAMETER
de Fortran ou les CONST de Pascal. Le sous-domaine \verb/expression/
permet de stocker l'expression qui a permis d'e'valuer la valeur
initiale contenue dans le sous-domaine \verb/constant/. Le sous-domaine
\verb/expression/ n'est utile qui si on cherche a` reproduire un texte
source fide`le.
}

\subsubsection{Constant Value}
\label{subsubsection-constant}
\index{Constant}

\domain{Constant = int + litteral:unit}
{
Le domaine \verb/constant/ est utilise' pour repre'senter la valeur
initiale des entite's constantes. Seules les entite's de type entier
nous inte'ressent, ce qui explique qu'une constante puisse e^tre soit un
\verb/int/ soit un \verb/litteral/ dont on ne garde pas la valeur (type unit).
}

\section{Code, Statements and Instructions}
\label{code}

\subsection{Module Code}
\label{subsection-code}
\index{Code}\index{Declarations}\index{Decls text}

\domain{Code = declarations:entity* x decls\_text:string}
{ 
Le domaine \verb/code/ est utilise'
pour stocker le corps des modules. Le sous-domaine \verb/declarations/
contient une liste d'entite's qui sont les variables locales,
parame`ters formels et commons de'clare's dans la fonction.

Le sous-domaine {\tt decls\_text} contient le texte exact de toutes les
de'clarations du module; ce texte est utilise' par de'faut par le
prettyprinter tant qu'il existe. Quand le code a e'te' fortement
transforme', le prettyprinter re'ge'ne`re des de'clarations
synthe'tiques.
}

\subsection{Callees}
\label{subsection-callees}
\index{Callees}

% Should be put somewhere else!

\domain{Callees = callees:string*}
{ Le domaine {\tt callees} sert a` porter des informations
interproce'durales, et sera enrichi dans le futur.  Le sous-domaine {\tt
callees} contient la liste des noms des sous-programmes et fonctions
directement appele's dans le code. Il contient une partie du callgraph.
}

\subsection{Statement}
\label{subsection-statement}
\index{Statement}

\domain{Statement = label:entity x number:int x ordering:int x comments:string x instruction}
{}

Le domaine \verb/statement/ permet de
repe'rer les instructions d'un module.  Le sous-domaine \verb/label/
contient une entite' qui de'finit le label\footnote{Un statement dont
l'instruction est un \verb/block/ ou un \verb/unstructured/ n'a jamais
de label.}. Un label spe'cial est de'fini pour les RETURN, ce qui permet
de convertir les appels a` RETURN en des branchements a` ce label
spe'cial. Un autre label spe'cial, \verb/empty_label/, est utilise' pour
les statements sans label.

Le sous-domaine \verb/number/ contient un nume'ro permettant de repe'rer
le statement pour le debugging ou l'information de l'utilisateur (valeur
par defaut: \verb+STATEMENT\_NUMBER\_UNDEFINED+). Ce nume'ro est de'fini
par l'utilisateur ou implicitement par le parser qui prend le nume'ro de
la premie`re ligne de l'sintruction dans le fichier source. Il n'est (en
principe) jamais modifie' par PIPS. Apre`s de'roulage de boucle,
plusieurs \verb/statement/s peuvent avoir le me^me nume'ro.

Le sous-domaine \verb/ordering/ contient un entier caracte'ristique du
statement; il est forme' de la concate'nation du nume'ro de composante
dans le graphe de contro^le (nume'ro du control) et du nume'ro de
statement dans dans cette composante; cet entier sert a` comparer
l'ordre lexical des statements et sa valeur par defaut est
\verb+STATEMENT\_ORDERING\_UNDEFINED+. Il est automatiquement recalcule'
apre`s chaque transformation de programme. 

Il est aussi utilise' comme nom absolu d'un \verb/statement/ quand des
structures de donne'es comme les tables de hash-code sont e'crites sur
disque ou relues. Il est aussi utilise' pour e'tabli un lien entre les
noeuds du graphe de de'pendance et les statements. Il est possible de
cre'er une table de correspondance entre \verb/ordering/ et
\verb/statement/, mais elle ne fait pas partie de la repre'sentation
interne et doit cond e^tre calcule'e explicitement.

Notons que le champs \verb/ordering/ n'est pas force'ment calcule' pour
tous les statements. En particulier, les statements qui ne sont pas
accessibles d'apre`s le flot de contro^le n'en ont pas. Les statements
sans e'tiquette se trouvant derrie`re un GOTO en sont un exemple. Les
statements peuvent e^tre parcourus de manie`re se'lective, suivant le
flot de contro^le, avec la macro \verb/CONTROL_MAP/\index{CONTROL MAP}, ou de manie`re
syste'matique avec les fonctions de parcours de NewGen,
\verb/gen_recurse/\index{gen\_recurse},
\verb/gen_multi_recurse/\index{gen\_multi\_recurse},...

Le sous-domaine {\tt comments} contient le texte du commentaire associe'
a ce statement dans le programme initial; ce texte est utilise' par le
prettyprinter. Ce sont les commentaires qui pre'ce`dent le statement
qui s'y trouvent associe's. En l'absence de commentaires, ce champ
prend la valeur \verb/string\_undefined/. Les commentaires associe's a`
des instructions qui peuvent disparai^tre au cours des traitements comme
CONTINUE, RETURN et GOTO, peuvent aussi disparaitre.

Le sous-domaine \verb/instruction/ contient
l'instruction proprement dite.

\domain{persistant\_statement\_to\_statement = persistant statement -> persistant statement}
{}

Used for example in \verb/use_def_elimination()/ to store the eventual
statement father of a statement. The persistance is needed to avoid
freeing the statements when the mapping is freed.

\subsection{Instruction}
\label{subsection-instruction}
\index{Instruction}

\domain{Sequence = statements:statement*}
\domain{Instruction = sequence + test + loop + goto:statement + call + unstructured}

{ 
Le domaine \verb/instruction/ permet de repre'senter les instructions
d'un module. Une instruction peut e^tre un sous-domaine \verb/block/,
c'est-a`-dire une liste de \verb/statement/, un sous-domaine \verb/test/
pour les instructions de test, un sous-domaine \verb/loop/ pour les
boucles se'quentielles, un sous-domaine \verb/goto/ pour les goto qui
contient le
\verb/statement/ vers lequel le goto se branche, un sous-domaine
\verb/call/ pour toutes les autres instructions (affectation, appel de
subroutine, entre'es-sorties, return, stop, etc) ou un sous-domaine de
\verb/unstructured/ dans le cas ou` l'on traite d'un graphe de contro^le
structure'. Toutes ces instructions 
sont repre'sente'es par des appels a` des fonctions pre'de'finies dont
nous e'tudierons la nature plus loin.
}

\subsubsection{Control Flow Graph (a.k.a. Unstructured)}
\label{subsubsection-unstructured}
\index{Unstructured}

\domain{Unstructured = control x exit:control}
{

Domain \verb/unstructured/ is used to represent unstructured parts of
the code in a structured manner which as a unique statement. The entry
node of the underlying CFG is in field \verb/control/, and the
unique exit node is in field \verb/exit/. The exit node should not be
modified by users of the unstructured\footnote{FI: I do not understand
why...}.  See Figure~\ref{figure-unstructured}.

The hierarchical structure is induced by the recursive nature of
statements.  Each control node points towards a statement which can also
contain an unstructured area of the code as well as structured
part. Unstructured parts of the code can thus be contained as much as
possible as well as be recursively decomposed.

For instance, the two DO loops in:
\begin{verbatim}
      DO 200 I = 1, N
100      CONTINUE
         DO 300 J = 1, M
            T(J) = T(J) + X
300      CONTINUE
         IF(X.GT.T(I)) GO TO 100
200   CONTINUE
\end{verbatim}
are preserved as DO loops in spite of the GO~TO statement (see
Figure~\ref{figure-hierarchical-control-flow-graph}).

\begin{figure}

\begin{center}

\unitlength 3pt

\begin{picture}(90,105)(0,0)
\put(40,70){\circle*{3}}
\put(50,70){DO 200}

\put(30,35){\circle*{3}}
\put(20,40){IF}
\put(40,45){\circle*{3}}
\put(50,45){100 CONTINUE}
\put(50,35){\circle*{3}}
\put(60,35){DO 300}

\put(50,10){\circle*{3}}
\put(60,10){T(J) = T(J) + X}

% link between structured and unstructured parts
\put(50,30){\line(0,-1){20}}
\put(40,60){\line(0,-1){15}}
\put(30,37){\line(1,3){8}}
\put(50,37){\line(-1,3){8}}

% control edges
\thicklines
\put(30,35){\vector(-1,0){15}}
\put(31,36){\vector(1,1){8}}
\put(41,44){\vector(1,-1){8}}
\put(50,35){\vector(-1,0){18}}
\thinlines

% Draw the planes
\multiput(0,0)(0,30){3}{\line(1,1){25}}
\multiput(0,0)(0,30){3}{\line(1,0){105}}
\end{picture}
\end{center}
\caption{Hierarchical Control Flow Graph}
\label{figure-hierarchical-control-flow-graph}
\end{figure}

}

\subsubsection{Conditional (a.k.a. Test)}
\label{subsubsection-test}
\index{Test}

\domain{Test = condition:expression x true:statement x false:statement}
{
Le domaine \verb/test/ permet de repre'senter toutes les instructions a` base
de contro^le. Le sous-domaine \verb/condition/ contient l'expression a`
tester, et les deux sous-domaines \verb/true/ et \verb/false/ contiennent les
instructions a` exe'cuter selon la valeur du test. 

Il faut noter que chaque instruction de contro^le de Fortran,
a` l'exception de l'instruction \verb/DO/, est
transforme'e en une combinaison se'mantiquement e'quivalente de \verb/test/s
et de \verb/goto/s.
}

\subsubsection{DO Loop, Sequential or Parallel}
\label{subsubsection-loop}
\index{Loop}

\domain{Loop = index:entity x range x body:statement x label:entity x execution x locals:entity*}
{
Le domaine \verb/loop/ permet de repre'senter les boucles du type DO Fortran
ou FOR Pascal. Le sous-domaine \verb/index/ contient l'entite' indice de
boucle, le sous-domaine \verb/range/ contient les bornes de la boucle, le
sous-domaine \verb/body/ contient le corps de la boucle, c'est-a`-dire un
\verb/statement/, le sous-domaine \verb/label/ contient le label de fin de boucle,
c'est-a`-dire une entite'. Le sous-domaine \verb/execution/ de'finit le
comportement dynamique d'une boucle. Les entite's pre'sentes dans
\verb/locals/ sont propres au corps de boucle (les effets sur elles sont
masque's quand on sort de la boucle).
}

\index{Execution}
\domain{Execution = sequential:unit + parallel:unit}
{
Le domain \verb/execution/ de'finit la se'mantique d'une boucle:
\verb/sequential/ correspond a` une boucle DO classique, \verb/parallel/
de'finit un boucle dont les instances d'ite'ration peuvent e^tre
exe'cute'es en paralle`le.
}

\label{range}
\index{Range}
\domain{Range = lower:expression x upper:expression x increment:expression}
{
Le domaine \verb/range/ permet de repre'senter les bornes des boucles DO
Fortran. Il y a trois sous-domaines \verb/lower/, \verb/upper/ et \verb/increment/ de
type \verb/expression/ qui sont respectivement la borne infe'rieure, la borne
supe'rieure et l'incre'ment.
}

\subsubsection{Function Call}
\label{subsubsection-call}
\index{Call}

\domain{Call = function:entity x arguments:expression*}
{}

Le domaine \verb/call/ permet de repre'senter les commandes et les
appels de fonctions Fortran sous une forme unique pseudo-fonctionelle.
Ces pseudo-fonctions jouent un ro^le important dans notre
repre'sentation interme'diaire puisque les constantes, les ope'rateurs
comme + et *, les intrinse`ques comme {\tt MOD} ou {\tt SIN} et surtout
les commandes (i.e. instructions) Fortran, a` commencer par
l'assignation et en continuant avec {\tt READ, WRITE, RETURN, CALL}
etc..., sont repre'sente'es comme les appels de fonctions de'finies par
l'utilisateur. Le nombre d'arguments de chaque pseudo-fonction varie: 0
pour les constantes, 1 ou 2 pour les ope'rateurs, etc. Les commandes
Fortran, les ope'rateurs et les intrinse`ques sont caracte'rise's par
des pseudo-fonctions pre'de'finies. Cette convention permet de diminuer
conside'rablement la taille de la de'finition de la repre'sentation
ainsi que le volume de code ne'cessaire a` de nombreux algorithmes.

Le sous-domaine \verb/function/ est une entite' qui de'finit la fonction
appele'e. Le sous-domaine \verb/arguments/ est une liste de sous-domaines
\verb/expression/ qui repre'sente les arguments d'appel de la fonction.

\subsubsection{Control Flow Graph (cont.)}
\label{subsubsection-control}
\index{Control}

\domain{Control = statement x predecessors:control* x successors:control*}
{}


Domain \verb/control/ is the type of nodes used to implement the CFG
implied by an unstructured instruction (see Domain
\verb/unstructured/). Each node points towards a statement which can
represent an arbitrary large piece of structured code. GOTO statements
are eliminated and represented by arcs. Nodes are doubly linked. Each
node points towards its successors (at most 2) and towards its
predecessors. The hierarchical nature of
domain \verb/statement/ is used to hide local branches from higher and
lower level pieces of code. The whole unstructured area of the code is
seen as a unique atomic statement from above, and is entirely ignored
from under. This explains the mutual recursion between \verb/control/
and \verb/statement/ (via \verb/instruction/).

\begin{figure}
\begin{center}
\mbox{\psfig{file=unstructured.idraw,width=\hsize}}
\end{center}
\caption{Control Flow Graph}
\label{figure-unstructured}
\end{figure}

All statements but \verb/test/s and the exit node only have one
successor. The first successor of \verb/test/ is the successor when the
test condition is evaluated to true.  And the other way round for the
second one. The exit node (see domain \verb/unstructured/) has no
successor. The entry node as well as all other nodes may have an
unlimited number of precedessors.

The value of the exit node when it is not reachable is unclear. This is
a minor problem since PIPS isn't supposed to deal with faulty programs.

All reachable nodes of a CFG can be visited in a meaningless order using the
\verb/CONTROL_MAP/ macro. Look for an example in library \verb/control/
because an auxiliary data structure, a block list, must be declared and
freed. They can also be visited with \verb/gen_recurse()/, in a
meaningless order, but regardless of their reachability.

Note that the data structure used for the CFG is obsolete. A generic
structure for oriented graphs, \verb/graph/, should be used instead so
as to pool basic graph functions, e.g. search for strongly connected
components.

\subsubsection{Mappings between Statements and Controls}

\domain{Controlmap = persistant statement->control}
{}

\domain{persistant\_statement\_to\_control = persistant statement -> persistant control}
{}

Used for example in \verb/use_def_elimination()/ to store the eventual
control father of a statement in order to travel on the control graph
associated to a statement. The persistance is needed to avoid freeing
the control graph when the mapping is freed.

% \section{Repre'sentation des expressions}
\section{Expressions}
\label{expression}
\index{Expression}

\domain{Expression = syntax x normalized}
{}

Le domaine \verb/expression/ permet de stocker les expressions.  Le
sous-domaine {\tt syntax} contient la description de l'expression telle
qu'elle apparai^t dans le texte source du programme. Le sous-domaine
{\tt normalized} contient une forme compile'e des expressions
line'aires, sous forme de \verb/Pvecteur/\index{Pvecteur}.

Si le sous-domaine {\tt normalized} contient la valeur {\tt
normalized\_undefined}, cela signifie que la fonction de line'arisation
n'a pas e'te' appele'e pour cette expression; cela {\bf ne} signifie
{\bf pas} que l'expression n'est pas line'aire.

The \verb/normalized/ field is redundant with the \verb/syntax/
field. There is no consistency check available. When new expressions are
derived from old expressions, all normalized fields should be
reset. Else some normalized expressions end up with non-normalized
sub-expressions, and with a non-consistent normalized form.


\subsection{Abstract Tree of an Expression: Syntax}
\label{subsection-syntax}
\index{Syntax}

\domain{Syntax = reference + range + call}
{}

Le domaine \verb/syntax/ permet de repre'senter les expressions telles
qu'elles apparaissent dans le texte source du programme. Un
\verb/syntax/ est soit une \verb/reference/ a` un e'le'ment de tableau
(on rappelle que les scalaires sont des tableaux a` 0 dimension) , soit
un \verb/call/ a` une fonction (les ope'rateurs sont repre'sente's par
des fonctions pre'-de'finies, y compris l'assignation; c'est pourquoi le
domaine {\tt call} est de'fini dans la section {\em Instructions}), soit
un \verb/range/, dans le cas des expressions bornes de boucles (le domaine
{\tt range} est pre'sente' au niveau des boucles, aussi dans la section
{\em Instructions}).


\subsubsection{Reference}
\label{subsubsection-reference}
\index{reference}

\domain{Reference = variable:entity x indices:expression*}
{
Le domaine \verb/reference/ est utilise' pour repre'senter une
re'fe'rence a` un e'le'ment de tableau\footnote{Les variables scalaires
e'tant repre'sente'es par des tableaux de dimension 0, les re'fe'rences
a des scalaires sont aussi prises en compte. Elles contiennent une liste
vide d'expressions d'indices.}.  Le sous-domaine \verb/variable/
contient une entite' de'finissant la variable re'fe'rence'e. Le
sous-domaine \verb/indices/ contient une liste {\tt expression}s qui sont les
indices de la re'fe'rence.
}

\subsubsection{Range}

See Section~\ref{range}.

\subsubsection{Function Call}

All operators, including assignment, are repreented as function calls
with side effect. See Section~\ref{subsubsection-call}.

\subsection{Affine Representation of an Expression}
\label{subsection-normalized}
\index{Normalized}

\domain{Normalized = linear:Pvecteur + complex:unit}
{ Le domaine {\tt normalized} permet de savoir si une expression est une
expression line'aire construite sur les variables simples entie`res
(sous-domaine {\tt linear}) ou non (sous-domaine {\tt complex}).

Le sous-domaine {\tt complex} est utilise' si l'expression n'est pas
line'aire (ex: {\tt I*J+4}) ou si elle est line'aire mais contient autre
chose que des re'fe'rences a` des scalaires entiers (ex: {\tt T(I-1) +
T(I) + T(I+1)}).

La forme normalise'e n'existe pas si l'expression n'a pas encore e'te'
examine'e. }

% \section{Effets des instructions}
\section{Memory Effects of Statements}
\label{effects}

Each statement read and write several memory locations to retrieve value
stored and to store new values. Understanding the relationship between
statements and memory is one of the many keys to restructure and
parallelize programs. Several analyses provide different approximations
of the statement effects on memory.

Each program variable is a unique set of memory locations. Effects can
be expressed as effects on these sets. They are called {\em atomic}
effects, because a whole data structure is seen as read or written as
soon as one element is read or written.

The memory location representation can be refined for arrays. Certain
sets of array locations are handled, for instance intervals like
\verb/A[I:J]/ or even the so-called regular sections or Fortran~90
triplets, like \verb/A[0:N:2]/, which adds a stride to the concept of
interval. PIPS is able to handle polyhedral sets, called {\em array
regions}. Extension to non-convex sets, intersections of a lattice and a
polyhedron, is under investigation.

Memory effects are not always perfectly known. It is undecidable in the
general case. Effects can be labelled as {\tt MAY} if they might happen,
{\tt MUST} if they always happen, and {\tt EXACT} if the abstract set
used to represent them is equal to the dynamic set of effects. For
historical reasons, exact effects are labelled {\tt MUST} and must
effects are not computed.

Finally, read and write effects are not precise enough for compound
statements. It is more interesting to known is the {\em initial} value
of a memory location is {\em used} by a statement, which is called a
{\tt IN} effect, or if the memory location only is used for temporary
storage. In the same way, it is important to know if the value left by a
statement in a memory location is dead when leaving a statement or if it
is used later by another statement execution. In the later case, it is
called an {\tt OUT} effect.

Note that spurious effects are added in loop bodies to avoid... and/or
simulate later a control dependence by a data dependence (see
PJ).  These effects are \verb/read/ effects on the loop bounds
(variables used in loop bound expressions?). 

Note also that \verb/read/ effects of loop indices are ignored because
they always are not upward exposed. This is due to the {\em compound}
nature of the PIPS \verb/DO/ construct. It if were decomposed into
elementary parts, there would be no such surprising approximations.

\subsection{Effects}
\label{subsection-effects}
\index{Effects}

The {\tt effects} domain is a list of individual effects. Each effect
can only be a read or a write and is related to only one variable. Lots
of individual effects are linked to each statements, especially compound
statements like {\tt blocks}, {\tt tests}, {\tt loops} and {\tt
unstructured}.

\domain{Effects = effects:effect*}

The next domain can be used to store summary effects of callees.

\domain{entity\_effects = entity->effects}
{}

\subsection{Effect}
\label{subsection-effect}
\index{Effect}\index{Region}

\domain{Effect = persistant reference x action x approximation x context:transformer}
{}

Le domaine \verb/effect/ est utilise' pour repre'senter les effets d'un
statement sur les variables du module. Les effets des instructions sont
le point de de'part du calcul des \htmladdnormallink{use-def
chains}{http://www.cri.ensmp.fr/pips/pipsmake-rc.html} , des
de'pendances, des Summary Data Flow Information (known as summary
effects at the module level, and as cumulated effects at the statement
level), et des re'gions.

Le sous-domaine {\tt reference} indique sur quelle variable, scalaire ou
tableau, a lieu un effet. L'attribut {\tt persistant} lui est donne'
parce que les re'fe'rences concerne'es fonr directement partie des
statements du programme, au moins quand il s'agit d'effets simples. Cet
attribut est naturellement ge^nant pour les re'gions qui utilisent des
re'fe'rences synthe'tiques base'es sur les pseudo-variables $PHI$.

Le sous-domaine {\tt action} pre'cise si la
re'fe'rence est lue ou e'crite, et le sous-domaine {\tt approximation}
permet de savoir si la re'fe'rence (pour les effets) ou l'ensemble des
e'le'ments de tableaux de'fini par le contexte (pour les re'gions) est lu ou
e'crit a` coup su^r ou non. 

Lors de la traduction interproce'durale des effets ou des re'gions portant
sur une variable globale non de'clare'e dans le module appelant ou sur une
variable statique apparaissant dans un {\tt SAVE}, il est important de
re'cupe'rer une re'fe'rence qui sera la me^me pour tous les sites d'appels.
Pour cela on choisit un module de re'fe'rence (dans lequel le common ou le
save est de'clare'), dont le nom pre'fixera le nom de la variable. Le choix
de ce module n'est pas trivial. A` l'heure actuelle, il s'agit du nom du
module de la premie`re variable apparaissant dans la liste des variables du
common:
\begin{quote}
 {\tt ram\_section(storage\_ram(entity\_storage(<my\_common>)))}
\end{quote}
Selon l'ordre dans lequel les modules dont analyse's, le nom de module
trouve' sera diffe'rent. Il faudrait en re'alite' prendre le premier nom
de module dans l'ordre lexicographique des modules appele's (callees).

Le sous-domaine {\tt reference} permet de pre'ciser qu'un effet n'a lieu que
sur un sous-tableau en utilisant un {\tt range} comme expression d'indice.
Ceci est utilise' lors de la traduction des effets cumule's d'un proce'dure
en les effets propres d'un call site. Pour les re'gions, ce sous-domaine
pre'cise l'entite' concerne'e ainsi que la liste des variables $\phi$ qui
de'crivent ses dimensions.

Le sous-domaine {\tt context} n'est utilise' que pour repre'senter les
effets des instructions par des re'gions (telles que de'finies par Re'mi
Triolet).

\subsection{Nature of an Effect}
\label{subsection-action}
\index{Action}

\domain{Action = read:unit + write:unit}
{}

Deux types d'effets sont utilise's dans les conditions de Bernstein
et dans les conditions propres a` chaque transformation de programme:
la lecture d'une variable et son e'criture.

\subsection{Approximation of an Effect}
\label{subsection-approximation}
\index{Approximation}

\domain{Approximation = may:unit + must:unit}
{}

La pre'sence de tests et boucles ne permet pas de de'terminer en ge'ne'ral
si une variable est effectivement lue ou e'crite lors de l'exe'cution
d'un {\tt statement}. Il se peut me^me que certaines exe'cutions
y acce`dent et que d'autres n'y fassent pas re'fe'rence. Les effets
calcule's sont alors de type {\tt may}.

Dans quelques cas particuliers, comme une affectation simple {\tt I = 2},
l'effet est certain ({\em must}). Il peut alors e^tre utilise' dans
le calcul des {\em use-def chains} pour effectuer un {\em kill} sur les
variables scalaires. Un effet {\em must} sur un tableau ne signifie pas
que tout le tableau est lu ou e'crit mais qu'au moins un de ses
e'le'ments l'est.

\subsection{Mapping from Statements to Effects}

A different mapping from reachable statements to effect lists is
computed by each effect analysis. Because NewGen did not offer the {\em
map} type construct, there is no NewGen type for these mappings. They
are encoded as hash tables and used with primitives provided by the
NewGen library. They are stored on and read from disk by PIPS
interprocedural database manager, {\em pipsdbm}.

For details about effect analyses available see the Effects Section in the
\htmladdnormallink{PIPS phase descriptions}{http://www.cri.ensmp.fr/pips/pipsmake-rc.html}).

\section{Analyse se'mantique}
\label{semantics}

\subsection{Transformer}
\label{subsection-transformer}
\index{Transformer}

\domain{Transformer = arguments:entity* x relation:predicate}
{}

Le domaine {\tt transformer} de'finit une relation entre deux e'tats
me'moire. Cette relation
porte sur les valeurs des variables scalaires entie`res d'un module ou
des variables globales au programme.

Les variables qui apparaissent dans la liste des arguments sont celles
qui ont e'te' modifie'es entre les deux e'tats. Deux valeurs
sont donc associe'es a` chacune d'entre elles: la pre- et la
post-valeur.  Les post-valeurs sont porte'es par les entite's
elles-me^mes. Les pre'-valeurs sont porte'es par des entite's
spe'ciales. Les variables scalaires entie`res qui ne sont pas modifie'es
et qui n'apparaissent donc pas dans la liste des arguments n'ont qu'une
seule valeur, porte'e par l'entite' correspondant a` la variable.

La relation est de'finie par des e'galite's et des ine'galite's
line'aires entre valeurs.

Deux types de transformers sont utilise's. Le premier est propre a` un
{\tt statement} et donne une abstraction de son effet sur les variables
entie`res. Les variables qui apparaissent dans la liste des arguments
sont celles qui sont affecte'es lors de son exe'cution.  Le second,
aussi associe' a` un {\tt statement}, donne une relation entre l'e'tat
initial d'un module et l'e'tat pre'ce'dent l'exe'cution de ce {\tt statement}.

Les transformers ne sont de'finis qu'apre`s une phase d'analyse se'mantique.

\subsection{Predicate}
\label{subsection-predicate}
\index{Predicate}\index{Precondition}\index{Transformer}

\domain{Predicate = system:Psysteme}
{}

Le domaine {\tt predicate} de'finit une relation entre valeurs de
variables scalaires entie`res. Son interpre'tation est fonction de
son utilisation. Il peut s'agir soit d'un pre'dicat valable en
un point du programme (i.e. un invariant), soit d'un pre'dicat
valable entre deux points du programme. Il s'agit alors d'une
abstraction d'une commande, c'est-a`-dire d'un {\tt transformer}.

\newpage

\section*{Annexe: NewGen Declarations -- ri.newgen --}
\verbatiminput{ri.newgen}

\newpage

% Cross-references for points and keywords

\input{ri.ind}

\end{document}
\end
