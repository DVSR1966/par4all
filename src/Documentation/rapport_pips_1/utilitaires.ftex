\chapter{Les phases utilitaires}

\section{Cre'ation d'un programme}
\subsection{De'coupage du programme}
\subsection{Cre'ation des entite's intrinse`ques}


\section{Analyse syntaxique d'un module}

\paragraph{}
L'analyse syntaxique du texte source d'un module {\tt M} du programme
{\tt P} est re'alise'e par la phase \parser. Rappelons que ce texte se
trouve dans la ressource {\tt SOURCE\_FILE(M)} cre'e'e par la phase
d'initialisation. 

\paragraph{}
L'exe'cution de cette phase consiste en la cre'ation d'un objet de type
{\tt statement} qui formera la ressource {\tt PARSED\_CODE} et en la mise
a jour de la ressource {\tt ENTITIES(P)} avec les entite's de'clare'es
ou utilise'es dans {\tt P}.

\paragraph{}
L'analyse 

\subsection{Langage d'entre'e}
\label{fortran-pips}

\paragraph{}
Le langage d'entre'e de \pips est Fortran-77 ampute' de quelques unes de
ses constructions syntaxiques les plus anciennes. Ces restrictions ont
e'te' faites dans le but de limiter la quantite' de code a` e'crire pour
mener a` bien le projet \pips.

\paragraph{}
Les restrictions que nous proposons dans la suite de ce document
n'entrainent pratiquement pas de modifications des programmes benchmarks
qui nous ont e'te' confie's par l'ONERA (cf. section~\ref{bench-onera}).

\paragraph{}
A l'oppose', nous avons introduit dans notre langage les extensions
admises par la plupart des grands constructeurs (IBM, CDC, CRAY, etc.),
qui sont relativement utiles ey qui risquent d'\^etre pre'sentes dans
d'autres programmes scientifiques.

\paragraph{}
La de'finition de notre sous ensemble de Fortran, note' Fortran-Pips
dans la suite de ce document, est conforme a` la norme ANSI X3.9-1978,
a` l'exception des restrictions cite'es dans la
section~\ref{restrictions} et des extensions cite'es dans la
section~\ref{extensions}.

\paragraph{}
Nous donnons en annexe les SYNTAX CHARTS de la norme ANSI modifie's en
tenant compte des restrictions et des extensions.

\subsubsection{Restrictions}
\label{restrictions}

\paragraph{Instruction ENTRY.}

L'instruction ENTRY permet de spe'cifier des points d'entre'e
multiples pour un module. Son utilisation cre'e des difficulte's pour
un analyseur automatique car le graphe des appels -- graphe qui permet
de savoir quels modules sont appele's par un module donne' -- peut
devenir tre`s complexe.

Cette instruction est peu utilise'e, et de toute manie`re peut \^etre
elimine'e facilement en dupliquant les modules contenant des ENTRYs.

\paragraph{Module BLOCK DATA.}

Les modules BLOCK DATA permettent de regrouper les initialisations par
DATA des variables globales. Fortran ne perd rien a` sa
ge'ne'ralite' si on interdit les BLOCK DATA et si on inse`re dans le
PROGRAM les initialisations contenues dans ceux-ci.

\paragraph{Instructions ASSIGN et GOTO nom-de-variable.}

L'instruction ASSIGN permet de stocker dynamiquement un label dans une
variable de type INTEGER. L'instruction GOTO nom-de-variable permet
d'exe'cuter un branchement vers le label contenu dans une variable.

Un programme contenant ces deux instructions est particulie`rement
difficile a` lire pour un programmeur, car le saut peut aboutir
n'importe o\`u. Dans le cas d'une analyse automatique, l'utilisation des
ces constructions va re'sulter en un graphe de contr\^ole complexe qui
fera apparaitre de nombreuses de'pendances de contr\^ole. Les
transformations de paralle'lisation seront tre`s improbables.

Ces deux instructions peuvent \^etre e'limine'es en rempla\c{c}ant les
instructions \verb+ASSIGN label TO variable+ par des affectations
\verb+variable = label+, et les instructions \verb+GOTO variable+ par
une suite d'instructions \verb+IF (variable .EQ. label) GOTO label+.

\paragraph{Instruction RETURN expression.}

Les retours secondaires de subroutine permettent d'exe'cuter un
branchement apre`s une instruction CALL dont la destination de'pend
d'une valeur transmise au moment de l'exe'cution du RETURN dans la
proce'dure appele'e.

Cette construction pose les m\^emes proble`mes de complexite' du
graphe de contr\^ole que pre'ce'demment. Elle peut \^etre remplace'e
en transformant la subroutine en fonction et en exe'cutant apr\`s le
CALL un branchement vers un label calcule' a` partir du re'sultat
renvoye' par la fonction.

\paragraph{Instruction COMPUTED GOTO.}

Cette instruction permet d'exe'cuter un branchement vers un label dont
la valeur de'pend de la valeur d'une expression entie`re.

Cette construction pose les m\^emes proble`mes de complexite' du
graphe de contr\^ole que pre'cedemment. Elle peut \^etre remplace'e
par une suite d'instructions \verb+IF (variable .EQ. valeur) GOTO label+.

\paragraph{Instruction INQUIRE.}

L'instruction INQUIRE permet d'interroger le syste`me d'exploitation
sur les caracte'ristiques d'un fichier.

Elle est tre`s peu utilise'e, et n'a aucun impact sur la
paralle'lisation automatique.

\paragraph{Extraction de sous-chaines.}

Fortran 77 permet de de'clarer des variables chaines de caracte`res,
puis de re'fe'rencer des portions de ces variables. Cette
possibilite' augmente la complexite' des programmes d'analyse de la
repre'sentation interne.

Cette construction est tre`s peu utilise'e et n'a aucun impact sur la
paralle'lisation. Nous conservons donc le type chaine de caracte`res,
mais interdisons la possibilite' d'utiliser des sous-chaines.

\subsection{Extensions}
\label{extensions}

Nous introduisons dans Fortran-Pips la possibilite' de pre'ciser le
nombre d'octets utilise's par les types de donne'es, comme dans:

\begin{verbatim}
        REAL*4 T1,T2,TMP(2),TL1,TL2,ETIME
        REAL*4 T1,T2,TMP(2),ETIME
        REAL*8 FUNCTION PHI(J,X)
\end{verbatim}

Nous introduisons d'autre part les instructions d'entre'es-sorties
asynchrones BUFFER IN et BUFFER OUT, dont la syntaxe est la suivante:

\begin{verbatim}
        BUFFER IN  (UNIT, MODE) (BBLOCK, EBLOCK)
        BUFFER OUT (UNIT, MODE) (BBLOCK, EBLOCK)
\end{verbatim}

o\`u UNIT est le nume'ro de l'unite' d'entre'-sortie, MODE est une
constante spe'cifiant le mode d'entre'e-sortie, BBLOCK et EBLOCK
sont des noms de variables ou d'e'le'ments de tableaux indiquant la
zone a` tranfe'rer.

\subsection{Analyse lexicale}

L'analyse lexicale de Fortran-Pips pose quelques proble`mes puisque ce
langage ne contient pas de mots clefs re'serve's comme c'est le cas de
langages plus re'cents tels que Pascal ou C.

Par exemple, on de'tecte que l'instruction suivante est une affectation
car le caracte`re qui suit la parenthe`se fermant la re'fe'rence au
tableau IF est le caracte`re '='.
\begin{verbatim}
IF(I, J, K) = 6.66
\end{verbatim}

\paragraph{}
En conse'quence, l'utilitaire {\em lex}, disponible sous UNIX, ne permet
pas de re'aliser un analyseur lexical pour Fortran-Pips. Une premie`re
solution consistait donc a` e'crire comple`tement un analyseur lexical
pour Fortran-Pips, ce qui aurait repre'sente' beaucoup de travail.

Nous avons pre'fe're' de'composer l'analyse lexicale de Fortran-Pips en
deux parties, une premie`re partie ayant pour objet de lever les
ambiguite's contenues dans un programme gr\^ace a` une pre'-analyse qui
introduit des mots clefs au de'but de chaque instruction, et une seconde
partie, beaucoup plus simple car base'e sur lex, qui re'alise l'analyse
syntaxique du programme avec mots clefs produit par la premie`re partie.

\subsubsection{Pre'-analyseur lexical}

La premie`re partie revient a` fournir a` l'utilitaire {\em yacc} une
fonction 'getc' qui permette de lever les difficulte's lie'es a`
Fortran-Pips.

La nouvelle fonction getc fonctionne de la fac,on suivante.  Getc lit
d'un seul coup toutes les lignes d'une instruction, c'est a` dire la
ligne initiale et les 19 e'ventuelles lignes de continuation, et les
stocke dans le buffer 'Stmt'.  Au vol, getc repe`re le label, enle`ve
tous les blancs, de'tecte les caracte`res entre simples quotes, et met
a` jour 4 variables externes, qui repre'sentent pour l'instruction
courante la premie`re et la dernie`re ligne commentaire, et la premie`re
et la dernie`re ligne source.  Ensuite, le contenu du buffer Stmt est
analyse' pour y de'tecter les mot clefs, c'est a` dire traiter les cas
des instructions IF, ELSEIF, ASSIGN, DO, des de'claratives IMPLICIT et
FUNCTION, et des operateurs {\em .XX.} (.EQ., .NEQV., ...).

Lorsqu'un mot clef est de'tecte', il est mis en miniscules dans le texte
source, sauf la premie`re lettre qui reste en majuscule.  Ainsi, lex
peut faire la diffe'rence entre le mot clef 'Assign' et l'identificateur
'ASSIGN'.  Gr\^ace a` la premie`re lettre, lex peut de'tecter deux mots
clef successifs, me^me sans blanc pour les se'parer, comme dans
'IntegerFunctionASSIGN(X)'.

Lorsqu'un ope'rateur .XX. est de'tecte', il est remplace' dans le source
par \verb+_XX_+.  Ainsi, lex peut faire la difference entre une
constante re'elle et un ope'rateur, comme dans \verb/(X+1._EQ_5)/.

\subsection{Post-analyseur lexical}

La seconde partie est tout a` fait classique, c'est une spe'cification
d'analyseur lexical, dans le langage propose' par lex. Cette
spe'cification se compose d'une liste d'expressions re'gulie`res
correspondant aux tokens du langage, ave{c}, pour chacune d'entre elles,
le code du token a` renvoyer a` yacc lorsqu'un token de ce type est
de'tecte' dans le programme source.

\section{Graphe de contro^le structure'}

\section{Edition des liens entre modules}

\section{Reproduction de programmes sources}
