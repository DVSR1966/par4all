%%
%% $Id$
%%
%% $Log: pipsmake-rc.tex,v $
%% Revision 1.12  2003/06/23 13:53:27  nguyen
%% Add a C parser (preliminary version)
%%
%% Revision 1.11  2003/06/20 11:07:38  irigoin
%% Reformatting to ease the derivation of resources.h
%%
%% Revision 1.10  2003/06/20 11:01:26  irigoin
%% New module resources height and depth added.
%%
%% Revision 1.9  2003/06/04 13:11:17  ferrand
%% Add a new atomizer customized for use within the SIMDizing process
%% with SAC.
%%
%% Revision 1.8  2003/05/21 12:28:11  ferrand
%% Remove unneeded dependence from Simdizer on MODULE.preconditions.
%% Add a new phase for SIMD-optimized loop unrolling (loop unrolling with
%% automatic calculation of "optimal" unroll factor).
%%
%% Revision 1.7  2003/04/11 14:47:13  ferrand
%% Remove dependences from SIMDizer on the execution of Loop Distribution
%% and Atomizer.
%%
%% Revision 1.6  2003/04/08 13:22:20  keryell
%% Added simdizer for François Ferrand.
%%
%% Revision 1.5  2002/11/22 14:53:35  phamdat
%% MODULE.preconditions added to input of impact_check
%%
%% Revision 1.4  2002/09/26 14:55:14  nguyen
%% Modification of array resizing statistic
%%
%% Revision 1.3  2002/07/22 19:09:54  phamdat
%% MODULE.proper_effects added to input of impact_check
%%
%% Revision 1.2  2002/07/18 12:16:51  phamdat
%% impact_check added
%%
%% Revision 1.1  2002/06/05 11:27:05  nguyen
%% Initial revision
%%
%% Revision 1.158  2002/06/05 09:35:01  nguyen
%% Create new section for program verifications
%%
%% Revision 1.157  2002/06/05 09:13:44  phamdat
%% change the comments of print_filtered_dependence_graph and print_filtered_dependence_daVinci_graph
%%
%% Revision 1.156  2002/06/05 09:03:45  phamdat
%% print_filtered_dependence_graph added
%% print_filtered_dependence_daVinci_graph added
%%
%% Revision 1.155  2002/06/04 14:45:10  phamdat
%% rice_filtered_dependence_graph deleted
%% rice_filtered_dependence_daVinci_graph deleted
%%
%% Revision 1.154  2002/06/04 13:47:14  phamdat
%% rice_filtered_dependence_graph added
%% rice_filtered_dependence_daVinci_graph added
%%
%% Revision 1.153  2002/05/30 16:03:34  phamdat
%% input CALLEES.icfg_file replaced by CALLEES.dvicfg_file in print_dvicfg_with_filtered_proper_effects
%%
%% Revision 1.152  2002/05/30 15:30:59  phamdat
%% change the position of declaration of print_dvicfg_with_filtered_proper_effects
%%
%% Revision 1.151  2002/05/30 13:51:01  phamdat
%% CALLEES.summary_effects added in input of print_dvicfg_with_filtered_proper_effects
%%
%% Revision 1.150  2002/05/28 11:53:47  phamdat
%% create new resource MODULE.dvicfg
%%
%% Revision 1.149  2002/05/28 10:04:44  phamdat
%% change the description of phase dvicfg
%%
%% Revision 1.148  2002/05/28 09:54:56  phamdat
%% change resource of dvicfg to MOUDULE.icfg because MODULE.dvicfg do not exist for this moment
%%
%% Revision 1.147  2002/05/22 12:34:00  phamdat
%% new resource for dvicfg_file added
%%
%% Revision 1.146  2002/05/22 09:07:35  phamdat
%% alias print_dvicfg_with_filtered_proper_effect added
%% print_dvicfg_with_filtered_proper_effect added
%%
%% Revision 1.145  2002/05/07 14:57:19  ancourt
%% alias print_icfg_with_filtered_proper_effect added
%%
%% Revision 1.144  2002/05/07 14:51:50  ancourt
%% print_icfg_with_filtered_proper_effects added
%%
%% Revision 1.143  2002/05/06 12:16:43  coelho
%% hop.
%%
%% Revision 1.142  2002/05/06 12:13:34  coelho
%% filtered_proper_effects added.
%%
%% Revision 1.141  2002/04/23 09:02:48  nguyen
%% Declaring new resource UBS for the used before set analysis
%%
%% Revision 1.140  2002/04/19 15:08:52  nguyen
%% add resource to used before set analysis
%%
%% Revision 1.139  2002/04/17 12:12:17  nguyen
%% Change input resources for Used Before Set
%%
%% Revision 1.138  2002/03/14 17:07:52  ancourt
%% modification de l'alias de total_preconditions_intra et
%% total_preconditions_inter pour oter l'ambiguite
%%
%% Revision 1.137  2002/03/14 17:05:52  ancourt
%% *** empty log message ***
%%
%% Revision 1.136  2002/01/22 09:18:51  nguyen
%% Add more resource input for used_before_set
%%
%% Revision 1.135  2002/01/14 13:40:05  nguyen
%% Add new verification: Used Before Set
%%
%% Revision 1.134  2001/12/07 13:29:08  nguyen
%% Remove the phase formal_array_resizing_bottom_up, use properties instead
%%
%% Revision 1.133  2001/12/05 13:48:08  nguyen
%% *** empty log message ***
%%
%% Revision 1.132  2001/12/05 13:40:46  nguyen
%% Add a new phase FORMAL_ARRAY_RESIZING_BOTTOM_UP which is lighter than
%% ARRAY_RESIZING_BOTTOM_UP because it computes new declaration for formal
%% array argument only, and it uses SUMMARY_REGIONS, not all REGIONS
%%
%% Revision 1.131  2001/10/31 13:51:44  nguyen
%% *** empty log message ***
%%
%% Revision 1.130  2001/10/31 13:49:49  nguyen
%% Modify array_resizing_statistic and add code instrumentation for
%% array resizing
%%
%% Revision 1.129  2001/10/29 09:47:40  nguyen
%% I want to add a table of contents to the documentation.
%%
%% Revision 1.128  2001/10/24 11:28:04  irigoin
%% Lots of new entries to accomodate total preconditions
%%
%% Revision 1.127  2001/10/12 11:13:15  irigoin
%% Resource PROGRAM.program_precondition forgotten for transformers_inter_fast
%%
%% Revision 1.126  2001/10/08 14:49:39  ancourt
%% refine transformers alias added
%%
%% Revision 1.125  2001/10/08 14:43:18  irigoin
%% functionality refine_transformers added to benefit from module
%% preconditions in order to refine transformers.
%%
%% Revision 1.124  2001/10/08 13:37:15  irigoin
%% PROGRAM.program_precondition requested to compute transformers in main if
%% interprocedural option is selected. Pipsmake is not flexible enough to
%% express the fact that this resource is only conditionally useful.
%%
%% Revision 1.123  2001/09/18 13:32:11  boucheba
%% *** empty log message ***
%%
%% Revision 1.122  2001/09/18 13:19:08  ancourt
%% *** empty log message ***
%%
%% Revision 1.121  2001/09/18 13:14:56  ancourt
%% *** empty log message ***
%%
%% Revision 1.120  2001/09/18 13:11:42  ancourt
%% mise a jour de la passe tiling_sequence
%%
%% Revision 1.119  2001/09/17 13:26:17  boucheba
%% tiling for sequences of loop nests (youcef bouchebaba)
%%
%% Revision 1.118  2001/07/09 16:17:48  irigoin
%% Comments about preconditions slightly modified
%%
%% Revision 1.117  2001/06/22 09:44:47  nguyen
%% *** empty log message ***
%%
%% Revision 1.116  2001/06/22 09:35:49  nguyen
%% Remove MODULE.regions and ALL.preconditions from input of alias_check
%%
%% Revision 1.115  2001/06/12 11:11:35  nguyen
%% Remove CALLERS.preconditions from input of alias_propagation
%%
%% Revision 1.114  2001/06/08 12:42:38  nguyen
%% Add array_resizing_bootom_up and top_down to the transformation menu of wpips
%%
%% Revision 1.113  2001/06/08 11:49:07  nguyen
%% *** empty log message ***
%%
%% Revision 1.112  2001/06/08 11:21:51  nguyen
%% Add phases to transformation menu
%%
%% Revision 1.111  2001/05/30 15:37:21  nguyen
%% Add new resources for alias_propagation and alias_check
%%
%% Revision 1.110  2001/05/25 15:45:08  nguyen
%% *** empty log message ***
%%
%% Revision 1.109  2001/05/25 12:54:50  nguyen
%% Add alias analysis
%%
%% Revision 1.108  2001/03/05 14:28:46  nguyen
%% Add resource MODULE.preconditions for interprocedural array bound checking
%%
%% Revision 1.107  2001/03/01 15:04:58  nguyen
%% Add new phase : Interprocedural Array Bound Check
%%
%% Revision 1.106  2001/01/04 10:27:57  nguyen
%% Add new phase adn_instrumentation
%%
%% Revision 1.105  2000/12/27 13:02:51  nguyen
%% *** empty log message ***
%%
%% Revision 1.104  2000/12/27 11:15:25  nguyen
%% Add resource : CALLERS.preconditions for top_down_array_declaration_normalization
%%
%% Revision 1.103  2000/12/19 13:53:01  nguyen
%% Phase top_down_array_declaration_normalization : add new resource (new_declarations)
%%
%% Revision 1.102  2000/12/13 10:00:28  nguyen
%% Add comments about array_declaration_normalization
%%
%% Revision 1.101  2000/12/13 09:49:07  nguyen
%% Renaming phase : declaration_table_normalization to
%% bottom_up_array_declaration_normalization
%%
%% Adding new phase : top_down_array_declaration_normalization
%%
%% Revision 1.100  2000/12/05 09:46:30  irigoin
%% Comments modified for suppress_dead_code(). Also, now suppress_dead_code() declares that MODULE.callees are (in fact may be) modified.
%%
%% Revision 1.99  2000/11/28 13:49:28  ancourt
%% add_declaration_common pass removed
%%
%% Revision 1.98  2000/11/28 13:24:42  ancourt
%% freeze_variables Pass added
%%
%% Revision 1.97  2000/09/22 11:57:54  nguyen
%% *** empty log message ***
%%
%% Revision 1.96  2000/09/22 11:05:24  nguyen
%% Add new transformation partial_redundancy_elimination for logical expression
%%
%% Revision 1.95  2000/08/25 16:02:37  quoc
%% Add new phase : add_declaration_common
%%
%% Revision 1.94  2000/08/22 13:49:55  nguyen
%% Add new input resource for array_bound_check_instrumentation
%%
%% Revision 1.93  2000/08/22 10:10:23  nguyen
%% Add array_bound_check_instrumentation phase
%%
%% Revision 1.92  2000/06/15 13:58:13  nguyen
%% Add new phase : region_based_array_bound_check
%%
%% Revision 1.91  2000/06/05 12:41:11  boucheba
%% guard_elimination added.
%%
%% Revision 1.90  2000/05/11 15:33:26  quoc
%% Deleted the line blank in the declaration of module declaration_table_normalization
%%
%% Revision 1.89  2000/05/11 13:17:24  quoc
%% Added the input MODULE.regions to declaration_table_normalization
%%
%% Revision 1.88  2000/05/10 12:47:51  nguyen
%% Comments added about GATHER_FORMAT_AT_BEGINNING/END
%%
%% Revision 1.87  2000/05/10 11:46:56  coelho
%% type_checker added.
%%
%% Revision 1.86  2000/04/28 09:48:12  quoc
%% Added declaration_table_normalization
%%
%% Revision 1.85  2000/04/19 12:03:06  quoc
%% Replace suppress_dead_code by suppress_trivial_test in UserManualDocumentation
%%
%% Revision 1.84  2000/04/19 11:00:28  quoc
%% Test_vide_elimination replaced by trivial_test_elimination
%%
%% Revision 1.83  2000/04/19 08:40:59  boucheba
%% *** empty log message ***
%%
%% Revision 1.82  2000/04/19 08:37:45  boucheba
%% loop stats added.
%%
%% Revision 1.81  2000/04/19 08:30:17  quoc
%% Added suppress_test_vide
%%
%% Revision 1.80  2000/04/14 09:14:46  quoc
%% *** empty log message ***
%%
%% Revision 1.79  2000/04/12 14:58:41  quoc
%% *** empty log message ***
%%
%% Revision 1.78  2000/03/11 15:40:56  irigoin
%% full_unroll_pragma() added
%%
%% Revision 1.77  2000/02/29 13:00:24  nguyen
%% Add MODULE.summary_effects for array_bound_check
%%
%% Revision 1.76  2000/02/03 13:24:34  nguyen
%% *** empty log message ***
%%
%% Revision 1.75  2000/02/02 15:01:01  irigoin
%% array_bound_check added for Nga
%%
%% Revision 1.74  1999/09/03 10:55:45  irigoin
%% Comments added for OPTIMIZE_EXPRESSIONS
%%
%% Revision 1.73  1999/07/01 11:36:25  coelho
%% c dumper added.
%%
%% Revision 1.72  1999/04/29 11:24:10  albiez
%% Added the input of MODULE.proper_effects to the invariant code motion.
%%
%% Revision 1.71  1999/04/12 08:16:53  albiez
%% Added a invariant code motion phase
%%
%% Revision 1.70  1999/01/11 08:57:32  irigoin
%% Comments added about use-def elimination and parallelization.
%%
%% Revision 1.69  1998/12/03 10:48:26  irigoin
%% Dummy transformation_test added as suggested by Fabien Coelho.
%%
%% Revision 1.65  1998/10/12 09:46:57  irigoin
%% rule loop_tiling added
%%
%% Revision 1.64  1998/10/09 12:50:36  irigoin
%% Entry for loop_hyperplane added
%%
%% Revision 1.62  1998/09/17 09:35:35  ancourt
%% clean-declaration and unsplit added to wpips
%%
%% Revision 1.61  1998/09/16 16:17:58  coelho
%% some fixes.
%%
%% Revision 1.60  1998/09/16 16:07:49  coelho
%% clone aliases added + transformation menu...
%%
%% Revision 1.59  1998/07/27 13:31:07  irigoin
%% html link towards properties-rc fixed
%%
%% Revision 1.58  1998/04/29 13:52:13  coelho
%% restructured a little bit.
%% optimize_expressions added for Julien.
%%
%% Revision 1.57  1998/04/20 11:10:10  keryell
%% Added aliases to all Graphical Call Graph functions.
%%
%% Revision 1.56  1998/04/20 09:01:31  keryell
%% Added support for daVinci call graph view with wpips/epips.
%%
%% Revision 1.55  1998/03/31 16:17:23  coelho
%% forward_substitute added.
%%
%% Revision 1.54  1998/03/19 21:29:42  coelho
%% order of graph of calls inversed.
%%
%% Revision 1.53  1998/03/19 19:42:24  coelho
%% full_graph_of_calls added.
%%
%% Revision 1.52  1998/03/19 16:39:23  coelho
%% graph_of_callees added.
%%
%% Revision 1.51  1998/02/06 13:50:39  coelho
%% print_chains_graph added.
%%
%% Revision 1.50  1997/12/16 16:19:36  keryell
%% alias_file is no longer the first entry in the View menu (that is the
%% default View menu entry).
%%
%% Revision 1.49  1997/11/27 12:48:09  keryell
%% Added verbatim around alias compsec 'Complementary Sections'.
%%
%% Revision 1.48  1997/11/26 13:07:26  keryell
%% Added my contribution to flint. :-)
%%
%% Revision 1.47  1997/11/26 12:33:35  keryell
%% Added entities, proper_effects and chains to flinter for my new
%% uninitialized variable checking.
%%
%% Revision 1.46  1997/11/24 16:08:11  keryell
%% Added a precision about PRINT_DEPENDENCE_GRAPH_USING_SRU_FORMAT.
%%
%% Revision 1.45  1997/11/24 13:29:50  williams
%% Minor typo. Nicky
%%
%% Revision 1.44  1997/11/24 13:19:27  williams
%% Updated dependences and description of alias lists. Nicky.
%%
%% Revision 1.43  1997/11/22 11:07:51  coelho
%% fix..
%%
%% Revision 1.42  1997/11/22 11:05:44  coelho
%% OMP interface added.
%%
%% Revision 1.41  1997/11/19 13:56:34  irigoin
%% typo fixed for coarse_grain_parallelization
%%
%% Revision 1.40  1997/11/04 10:15:06  coelho
%% clone_substitute added.
%%
%% Revision 1.39  1997/11/03 16:31:36  coelho
%% typo...
%%
%% Revision 1.38  1997/11/03 13:01:50  coelho
%% clone_on_argument and clone interfaces...
%%
%% Revision 1.37  1997/10/31 12:24:41  coelho
%% cloning rule added. more comments needed.
%%
%% Revision 1.36  1997/10/31 10:50:05  irigoin
%% Comments added about directories for Fortran include files, modifications
%% about typing of intrinsics, several \index added in a FAQ fashion.
%%
%% Revision 1.35  1997/10/21 15:48:36  coelho
%% clean_declarations added.
%%
%% Revision 1.34  1997/10/21 12:44:20  coelho
%% unsplit added.
%%
%% Revision 1.33  1997/10/16 09:51:34  coelho
%% texttt -> verb
%%
%% Revision 1.32  1997/10/16 07:35:29  coelho
%% filter_file needs user_file resource.
%%
%% Revision 1.31  1997/10/15 06:07:37  coelho
%% order fixed.
%%
%% Revision 1.30  1997/10/15 05:05:50  coelho
%% initial_file resource and filter_file pass added.
%%
%%
%
% PIPS Project
%
% Description des enchainements possibles des passes et analyses de PIPS
% pour pipsmake
%
% Attention : chaque phase ne doit utiliser, pour les modules, 
% que des ressources definies dans une phase precedente !
%
% Derivation rules and aliases must be included in verbatim environments. 
% Nothing else should appear in a verbatim environment.
% 
% Modifications:
%  - a dependence on MODULE.cumulated_effects for print_transformers and
%    print_preconditions
%  - print_code_complexities depends on MODULE.summary_complexity
%    added by Lei Zhou   Feb.28 91
%  - atomizer, a program transformation that translates the fortran
%    instructions into atomic instructions (still in fortran style).
%    added by Alexis Platonoff, Jun 12 1991
%  - wp65, code generation for distributed memory machines: PUMA,
%    ESPRIT project 2701, Francois Irigoin, 15 October 1991
%  - loop_normalize, introduced by A.Platonoff, Oct. 30 1991.
%  - print_parallelized_code is removed, because it is identical to 
%    print_parallelized77_code. L. Zhou, Jan. 20 1992.
%  - reductions, Pierre Jouvelot, Apr. 1992
%  - rice_data_dependence_graph,Pierre Jouvelot, Apr. 1992
%  - print_rice_semantics_dependence_graph, Yi-Qing Yang, June, 1992
%  - choice for use-def chains between standard (atomic) use-def chains
%    and use-def chains based on regions;
%  - MODULE.code added as a production of the four parallelization rules
%    to overcome the inconsistency of hash tables after a
%    parallelization, Francois Irigoin, 18 May 1993
%  - Last modification undone because of a 
%   methods_io.c:122: `DBR_PARALLELIZED_CODE' undeclared, outside of functions
%    in ~pips/Pips/Development/Lib/pipsdbm. Ronan Keryell, 19 may 1993.
%  - hpfc rules added, Fabien Coelho, 16/09/93
%  - static_controlize, print_code_static_control, rules added,
%    Arnauld Leservot et Alexis Platonoff, 6/10/93
%  - loop_normalize removed, A.Platonoff, 6/10/93
%  - normalization of rule names as names of functions called by
%  pipsmake; this is necessary to automatize the computation of the
%  builder_map; Francois Irigoin, 8 October 1993
%  - array_dfg, skeleton, print_array_dfg, scheduling, print_bdt rules added
%    AL, AP, 12/10/93
%  - Flinter and print_parallelized*_code replaced so that those
%    phases use only resources previously defined. AL 13/10/93
%  - hpfcompile will use regions. FC 24/03/94
%  - prgm_mapping,  reindexing, print_parallelizedCMF_code,
%    print_parallelizedCRAFT_code rules added, AP, 9/11/94
%  - reindexed_code resource added, AP, 9/11/94
%  - skeleton removed, AP, 9/11/94
%  - unspaghettify added. RK, 26/07/1995.
%  - loop_normalize (again :-), in transformations, AP, 22/09/95
%  - continuation added, BC, 26/2/96.
%  - reductions added, FC 15/06/96

\documentclass[a4paper]{article}
%\usepackage{alltt,html,fancybox,amstext,xspace,psfig}
\usepackage{psfig,amstext,alltt,html}

%% Cannot work with verbatim: \begin{verbatim} absorbs \end{example}
%% \newenvironment{example}{\begin{verbatim}}{\end{verbatim}}
\newenvironment{PipsExample}{\VerbatimEnvironment
\begin{Verbatim}}{\end{Verbatim}}


\title{PIPS High-Level Software Interface \\
    Pipsmake}
\author{Remi Triolet,  Fran\c{c}ois Irigoin \\
        Ecole des Mines de Paris \\
        Centre de Recherche en Informatique \\
        77305 Fontainebleau Cedex \\
        France \\}
\date{
$~$Date: 2003/06/23 13:53:27 $~$
}

% \addtolength{\textwidth}{72pt}
% \addtolength{\oddsidemargin}{-48pt}
% \addtolength{\evensidemargin}{-48pt}
% \addtolength{\textheight}{172pt}
% \addtolength{\topmargin}{-60pt}

\renewcommand{\indexname}{Index}


%%@UserManualDeclarations
%% Some declarations used to factorize all the label names and so on:

%% Warning : spaces inside \htmladdnormallink{} seems to lead to wrong
%% results...

\newcommand{\CPU}{{\em CPU}}
\newcommand{\HPF}{{\em HPF}}
\newcommand{\HPFC}{\htmladdnormallink{\emph{HPFC}}{http://www.cri.ensmp.fr/pips/hpfc.html}}
\newcommand{\HPFcompiler}{\htmladdnormallink{\emph{HPF\space{}compiler}}{http://www.cri.ensmp.fr/pips/hpfc.html}}
\newcommand{\PArrayDataFlowGraphView}{{Array Data Flow Graph View}}
\newcommand{\PELSE}{{\tt ELSE}}
\newcommand{\PGOTO}{{\tt GOTO}}
\newcommand{\PIF}{{\tt IF}}
\newcommand{\PIPS}{\htmladdnormallink{\emph{PIPS}}{http://www.cri.ensmp.fr/pips}}
\newcommand{\PIPSMAKE}{\htmladdnormallink{\emph{pipsmake/}}{http://www.cri.ensmp.fr/pips/pipsmake.html}}
\newcommand{\PLinear}{\emph{Linear C$^3$}}
\newcommand{\PNEWGEN}{\htmladdnormallink{\emph{NewGen}}{http://www.cri.ensmp.fr/pips/newgen-manual/newgen-manual.html}}
\newcommand{\PROPERTIES}{\htmladdnormallink{\emph{properties}}{http://www.cri.ensmp.fr/pips/properties-rc}}
\newcommand{\PTHEN}{{\tt THEN}}
\newcommand{\PVM}{{\em PVM}}
\newcommand{\PCallgraphView}{{Call Tree View}}
\newcommand{\PCompileAnHPFProgram}{{Compile an HPF Program}}
\newcommand{\Pcontrolgraph}{{control flow graph}}
\newcommand{\Pcurrentmodule}{{current module}}
\newcommand{\PdaVinci}{\htmladdnormallink{\emph{daVinci}}{http://www.informatik.uni-bremen.de/~davinci}}
\newcommand{\PDependenceGraphView}{{Dependence Graph View}}
\newcommand{\PDistributedView}{{Distributed View}}
\newcommand{\PEdit}{{Edit}}
\newcommand{\PFlintView}{{Flint View}}
\newcommand{\PICFGView}{{ICFGView}}
\newcommand{\PMakeAnHPFProgram}{{Make an HPF Program}}
\newcommand{\PParallelView}{{Parallel View}}
\newcommand{\PPartialEval}{{Partial Eval}}
\newcommand{\PPlacementView}{{Placement View}}
\newcommand{\Ppreconditions}{{preconditions}}
\newcommand{\PRunAnHPFProgram}{{Run an HPF Program}}
\newcommand{\PSchedulingView}{{Scheduling View}}
\newcommand{\PSequentialView}{{Sequential View}}
\newcommand{\PSequentialViewControlGraph}{{Sequential View with
    Control Graph}}
\newcommand{\Punstructured}{{unstructured}}
\newcommand{\PUserView}{{User View}}
\newcommand{\PAliasView}{{Alias View}}
\newcommand{\PViewTheHPFCompilerOutput}{{View the HPF
    Compiler Output}}
\newcommand{\Pri}{\htmladdnormallink{\emph{Internal\space{}Representation}}{http://www.cri.ensmp.fr/pips/ri/ri.html}}
\newcommand{\WPsc}{\htmladdnormallink{\emph{WP65}}{http://www.cri.ensmp.fr/pips/wp65.html}}
 
%% Now the interface names :
\newcommand{\pips}{\htmladdnormallink{\texttt{pips}}{http://www.cri.ensmp.fr/pips/batch-interface.html}}
\newcommand{\EPIPS}{\htmladdnormallink{\texttt{epips}}{http://www.cri.ensmp.fr/pips/wpips-epips-user-manual/wpips-epips-user-manual.html}}
\newcommand{\TPIPS}{\htmladdnormallink{\texttt{tpips}}{http://www.cri.ensmp.fr/pips/line-interface.html}}
\newcommand{\WPIPS}{\htmladdnormallink{\texttt{wpips}}{http://www.cri.ensmp.fr/pips/wpips-epips-user-manual/wpips-epips-user-manual.html}}
\newcommand{\Init}{\htmladdnormallink{\texttt{Init}}{http://www.cri.ensmp.fr/pips/Init.html}}
\newcommand{\Select}{\htmladdnormallink{\texttt{Select}}{http://www.cri.ensmp.fr/pips/Select.html}}
\newcommand{\Perform}{\htmladdnormallink{\texttt{Perform}}{http://www.cri.ensmp.fr/pips/Perform.html}}
\newcommand{\Display}{\htmladdnormallink{\texttt{Display}}{http://www.cri.ensmp.fr/pips/Display.html}}
\newcommand{\Delete}{\htmladdnormallink{\texttt{Delete}}{http://www.cri.ensmp.fr/pips/Delete.html}}

%% Pour Béatrice :
\newcommand{\exact}[0]{{\tt EXACT}}
\newcommand{\incluseg}{\subseteq}
\newcommand{\phik}[1]{\ifmmode\phi_{#1}\else$\phi_{#1}$\fi}
\newcommand{\must}[0]{{\tt MUST}}
\newcommand{\may}[0]{{\tt MAY}}
%%ÿUserManualDeclarations

\externallabels{http://www.cri.ensmp.fr/pips/ri}{public_html/ri/labels.pl}

\makeindex

\begin{document}
\thispagestyle{empty}

\maketitle

% \begin{abstract}
% \end{abstract}

%\begin{PipsExample}
%petit essai
%à mettre ailleurs ! @!#%!#&@*I#(**()\\$$ pour tester
%\end{PipsExample}

%% The environment used to mark up the menus layout :
\newenvironment{PipsMenu}[1]{\par{\bf #1}\\\begin{alltt}}{\end{alltt}}




\section*{Introduction}

This paper describes high-level objects and functions which are
potentially user-visible in a \PIPS{}~\cite{IJT91} interactive environment.
It defines the internal {\em software} interface between a user interface and
program analyses and transformations. This clearly is not a user guide
but can be used as a reference guide, the best one before source code...

Objects can be viewed and functions activated by one of \PIPS{}
existing user interfaces: \TPIPS{}, the tty style interface,
\pips{}~\cite{BIJ91}, the batch interface, improved by many shell
scripts\footnote{Manual pages are available for \Init{}, \Select{},
  \Perform{}, \Display{}, and \Delete{}, and \pips{}.}, \WPIPS{} and
{\tt epips}, the X-Window System interfaces.  The {\tt epips}
interface is an extension of \WPIPS{} which uses {\tt Emacs} to
display more information in a more convenient way.

From a theoretical point of view, the object types and functions available
in \PIPS{} define an heterogeneous algebra with constructors (e.g. parser),
extractors (e.g. prettyprinter) and operators (e.g. loop unrolling).  Very
few combinations of functions make sense, but many functions and object
types are available. This abundance is confusing for casual and
experiences users and it was deemed necessary to assist them by providing
default computation rules and automatic consistency management. The rule
interpretor is called \verb/pipsmake/ and described in~\cite{B91}.

For debugging purposes and for advanced users, the precise choice and
tuning of an algorithm can be made using \PROPERTIES{}. Default properties
are installed with \PIPS{} but they can be redefined, partly or entirely,
by a {\tt properties.rc} file located in the current directory. Properties
can also be redefined when the \TPIPS{} interface is used (command {\tt
  setproperty}).

As far as their static structures are concerned, most object types are
described in more details in {\em \PIPS{} Internal Representation}. A
dynamic view is given here. In which order should functions be applied?
Which object do they produce and vice-versa which function does produce
such and such objects? How does \PIPS{} cope with bottom-up and top-down
interprocedurality?

Resources produced by several rules and their associated rule must be
given alias names when they should be explicitly computed or activated by an
interactive interface. This is otherwise not relevant. The alias names are
used to generate automatically header files and/or test files used by PIPS
interfaces.

No more than one resource should be produced per line of rule because
different files are automatically extracted from this one\footnote{See
the local Makefile: pipsmake-rc, and alias file: wpips-rc.}. Another
caveat is that \emph{all} resources the name of which is suffixed with
\verb|_file| are considered printable or displayable, and the others
are considered binary data.

This Latex file is used by several procedures to derive some pieces of C
code and ASCII files. The useful information is located in the {\em
  verbatim} areas, a very simple literate programming environment... For
instance \verb+alias+ information is used to generate automatically menus
for \verb+wpips+. Object (a.k.a resource) types and functions are renamed
using the alias declaration. The name space of aliases is global. All
aliases must have different names. Function declarations are used to build
a mapping table between function names and pointer to C functions, {tt
  phases.h}. Object suffixes are used to derive a header file, {\tt
  resources.h}, with all resource names. Parts of this file are also
extracted to generate on-line information for {\tt wpips}.

Rules and objects are grouped in the first five sections: input files,
syntax analysis and abstract syntax tree, analyses, transformations and
parallelizations, and prettyprinters of output files.
Section~\ref{section-feautrier-methods} describes several analyses defined
by P. Feautrier. Section~\ref{section-user-interface-menu-layouts}
contains a set of menu declarations for the window-based interfaces.

\newpage

\tableofcontents

\newpage

% PROGRAM, MODULE, CALLERS, CALLEES.




\section{Input Files}
\label{section-input-files}
\index{Input File}
 
\subsection{User File}
\label{subsection-user-file}
\index{User File}

An input program is a set of user Fortran~77 source files and a name,
called a {\em workspace}. The files are looked for in the current
directory, then by using the colon-separated \verb|PIPS_SRCPATH| variable
for other directories where they might be found. The first occurrence of
the file name in the ordered directories is chosen, what is consistent
with \texttt{PATH} and \texttt{MANPATH} for instance. 

The Fortran files are splitted by \PIPS{} at the
program initialization phase to produce one \PIPS{}-private source file
for each procedure, subroutine or function, and for each block data. A
function like \verb+fsplit+ is used and the new files are stored in the
workspace, which simply is a UNIX sub-directory of the current directory.
These new files have names suffixed by {\tt .f.orig}.

Since \PIPS{} performs interprocedural analyses, it expects to find a
source code file for each procedure or function called. Missing modules
can be replaced by stubs, which can be made more or less precise with
respect to their effects on formal parameters and global variables. A
stub may be empty. Empty stubs can be automatically generated if the code
is properly typed (see Section~\ref{subsection-source-file}).

The {\em user} source files should not be edited by the user once \PIPS{}
has been started because these editions are not going to be taken into
account unless a new workspace is created.
 Their preprocessed copies, the
\PIPS{} source files, safely can be edited while running \PIPS{}. The
automatic consistency mechanism makes sure that any information
displayed to the user is consistent with the current state of the
sources files in the workspace. These source files have names terminated
by the standard suffix, {\tt .f}.

New user source files should be automatically and completely re-built when the program
is no longer under \PIPS{} control\footnote{FI: the file reconstruction
procedure has not been implemented (September 1997).}, i.e. when the
workspace is closed. An executable application can easily be regenerated
after code transformations using the \TPIPS{} interface and requesting the
{\tt PRINTED\_FILE} resources for all modules:

\begin{quote}
{\tt display PRINTED\_FILE(\$ALL)}
\end{quote}

Note that \PIPS{} expects proper ANSI Fortran 77 code. Its parser was not
designed to locate syntax errors. It is highly recommended to check source
files with a standard Fortran compiler (see
Section~\ref{subsection-preprocessing-and-splitting}) before submitting them to
\PIPS{}.


\subsection{Preprocessing and Splitting}
\label{subsection-preprocessing-and-splitting}
\index{Preprocessing}
\index{Splitting}
\index{Include}
\index{Hollerith}

The Fortran files specified as input to \PIPS{} by the user are
preprocessed in various ways.

\begin{description}
  
\item[Fortran syntax:] if the \verb|PIPS_CHECK_FORTRAN| shell environment
  variable is defined to true, the syntax of the file is checked by
  compiling it with \verb|f77| (namely, the \verb|PIPS_FLINT| variable is
  used for that purpose, and defaults to \verb|f77 -c -ansi|).
  
  In case of failure, a warning is displayed. Note that if the program
  cannot be compiled properly with a Fortran compiler, it is likely that
  many problems will be encountered within \PIPS{}.

  The property \verb/CHECK_FORTRAN_SYNTAX_BEFORE_PIPS/ can also trigger
  this preliminary syntactic verification.

\item[C Preprocessor:] if the file suffix is \verb|.F|, the file is
  processed by \verb|cpp|. This is the standard suffix for Fortran compilers.
  The cpp and options used can be modified with the \verb|PIPS_CPP| and
  \verb|PIPS_CPP_FLAGS| variables, which default to \verb|cpp| and
  \verb|-P -C -D__PIPS__ -D__HPFC__| respectively.

  The Shell variable \verb|PIPS_CPP_FLAGS| may be used to locate the include
  files. Directories to search are specified with the \verb/-I/ option.
  
\item[Fortran Split:] the file is then split into one file per module
  using a PIPS specialized version of \texttt{fsplit}\footnote{The PIPS
    version of \texttt{fsplit} is derived from the BSD \texttt{fsplit}.
    Several improvements have been performed.}. This preprocessing also
  handles (1) Hollerith constants by converting them to the quoted
  syntax\footnote{Hollerith constants are considered obsolete by the new
    Fortran standards.}, (2) unnamed modules by adding \texttt{MAIN000} or
  \texttt{PROGRAM MAIN000} or or \texttt{DATA000} or \texttt{BLOCK DATA
    DATA000} according to needs.

\end{description}

The output of this phase is a set of \verb|.f_initial| files in 
per-module subdirectories. They constitute the resource 
\verb|INITIAL_FILE|.


\subsection{Syntactic Preprocessing}
\label{subsection-syntactic-preprocessing}
\index{Preprocessing}
\index{Include}
\index{Complex Constant}
\index{Implicit None}

A second step of preprocessing is performed to produce \verb/SOURCE_FILE/
files with standard Fortran suffix \texttt{.f} from the \verb|.f_initial|
files. The two preprocessing steps are shown in
Figure~\ref{figure-user-and-source-files}. 

\begin{figure}
\begin{center}
\mbox{\psfig{file=user-and-source-files.idraw,width=\hsize}}
\end{center}
\caption{Preprocessing phases: from a user file to a source file}
\label{figure-user-and-source-files}
\end{figure}

\begin{description}
  
\item[Cleaning:] each module source file is then processed by
  \texttt{top-level} to handle Fortran \verb|include| and to comment out
  \texttt{IMPLICIT NONE} which are not managed by \PIPS{}. Also this phase
  performs some transformations of complex constants to help the pips
  parser. Files referenced in Fortran \texttt{include} statements are
  looked for from the directory where the Fortran file is.  The Shell
  variable \verb|PIPS_CPP_FLAGS| is {\em not} used to locate these include
  files.

\end{description}

\subsection{Source File}
\label{subsection-source-file}
\index{Source File}
\index{Missing Code}
\index{Type Checking}

A \verb/source_file/ contains the code of exactly one module. Source files
are created from user source files at program initialization by
\texttt{fsplit} or a similar function if \texttt{fsplit} is not available (see
Section~\ref{subsection-preprocessing-and-splitting}).  A
source file may be updated by the user, but not by \PIPS{}\footnote{The
  X-window interface, \texttt{wpips} has an \texttt{edit} entry in the
  transformation menu.}. Program
transformations are performed on the internal representation
(see~\ref{section-abstract-syntax-tree}) and visible in the prettyprinted
output (see~ref{section-output-files}).

Source code splitting and preprocessing, e.g. \texttt{cpp}, are performed
by Function \verb/create_workspace()/ from the \texttt{top-level} library,
in collaboration with \verb/db_create_workspace()/ from library
\texttt{pipsdbm} which creates the workspace directory. The user source
files have names suffixed by \texttt{.f} or \texttt{.F} if \texttt{cpp}
must be applied. They are split into {\em original} \verb/user_files/ with
suffix \texttt{.f.orig}. These so-called original user files are in fact
copies stored in the workspace. The a syntactic PIPS preprocessor is
applied to generate what is known as a \verb/source_file/ by PIPS. This
process is fully automatized and not visible from PIPS user interfaces.
However, the cpp preprocessor actions can be controlled using the Shell
environment variable \verb/PIPS_CPP_FLAGS/.

Function \verb/initializer/ is only called when the source code is not
found. If the user code is properly typed, it is possible to force
\verb/initializer/ to generate empty stubs by setting properties
\verb/GENERATE_MISSING_SOURCE_FILES/ and, to avoid inconsistency,
\verb/PARSER_TYPE_CHECK_CALL_SITES/. But remember that many Fortran codes
use subroutine with variable numbers of arguments and with polymorphic
types. Fortran varargs mechanism can be achieved by using or not the
second argument according to the first one. Polymorphism can be useful to
design an IO package or generic array subroutine, e.g. a subroutine
setting an array to zero or a subroutine to copy an array into another
one.

The current default option is to generate a user error if some source code
is missing. This decision was made for two reasons:

\begin{enumerate}

\item Too many warnings about typing are generated as soon as polymorphism
  is used.

\item Analysis results and code transformations are potentially wrong
  because no memory effects are synthesized

\end{enumerate}


\begin{verbatim}
initializer                     > MODULE.user_file
                                > MODULE.initial_file
\end{verbatim}

Note: the generation of the resource \verb|user_file| here above is mainly 
directed in having the resource concept here. More thought is needed to
have the concept of user files managed by pipsmake.

MUST appear after initializer:

\begin{verbatim}
filter_file                     > MODULE.source_file
                < MODULE.initial_file
                < MODULE.user_file
\end{verbatim}


\subsection{Regeneration of user source files}

The \texttt{unsplit} phase regenerates user files from available
\verb|printed_file|. The various modules that where initialy stored in
single file are appended together in a file with the same name. Not that
just \texttt{fsplit} is reversed, not a preprocessing thru \texttt{cpp}. 
Also the \texttt{include} file preprocessing is not reversed.


%%@UserManualDocumentation: unsplit
Regeneration of user files. The various modules that where initialy stored in
single file are appended together in a file with the same name.
%%ÿUserManualDocumentation
\begin{verbatim}

alias unsplit 'User files Regeneration'

unsplit                         > PROGRAM.user_file
                < ALL.user_file
                < ALL.printed_file
\end{verbatim}

\section{Abstract Syntax Tree}
\label{section-abstract-syntax-tree}
\index{AST}
\index{IR}
\index{RI}
\index{Abstract Syntax Tree}

The abstract syntax tree, a.k.a intermediate representation,
a.k.a. internal representation, is presented in~\cite{IJT92} and in \Pri{}.

\subsection{Entities}
\label{subsubsection-entities}
\index{Entity}
\index{Variable}
\index{Module}

Program entities are stored in \PIPS{} unique symbol table\footnote{FI:
retrospectively, having a {\em unique} symbol table for all modules was
a design mistake. The decision was made to have homogeneous accesses to
local and global entities. It was also made to match NewGen {\em
tabulated} type declaration.}, called \verb+entities+. Fortran entities,
like intrinsics and operators, are created by \verb+bootstrap+ at
program initialization. The symbol table is updated with user local and
global variables when modules are parsed or linked together. This side
effect is not disclosed to {\em pipsmake}.

\begin{verbatim}
bootstrap                       > PROGRAM.entities
\end{verbatim}

The entity data structure is described in \Pri{}.

The declaration of new intrinsics is not easy because it was assumed that
there number was fixed and limited by the Fortran standard. In fact,
Fortran extensions define new ones. To add a new intrinsic C code in
\verb|bootstrap/bootstrap.c| and in \verb|effects-generic/intrinsics.c|
must be added to declare its name and type and Read/Write memory effects.

Information about entities generated by the parser is printed out
conditionally to property:

\begin{quote}
\verb/PARSER_DUMP_SYMBOL_TABLE/
\end{quote}

which is set to false by default,

\subsection{Parsed Code and Callees}
\label{subsection-parsed-code-and-callees}
\index{Parsed Code}
\index{Callees}

Each module source code is parsed to produce an internal representation
called \verb+parsed_code+ and a list of called module names,
\verb+callees+. Source code is assumed to be fully Fortran-77
compliant. On the first encountered error, the parser may be able to
emit a useful message or the non-analyzed part of the source code is
printed out.

\PIPS{} input language is standard Fortran~77 with few extensions and some
restrictions. The input character set includes underscore, \verb/_/, and
varying length variable names, i.e. they are not restricted to 6
characters.

\paragraph{The restrictions are:}

\begin{enumerate}

  \item \texttt{ENTRY} statements are not recognized and a user error is
generated. Very few cases of this obsolete feature were
encountered in the codes initially used to benchmark \PIPS{}. ENTRY statements have to be replaced manually by \texttt{SUBROUTINE} or
\texttt{FUNCTION} and appropriate commons.  If the parser bumps into a
call to an ENTRY point, it may wrongly diagnose a missing source code
for this entry, or even generate a useless but pipsmake satisfying stub if the corresponding
property has been set (see Section~\ref{subsection-source-file}).

  \item Multiple returns are not in \PIPS{} Fortran.

  \item \texttt{ASSIGN} and assigned \texttt{GOTO} are not in \PIPS{} Fortran.

  \item Computed \texttt{GOTO}s are not in \PIPS{} Fortran. 
    They are automatically
    replaced by a \texttt{IF...ELSEIF...ENDIF} construct in the parser.

  \item Functional formal parameters are not accepted. This is deeply
    exploited in {\em pipsmake}.

  \item Integer PARAMETERs must be initialized with integer constant
    expressions because conversion functions are not implemented.

  \item DO loop headers should have no label. Add a \texttt{CONTINUE} just
    before the loop when it happens. This can be performed automatically if
    the property 
    \verb/PARSER_SIMPLIFY_LABELLED_LOOPS/ is set to \texttt{TRUE}. This
    restriction is imposed by the parallelization phases, not by the parser.
  
  \item Complex constants, e.g. \texttt{(0.,1.)}, are not directly
    recognized by the 
    parser. They must be replaced by a call to intrinsic \texttt{CMPLX}. The
    \PIPS{} preprocessing replaces them by a call to \texttt{COMPLX\_}.

  \item Function formulae are not recognized by the parser. An undeclared
    array and/or an 
    unsupported macro is diagnosed. They may be substituted in an unsafe way
    by the preprocessor if the property 
    \begin{quote}
      \verb/PARSER_EXPAND_STATEMENT_FUNCTIONS/ 
    \end{quote}
    is set. If the substitution is considered possibly unsafe, a warning is
    displayed. 

\end{enumerate}

These parser restrictions were based on funding constraints. They are
mostly alleviated by the preprocessing phase. PerfectClub and SPEC-CFP95
benchmarks are handled without manual editing, but for ENTRY statements
which are obsoleted by the current Fortran standard.


\paragraph{Some additional remarks:}
\begin{itemize}
\item The PIPS preprocessing stage included in \texttt{fsplit()} is going
  to name unnamed modules \texttt{MAIN000} and unnamed  blockdata
  \texttt{DATA000} to be consistent with the generated file name.
  
\item Hollerith constants are converted to a more readable quoted form, 
  and then output as such by the prettyprinter.

\end{itemize}

\paragraph{Some unfriendly features:}

\begin{enumerate}

  \item Source code is read in columns 1-72 only. Lines ending in columns
73 and beyond usually generate incomprehensible errors. A warning is
generated for lines ending after column 72.

\item Comments are carried by the {\em following} statement. Comments
  carried by \texttt{RETURN}, \texttt{ENDDO}, \texttt{GOTO} or
  \texttt{CONTINUE} statements are not always preserved because the
  internal representation transforms these statements or because the
  parallelization phase regenerates some of them. However, they are
  more likely to be hidden by the prettyprinter.  There is a large
  range of prettyprinter \PROPERTIES{} to obtain less filtered view of
  the code.
  
\item Formats and character constants are not properly handled. Multiline
  formats and constants are not always reprinted in a Fortran correct
  form.

\item Declarations are exploited on-the-fly. Thus type and dimension
  information must be available {\em before} common declaration. If not,
  wrong common offsets are computed at first and fixed
  later in Function \texttt{EndOfProcedure}). Also, formal arguments
  implicitly are declared using the default implicit rule. If it is
  necessary to declare them, this new declarations should occur {\em
    before} an \texttt{IMPLICIT} declaration. Users are surprised by the
  {\em type redefinition} errors displayed.

%   \item Double quote is not accepted as substitute for simple quote in
% character string constants.

\end{enumerate}

\paragraph{Declaration of the standard parser:}

\begin{verbatim}
parser                          > MODULE.parsed_code 
                                > MODULE.callees      
        < PROGRAM.entities 
        < MODULE.source_file
\end{verbatim}

\paragraph{Declaration of HPFC parser:}

This parser takes a different Fortran file but applies the same
processing as the previous parser. The Fortran file is the result of the
preprocessing by the \verb|hpfc_filter| phase of the original file in
order to extract the directives and switch them to a Fortran~77 parsable
form. As another side-effect, this parser hides some callees from
pipsmake. This callees are temporary functions used to encode HPF
directives. Their call sites are removed from the code before requesting full analyses
to PIPS. This parser is triggered automatically by the \verb|hpfc_close|
phase when requested. It should never be selected or activated by hand.

\begin{verbatim}
hpfc_parser                     > MODULE.parsed_code
                                > MODULE.callees
        < PROGRAM.entities
        < MODULE.hpfc_filtered_file
\end{verbatim}

\paragraph{Declaration of the C parser:}

This draft parser is used to parse C code.  

\begin{verbatim}
c_parser                        > MODULE.parsed_code
                                > MODULE.callees
        < PROGRAM.entities
        < MODULE.source_file
\end{verbatim}

\subsection{Controlized Code}
\label{subsection-controlized-code}
\index{Controlizer}
\index{CFG}
\index{Control Flow Graph}

\PIPS{} analyses and transformations take advantage of a hierarchical
control flow graph, which preserves structured part of code as such, and
uses a control flow graph only when no syntactic representation is
available (see~\cite{IJT91}). The encoding of the relationship between
structured and unstructured parts of code is explained
in~\externalref{section-code}.

The \verb+controlizer+ removes \verb+GOTO+
statements in the parsed code and generates a similar representation
with small CFGs.

The hierarchical control flow graph built by the \texttt{Controlizer} is
pretty crude. The partial control flow graphs, called
\texttt{unstructured} statements, are derived from syntactic
constructs. The control scope of an unstructured is the smallest
enclosing structured construct, whether a loop, a test or a sequence.
Thus statements which might be seen as part of structured code end up
nodes of an unstructured.

Note that sequences of statements are identified as such by
\texttt{Controlizer}. Each of them appears as a unique node.

Also, useless CONTINUE statements may be added as provisional landing
pads and not removed. The exit node should never have successors but this
may happen after some PIPS function calls. The
exit node, as well as several other nodes, also may be unreachable. After
clean up, there should be no unreachable node or the only unreachable node
should be the exit node.
Function \texttt{unspaghettify} (see
Section~\ref{subsubsection-unspaghettify}) is applied by default to clean
up and to reduce the control flow graphs after \texttt{Controlizer}.

The {\tt GOTO} statements are transformed in arcs but also in {\tt
CONTINUE} statements to preserve as many user comments as possible.

The top statement of a module returned by the \texttt{Controlizer} used to
contain always an unstructured instruction with only one node. Several phases
in \PIPS{} assumed that this always is the case, although other program
transformations may well return any kind of top statement, most likely a
\texttt{block}. This is no longer true. The top statement of a module may
contain any kind of instruction.

%Controlizer                     > MODULE.Controlizer_code
\begin{verbatim}
controlizer                     > MODULE.code
        < PROGRAM.entities
        < MODULE.parsed_code
\end{verbatim}







\section{Analyses}
\label{section-analyses}
\index{Analysis}

Analyses encompass the computations of call graphs, the memory effects,
reductions, use-def chains, dependence graphs, interprocedural checks
({\em flinter}), semantics information (transformers and preconditions),
continuations, complexities, array regions, dynamic aliases and
complementary regions.

\subsection{Call Graph}
\label{subsection-call-graph}
\index{Call Graph}

All lists of callees are needed to build the global lists of callers
for each module. The callers and callees lists are used by {\em
pipsmake} to control top-down and bottom-up analyses. The call graph is
assumed to be a DAG, i.e. no recursive cycle exists, but it is not
necessarily connected.

The height of a module can be used to schedule bottom-up analyses. It is
zero if the module has no callees. Else, it is the maximal height of the
callees plus one.

The depth of a module can be used to schedule top-down analyses. It is
zero if the module has no callers. Else, it it the mazimal depth of the
callers plus one.

\begin{verbatim}
callgraph                       > ALL.callers
                                > ALL.height
                                > ALL.depth
        < ALL.callees
\end{verbatim}

This pass generates a daVinci version of the callgraph.  Its quite partial
since it should rely on an hypothetical \emph{all callees}, direct and
indirect, resource.

\begin{verbatim}
alias dvcg_file 'Graphical Call Graph'
alias graph_of_calls 'For current module'
alias full_graph_of_calls 'For all modules'

graph_of_calls               > MODULE.dvcg_file
        < ALL.callees

full_graph_of_calls          > PROGRAM.dvcg_file
        < ALL.callees
\end{verbatim}

\subsection{Effects}
\label{subsection-effects}
\index{Effect}
\index{Memory Effect}

The data structures used to represent effects and their computation are
described in~\cite{IJT92}. Another description is available on line, in
\Pri{} Technical
Report.

\subsubsection{Proper Effects}
\label{subsubsection-proper-effects}
\index{Proper Effects}
\index{Effects (Proper)}

The proper effects of a statement are lists of variables read or written by
the statement. They are used to build use-def chains and then the
dependence graph.

Proper means that the effects of a compound statement do not include the
effects of lower level statement. For instance, body of a loop, true and
false branches of test statement, control nodes in an unstructured
statement ... are ignored to compute the proper effects of a loop, a
test or an unstructured.

Variables private to loop are handled like regular variable.

Proper references try to keep the local references as much as possible. WE
have to think a little more about this concept. 

\begin{verbatim}
proper_effects                  > MODULE.proper_effects
        < PROGRAM.entities 
        < MODULE.code 
        < CALLEES.summary_effects
\end{verbatim}


\subsubsection{Filtered Proper Effects}
\label{subsubsection-filtered-proper-effects}

This phase collects information about where a given global variable is
actually modified in the program.

To be continued...

\begin{verbatim}
filter_proper_effects         > MODULE.filtered_proper_effects
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < CALLEES.summary_effects
\end{verbatim}


\subsubsection{Cumulated Effects}
\label{subsubsection-cumulated-effects}
\index{Cumulated Effects}
\index{Effects (Cumulated)}

Cumulated effects of statements are also lists of read or written
variables. Cumulated means that the effects of a compound statement, do
loop, test or unstructured, include the effects of the lower level
statements.

\begin{verbatim}
cumulated_effects               > MODULE.cumulated_effects
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.proper_effects
\end{verbatim}

Cumulated effects do not take into account local effects on private
variables. Interprocedurally, effects on dynamic variables are ignored.

Cumulated references integrate proper references over the program code. 

\emph{FC: I should implement real summary references?}

\begin{verbatim}
proper_references       > MODULE.proper_references
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.summary_effects

cumulated_references    > MODULE.cumulated_references
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_references
\end{verbatim}

Cumulated effects of a all module are used to compute the proper effects
the corresponding call sites. They are translated from the callee's scope
into the caller's scope. The translation is based on the actual-to-formal
binding. If too many actual arguments are defined, a user warning is
issued but the processing goes on because a simple semantics is available:
ignore useless actual arguments. If too few actual arguments are provided,
a user error is issued because the effects of the call are not defined. It
would be necessary to assume either a general \verb+READ+ or a general
\verb+WRITE+ for each read or written formal parameter with no actual
counterpart.

\subsubsection{Summary Data Flow Information (SDFI)}
\label{subsubection-summary-data-flow-information}
\index{SDFI}

Summary data flow information is the simplest interprocedural
information needed to take procedure into account in a
parallelizer. They were introduced in Parafrase. The
\verb+summary_effects+ of a module are the cumulated effects of its top
level statement, but effects on local dynamic variables are ignored and
subscript expressions of remaining effects are eliminated.

The proper effects of a call site are computed by translating the
summary effects of the callee.

\begin{verbatim}
summary_effects                 > MODULE.summary_effects
        < PROGRAM.entities 
        < MODULE.code MODULE.cumulated_effects
\end{verbatim}


\subsubsection{IN and OUT Effects}
\label{subsubsection-in-and-out-effects}
\index{IN Effects}
\index{OUT Effects}
\index{Effects (IN)}
\index{Effects (OUT)}

\begin{verbatim}

in_effects > MODULE.in_effects
           > MODULE.cumulated_in_effects
         < PROGRAM.entities 
         < MODULE.code  
         < MODULE.cumulated_effects
         < CALLEES.in_summary_effects

in_summary_effects > MODULE.in_summary_effects
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.in_effects 

out_summary_effects > MODULE.out_summary_effects
        < PROGRAM.entities 
        < MODULE.code 
        < CALLERS.out_effects

out_effects > MODULE.out_effects
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.out_summary_effects   
        < MODULE.cumulated_in_effects   


\end{verbatim}

\subsection{Reductions}
\label{sec:reductions}

The proper reductions are computed from a code.

\begin{verbatim}
proper_reductions > MODULE.proper_reductions
  < PROGRAM.entities
  < MODULE.code
  < MODULE.proper_references
  < CALLEES.summary_effects
  < CALLEES.summary_reductions
\end{verbatim}

The cumulated reductions propagate the reductions in the code, upwards. 

\begin{verbatim}
cumulated_reductions > MODULE.cumulated_reductions
  < PROGRAM.entities
  < MODULE.code
  < MODULE.proper_references
  < MODULE.cumulated_effects
  < MODULE.proper_reductions
\end{verbatim}

This pass summarizes the reductions candidates found in a module for
export to its callers. The summary effects should be used to restrict
attention to variable of interest in the translation?

\begin{verbatim}
summary_reductions > MODULE.summary_reductions
  < PROGRAM.entities
  < MODULE.code
  < MODULE.cumulated_reductions
  < MODULE.summary_effects
\end{verbatim}

Some possible (simple) transformations could be added to the code to mark
reductions in loops, for latter use in the parallelization.

\begin{verbatim}
loop_reductions > MODULE.code
  < PROGRAM.entities
  < MODULE.code
  < MODULE.cumulated_reductions
\end{verbatim}

\subsection{Chains (Use-Def Chains)}
\label{subsection-chains}
\index{Use-Def Chains}
\index{Def-Use Chains}
\index{Use-Use Chains}
\index{Use-Def Chains}

%%@UserManualDocumentation: chains
Use-def and def-use chains are a standard data structure in optimizing
compilers~\cite{Aho86}. These chains are used as a first approximation of
the dependence graph. Chains based on regions (see
Section~\ref{subsection-array-regions}) are more effective for
interprocedural parallelization.

\paragraph{Note:} 
If chains based on regions have been selected, the simplest dependence
test must be used because regions carry more information than any kind
of preconditions. Preconditions and loop bound information already are
included in the region predicate.
%%ÿUserManualDocumentation

\subsubsection{Menu for Use-Def Chains}

\begin{verbatim}
alias chains 'Use-Def Chains'

alias atomic_chains 'Standard'
alias region_chains 'Regions'
alias in_out_regions_chains 'In-Out Regions'
\end{verbatim}

\subsubsection{Standard Use-Def Chains (a.k.a. Atomic Chains)}
\label{subsubsection-atomic-chains}
\index{Use-Def Chains}
\index{Atomic Chains}

%%@UserManualDocumentation: atomic_chains
The algorithm used to compute use-def chains is original because it is
based on \PIPS{} hierarchical control flow graph and not on a unique
control flow graph.

This algorithm generates inexistent dependencies on loop indices. These
dependence arcs appear between DO loop headers and implicit DO loops in
IO statements, or between one DO loop header and unrelated DO loop bound
expressions using that index variable. It is easy to spot the problem
because loop indices are not privatized. A prettyprint option,
\begin{center}
\verb/PRETTYPRINT_ALL_PRIVATE_VARIABLES/ 
\end{center}
must be set to true to see if
the loop index is privatized or not). The problem disappears when some
loop indices are renamed.

The problem is due to the internal representation of DO loops: \PIPS{} has
no way to distinguish between initialization effects and increment
effects. They have to be merged as proper loop effects. To reduce the
problem, proper effects of DO loops do not include the index read effect
due to the loop incrementation.

Artificial arcs are added to... (Pierre Jouvelot, help!).
%%ÿUserManualDocumentation

\begin{verbatim}
atomic_chains                   > MODULE.chains
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{READ/WRITE Region-Based Chains}

%%@UserManualDocumentation: region_chains
\label{subsubsection-read-write-region-based-chains}

Such chains are required for effective interprocedural parallelization. The
dependence graph is annotated with {\em proper regions}, to avoid inaccuracy
due to summarization at simple statement level (see
Section~\ref{subsection-array-regions}).


Region-based chains only are compatible with the Rice Fast Dependence Graph
option (see Section~\ref{subsubsection-menu-for-dependence-tests}).  Other
dependence tests are likely to lack accuracy because a transitive check has
been added by Be'atrice Creusillet to improve speed. The other tests could
not improve the simplest test based on regions. Note that it is not fast
anymore when coping with regions.
%%ÿUserManualDocumentation

\begin{verbatim}
region_chains                   > MODULE.chains
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.proper_regions
\end{verbatim}

\subsubsection{IN/OUT Region-Based Chains}

%%@UserManualDocumentation: in_out_regions_chains
\label{subsubsection-in-out-region-based-chains}
When \verb+in_out_regions_chains+ is selected, IN and OUT regions (see
Sections~\ref{subsubsection-in-regions} and
\ref{subsubsection-out-regions}) are used only for calls. Otherwise,
usual regions are used. Arrays and scalars which are {\em logically}
local to callees are ignored but the resulting parallel loops require
some reallocation work. Ideally, the logically local variables should be
made {\em physically} local automatically, but this is not (yet)
implemented in \PIPS{}. 

As for region-based chains (see
Section~\ref{subsubsection-read-write-region-based-chains}), the
simplest dependence test should be selected for best results.
%%ÿUserManualDocumentation

\begin{verbatim}
in_out_regions_chains           > MODULE.chains
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.proper_regions
        < MODULE.in_regions
        < MODULE.out_regions
\end{verbatim}

The loop in Subroutine \verb+inout+ cannot be parallelized legally
because Subroutine \verb+foo+ uses a static variable, \verb+y+. However,
\PIPS{} will display this loop as (potentially) parallel if the
\verb+in_out+ option is selected for use-def chain computation. Remember
that IN/OUT regions require MUST regions to obtain interesting results
(see Section~\ref{subsubsection-in-regions}).

\noindent
\verb!      subroutine inout(a,n)!\\
\verb!      real a(n)!\\
\verb!      !\\
\verb!      do i = 1, n!\\
\verb!         call foo(a(i))!\\
\verb!      enddo!\\
\verb!      !\\
\verb!      end!\\
\verb!      !\\
\verb!      subroutine foo(x)!\\
\verb!      save y!\\
\verb!      !\\
\verb!      y = x!\\
\verb!      x = x + y!\\
\verb!      !\\
\verb!      end!\\

\subsection{Dependence Graph (DG)}
\label{subsection-dependence-graph}
\index{DG}
\index{Dependence Graph}

%%@UserManualDocumentation: dg
The dependence graph is used primarily by the parallelization
algorithms. A dependence graph is a refinement of use-def chains
(Section~\ref{subsection-chains}). If is {\em location}-based and not
{\em value}-based. See Section~\ref{subsection-array-data-flow-graph}
for information about \PIPS{} value-based dependence graph, Feautrier's
DFG.

There are several ways to compute a dependence graph. Some of them are
fast (Banerjee's one for instance) but provide poor results, others
might be slower (R\'emi's one for instance) but produce better
results.

Three different dependence tests are available, all based on
Fourier-Motzkin elimination improved with a heuristics for the integer
domain. The \verb+fast+ version uses subscript expressions only (unless regions
were used to compute use-def chains, in which case regions are used
instead). The \verb+full+ version uses subscript expressions and loop
bounds. The \verb+semantics+ version uses subscript expressions and
preconditions (see~\ref{subsection-semantics-analysis}).

Note that for interprocedural parallelization precise array regions only
are used by the fast dependence test if the proper kind of use-def
chains has been previously selected (see
Section~\ref{subsubsection-read-write-region-based-chains}).

There are several kinds of dependence graphs. Most of them share the
same overall data structure: a graph with labels on arcs and vertices.
usually, the main differences are in the labels that decorate arcs;
for instance, Kennedy's algorithm requires dependence levels (which
loop actually creates the dependence) while algorithms originated from
CSRD prefer DDVs (relations between loop indices when the dependence
occurs). Dependence cones introduced in~\cite{I87,IT87a,IT87b,IT88a}
are even more precise~\cite{AIY94}.

The computations of dependence level and dependence cone~\cite{Y93} are
both implemented in \PIPS{}. DDV's are not computed. Currently, only
dependence levels are exploited by parallelization algorithms.

The dependence graph can be printed with or without filters (see
Section~\ref{subsection-dependence-graph-file}). The standard dependence
graph includes all arcs taken into account by the parallelization
process (Allen \& Kennedy~\cite{AK87}), except those that are due to scalar private
variables and that impact the distribution process only. The loop
carried dependence graph does not include intra-iteration dependences
and is a good basis for iteration scheduling. The whole graph includes
all arcs, but input dependence arcs.

It is possible to gather some statistics about dependences by turning
on property \verb/RICEDG_PROVIDE_STATISTICS/ (more details in the
\PROPERTIES{}). A Shell script from \PIPS{} utilities,
\verb/print-dg-statistics/, can be used in combination to extract the
most relevant information for a whole program.

The main contributors for the design and development of dependence
analysis are R\'emi Triolet, Fran\c{c}ois Irigoin and Yi-qing
Yang~\cite{Y93}. The code was improved by Corinne Ancourt and B\'eatrice
Creusillet.
%%ÿUserManualDocumentation

\subsubsection{Menu for Dependence Tests}
\label{subsubsection-menu-for-dependence-tests}

\begin{verbatim}
alias dg 'Dependence Test'

alias rice_fast_dependence_graph 'Preconditions Ignored'
alias rice_full_dependence_graph 'Loop Bounds Used'
alias rice_semantics_dependence_graph 'Preconditions Used'
alias rice_regions_dependence_graph 'Regions Used'
\end{verbatim}

\subsubsection{Fast Dependence Test}
\label{subsubsection-fast-dependence-test}
\index{Fast Dependence Test}

%%@UserManualDocumentation: rice_fast_dependence_graph
Use subscript expressions only (unless regions were used to compute
use-def chains, in which case regions are used instead). {\tt
  rice\_regions\_dependence\_graph} is a synonym for this rule, but emits a
warning if {\tt region\_chains} is not selected. 
%%ÿUserManualDocumentation

\begin{verbatim}
rice_fast_dependence_graph      > MODULE.dg
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.chains
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Full Dependence Test}
\label{subsubsection-full-dependence-test}
\index{Full Dependence Test}

%%@UserManualDocumentation: rice_full_dependence_graph
Use subscript expressions and loop bounds.
%%ÿUserManualDocumentation

\begin{verbatim}
rice_full_dependence_graph      > MODULE.dg
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.chains
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Semantics Dependence Test}
\label{subsubsection-semantics-dependence-test}
\index{Fast Dependence Test}

%%@UserManualDocumentation: rice_semantics_dependence_graph
Uses subscript expressions and preconditions
(see~\ref{subsection-semantics-analysis}).
%%ÿUserManualDocumentation

\begin{verbatim}
rice_semantics_dependence_graph > MODULE.dg
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.chains
        < MODULE.preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Dependence Test with Array Regions}
\label{subsubsection-regions-dependence-test}
\index{Fast Dependence Test}

%%@UserManualDocumentation: rice_regions_dependence_graph
Synonym for {\tt rice\_fast\_dependence\_graph}, except that it emits a
warning when {\tt region\_chains} is not selected.
%%ÿUserManualDocumentation

\begin{verbatim}
rice_regions_dependence_graph      > MODULE.dg
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.chains
        < MODULE.cumulated_effects
\end{verbatim}

\subsection{Flinter}
\label{subsection-flinter}
\index{Flinter}

Function \verb+flinter+ performs some intra and interprocedural checks
about formal/actual argument pairs, use of COMMONs,... It was developed
by Laurent Aniort and Fabien Coelho. Ronan Keryell added the
uninitialized variable checking.

\begin{verbatim}
alias flinted_file 'Flint View'
flinter                         > MODULE.flinted_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.code
        < MODULE.proper_effects
        < MODULE.chains
\end{verbatim}

In the past, \texttt{flinter} used to require \texttt{MODULE.summary\_effects}
to check the parameter passing modes and to make sure that no module would
attempt an assignment on an expression. However, this kind of bug is
detected by the effect analysis... which was required by flinter.

Resource \texttt{CALLEES.code} is not explicitly required but it produces the
global symbols which function \texttt{flinter} needs to check parameter lists.

\subsection{Loop statistics}

Computes statistics about loops in module. It computes the number of
perfectly and imperfectly  nested loops and gives their depths. And it gives
the number of nested loops which we can treat with our algorithm.    

\begin{verbatim}
loop_statistics > MODULE.stats_file
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsection{Semantics Analysis}
\label{subsection-semantics-analysis}
\index{Semantics Analysis}
\index{Analysis (Semantics)}

\PIPS{} semantics analysis targets integer scalar variables. It is a
two-pass process, with a bottom-up pass computing \verb+transformers+, and
a top-down pass propagating \verb+preconditions+. Transformers and
preconditions are specially powerful case of return and jump
functions~\cite{CCKT86}. They abstract relations between program states
with polyhedra and encompass most standard interprocedural constant
propagations as well as most interval analyses. It is a powerful {\em
  relational} symbolic analysis.

Unlike~\cite{HC78} their computations are based on \PIPS{}
Hierarchical Control Flow Graph and on syntactic constructs instead of a
standard flow graph. The best presentation of this part of \PIPS{} is
in~\cite{Ir92}.

A similar analysis is available in Parafrase-2~\cite{}. It handles {\em
polynomial} equations between scalar integer variables. SUIF~\cite{}
also performs some kind of semantics analysis.

The semantics analysis part of \PIPS{} was designed and developed by
Fran\c{c}ois Irigoin.

\subsubsection{Transformers}
\label{subsubsection-transformers}
\index{Transformer}

%%@UserManualDocumentation: transformers
A transformer is an approximate relation between the symbolic initial
values of integer scalar variables and their values after the execution
of a statement (see~\cite{IJT92} and~\cite{Ir92}).

Intraprocedural algorithms use \verb+cumulated_effects+ to handle
procedure calls. In some respect, they are interprocedural since call
statements are accepted. Interprocedural algorithms use the
\verb+summary_transformers+ of the called procedures.

Fast algorithms use a very primitive non-iterative fix-point algorithm
(two possible version: flow sensitive or flow insensitive).  Full
algorithms use a fix-point on vector subspace (i.e. à la K{\sc
  arr}~\cite{Karr76}) or a fix-point on polyhedra (i.e. H{\sc
  albwachs}/C{\sc ousot}~\cite{HC78}; implemented... but not connected
as of Sept. 95).

A transformer map contains a transformer for each statement of a
module. It is a mapping from statements to transformers (type
\verb+statement_mapping+, which is not a NewGen file). Transformers maps
are stored on and retrieved from disk by {\em pipsdbm}.

Note: summary effects should not be used but the summary transformer is
in fact computed along with the transformers (Francois Irigoin, 4 Sept. 90).
%%ÿUserManualDocumentation

\paragraph{Menu for Transformers}

\begin{verbatim}
alias transformers 'Transformers'
alias transformers_intra_fast 'Quick Intra-Procedural Computation'
alias transformers_inter_fast 'Quick Inter-Procedural Computation'
alias transformers_intra_full 'Full Intra-Procedural Computation'
alias transformers_inter_full 'Full Inter-Procedural Computation'
alias refine_transformers 'Refine Transformers'
\end{verbatim}

\paragraph{Fast Intraprocedural Transformers}

%%@UserManualDocumentation: transformers_intra_fast
Build the fast intraprocedural transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
transformers_intra_fast         > MODULE.transformers
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.proper_effects
\end{verbatim}

\paragraph{Full Intraprocedural Transformers}
                
%%@UserManualDocumentation: transformers_intra_full
Build the improved intraprocedural transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
transformers_intra_full         > MODULE.transformers
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.proper_effects
\end{verbatim}

\paragraph{Fast Interprocedural Transformers}

%%@UserManualDocumentation: transformers_inter_fast
Build the fast interprocedural transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
transformers_inter_fast         > MODULE.transformers
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < CALLEES.summary_transformer
        < MODULE.proper_effects
        < PROGRAM.program_precondition
\end{verbatim}

\paragraph{Full Interprocedural Transformers}

%%@UserManualDocumentation: transformers_inter_full
Build the improved interprocedural transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
transformers_inter_full         > MODULE.transformers
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < CALLEES.summary_transformer
        < MODULE.proper_effects
        < PROGRAM.program_precondition
\end{verbatim}

\paragraph{Full Interprocedural Transformers}

%%@UserManualDocumentation: refine_transformers
Rebuild the interprocedural transformers using interprocedural preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
refine_transformers         > MODULE.transformers
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < CALLEES.summary_transformer
        < MODULE.proper_effects
        < MODULE.transformers
        < MODULE.summary_precondition
        < PROGRAM.program_precondition
\end{verbatim}

\subsubsection{Summary Transformer}
\label{subsubsection-summary-transformer}
\index{Transformer (Summary)}
\index{Summary Transformer}

A summary transformer is an interprocedural version of the module
statement transformer, obtained by eliminating dynamic local variables. The
filtering is based on the module summary effects. Note: each module has
a UNIQUE top-level statement.

A \verb+summary_transformer+ is of Newgen type \texttt{transformer}.

\begin{verbatim}
summary_transformer             > MODULE.summary_transformer
        < PROGRAM.entities
        < MODULE.transformers
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Preconditions}
\label{subsubsection-preconditions}
\index{Precondition}

%%@UserManualDocumentation: preconditions
A precondition for a statement $s$ in a module $m$ is a predicate true
for every state reachable from the initial state of $m$, in which $s$
is executed. A precondition is of NewGen type "transformer" (see
\Pri{}) and preconditions is of type \verb+statement_mapping+.

Option \verb+preconditions_intra+ associates a precondition to each
statement, assuming that no information is available at the module entry
point. 

Inter-procedural preconditions may be computed with {\em
intra}-procedural transformers but the benefit is not
clear. Intra-procedural preconditions may be computed with {\em
inter}-procedural transformers. This is faster that a full
interprocedural analysis because there is no need for a top-down
propagation of summary preconditions. This is compatible with code
transformations like partial evaluation (see
Section~\ref{subsubsection-partial-evaluation}), dead code elimination
(see Section~\ref{subsubsection-dead-code-elimination}) and use-def
based dead code elimination (see
Section~\ref{subsubsection-dead-code-elimination}).

Since these two options for transformer and precondition computations are
independent and that \verb/transformer_full_inter/ and
\verb/preconditions_full_inter/ must be both (independently) selected
to obtain the best possible results.

% Known bug: the postcondition of a loop, computed with the {\em full}
% option for transformers and preconditions is wrong because the last
% increment of the index is not performed. Besides the exit condition is
% not added (yet).
%%ÿUserManualDocumentation

\paragraph{Menu for Preconditions}

\begin{verbatim}
alias preconditions 'Preconditions'

alias preconditions_intra 'Intra-Procedural Analysis'
alias preconditions_inter_fast 'Quick Inter-Procedural Analysis'
alias preconditions_inter_full 'Full Inter-Procedural Analysis'
\end{verbatim}

\paragraph{Intra-Procedural Preconditions}

%%@UserManualDocumentation: preconditions_intra
Only build the preconditions in a module without any interprocedural
propagation.
%%ÿUserManualDocumentation

\begin{verbatim}
preconditions_intra            > MODULE.preconditions
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.summary_effects
        < MODULE.summary_transformer
        < MODULE.code
\end{verbatim}

\paragraph{Fast Inter-Procedural Preconditions}

%%@UserManualDocumentation: preconditions_inter_fast
Option \verb+preconditions_inter_fast+ uses the module own precondition
derived from its callers as initial state value and propagates it
downwards in the module statement.

The {\em fast} versions use no fix-point operations for loops.
%%ÿUserManualDocumentation


\begin{verbatim}

preconditions_inter_fast        > MODULE.preconditions
        < PROGRAM.entities
        < PROGRAM.program_precondition
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < CALLEES.summary_effects
        < MODULE.summary_transformer
\end{verbatim}

\paragraph{Full Inter-Procedural Preconditions}

%%@UserManualDocumentation: preconditions_inter_full
Option \verb+preconditions_inter_full+ uses the module own precondition
derived from its callers as initial state value and propagates it
downwards in the module statement.

The {\em full} versions use fix-point operations for loops.
%%ÿUserManualDocumentation

\begin{verbatim}
preconditions_inter_full        > MODULE.preconditions
        < PROGRAM.entities
        < PROGRAM.program_precondition
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < CALLEES.summary_effects
        < MODULE.summary_transformer

\end{verbatim}

\subsubsection{Summary Precondition}
\index{Summary Precondition}
\index{Precondition (Summary)}

An initial precondition for a module is derived from all its call
sites. Of course, preconditions must be known for all its callers'
statements.  The summary precondition is the convex hull of all call
sites preconditions, translated into a proper environment which is {\em
not} necessarily the module's frame. Because of {\em invisible} global
and static variables and aliasing, it is difficult for a caller to know which
variables might be used by the caller to represent a given memory
location. To avoid the problem, the current summary precondition is
always translated into the {\em caller}'s frame. So each module must
first translate its summary precondition, when receiving it from the
resource manager ({\em pipsdbm}) before using it.

A summary precondition is of type "transformer".

Note: the previous algorithm was based on a on-the-fly reduction by
convex hull. Each time a call site was encountered while computing a
module preconditions, the callee's summary precondition was updated. This
old scheme was more efficient but not compatible with program
transformations because it was impossible to know when the summary
preconditions of the modules had to be reset to the infeasible
(a.k.a. empty) precondition. An infeasible precondition means that the
module is never called (not implemented?).

\begin{verbatim}
summary_precondition            > MODULE.summary_precondition
        < PROGRAM.entities
        < CALLERS.preconditions
        < MODULE.callers
\end{verbatim}

\subsubsection{Initial Precondition}
\label{subsubsection-initial-precs}
\index{Precondition (Initial)}
\index{Initial Precondition}

All \texttt{DATA} initializations contribute to the global initial state
of the program. The contribution of each module is computed independently.
Note that variables statically initialized behave as static variables and
are preserved between calls according to Fortran standard. The module
initial states are abstracted by an initial precondition based on integer
scalar variables only.

\begin{verbatim}
initial_precondition     > MODULE.initial_precondition
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

All initial preconditions, including the initial precondition for the
main, are combined to define the program precondition which is an
abstraction of the program initial state.

\begin{verbatim}
program_precondition     > PROGRAM.program_precondition
        < PROGRAM.entities
        < ALL.initial_precondition
\end{verbatim}

The program precondition can only be used for the initial state of the
main procedure. Although it appears below for all interprocedural analyses
and it always is computed, it only is used when a main procedure is
available.

\subsubsection{Total Preconditions}
\label{subsubsection-ototal-preconditions}
\index{Total Precondition}

%%@UserManualDocumentation: total preconditions
A total precondition for a statement $s$ in a module $m$ is a predicate true
for every state from which the final state of $m$, in which $s$
is executed, is reached. It is an over-approximation of the theoretical
total precondition. Hence, if the predicate is false, the final state
cannot be reached. A total precondition is of NewGen type "transformer" (see
\Pri{}) and total\_preconditions is of type \verb+statement_mapping+.

The relationship with continuations (see
Section~\ref{subsection-continuation-conditions}) is not clear. Total
preconditions should be more general but no must version exist.

Option \verb+total_preconditions_intra+ associates a precondition to each
statement, assuming that no information is available at the module return
point. 

Inter-procedural total preconditions may be computed with {\em
intra}-procedural transformers but the benefit is not
clear. Intra-procedural total preconditions may be computed with {\em
inter}-procedural transformers. This is faster than a full
interprocedural analysis because there is no need for a top-down
propagation of summary total postconditions.

Since these two options for transformer and total precondition computations are
independent, \verb/transformer_full_inter/ and
\verb/total_preconditions_inter/ must be both (independently) selected
to obtain the best possible results.
%%ÿUserManualDocumentation

\paragraph{Menu for Total Preconditions}

\begin{verbatim}
alias total_preconditions 'Total Preconditions'

alias total_preconditions_intra 'Total Intra-Procedural Analysis'
alias total_preconditions_inter 'Total Inter-Procedural Analysis'
\end{verbatim}

\paragraph{Intra-Procedural Total Preconditions}

%%@UserManualDocumentation: preconditions_intra
Only build the total preconditions in a module without any interprocedural
propagation. No specific condition must be met when reaching a RETURN statement.
%%ÿUserManualDocumentation

\begin{verbatim}
total_preconditions_intra            > MODULE.total_preconditions
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.summary_effects
        < MODULE.summary_transformer
        < MODULE.code
\end{verbatim}

\paragraph{Inter-Procedural Total Preconditions}

%%@UserManualDocumentation: preconditions_inter_fast
Option \verb+total_preconditions_inter+ uses the module own total postcondition
derived from its callers as final state value and propagates it
backwards in the module statement. This total module postcondition must be
true when the RETURN statement is reached.
%%ÿUserManualDocumentation


\begin{verbatim}

total_preconditions_inter        > MODULE.total_preconditions
        < PROGRAM.entities
        < PROGRAM.program_postcondition
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.summary_total_postcondition
        < MODULE.summary_effects
        < CALLEES.summary_effects
        < MODULE.summary_transformer
\end{verbatim}

The program postcondition is only used for the main module.

\subsubsection{Summary Total Precondition}
\index{Summary Total Precondition}
\index{Total Precondition (Summary)}

The summary total precondition of a module is the total precondition of
its statement limited to information observable by callers, just like a
summary transformer (see Section~\ref{subsubsection-summary-transformer}).

A summary total precondition is of type "transformer".

\begin{verbatim}
summary_total_precondition            > MODULE.summary_total_precondition
        < PROGRAM.entities
        < CALLERS.total_preconditions
\end{verbatim}

\subsubsection{Summary Total Postcondition}
\index{Summary Total Postcondition}
\index{Total Postcondition (Summary)}

A final postcondition for a module is derived from all its call
sites. Of course, total postconditions must be known for all its callers'
statements.  The summary total postcondition is the convex hull of all call
sites total postconditions, translated into a proper environment which is {\em
not} necessarily the module's frame. Because of {\em invisible} global
and static variables and aliasing, it is difficult for a caller to know which
variables might be used by the caller to represent a given memory
location. To avoid the problem, the current summary total postcondition is
always translated into the {\em caller}'s frame. So each module must
first translate its summary total postcondition, when receiving it from the
resource manager ({\em pipsdbm}) before using it.

A summary total postcondition is of type "transformer".

\begin{verbatim}
summary_total_postcondition            > MODULE.summary_total_postcondition
        < PROGRAM.entities
        < CALLERS.total_preconditions
        < MODULE.callers
\end{verbatim}

\subsubsection{Final Postcondition}
\label{subsubsection-final-postcondition}
\index{Postcondition (Final)}
\index{Final Postcondition}

The program postcondition cannot be derived from the source code. It
should be defined explictly by the user. By default, the predicate is
always true. But you might want some variables to have specific values,
e.g. \verb+KMAX==1+, or signs,\verb+KMAX>1+ or relationships
\verb+KMAX>JMAX+.

\begin{verbatim}
program_postcondition     > PROGRAM.program_postcondition
\end{verbatim}

\subsection{Continuation conditions}
\label{subsection-continuation-conditions}

Continuation conditions are attached to each statement. They represent the
conditions under which the program will not stop in this statement. Under-
and over-approximations of these conditions are computed.

\begin{verbatim}
continuation_conditions > MODULE.must_continuation
                        > MODULE.may_continuation
                        > MODULE.must_summary_continuation
                        > MODULE.may_summary_continuation
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.transformers
        < CALLEES.must_summary_continuation
        < CALLEES.may_summary_continuation
\end{verbatim}

\subsection{Complexities}
\label{subsection-complexities}
\index{Complexity}

%%@UserManualDocumentation: complexities
Complexities are symbolic approximations of the execution times of
statements. They are computed interprocedurally and based on polynomial
approximations of execution times. Non-polynomial execution times are
represented by {\em unknown} variables which are not free with respect
to the program variables. Thus non-polynomial expressions are equivalent
to polynomial expressions over a larger set of variables.

Probabilities for tests should also result in
unknown variables (still to be implemented). See~\cite{Z94}.

A \verb+summary_complexity+ is the approximation of a module execution
times. It is translated and used at call sites.

Complexity estimation could be refined (i.e. the number of unknown
variables reduced) by using transformers to combine elementary
complexities using local states, rather than preconditions to combine
elementary complexities relatively to the module initial state. The same
options exist for region computation. The initial version~\cite{Pla90}
used the initial state for combinations. The new version~\cite{CI95}
delays evaluation of variable values as long as possible but does not
really use local states.

The first version of the complexity estimator was designed and
developed by Pierre berthomier. It was restricted to intra-procedural
analysis. This first version was enlarged and validated on real code for
SPARC-2 machines by Lei Z{\sc hou}~\cite{Z94}. Since, it has been modified
slightly by Fran\c{c}ois I{\sc rigoin}. For simple programs, complexity
estimation are strongly correlated with execution times. The estimations
can be used to see if program transformations are beneficial.

Known bugs: tests and while loops are not correctly handled because a
fixed probably of 0.5 is systematically assumed.
%%ÿUserManualDocumentation

\subsubsection{Menu for Complexities}

\begin{verbatim}
alias complexities      'Complexities'
alias uniform_complexities      'Uniform'
alias fp_complexities   'FLOPs'
alias any_complexities  'Any'
\end{verbatim}

\subsubsection{Uniform Complexities}
\label{subsubsection-uniform-complexities}
\index{Uniform Complexity}
\index{Complexity (Uniform)}

%%@UserManualDocumentation: uniform_complexities
Complexity estimation is based on a set of basic operations and fixed
execution times for these basic operation. The choice of the set is
critical but fixed. Experiments by Lei Zhou showed that it should be
enlarged. However, the basic times, which also are critical, are
tabulated. New sets of tables can easily be developed for new
processors.

Uniform complexity tables contain a unit execution time for all basic
operations. They nevertheless give interesting estimations for SPARC
SS-10, especially for -O2/-O3 optimized code.
%%ÿUserManualDocumentation

\begin{verbatim}
uniform_complexities                    > MODULE.complexities
        < PROGRAM.entities 
        < MODULE.code MODULE.preconditions
        < CALLEES.summary_complexity
\end{verbatim}

\subsubsection{Summary Complexity}
\label{subsubsection-summary-complexity}
\index{Summary Complexity}
\index{Complexity (Summary)}

%%@UserManualDocumentation: summary_complexity
Local variables are eliminated from the complexity associated to the top
statement of a module in order to obtain the modules's summary complexity.
%%ÿUserManualDocumentation

\begin{verbatim}
summary_complexity              > MODULE.summary_complexity
        < PROGRAM.entities 
        < MODULE.code MODULE.complexities 
\end{verbatim}

\subsubsection{Floating Point Complexities}
\label{subsubsection-floating-point-complexities}
\index{Floating Point Complexity}
\index{Complexity (Floating Point)}

%%@UserManualDocumentation: fp_complexities
Tables for floating point complexity estimation are set to 0 for
non-floating point operations, and to 1 for all floating point
operations, including intrinsics like \texttt{SIN}.
%%ÿUserManualDocumentation

\begin{verbatim}
fp_complexities                    > MODULE.complexities
        < PROGRAM.entities 
        < MODULE.code MODULE.preconditions
        < CALLEES.summary_complexity
\end{verbatim}

%%@UserManualDocumentation: any_complexities
This enables the default specification within the properties to
be considered. 
%%ÿUserManualDocumentation

\begin{verbatim}
any_complexities                    > MODULE.complexities
        < PROGRAM.entities 
        < MODULE.code MODULE.preconditions
        < CALLEES.summary_complexity
\end{verbatim}

\subsection{Array Regions}
\label{subsection-array-regions}
\index{Region}
\index{Array Region}

Regions of module statements.
%%@UserManualDocumentation: regions
A local region provides an approximation of the effects a statement has on
the module variables.  See~\cite{T84,TIF86,Pla90,C90,CI95,CI96} for more
information about regions.


Regions are not sets of array elements but functions mapping a store onto a
convex set of array elements. Regions may be expressed with respect to the
initial store of a module, or to the store passed to the statement they are
associated with. 

An array region is described by a convex polyhedron containing equalities
and inequalities~\cite{T84}: they link the {\em region parameters\/} (or
$\phi$ variables) that represent the array dimensions, to the values of the
program integer scalar variables. Two other characteristics are also of
interest:
%
\begin{itemize}
\item The {\em type\/} of the region: \verb+READ+ (\verb+R+) or \verb+WRITE+
(\verb+W+) to represent the effects of statements and procedures; \verb+in+
and \verb+out+ to represent the flow of array elements.

\item The {\em approximation\/} of the region: \verb+EXACT+ when the region
  exactly represents the requested set of array elements, or \verb+MAY+ or
  \verb+MUST+ if it is an over- or under-approximation ($\text{\must}
  \incluseg \text{\exact} \incluseg \text{\may}$). 

  Unfortunately, for historical reasons, \verb+MUST+ is still used in the
  implementation instead of \verb+EXACT+, and actual \verb+MUST+ regions are
  not computed. Moreover, the {\tt must\_regions} option in fact computes
  exact and may regions. 
  
  \verb+MAY+ regions are flow-insensitive regions, whereas \verb+MUST+
  regions are flow sensitive. Any array element touched by any execution of
  a statement is in the \verb+MAY+ region of this statement. Any array
  element in the \verb+MUST+ region of a statement is accessed by any
  execution of this statement. \end{itemize}
%

For instance, the region:
\begin{alltt}
  \begin{center}
  <A(\phik{1},\phik{2})-W-EXACT-\{\phik{1}==I, \phik{1}==\phik{2}\}>
\end{center}
\end{alltt}
where the region parameters \phik{1} and \phik{2} respectively represent
the first and second dimensions of \verb+A+, corresponds to an assignment
of the element \verb+A(I,I)+.


\verb+MAY+ \verb+READ+ and \verb+WRITE+ region analysis was first designed
by R\'emi Triolet and then revisited by Fran\c{c}ois Irigoin. The concept of
region is being revisited by B\'eatrice Creusillet, who added \verb+MUST+,
\verb+IN+ and \verb+OUT+ regions. Alexis Platonoff implemented the first
version of region analysis in \PIPS{}. These regions were computed with
respect to the initial stores of the modules. Fran\c{c}ois Irigoin and,
mainly, B\'eatrice Creusillet added new functionalities to this first
version, as well as functions to compute the new kinds of regions.

Internally, regions are of type \texttt{effect} and as such can be used to build
use-def chains (see Section~\ref{subsection-chains}). The most important
option is based on {\em proper regions}. Proper regions are 
\verb+READ+ and \verb+WRITE+ regions. For simple statements (assignments,
calls to intrinsic functions), summarization is avoided to preserve
accuracy. At this inner level of the program control flow graph, the extra
amount of memory necessary to store regions without computing their convex
hull should not be too high compare to the expected gain for dependence
analysis. For tests and loops, proper regions contain the regions associated
to the condition or the range. And for external calls, proper regions are
the summary regions of the callee translated into the caller's name space, to
which are merely appended the regions of the expressions passed as argument
(no summarization for this step). 

%%ÿUserManualDocumentation

\subsubsection{Menu for Array Regions}

\begin{verbatim}
alias regions 'Array regions'

alias may_regions 'MAY regions'
alias must_regions 'EXACT or MAY regions'
\end{verbatim}

\subsubsection{MAY READ/WRITE Regions}
\label{subsubsection-may-regions}
\index{MAY Region}

%%@UserManualDocumentation: may_regions
This function computes the \verb|MAY| regions in a module.
%%ÿUserManualDocumentation
\begin{verbatim}
may_regions                     > MODULE.regions
                                > MODULE.proper_regions
                                > MODULE.inv_regions
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.preconditions      
        < CALLEES.summary_regions 
\end{verbatim}

\subsubsection{MUST READ/WRITE Regions}
\label{subsubsection-must-regions}
\index{MUST Region}

%%@UserManualDocumentation: must_regions
This function computes the \verb|MUST| regions in a module.
%%ÿUserManualDocumentation
\begin{verbatim}
must_regions                    > MODULE.regions
                                > MODULE.proper_regions
                                > MODULE.inv_regions
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.preconditions      
        < CALLEES.summary_regions 
\end{verbatim}

\subsubsection{Summary READ/WRITE Regions}
\label{subsubsection-summary-regions}
\index{Summary Region}
\index{Region (Summary)}

SUMMARY\_REGIONS. Regions of a module. A summary region provides an
approximation of the effects observable by a caller that a module has on
its variables and, indirectly, on the global and static variables of its
callees.

\begin{verbatim}
summary_regions                 > MODULE.summary_regions
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.regions   
\end{verbatim}

\subsubsection{IN Regions}
\label{subsubsection-in-regions}
\index{IN Regions}
\index{Regions (IN)}

\verb+IN+ regions are flow sensitive regions. They are read regions not
covered (i.e. not previously written) by assignments in the local
hierarchical control-flow graph. There is no way with the current
pipsmake-rc and pipsmake to express the fact that \verb+IN+ (and \verb+OUT+)
regions must be calculated using \verb+must_regions+ (a new kind of
resources, \verb+must_region+, should be added). The user must be
knowledgeable enough to select \verb+must_regions+ first.

\begin{verbatim}
in_regions                      > MODULE.in_regions
                                > MODULE.cumulated_in_regions
                                > MODULE.inv_in_regions
        < PROGRAM.entities 
        < MODULE.code  
        < MODULE.summary_effects
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.preconditions 
        < MODULE.regions
        < MODULE.inv_regions
        < CALLEES.in_summary_regions
\end{verbatim}

\subsubsection{IN Summary Regions}
\label{subsubsection-in-summary-regions}
\index{IN Summary Regions}
\index{Summary Regions (IN)}

\begin{verbatim}
in_summary_regions              > MODULE.in_summary_regions
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.transformers
        < MODULE.preconditions  
        < MODULE.in_regions   
\end{verbatim}


\subsubsection{OUT Summary Regions}
\label{subsubsection-out-summary-regions}
\index{OUT Summary Regions}
\index{Summary Regions (OUT)}

See Section~\ref{subsubsection-out-regions}.

\begin{verbatim}
out_summary_regions             > MODULE.out_summary_regions
        < PROGRAM.entities 
        < CALLERS.out_regions   
\end{verbatim}


\subsubsection{OUT Regions}
\label{subsubsection-out-regions}
\index{OUT Regions}
\index{Regions (OUT)}

\verb+OUT+ regions are also flow sensitive regions. They are downward
exposed written regions which are also used (i.e. imported) in the
continuation of the program. They are also called {\em exported\/} regions.
Unlike \verb+READ+, \verb+WRITE+ and \verb+IN+ regions, they are propagated
downward in the call graph and in the hierarchical control flow graphs of
the subroutines.

\begin{verbatim}
out_regions                     > MODULE.out_regions
        < PROGRAM.entities 
        < MODULE.code  
        < MODULE.transformers
        < MODULE.preconditions 
        < MODULE.regions
        < MODULE.inv_regions
        < MODULE.summary_effects
        < MODULE.cumulated_effects
        < MODULE.cumulated_in_regions
        < MODULE.inv_in_regions
        < MODULE.out_summary_regions
\end{verbatim}

\subsection{Alias Analysis}
\label{subsection-alias-analysis}
\index{Alias Analysis}

\subsubsection{Dynamic Aliases}
\label{subsubsection-dynamic-aliases}
\index{Dynamic Aliases}
\index{Alias Classes}

Dynamic aliases are pairs (formal parameter, actual parameter) of regions
generated at call sites. An ``IN alias pair'' is generated for each IN
region of
a called module and an ``OUT alias pair'' for each OUT region. For EXACT
regions, the transitive, symmetric and reflexive closure of the dynamic
alias relation results in the creation of equivalence classes of regions
(for MAY regions, the closure is different and does not
result in an equivalence relation, but nonetheless allows us to define alias
classes). A set of alias
classes is generated for a module, based on the IN and OUT alias
pairs of all the modules below it in the callgraph. The alias classes for
the whole workspace are those of the module which is at the root of the
callgraph, if the callgraph has a unique root. As an intermediate phase
between the creation of the
IN and OUT alias pairs and the creation of the alias classes, ``alias
lists'' are created for each module. An alias list for a module is the
transitive closure of the alias pairs (IN or OUT) for a particular path
through the callgraph subtree rooted in this module.

\begin{verbatim}
in_alias_pairs > MODULE.in_alias_pairs
        < PROGRAM.entities
        < MODULE.callers
        < MODULE.in_summary_regions
        < CALLERS.code
        < CALLERS.cumulated_effects
        < CALLERS.preconditions

out_alias_pairs > MODULE.out_alias_pairs
        < PROGRAM.entities
        < MODULE.callers
        < MODULE.out_summary_regions
        < CALLERS.code
        < CALLERS.cumulated_effects
        < CALLERS.preconditions

alias_lists > MODULE.alias_lists
        < PROGRAM.entities
        < MODULE.in_alias_pairs
        < MODULE.out_alias_pairs
        < CALLEES.alias_lists

alias_classes > MODULE.alias_classes
        < PROGRAM.entities
        < MODULE.alias_lists
\end{verbatim}


\subsubsection{Menu for Alias Views}

\begin{verbatim}
alias alias_file 'Alias View'

alias print_in_alias_pairs 'In Alias Pairs'
alias print_out_alias_pairs 'Out Alias Pairs'
alias print_alias_lists 'Alias Lists'
alias print_alias_classes 'Alias Classes'
\end{verbatim}

%%@UserManualDocumentation: print_in_alias_pairs
Display the dynamic alias pairs (formal region, actual region) for the IN
regions of the module.
%%ÿUserManualDocumentation
\begin{verbatim}
print_in_alias_pairs > MODULE.alias_file
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.in_alias_pairs
\end{verbatim}

%%@UserManualDocumentation: print_out_alias_pairs
Display the dynamic alias pairs (formal region, actual region) for the OUT
regions of the module.
%%ÿUserManualDocumentation
\begin{verbatim}
print_out_alias_pairs > MODULE.alias_file
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.out_alias_pairs
\end{verbatim}

%%@UserManualDocumentation: print_alias_lists
Display the transitive closure of the dynamic aliases for the module.
%%ÿUserManualDocumentation
\begin{verbatim}
print_alias_lists > MODULE.alias_file
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.alias_lists
\end{verbatim}

%%@UserManualDocumentation: print_alias_classes
Display the dynamic alias equivalence classes for this module and those
below it in the callgraph.
%%ÿUserManualDocumentation
\begin{verbatim}
print_alias_classes > MODULE.alias_file
        < PROGRAM.entities
        < MODULE.cumulated_effects
        < MODULE.alias_classes
\end{verbatim}


\subsection{Complementary Sections}
\label{subsection-complementary-sections}
\index{Complementary Sections}
\index{Array Region}

\begin{verbatim}
alias compsec 'Complementary Sections'
\end{verbatim}

A new type of array regions, from Manjunathaiah Muniyappa.

\subsubsection{READ/WRITE Complementary Sections}
\label{subsubsection-complementary-sections}

%%@UserManualDocumentation complementary_sections
This function computes the complementary sections in a module.
%%ÿUserManualDocumentation
\begin{verbatim}
complementary_sections > MODULE.compsec
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.cumulated_effects
        < MODULE.transformers
        < MODULE.preconditions      
        < CALLEES.summary_compsec 
\end{verbatim}

\subsubsection{Summary READ/WRITE Complementary Sections}
\label{subsubsection-summary-complementary-sections}
\index{Summary Complementary Sections}
\index{Complementary Sections (Summary)}


\begin{verbatim}
summary_complementary_sections > MODULE.summary_compsec
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.compsec   
\end{verbatim}







\section{Parallelization and Distribution}
\label{section-program-transformations-parallelization-distribution}
\index{Transformation}
\index{Program Transformation}

\subsection{Code Parallelization}
\label{subsection-parallelization}
\index{Parallelization}

%%@UserManualDocumentation: parallelized_code
\PIPS{} basic parallelization function, \verb+rice_all_dependence+,
produces a new version of the Module code with DOALL loops exhibited using
A{\sc llen} \& K{\sc ennedy}'s algorithm. The DOALL syntactic construct is
non-standard but easy to understand and usual in text book like Wolfe 96.
As parallel prettyprinter option, it is possible to use Fortran~90 array
syntax (see Section~\ref{subsection-parallel-printed-files}).

Remember that A{\sc llen} \& K{\sc ennedy}'s algorithm can only be applied
on loops with simple bodies, i.e. sequences of assignments, because it
performs loop distribution and loop regeneration without taking control
dependencies into account. If the loop body contains tests and branches,
the coarse grain parallelization algorithm should be used (see
\ref{subsubsection-coarse-grain-parallelization}).

Loop index variables are privatized whenever possible, using a simple
algorithm. Dependence arcs related to the index variable and stemming
from the loop body must end up inside the loop body. Else, the loop
index is not privatized because its final value is likely to be needed
after the loop end and because no copy-out scheme is supported.

A better privatization algorithm for all scalar variable may be used as
a preliminary code transformation. An array privatizer is also available
(see Section~\ref{subsubsection-scalar-and-array-privatization}). A
non-standard {\tt PRIVATE} declaration is used to specify which variables
should be allocated on stack for each loop iteration. An HPF format can
also be selected.

Objects of type \verb+parallelized_code+ differs from objects of type
\verb+code+ because most algorithms cannot be applied on {\tt DOALL}
loops. This is true for pre-condition computation, dependence testing
and so on... It is possible neither to re-analyze parallel code, nor to
re-parse it (although it would be interesting to compute the complexity
of a parallel code).
%%ÿUserManualDocumentation

\subsubsection{Menu for Parallelization Algorithm Selection}

Entries in menu for the resource \verb/parallelized_code/ and for the
different parallelization algorithms with may be activated or
selected. Note that the nest parallelization algorithm is not debugged.

\begin{verbatim}
alias parallelized_code 'Parallelization'

alias rice_all_dependence 'All Dependences'
alias rice_data_dependence 'True Dependences Only'
alias rice_cray 'CRAY Microtasking'
alias nest_parallelization 'Loop Nest Parallelization'
alias coarse_grain_parallelization 'Coarse Grain Parallelization'
\end{verbatim}

\subsubsection{Allen \& Kennedy's Parallelization Algorithm}
\label{subsubsection-allen-kennedy-parallelization-algorithm}
\index{Parallelization}
\index{Allen \& Kennedy Algorithm}

%%@UserManualDocumentation: rice_all_dependence
Use A{\sc llen} \& K{\sc ennedy}'s algorithm and consider all
dependences.
%%ÿUserManualDocumentation

\begin{verbatim}
rice_all_dependence             > MODULE.parallelized_code
        < PROGRAM.entities 
        < MODULE.code MODULE.dg
\end{verbatim}

\subsubsection{Def-Use Based Parallelization Algorithm}

%%@UserManualDocumentation: rice_data_dependence
Several other parallelization functions for shared-memory target
machines are available. Function \verb+rice_data_dependence+ only takes into
account data flow dependences, a.k.a true dependences. It is of limited
interest because transitive dependences are computed. It is not
equivalent at all to performing array and scalar expansion based on direct
dependence computation (Brandes, Feautrier, Pugh).
%%ÿUserManualDocumentation

\begin{verbatim}
rice_data_dependence            > MODULE.parallelized_code
        < PROGRAM.entities 
        < MODULE.code MODULE.dg
\end{verbatim}

\subsubsection{Parallelization and Vectorization for Cray Multiprocessors}
\index{Cray}

%%@UserManualDocumentation: rice_cray
Function \verb+rice_cray+ targets Cray vector multiprocessors. It
selects one outermost parallel loop to use multiple processors and one
innermost loop for the vector units. It uses Cray microtasking
directives. Note that a prettyprinter option must also be selected independently (see
Section~\ref{subsection-parallel-printed-files}).
%%ÿUserManualDocumentation

\begin{verbatim}
rice_cray                   > MODULE.parallelized_code
        < PROGRAM.entities 
        < MODULE.code MODULE.dg
\end{verbatim}

\subsubsection{Global Loop Nest Parallelization}

%%@UserManualDocumentation: nest_parallelization
Function \verb+nest_parallelization+ is an attempt at combining loop
transformations and parallelization for perfectly nested
loops. Different parameters are computed like loop ranges and contiguous
directions for references. Loops with small ranges are fully
unrolled. Loops with large ranges are strip-mined to obtain vector and
parallel loops. Loops with medium ranges simply are parallelized. Loops
with unknown range also are simply parallelized.

For each loop direction, the amount of spatial and temporal localities
is estimated. The loop with maximal locality is chosen as innermost
loop.

This algorithm still is in the development stage. Do not use it!
%%ÿUserManualDocumentation

\begin{verbatim}
nest_parallelization                    > MODULE.parallelized_code
        < PROGRAM.entities 
        < MODULE.code MODULE.dg
\end{verbatim}


\subsubsection{SIMDizer for SIMD multimedia instruction set}

%%@UserManualDocumentation:  simd_atomizer
Here is yet another atomizer, based on 'new atomizer'. There are only
some minor differences with respect to new atomizer, except that it
does not atomize ``simple'' arguments (that is, arguments that are the
sum of a reference and a constant). This is needed to be able to
generate code that would potentially be efficient, whereas the
original atomizer would most of the time generate unusable code.
%%ÿUserManualDocumentation

\begin{verbatim}
alias simd_atomizer 'SIMD Atomizer'

simd_atomizer                      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

%%@UserManualDocumentation: simdizer_auto_unroll
Function \verb+simdizer_auto_unroll+ tries to unroll the code for
making the simdizing process more efficient. It thus tries to compute
the optimal unroll factor, allowing to pack the most instructions together.
%%ÿUserManualDocumentation

\begin{verbatim}
alias simdizer_auto_unroll 'SIMD-Auto Unroll'

simdizer_auto_unroll        > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

%%@UserManualDocumentation: simdizer
Function \verb+simdizer+ is an attempt at generating SIMD code for SIMD
multimedia instruction set such as MMX, SSE2, VIS,...
%%ÿUserManualDocumentation

\begin{verbatim}
alias simdizer 'Generate SIMD code'

simdizer                    > MODULE.code
        < PROGRAM.entities 
        < MODULE.code MODULE.dg
\end{verbatim}


\subsubsection{Coarse Grain Parallelization}
\label{subsubsection-coarse-grain-parallelization}

%%@UserManualDocumentation: coarse_grain_parallelization
Function \verb+coarse_grain_parallelization+ implements a loop parallelization
algorithm based on array regions. It considers only one loop at a time, its
body being abstracted by its invariant read and write regions. No loop
distribution is performed, but any kind of loop body is acceptable
whereas Allen\&Kennedy algorithm only copes with very simple loop bodies. 
%%ÿUserManualDocumentation

\begin{verbatim}
coarse_grain_parallelization > MODULE.parallelized_code
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.inv_regions
\end{verbatim}

\subsection{Code Distribution}
\label{subsection-code-distribution}
\index{Distribution}
\index{Automatic Distribution}

Two automatic code distribution techniques are implemented in \PIPS{} for
distributed-memory machines. The first one is based on the emulation of
a shared-memory. The second one is based on HPF.

\subsubsection{Shared-Memory Emulation}
\label{subsubsection-shared-memory-emulation}
\index{Emulated Shared Memory}
\index{Software Caching}
\index{WP65}

\WPsc{}~\cite{IA91,IA92a,IA92b} produces a new version of a module
transformed to be executed on a distributed memory machine. Each module
is transformed into two modules. One module, \verb+wp65_compute_file+,
performs the computations, while the other one, \verb+wp65_bank_file+,
emulates a shared memory.

This rule does not have data structure outputs, as the two new program
generated have computed names. This does not fit the {\em pipsmake} framework
too well, but is OK as long as nobody wishes to apply \PIPS{} on the
generated code, e.g. to propagate constant or eliminate dead code.

Note that use-use dependencies are used to allocate temporary arrays in
local memory (i.e. in the software cache).

This compilation scheme was designed by Corinne Ancourt and Fran\c{c}ois
Irigoin. It uses theoretical results in~\cite{AI91}. Its input is a very
small subset of Fortran program (e.g. procedure calls are not supported).
It was implemented by the designers, with help from Lei Zhou.

\begin{verbatim}
alias wp65_compute_file 'Distributed View'
alias wp65_bank_file 'Bank Distributed View'
wp65                            > MODULE.wp65_compute_file
                                > MODULE.wp65_bank_file
        ! MODULE.privatize_module
        < PROGRAM.entities
        < MODULE.code
        < MODULE.dg
        < MODULE.cumulated_effects
        < MODULE.chains
        < MODULE.proper_effects

\end{verbatim}

\subsubsection{HPF Compiler}
\label{subsubsection-hpf-compiler}
\index{HPF}
\index{HPFC}

The \HPFcompiler{} is a project by itself, developed by Fabien Coelho in
\PIPS{} framework.

A whole set of rules is used by the \PIPS{} \HPFcompiler{}, \HPFC{}. 
By the way, the whole compiler is just a big hack. {\em Fabien Coelho}.

\paragraph{HPFC Filter}

The first rule is used to apply a shell to put HPF-directives in an f77 parsable form.
Some shell script based on sed is used. The \verb+hpfc_parser+ must be
called to analyze the right file. This is trigerred automatically by the
bang selection in the \verb|hpfc_close| phase.

\begin{verbatim}
hpfc_filter             > MODULE.hpfc_filtered_file
    < MODULE.source_file
\end{verbatim}

\paragraph{HPFC Initialization}

The second HPFC rule is used to initialize the hpfc status and other data
structures global to the compiler. The HPF compiler
status is bootstrapped. The compiler status stores (or should store) all relevant
information about the HPF part of the program (data distribution, IO
functions and so on).

\begin{verbatim}
hpfc_init              > PROGRAM.entities
                       > PROGRAM.hpfc_status
    < PROGRAM.entities
\end{verbatim}

\paragraph{HPF Directive removal}

This phase removes the directives (some special calls) from the code.
The remappings (implicit or explicit) are also managed at this level,
through copies between differently shaped arrays. 

To manage calls with distributed arguments, I need to apply the directive
extraction bottom-up, so that the callers will know about the callees
through the \verb+hpfc_status+. In order to do that, I first thought of an
intermediate resource, but there was obscure problem with my fake calls. 
Thus the dependence static then dynamic directive analyses is enforced at
the bang sequence request level in the \verb|hpfc_close| phase.

The \verb|hpfc_static_directives| phase analyses static mapping directives
for the specified module. The \verb|hpfc_dynamic_directives| phase does
manages realigns and function calls with prescriptive argument
mappings. In order to do so it needs its callees' required mappings, hence
the need to analyze beforehand static directives. The code is cleaned from
the \verb|hpfc_filter| artifacts after this phase, and all the proper
information about the HPF stuff included in the routines is stored in
\verb|hpfc_status|. 

\begin{verbatim}
hpfc_static_directives         > MODULE.code
                        > PROGRAM.hpfc_status
    < PROGRAM.entities
    < PROGRAM.hpfc_status
    < MODULE.code

hpfc_dynamic_directives         > MODULE.code
                        > PROGRAM.hpfc_status
    < PROGRAM.entities
    < PROGRAM.hpfc_status
    < MODULE.code
    < MODULE.proper_effects
\end{verbatim}

\paragraph{HPFC actual compilation}

This rule launches the actual compilation. Four files are generated:

\begin{enumerate}
\item  the host code that mainly deal with I/Os, 
\item the SPMD node code, 
\item and some initialization stuff for the runtime (2 files).
\end{enumerate}

Between this phase and the previous
one, many PIPS standard analyses are performed, especially the regions and
preconditions.  Then this phase will perform the actual translation of the
program into a host and SPMD node code.

\begin{verbatim}
hpfc_compile           > MODULE.hpfc_host
                       > MODULE.hpfc_node
                       > MODULE.hpfc_parameters
                       > MODULE.hpfc_rtinit
                       > PROGRAM.hpfc_status
    < PROGRAM.entities
    < PROGRAM.hpfc_status
    < MODULE.regions
    < MODULE.summary_regions
    < MODULE.preconditions
    < MODULE.code
    < MODULE.cumulated_references
    < CALLEES.hpfc_host
\end{verbatim}

\paragraph{HPFC completion}

This rule deals with the compiler closing. It must deal with commons. The
hpfc parser selection is put here. Maybe not a very good idea? (FC:
explain! why not in \verb/hpfc_init/?) I guess
nobody should have to require intermediate targets such as ???. Ya!

\begin{verbatim}
hpfc_close             > PROGRAM.hpfc_commons
    ! SELECT.hpfc_parser
    ! SELECT.must_regions
    ! ALL.hpfc_static_directives
    ! ALL.hpfc_dynamic_directives
    < PROGRAM.entities
    < PROGRAM.hpfc_status
    < MAIN.hpfc_host
\end{verbatim}

\paragraph{HPFC install}

This rule performs the installation of HPFC generated files in a separate
directory. This rule is added to make hpfc usable from wpips and epips. I
got problems with the make and run rules, because it was trying to
recompute everything from scratch. To be investigated later on.

\begin{verbatim}
hpfc_install            > PROGRAM.hpfc_installation
    < PROGRAM.hpfc_commons

hpfc_make               

hpfc_run

\end{verbatim}




\section{Program Transformations}
\label{section-program-transformations}
\index{Transformation}
\index{Program Transformation}

%% Define here the documentation of the pseudo-function
%% "TheTransformations" that describes indeed the concept of
%% transformations in the user manual. This documentation is splitted
%% in two parts, one printed before the description of the various
%% transformations and another ("TheTransformationsAtEnd") afterwards
%% in the user manual:
%%@UserManualDocumentation: TheTransformations
A program transformation is a special phase which takes a code as
input, modifies it, possibly using results from several different
analyses, and puts back this modified code as result.
%%ÿUserManualDocumentation

%% This will be printed after the description of the transformations in
%% the user manual:
%%@UserManualDocumentation: TheTransformationsAtEnd
A rule describing a program transformation will never be chosen
automatically by \PIPSMAKE{} to generate some code since every
transformation rule contains a cycle for the \verb+MODULE.code+
resource. Since the first rule producing code, described in this file,
is \verb+controlizer+ and since it is the only non-cyclic rule, the
internal representation always is initialized with it.

As program transformations produce nothing else, pipsmake cannot guess
when to apply these rules automatically. This is exactly what the user
want most of the time: program transformations are under explicit
control by the user. Transformations are applied when the user pushes
one of \WPIPS{} transformation buttons or when (s)he enters an {\em
apply} command when running \TPIPS{}, or by executing a
\verb+Perform+ Shell script. See the introduction for pointers to the
user interfaces.

Unfortunately, it is sometime nice to be able to chain several
transformations without any user interaction. No general macro mechanism is
available in pipsmake, but it is possible to impose some program
transformations with the '!' command.

User inputs are not well-integrated although a \verb+user_query+ rule
and a \verb+string+ resource could easily be added. User interaction
with a phase are performed directly without notifying {\em pipsmake} to be
more flexible and to allow dialogues between a transformation and the user.
%%ÿUserManualDocumentation

\subsection{Loop Transformations}

\subsubsection{Loop Distribution}
\label{subsection-loop-distribution}
\index{Loop Distribution}

Function \verb+distributer+ is a restricted version of the
parallelization function \verb+rice+ (see
Section~\ref{subsubsection-allen-kennedy-parallelization-algorithm}).

%%@UserManualDocumentation: distributer
Distribute all the loops of the module.

Allen \& Kennedy's algorithm~\cite{AK87} is used in both cases. The only
difference is that \verb+distributer+ does not produce DOALL loops,
but just distributes loops as much as possible.
%%ÿUserManualDocumentation

\begin{verbatim}
alias distributer 'Distribute Loops'
distributer                    > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Loop Unrolling}
\label{subsection-loop-unrolling}
\index{Loop Unrolling}

\paragraph{Regular Loop Unroll}

%%@UserManualDocumentation: unroll
Unroll requests a loop label and an unrolling factor from the user.
Then it unrolls the specified loop as specified. The transformation is
very general, and it is interesting to run \verb+partial_eval+ and
\verb+suppress_dead_code+ and \verb+use_def_elimination+ after this
transformation.

Labels in the body are deleted. To unroll nested loops, start with the
innermost loop.

This transformation always is legal.
%%ÿUserManualDocumentation

\begin{verbatim}
alias unroll 'Loop Unroll'
unroll                          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\paragraph{Full Loop Unroll}

%%@UserManualDocumentation: full_unroll
A loop can also be fully unrolled if the range is numerically known.
``\PPartialEval'' may be usefully applied first.

This is only useful for small loop ranges.

Unrolling can be interactively applied and the user is requested a loop
label. Or pragma can be inserted as comments for loops to be unrolled.
%%ÿUserManualDocumentation

\begin{verbatim}
alias full_unroll 'Full Loop Unroll (Interactive)'
full_unroll                          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\begin{verbatim}
alias full_unroll_pragma 'Full Loop Unroll (Pragma)'
full_unroll_pragma                   > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Strip-mining}
\label{subsection-strip-mining}
\index{Strip-Mining}

%%@UserManualDocumentation: strip_mine
Strip-mine requests a loop label and either a chunk size or a chunk number.
Then it strip-mines the specified loop, if it is found. Note that the
DO/ENDDO construct is not compatible with such local program transformations.
%%ÿUserManualDocumentation

\begin{verbatim}
alias strip_mine 'Strip Mining'
strip_mine                          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Loop Interchange}
\label{subsection-loop-interchange}
\index{Loop Interchange}
\index{General Loop Interchange}

%%@UserManualDocumentation: loop_interchange
\verb/Loop_interchange/ requests a loop label and exchange the outer-most loop
with this label and the inner-most one in the same loop nest, if such a
loop nest exists.

Presently, legality is not checked.
%%ÿUserManualDocumentation

\begin{verbatim}
alias loop_interchange 'Loop Interchange'
loop_interchange                            > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Hyperplane Method}
\label{subsection-hyperplane-method}
\index{Hyperplane Method}

%%@UserManualDocumentation: hyperplane_method
\verb/Loop_hyperplane/ requests a loop label and a hyperplane direction
vector and applies the hyperplane method to the loop nest starting with this
loop label, if such a loop nest exists.

Presently, legality is not checked.
%%ÿUserManualDocumentation

\begin{verbatim}
alias loop_hyperplane 'Hyperplane Method'
loop_hyperplane                            > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Loop Nest Tiling}
\label{subsection-loop-nest-tiling}
\index{Tiling}

%%@UserManualDocumentation: loop_tiling
\verb/Loop_tiling/ requests from the user a numerical loop label and a
numerical partitioning matrix and applies the tiling method to the loop
nest starting with this loop label, if such a loop nest exists.

The partitioning matrix must be of dimension $n \times n$ where $n$ is the
loop nest depth. The default origin for the tiling is 0, but lower loop
bounds are used to adjust it and decrease the control overhead. For
instance, if each loop is of the usual kind, \verb+DO I = 1, N+, the
tiling origin is point (1, 1,...). The code generation is performed
according to the PPoPP'91 paper but redundancy elimination may results in
different loop bounds.

Presently, legality is not checked. There is no decision procedure to
select automatically an {\em optimal} partitioning matrix. Since the
matrix must be numerically known, it is not possible to generate a block
distribution unless all loop bounds are numerically known. It is assumed
that the loop nest is fully parallel.

Jingling Xue published an advanced code generation algorithm for tiling in
Parallel Processing Letters (htpp://cs.une.edu.au/~xue/pub.html).
%%ÿUserManualDocumentation

\begin{verbatim}
alias loop_tiling 'Tiling'
loop_tiling                            > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Loop Normalize}
\label{subsection-loop-normalize}
\index{Loop Normalize}

%%@UserManualDocumentation: loop_normalize
The loop normalization consists in transforming all the loops of a given
module into a normal form. In this normal form, the lower bound and the
increment are equal to one (1).

If we note the initial DO loop as:
\begin{tabbing}
xxxxxx \= xx \= \kill
\> {\tt DO I = lower, upper, incre}  \> \\
\> \> ... \\
\> {\tt ENDDO} \>
\end{tabbing}
the transformation gives the folowing code:
\begin{tabbing}
xxxxxx \= xx \= \kill
\> {\tt DO} \> {\tt NLC = 0, (upper - lower + incre)/incre - 1, 1} \\
\> \> {\tt I = incre*NLC + lower} \\
\> \> ... \\
\> {\tt ENDDO} \> \\
\> {\tt I =} \> {\tt ~incre * MAX((upper - lower + incre)/incre, 0) + lower}
\end{tabbing}

The normalization is done only if the initial increment is a constant
number. The normalization produces two assignment statements on the
initial loop index. The first one (at the beginning of the loop body)
assigns it to its value function of the new index and the second one
(after the end of the loop) assigns it to its final value.
%%ÿUserManualDocumentation

\begin{verbatim}
alias loop_normalize 'Loop Normalize'
\end{verbatim}

\begin{verbatim}
loop_normalize          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}


\subsubsection{Guard Elimination and Loop Transformations}
\label{subsection-guard-elimination}

Youcef Bouchebaba's implementation of unimodular loop transformations\ldots

\begin{verbatim}
guard_elimination       > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Tiling for sequences of loop nests }
\label{subsection-tiling-for-sequences-loop-ness}

%%@UserManualDocumentation: tiling_sequence
Tiling for sequences of loop nests
%%ÿUserManualDocumentation

Youcef Bouchebaba's implementation of Tiling for sequences of loop nests  \ldots
  
\begin{verbatim}
alias tiling_sequence 'Tiling sequence of loop nests'
\end{verbatim}

\begin{verbatim}
tiling_sequence      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}



%-----------End of Loop Transformations -------------------------

\subsection{Redundancy Elimination}

\subsubsection{Invariant Code Motion}
\label{subsection-invariant_code_motion}


%%@UserManualDocumentation: invariant_code_motion
This is a test to implement a invariant code motion. It doesn't work currently.
%%ÿUserManualDocumentation

\begin{verbatim}
invariant_code_motion             > MODULE.code
        < PROGRAM.entities 
        < MODULE.proper_effects
        < MODULE.code MODULE.dg
\end{verbatim}

\subsubsection{Partial Redundancy Elimination}
\label{subsection-partial_redundancy_elimination}


%%@UserManualDocumentation: partial_redundancy_elimination

In essence, a {\it partial redundancy} \cite{Much97} is a computation that is
done more than once on some path through a flowgraph. We implement here a
partial redundancy elimination transformation for logical
expressions such as bound checks by using informations given by
precondition analyses.

This transformation is implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}

alias partial_redundancy_elimination 'Partial Redundancy Elimination'

partial_redundancy_elimination             > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.preconditions
\end{verbatim}

%-----------End of Redundancy Elimination -------------------------

\subsection{Control-flow Optimizations}

\subsubsection{Dead Code Elimination}
\label{subsection-dead-code-elimination}
\index{Dead Code Elimination}
\index{Unreachable Code Elimination}
\index{If Simplification}
\index{Loop Simplification}

%%@UserManualDocumentation: suppress_dead_code
Function \verb+suppress_dead_code+ is used to delete non-executed code,
such as empty loop nests or zero-trip loops, for example after
strip-mining or partial evaluation. Preconditions are used to find always
true conditions in tests and to eliminate such tests. One-trip loops are
replaced by an index initialization and the loop body. Zero-trip loops are
replaced by an index initialization. Effects in bound computations are
preserved.

A lot of dead code can simply be eliminated by testing its precondition
feasibility. A very simple and fast test may be used if the preconditions
are normalized when they are computed, but this slows down the
precondition computation. Or non-normalized preconditions are stored in
the database and an accurate and slow feasibility test must be used.
Currently, the first option is used for assignments, calls, IOs and IF
statements but a stronger feasibility test is used for loops.

FORMAT statements are suppressed because they behave like a NOP command.
They should be gathered at the beginning or at the end of the module using
property \texttt{GATHER\_FORMATS\_AT\_BEGINNING} or
\texttt{GATHER\_FORMATS\_AT\_END}. The property must be set before the
control flow graph of the module is computed.

The cumulated effects are used in debug mode to display information.

Note that according to~\cite{Aho86}
and~\cite{Much97} , there may be confusion between Dead-code elimination
and Unreachable-code elimination. {\em Unreachable code} is code that
cannot possibly be executed, regardless of the input data. {\em Dead code}
elimination removes code that is executable but that has no effect on the
result of the computation being performed (see Section $18.1$ and Section
$18.10$ of~\cite{Much97} ). So \verb+suppress_dead_code+ in PIPS is in
fact unreachable code elimination. Dead code elimination is performed by
phase \verb|use_def_elimination| (see Section~\ref{Use-Def Elimination}).

The \verb+suppress_dead_code+ phase also performs some {\em If
  Simplifications} and {\em Loop Simplifications}~\cite{Much97}.

This function was designed and implemented by Ronan K{\sc eryell}.

%%ÿUserManualDocumentation

\begin{verbatim}
alias suppress_dead_code 'Dead Code Elimination'
suppress_dead_code          > MODULE.code
                            > MODULE.callees      
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < MODULE.cumulated_effects
        < MODULE.preconditions
\end{verbatim}

\subsubsection{Use-Def Elimination}
\label{subsection-use-def-elimination}
\index{Use-Def Elimination}

%%@UserManualDocumentation: use_def_elimination
Function \verb+use_def_elimination+ deletes statements whose def
references are all dead, i.e. are not used by later executions of
statements. It was developed by Ronan K{\sc eryell}. The algorithm compute
the set of live statements without fix-point. An initial set of live
statements is extended with new statements reached thru use-def chains,
control dependences and....

The initial set of live statements contains IO statements, RETURN, STOP,...

Note that use-def chains are computed intraproceduraly and not
interproceduraly. Hence some statements may be preserved because they
update a formal parameter although this formal parameter is no longer used
by the callers.

The dependence graph may be used instead of the use-def chains, but
Ronan Keryell, designer and implementer, did not produce convincing
evidence of the benefit... The drawback is the additional CPU time
required.

Known bug: FORMAT are found useless and eliminated.

Comments from Nga Nguyen : According to~\cite{Aho86} p. 595,  and~\cite{Much97} p. 592, a
variable is {\it dead} if it is not used on any path from the location in
the code where it is defined to the exit point of the routine in the
question ; an instruction is {\it dead} if it computes only values that
are not used on any executable path leading from the instruction. The
transformation that identifies and removes such dead code is called dead
code elimination. So in fact, Use-def elimination in PIPS is Dead code
elimination ! 

%%ÿUserManualDocumentation

\begin{verbatim}
alias use_def_elimination 'Use-Def elimination'
use_def_elimination          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < MODULE.chains
\end{verbatim}

\subsubsection{Control Restructurers}
\label{subsection-unspaghettify}
\index{Unspaghettify}
\index{Restructurer}
\index{Control Restructurer}

Two control restructurers are available: \verb/unspaghettify/ which is
used by default in conjunction with \verb/controlizer/ and
\verb/restructurer/ which must be explicitly applied\footnote{A property
  can be used to force the call to \texttt{restructurer} by
  \texttt{Controlizer}.}

\paragraph{Unspaghettify}

%%@UserManualDocumentation: unspaghettify
The \texttt{unspaghettifier} is a heuristic to clean up and to simplify
the control graphs of a module. It was developed by Ronan Keryell. It
is useful because the controlizer (see
Section~\ref{subsection-controlized-code}) or some transformation phases
can generate some {\em spaghetti} code with a lot of useless
unstructured code which can confuse some other parts of \PIPS{}. Dead code
elimination, for example, uses \texttt{unspaghettify}.

This control restructuring transformation can be automatically applied
in the \texttt{controlizer} phase (see
Section~\ref{subsection-controlized-code}) if the
\begin{center}
\verb|UNSPAGHETTIFY_IN_CONTROLIZER| 
\end{center}
property is true.

To add flexibility, the behavior of \texttt{unspaghettifier} is
controlled by the properties 
\begin{center}
\verb|UNSPAGHETTIFY_TEST_RESTRUCTURING|
and \verb|UNSPAGHETTIFY_RECURSIVE_DECOMPOSITION|
\end{center}
to allow more
restructuring from \verb|restructure_control| to be added in the
\texttt{controlizer} for example.

This function was designed and implemented by Ronan K{\sc eryell}.
%%ÿUserManualDocumentation
%% Control Graph Restructuring
\begin{verbatim}
alias unspaghettify 'Unspaghettify the Control Graph'
\end{verbatim}

\begin{verbatim}
unspaghettify          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}


\paragraph{Restructure Control}

%%@UserManualDocumentation: restructure_control
\verb|restructure_control| is a more complete restructuring phase that
is useful to improve the accuracy of various \PIPS{} phases.

It recursively implement TEST restructuring (replacing IF/THEN/ELSE
with GOTOs with structured IF/THEN/ELSE without any GOTOs when
possible) by applying pattern matching methods.

It also implement a recursive decomposition of the control flow graph
by an interval graph partitioning method.

Other restructuring methods are available in \PIPS{} with the TOOLPACK's
restructurer (see
Section~\ref{subsection-control-structure-normalization-stf}).
%%ÿUserManualDocumentation

\begin{verbatim}
alias restructure_control 'Restructure the Control Graph'

restructure_control          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Control Structure Normalisation (STF)}
\label{subsection-control-structure-normalization-stf}
\index{STF}
\index{Control Restructurer}

%%@UserManualDocumentation: stf
Transformation \texttt{stf} is a C interface to a Shell script used to
restructure a Fortran program using ISTST (via the combined tool
fragment ISTLY = ISTLX/ISTYP and then ISTST) from TOOLPACK~\cite{toolpack,Ost83}. 

Be careful, since TOOLPACK is written in Fortran, you need the Fortran
runtime libraries to run STF if is has not been statically compiled...

Known bug/feature: \texttt{stf} does not change resource \texttt{code} like
other transformations, but the \texttt{source} file. Transformations
applied before \texttt{stf} are lost. This should be changed in the near
future.

This transformation is now assumed redundant with respect to the native
PIPS control restucturers.
%%ÿUserManualDocumentation

\begin{verbatim}
alias stf 'Restructure with STF'
stf                      > MODULE.source_file
        < MODULE.source_file
\end{verbatim}

\subsubsection{Trivial Test Elimination}
\label{subsection-trivial-test-elimination}
\index{Trivial Test Elimination}

%%@UserManualDocumentation: suppress_trivial_test
Function \verb+suppress_trivial_test+ is used to delete the branch TRUE of
trivial test instruction. After apply \verb+suppress_trivial_test+, the condition of the
new test instruction is the condition correspondent to the branch FALSE of
the test initial.

This function was designed and implemented by Trinh Quoc Anh.
%%ÿUserManualDocumentation

\begin{verbatim}
alias suppress_trivial_test 'Trivial Test Elimination'
suppress_trivial_test          > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}



%\subsubsection{Declaration Common Addition}
%\label{subsection-declaration-common-addition}
%\index{Declaration Common Addition}%


%Function \verb+add_declaration_common+ is used to add the declarations of
%all the variables common of a whole program into each module. After apply
%\verb+add_declaration_common+, all of the old declarations common had
%insteaded by one new declaration.%

%This function was designed and implemented by Trinh Quoc Anh.


%\begin{verbatim}
%alias add_declaration_common 'Declaration Common Addition'
%add_declaration_common          > MODULE.code
%        < PROGRAM.entities
%        < MODULE.code
%\end{verbatim}

%-----------End of Control-flow Optimizations -------------------------


\subsection{Expression Transformations}

\subsubsection{Atomizers}
\label{subsection-atomizers}
\index{Atomizer}
\index{Three-Address Code}

%%@UserManualDocumentation: atomizer
Atomizer produces, or should produce, three-address like instructions,
in Fortran. An atomic instructions is an instruction that contains no
more than three variables, such as {\tt A = B op C}. The result is a
program in a low-level Fortran on which you are able to use all the
others passes of \PIPS{}.

Atomizers are used to simplify the statement encountered by automatic
distribution phases. For instance, indirect addressing like
\verb/A(B(I)) = .../ is replaced by \verb/T=B(I);A(T) = .../.
%%ÿUserManualDocumentation

\paragraph{General Atomizer}

\begin{verbatim}
alias atomizer 'Atomizer'
atomizer                      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.dg
\end{verbatim}

\paragraph{Limited Atomizer}

%%@UserManualDocumentation:  new_atomizer
Here is a new version of the atomizer using a small atomizer from
the HPF compiler (see Section~\ref{subsubsection-hpf-compiler}).
%%ÿUserManualDocumentation
\begin{verbatim}
alias new_atomizer 'New Atomizer'
new_atomizer                      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

An atomizer is also used by WP65 (see
Section~\ref{subsubsection-shared-memory-emulation})

\subsubsection{Partial Evaluation}
\label{subsection-partial-evaluation}
\index{Partial Evaluation}

%%@UserManualDocumentation: partial_eval
Function \verb+Partial_eval+ produces code where {\em numerical} constant
expressions or subexpressions are replaced by their value. Using the
preconditions, some variables are evaluated to a integer constant, and
replaced wherever possible. They are not replaced in user function calls
because Fortran uses a call-by-reference mechanism and because they might
be updated by the function. For the same conservative reason, they are not
replaced in intrinsics calls.

Note that {\em symbolic} constants were left unevaluated because they
already are constant. However it was found unfriendly by users because the
principle of least surprise was not enforced: symbolic constants were
sometimes replaced in the middle of an expression but not when the whole
expression was a reference to a symbolic constant. Symbolic integer
constants are now replaced by their values systematically.

Transformations \verb/dead_code_elimination/ and \verb/use_def_elimination/ should be
performed after partial evaluation. It is sometimes important to run
more than one partial evaluation in a row, because the first partial
evaluation may linearize some initially non-linear expressions. Perfect
Club benchmark {\tt ocean} is a case in point.

Comments from Nga Nguyen: According to~\cite{Aho86} and~\cite{Much97}, the
name of this optimization should be Constant-Expression Evaluation or
Constant Folding for integer values. This transformation produces well
error message at compile time indicating potential error such as division
by zero.  
%%ÿUserManualDocumentation

\begin{verbatim}
alias partial_eval 'Partial Eval'
partial_eval                    > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < MODULE.cumulated_effects
        < MODULE.preconditions
\end{verbatim}

This function was implemented initially by Bruno Baron.

\subsubsection{Reduction Detection}
\label{subsection-reduction-detection}
\index{Reduction Detection}

Phase \texttt{Reductions} detects generalized instructions and replaces
them by calls to a run-time library supporting parallel reductions. It was
developed by Pierre Jouvelot in CommonLISP, as a prototype, to show than
NewGen data structures were language-neutral. Thus it by-passes some of 
{\em pipsmake/dbm} facilities.

This phase is now obsolete, although reduction detection is critical for
code restructuring and optimization... A new reduction detection phase was
implemented by Fabien Coelho. It does not include a code transformation.
Its result could be prettyprinted in an HPF style (FC: implementation?).

\begin{verbatim}
old_reductions                      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Forward Substitution}

Scalars can be forward substitute. The effect is to undo already performed
optimizations such as invariant code motion and common subexpressions, or
manual atomization. However we hope to do a better job automatically!

\begin{verbatim}
alias forward_substitute 'Forward Substitution'

forward_substitute      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < MODULE.cumulated_effects
\end{verbatim}


\subsubsection{Expression Optimizations}
\label{subsection-expression-optimizations}

%%@UserManualDocumentation: optimize_expressions
This is an experimental section developped by Julien Zory as PhD work.
This phase aims at optimizing expression evaluation using algebraic
properties such as associativity, commutativity, neutral elements and so
forth.

This phase restructure arithmetic expressions in order (1) to decrease the
number of operations (e.g. through factorization), (2) to increase the ILP
by keeping the corresponding DAG wide enough, (3) to facilitate the
detection of composite instructions such as multiply-add, (4) to provide
additional opportunities for (4a) invariant code motion (ICM) and (4b)
common subexpression elimination (CSE).

Large arithmetic expressions are first built up via forward substitution
when the programmer has already applied ICM and CES by hand.

The optimal restructuring of expressions depends on the target defined by
a combination of the computer architecture and the compiler. The target is
specified by a string property called \verb|EOLE_OPTIMIZATION_STRATEGY|
which can take values such as \verb|"P2SC"| for IBM Power-2 architecture
and XLF~4.3. To activate all sub-transformations such as ICM and CSE set
it to \verb|"FULL"|. See \PROPERTIES{} for more information about values
for this property and about other properties controlling the behavior of
this phase.

The current implementation is still shaky and does not handle well
expressions of mixed types such as \verb|X+1| where \verb|1| is implictly
promoted from integer to real.
%%ÿUserManualDocumentation
\begin{verbatim}
alias optimize_expressions 'Optimize Expressions'

optimize_expressions    > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}


%-----------End of Expression Transformations -------------------------

\subsection{Declaration Transformations}

\subsubsection{Declarations cleaning}

Clean the declarations of unused variables and commons and so.
It is not really a code transformation, since only the module entity is
updated by the process, but it is put as so since it should affect the
prettyprint. 

%%@UserManualDocumentation: clean_declarations
Clean the declarations of unused variables and commons and so.
%%ÿUserManualDocumentation
\begin{verbatim}

alias clean_declarations 'Clean Declarations'

clean_declarations      > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Array Resizing}
\label{subsubsection-array-resizing}

One problem of Fortran code is the unnormalized array bound
declarations. In many program, the programmer put an asterisk
(assumed-size array declarator), even 1 for every
upper bound of last dimension of array declaration. This feature affects
code quality and prevents others analyses such as array bound checking,
alias analysis. We developed in PIPS two new methods to find out
automatically the proper upper bound for the unnormalized and assumed-size
array declarations, a process we call {\em array resizing}. Both
approaches have advantages and drawbacks and maybe a combination of these
ones is needed.

To have 100\% resized arrays, we implement also the code instrumentation
task, in the top-down approach. 

Different options to compute new declarations for different kinds of
arrays are described in properties-rc.tex. You can combine the two
approaches to have a better results by using these options. 

How to use these approaches: after generating new declarations in the
logfile, you have to use the script 
\$PIPS\_ROOT/Src/Script/misc/array\_resizing\_instrumentation.pl to replace the unnormalized
declarations and add new assignments in the source code. 

\paragraph{ Top Down Array Resizing}
%%@UserManualDocumentation: array_resizing_top_down

The  method uses the relationship between actual and formal arguments from parameter-passing
rules. New array declarations in the called procedure are
computed with respect to the declarations in the calling procedures. 
It is  faster than the first one because array regions are not needed. 

This phase is implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_resizing_top_down 'Top Down Array Resizing'
array_resizing_top_down         > MODULE.new_declarations
                                > PROGRAM.entities
        < PROGRAM.entities
        < CALLERS.code
        < CALLERS.new_declarations
        < CALLERS.preconditions
\end{verbatim}

\paragraph{Bottom Up Array Resizing}

%%@UserManualDocumentation: array_resizing_bottom_up

The approach is based on an array region analysis that gives
  information about the set of array elements accessed during the
  execution of code. The regions READ and WRITE of each
array in each module are merged and a new value for the upper bound of the last
dimension is calculated and then it will replace the 1 or *. 

This function is firstly implemented by Trinh Quoc Anh, and ameliorated by
Corinne Ancourt, Nguyen Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_resizing_bottom_up 'Bottom Up Array Resizing'
array_resizing_bottom_up         > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.preconditions
        < MODULE.regions
\end{verbatim}

\paragraph{Array Resizing Statistic }

We provide here a tool to calculate the number of pointer-type A(,1) and
assumed-size A(,*) array declarators as well as other information.

\begin{verbatim}
alias array_resizing_statistic 'Array Resizing Statistic'
array_resizing_statistic   > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
\end{verbatim}

%-----------End of Declaration Transformations -------------------------

\subsection{Array Bound Checking}
\label{subsection-array-bound-checking}

Array bound checking refers to determining whether all array references
are within their declared range in all of their uses in a program. These
array  bound checks may be analyses intraprocedurally or
interprocedurally, depending on the need for accuracy. 

There are two versions of intraprocedural array bounds checking: 

\subsubsection{Elimination of Redundant Tests}
\label{subsection-array-bound-check_bottom_up}

%%@UserManualDocumentation: array_bound_check_bottom_up 
This transformation takes as input the current module, adds array range
checks (lower and upper bound checks) to every statement that has one or
more array accesses. The output is the module with those added tests.

If one test is trivial or exists already for the same statement, it is
no need to be generated in order to reduce the
number of tests.  As Fortran language permits an assumed-size array
declarator with the unbounded upper bound of the last dimension, no range check is generated for this case also.

Associated with each test is a bound violation error message and in case
of real access violation, a STOP statement will be put before the current
statement. 

This phase is always followed by the \verb/partial_redundancy_elimination/ for logical
expression in order to reduce the number of bound checks.  
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_bound_check_bottom_up 'Elimination of Redundant Tests'
array_bound_check_bottom_up            > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
\end{verbatim}


\subsubsection{Insertion of Unavoidable Tests}
\label{subsection-array-bound-check_top_down}

%%@UserManualDocumentation: array_bound_check_top_down
This second implementation is based on the array region analyses phase which benefits some interesting proven properties: 

\begin{enumerate}

\item If a MAY region correspond to one node in the control flow graph
  that represents a block of code of program is included in the
  declared dimensions of the array, no bound check is needed for this
  block of code.
 
\item If a MUST region correspond to one node in the control 
  flow graph that represents a block of code of program contains elements
  which are outside the declared dimensions of the  array, there is
  certainly bound violation in this block of code. An error can be
  detected just in compilation time. 

\end{enumerate}

If none of these two properties are satisfied, we consider the
approximation of region. In case of MUST region, if the exact bound checks
can be generated, they will be inserted before the block of code. If not, like in
case of MAY region, we continue to go down to the children nodes in the
control flow graph.    

 The main advantage
of this algorithm is that it permits to detect the sure bound violations
or to tell that there is certainly no bound violation as soon as
possible, thanks to the context given by preconditions and the top-down
analyses. 
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_bound_check_top_down 'Insertion of Unavoidable Tests'
array_bound_check_top_down   > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.regions
\end{verbatim}

\subsubsection{Interprocedural Array Bound Checking}
\label{subsection-array-bound-check_interprocedural}

%%@UserManualDocumentation: array_bound_check_interprocedural
This phase checks for out of bound error when passing arrays or array
elements as arguments in procedure call. It ensures that there is no bound
violation in every array access in the callee procedure, with respect to
the array declarations in the caller procedure.
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_bound_check_interprocedural 'Interprocedural Array Bound Checking'
array_bound_check_interprocedural             > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.preconditions
\end{verbatim}

\subsubsection{Array Bound Checking Instrumentation }
\label{subsection-array-bound-check_instrumentation}

%%@UserManualDocumentation: array_bound_check_instrumentation

We provide here a tool to calculate the number of dynamic bound checks
from both initial and PIPS generated code.

These transformations are implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}
alias array_bound_check_instrumentation 'Array Bound Checking Instrumentation'
array_bound_check_instrumentation > MODULE.code
        < PROGRAM.entities 
        < MODULE.code
\end{verbatim}

\subsection{Alias Verification}
\label{subsection-alias-verification}

\subsubsection{Alias Propagation}
\label{subsubsection-alias-propagation}
\index{Alias Propagation}

%%@UserManualDocumentation: alias_propagation

\textit {Aliasing} occurs when two or more variables refer to the same
storage location at the same program point. Alias analysis is critical for
performing most optimizations correctly because we must know for certain
that we have to take into account 
all the ways a location, or the value of a variable, may (or must)
be used or changed. Compile-time alias information is also important for
program verification, debugging and understanding.

In Fortran 77, parameters are passed by address in such
a way that, as long as the actual argument is associated with a named
storage location, the called subprogram can change the value of the actual
argument by assigning a value to the corresponding formal parameter. So
new aliases can be created between formal parameters if the
same actual argument is passed to two or more formal parameters, or between formal
parameters and global parameters if an actual
argument is an object in common storage which is also visible in the
called subprogram or other subprograms in the call chain below it.

Both \textit{intraprocedural} and \textit{interprocedural} alias
determinations are important for program analysis. Intraprocedural aliases
occur due to pointers in languages like LISP, C, C++ or Fortran 90,
union construct in C or \verb+EQUIVALENCE+ in Fortran. Interprocedural aliases
are generally created by parameter passing and by access to global
variables, which propagates intraprocedural aliases  across procedures and
introduces new aliases.     

The basic idea for computing interprocedural aliases is to follow all the
possible chains of argument-parameters and nonlocal variable-parameter
bindings at all call sites. We introduce a \textit{naming memory
  locations} technique which guarantees the correctness and enhances the
precision of data-flow analysis. The technique associates sections,
offsets of actual parameters to formal parameters following a certain call
path. Precise alias information are computed for both scalar and array
variables. The analysis is called alias propagation.

This analysis is implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}

alias_propagation           > MODULE.alias_associations
        < PROGRAM.entities 
        < MODULE.code
        < CALLERS.alias_associations
        < CALLERS.code

\end{verbatim}

\subsubsection{Alias Checing}
\label{subsubsection-alias-check}
\index{Alias Checking}

%%@UserManualDocumentation: alias_check

With the call-by-reference mechanism in Fortran 77, new aliases can be
created between formal parameters if the
same actual argument is passed to two or more formal parameters, or between formal
parameters and global parameters if an actual
argument is an object in common storage which is also visible in the
called subprogram or other subprograms in the call chain below it.

Restrictions on association of entities in Fortran 77 (Section 15.9.3.6
\cite{ANSI83}) say that neither aliased formal parameters nor the variable in the
common block may become defined during execution
of the called subprogram or the others subprograms in the call chain.

This phase uses information from the alias\_propagation
analysis and computes the definition
informations of variables in a program, and then to verify
statically if the program violates the standard restriction on alias or
not. If these informations are not known at compile-time, we instrument
the code with tests that check the violation dynamically during
execution of program. 

This verification is implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

% Attention : will we use the preconditions, regions, effects ? 
% They are may be wrong 

\begin{verbatim}
alias alias_check 'Alias Check'
alias_check   > MODULE.code
        < PROGRAM.entities 
        < MODULE.alias_associations
        < MODULE.cumulated_effects
        < ALL.code
\end{verbatim}

\subsection{Used Before Set}
\label{subsection-used-before_set}

%%@UserManualDocumentation: used_before_set
This analysis checks if the program uses a variable or an array element
which has not been assigned a value. In this case, anything may happen:
the program may appear to run normally, or may
crash, or may behave unpredictably. We use IN regions
that give a set of read variables not previously written. Depending on the
nature of the variable: local, formal or global, we have different
cases. In principle, it
works as follows: if we have a MUST IN region at the module statement, the
corresponding variable must be used before
being defined, a STOP is inserted. Else, we insert an initialization
function and go down, insert a verification function before each MUST IN
at each sub-statements.   

This is a top-down analysis that process a procedure before all its
callees. Information given by callers is used to verify if we have to
check for the formal parameters in the current module or not. In addition,
we produce information in the resource MODULE.ubs to tell if the formal
parameters of the called procedures have to be checked or not.  
 
This verification is implemented by NGUYEN Thi Viet Nga.
%%ÿUserManualDocumentation

\begin{verbatim}
alias used_before_set 'Used Before Set'
used_before_set   > MODULE.ubs
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.in_regions
        < CALLERS.ubs
\end{verbatim}


\subsection{Miscellanous Transformations}

\subsubsection{Type Checker}
\label{subsection-type-checker}
\index{TypeChecker}

Typecheck code according to Fortran standard + double-complex.
Typechecking is performed interprocedurally for user-defined functions.
Insert type conversions where implicitly needed. 
Use typed intrinsics instead of generic ones.
Precompute constant conversions if appropriate (e.g. 16 to 16.0E0).
Add comments about type errors detected in the code.
Report back how much was done.

\begin{verbatim}
type_checker            > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.code
\end{verbatim}


\subsubsection{Scalar and Array Privatization}
\label{subsection-scalar-and-array-privatization}
\index{Privatization}
\index{Array Privatization}

Variable privatization consists in discovering variables whose values are
local to a particular scope, usually a loop iteration.

Three different privatization functions are available. The {\em quick}
privatization is restricted to loop indices and is included in the
dependence graph computation (see
Section~\ref{subsection-dependence-graph}). The scalar privatization should
be applied before any serious parallelization attempt. The array
privatization is much more expensive and still is mainly experimental.

\paragraph{Scalar Privatization}
\index{Scalar Privatization}

%%@UserManualDocumentation: privatize_module 
Privatizer detects variables that are local to a loop nest and marks
these variables as private. A variable is private to a loop if the
values assigned to this variable inside the loop cannot reach a
statement outside the loop body.
%%ÿUserManualDocumentation

\begin{verbatim}
alias privatize_module 'Privatize Scalars'
privatize_module                    > MODULE.code
        < PROGRAM.entities 
        < MODULE.code 
        < MODULE.proper_effects
        < MODULE.cumulated_effects
        < MODULE.chains
\end{verbatim}

\paragraph{Array Privatization}
\index{Array Privatization}

%%@UserManualDocumentation: array_privatizer
Array privatization aims at privatizing arrays (option
\verb|array_privatizer|) or sets of array elements
(\verb|array_section_privatizer|) instead of scalar variables only.
The algorithm used, developed by B\'eatrice C{\sc reusillet}, is very
different from the algorithm used for solely privatizing scalar
variables. It uses IN and OUT regions. Of course, it can also
privatize scalar variables, although the algorithm is much more
expensive and as such should be used only when necessary.
  
Moreover, {\em array section\/} privatization is still experimental and
should be used with great care. In particular, it is not compatible with the
next steps of the parallelization process, i.e. dependence tests and code
generation.

Scalar and entire array privatization is accessible via the Transform/Edit
menu, while the results of scalar and array section privatization can be
accessed via the option panel (sequential or user view). Private array
sections are then displayed as array regions.

Another transformation, which can also be called a \emph{privatization},
consists in declaring as \emph{local} to a procedure or function the
variables which are used only locally. This happens quite frequently in old
codes where variables are declared as {\tt SAVE}d to avoid allocations at
each invocation of the routine. However, this prevents parallelization of
the loop surrounding the calls. The function which performs this
transformation is called \verb|declarations_privatizer|.
%%ÿUserManualDocumentation


%%@UserManualDocumentation: declarations_privatizer

%%ÿUserManualDocumentation

\begin{verbatim}
alias array_privatizer 'Privatize Scalars & Arrays'
alias array_section_privatizer 'Scalar and Array Section Privatization'
alias declarations_privatizer 'Declaration Privatization'
\end{verbatim}

\begin{verbatim}
array_privatizer             > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.transformers
        < MODULE.preconditions
        < MODULE.regions
        < MODULE.in_regions
        < MODULE.out_regions

array_section_privatizer             > MODULE.code
                                     > MODULE.privatized_regions
                                     > MODULE.copy_out_regions
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.transformers
        < MODULE.preconditions
        < MODULE.regions
        < MODULE.in_regions
        < MODULE.out_regions

declarations_privatizer              > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.regions
        < MODULE.in_regions
        < MODULE.out_regions

\end{verbatim}


\subsubsection{Freeze variables}
\label{subsection-freeze-variables}
\index{freeze variables}

%%@UserManualDocumentation: freeze_variables
Function \verb+freeze_variables+ produces code where variables 
given by the user are frozen.
%%ÿUserManualDocumentation

\begin{verbatim}
alias freeze_variables 'Freeze Variables'
freeze_variables                   > MODULE.code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Manual Editing}

The window interfaces let the user edit the source files. As with
\texttt{stf}, editing is not integrated like other program
transformations, and previously applied transformations are lost.
Consistency is however always preserved.

A general edit facility fully integrated in \texttt{pipsmake} is planned
for the (not so) near future. Not so near because user demand for this
feature is low.

\subsubsection{Cloning}

%%@UserManualDocumentation: clone
User assisted cloning.
%%ÿUserManualDocumentation
\begin{verbatim}

alias clone 'Manual Clone'

clone                   > CALLERS.code
                        > CALLERS.callees
        < MODULE.code
        < MODULE.callers
        < MODULE.user_file
        < CALLERS.callees
        < CALLERS.code
\end{verbatim}

%%@UserManualDocumentation: clone_substitute
%%ÿUserManualDocumentation

\begin{verbatim}
alias clone_substitute 'Manual Clone Substitution'

clone_substitute        > CALLERS.code
                        > CALLERS.callees
        < MODULE.code
        < MODULE.callers
        < MODULE.user_file
        < CALLERS.callees
        < CALLERS.code
\end{verbatim}

%%@UserManualDocumentation: clone_on_argument

Cloning of a subroutine according to an integer scalar argument.
The argument is specified thru integer property 
\verb|TRANSFORMATION_CLONE_ON_ARGUMENT|. If set to $0$, a user request is
performed. 
%%ÿUserManualDocumentation

\begin{verbatim}
alias clone_on_argument 'Clone On Argument'

clone_on_argument       > CALLERS.code
                        > CALLERS.callees
                        > MODULE.callers
        < MODULE.code
        < MODULE.callers
        < MODULE.user_file
        < CALLERS.callees
        < CALLERS.preconditions
        < CALLERS.code
\end{verbatim}

\subsubsection{Transformation Test}
\label{subsection-transformation_test}

%%@UserManualDocumentation: transformation_test
This is plug to implement quickly a program transformation requested by a
user. Currently, it is a full loop distribution suggested by Alain Darte
to compare different implementations, namely Nestor and PIPS.
%%ÿUserManualDocumentation
\begin{verbatim}
alias transformation_test 'Transformation Test'

transformation_test    > MODULE.code
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}


\section{Output Files (Prettyprinted Files)}
\label{section-output-files}
\index{Prettyprinter}

\PIPS{} results for any analysis and/or transformations can be
displayed in several different formats. User views are the closest one
to the initial user source code. Sequential views are obtained by
prettyprinting the \PIPS{} internal representation of modules. Code
can also be displayed graphically or using EMACS facilities (through a
property). Of course, parallelized versions are available. At the
program level, call graph and interprocedural control flow graphs,
with different degrees of elipse, provide interesting summaries.

Dependence graphs can be shown, but they are not user-friendly. No
filtering interface is available. They mainly are useful for debugging
and for teaching purposes.

\subsection{Parsed Printed Files (User View)}

%%@UserManualDocumentation: parsed_printed_file
\label{sec:parsed_printed_files}
\label{subsection-parsed-printed-files}
These are files containing a pretty-printed version of the {\em parsed} code,
before the controlizer is applied. It is the code display closest to the
user source code, because arcs in control flow graphs do not have to be
rewritten as {\tt GOTO} statements. However, it is inconsistent with the
internal representation of the code as soon a a code transformation
has been applied.

Bug: the inconsistence between the user view and the internal code
representation presently is not detected. Solution: do not use user views.

The Fortran statements may be
decorated with preconditions or transformers or complexities or any kind
of effects, including regions,... depending on the
prettyprinter selected used to produce this file.

Transformers and preconditions require cumulated effects to build the
module value basis.
%%ÿUserManualDocumentation

\subsubsection{Menu for User Views}

\begin{verbatim}
alias parsed_printed_file 'User View'

alias print_source 'Basic'
alias print_source_transformers 'With Transformers'
alias print_source_preconditions 'With Preconditions'
alias print_source_total_preconditions 'With Total Preconditions'
alias print_source_regions 'With Regions'
alias print_source_in_regions 'With IN Regions'
alias print_source_out_regions 'With OUT Regions'
alias print_source_complexities 'With Complexities'
alias print_source_proper_effects 'With Proper Effects'
alias print_source_cumulated_effects 'With Cumulated Effects'
alias print_source_in_effects 'With IN Effects'
alias print_source_out_effects 'With OUT Effects'
alias print_source_continuation_conditions 'With Continuation Conditions'
\end{verbatim}

\subsubsection{Standard User View}

%%@UserManualDocumentation: print_source
Display the code without any decoration.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source         > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
\end{verbatim}

\subsubsection{User View with Transformers}

%%@UserManualDocumentation: print_source_transformers
Display the code decorated with the transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_transformers         > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{User View with Preconditions}

%%@UserManualDocumentation: print_source_preconditions
Display the code decorated with the preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_preconditions        > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.preconditions
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{User View with Total Preconditions}

%%@UserManualDocumentation: print_source_total_preconditions
Display the code decorated with the total preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_total_preconditions        > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.total_preconditions
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{User View with Continuation Conditions}

%%@UserManualDocumentation: print_source_continuation_conditions
Display the code decorated with the continuation conditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_continuation_conditions   > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.must_continuation
        < MODULE.may_continuation
        < MODULE.must_summary_continuation
        < MODULE.may_summary_continuation        
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{User View with Regions}

%%@UserManualDocumentation: print_source_regions
Display the code decorated with the regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_regions              > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code 
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{User View with IN Regions}

%%@UserManualDocumentation: print_source_in_regions
Display the code decorated with the IN regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_in_regions              > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{User View with OUT Regions}

%%@UserManualDocumentation: print_source_out_regions
Display the code decorated with the OUT regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_out_regions              > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}


\subsubsection{User View with Complexities}
\index{Complexity}

%%@UserManualDocumentation: print_source_complexities
Display the code decorated with the complexities.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_complexities         > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.complexities
        < MODULE.summary_complexity
\end{verbatim}

\subsubsection{User View with Proper Effects}

%%@UserManualDocumentation: print_source_proper_effects
Display the code decorated with the proper effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_proper_effects       > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        <  MODULE.proper_effects
\end{verbatim}

\subsubsection{User View with Cumulated Effects}

%%@UserManualDocumentation: print_source_cumulated_effects
Display the code decorated with the cumulated effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_cumulated_effects    > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{User View with IN Effects}
%%@UserManualDocumentation: print_source_in_effects
Display the code decorated with its IN effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_in_effects       > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.in_effects
        < MODULE.in_summary_effects
\end{verbatim}

\subsubsection{User View with OUT Effects}
%%@UserManualDocumentation: print_source_out_effects
Display the code decorated with its OUT effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_source_out_effects       > MODULE.parsed_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.out_effects
        < MODULE.out_summary_effects
\end{verbatim}



\subsection{Printed File (Sequential Views)}

%%@UserManualDocumentation: printed_file
These are files containing a pretty-printed version of the internal
representation, \verb+code+.

The Fortran statements may be decorated with the result of any analysis,
e.g.complexities, preconditions, transformers, regions,\ldots{} depending on
the printer used to produce this file.

Transformers and preconditions (and regions?) require cumulated effects
to build the module value basis.
%%ÿUserManualDocumentation

\subsubsection{Menu for Sequential Views}

\begin{verbatim}
alias printed_file 'Sequential View'

alias print_code 'Statements Only'
alias print_code_transformers 'Statements & Transformers'
alias print_code_complexities 'Statements & Complexities'
alias print_code_preconditions 'Statements & Preconditions'
alias print_code_total_preconditions 'Statements & Total Preconditions'
alias print_code_regions 'Statements & Regions'
alias print_code_complementary_sections 'Statements & Complementary Sections'
alias print_code_in_regions 'Statements & IN Regions'
alias print_code_out_regions 'Statements & OUT Regions'
alias print_code_privatized_regions 'Statements & Privatized Regions'
alias print_code_proper_effects 'Statements & Proper Effects'
alias print_code_in_effects 'Statements & IN Effects'
alias print_code_out_effects 'Statements & OUT Effects'
alias print_code_cumulated_effects 'Statements & Cumulated Effects'
alias print_code_proper_reductions 'Statements & Proper Reductions'
alias print_code_cumulated_reductions 'Statements & Cumulated Reductions'
alias print_code_static_control 'Statements & Static Controls'
alias print_code_continuation_conditions 'Statements & Continuation Conditions'
alias print_code_proper_regions 'Statements & Proper Regions'
alias print_code_proper_references 'Statements & Proper References'
alias print_code_cumulated_references 'Statements & Cumulated References'
alias print_initial_precondition 'Initial Preconditions'
\end{verbatim}

\subsubsection{Standard Sequential View}
\label{subsubsection-standard-sequential-view}
\index{Sequential View}

%%@UserManualDocumentation: print_code
Display the code without any decoration.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code                      > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Sequential View with Transformers}

%%@UserManualDocumentation: print_code_transformers
Display the code decorated with the transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_transformers         > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Initial Preconditions}

\begin{verbatim}
print_initial_precondition  > MODULE.printed_file
        < MODULE.initial_precondition
        < PROGRAM.entities

print_program_precondition  > PROGRAM.printed_file
        < PROGRAM.program_precondition
        < PROGRAM.entities
\end{verbatim}

\subsubsection{Sequential View with Complexities}

%%@UserManualDocumentation: print_code_complexities
Display the code decorated with the complexities.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_complexities         > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.complexities
        < MODULE.summary_complexity
\end{verbatim}

\subsubsection{Sequential View with Preconditions}

%%@UserManualDocumentation: print_code_preconditions
Display the code decorated with the preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_preconditions        > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.preconditions
        < MODULE.summary_precondition
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Sequential View with Total Preconditions}

%%@UserManualDocumentation: print_code_preconditions
Display the code decorated with the total preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_total_preconditions        > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.total_preconditions
        < MODULE.summary_total_precondition
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Sequential View with Continuation Conditions}

%%@UserManualDocumentation: print_code_continuation_conditions
Display the code decorated with the continuation preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_continuation_conditions   > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.parsed_code
        < MODULE.must_continuation
        < MODULE.may_continuation
        < MODULE.must_summary_continuation
        < MODULE.may_summary_continuation        
        < MODULE.cumulated_effects
\end{verbatim}


\subsubsection{Sequential View with Regions}

%%@UserManualDocumentation: print_code_regions
Display the code decorated with the regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_regions              > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Sequential View with Proper Regions}

%%@UserManualDocumentation: print_code_proper_regions
Display the code decorated with the proper regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_proper_regions              > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.proper_regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Sequential View with IN Regions}

%%@UserManualDocumentation: print_code_in_regions
Display the code decorated with the IN regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_in_regions              > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Sequential View with OUT Regions}

%%@UserManualDocumentation: print_code_out_regions
Display the code decorated with the OUT regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_out_regions              > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Sequential View with Privatized Regions}

%%@UserManualDocumentation: print_code_privatized_regions
Display the code decorated with the privatized regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_privatized_regions       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.cumulated_effects
        < MODULE.summary_effects
        < MODULE.privatized_regions
        < MODULE.copy_out_regions
\end{verbatim}

\subsubsection{Sequential View with Complementary Sections}

%%@UserManualDocumentation: print_code_complementary_sections
Display the code decorated with complementary sections.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_complementary_sections > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.compsec
        < MODULE.summary_compsec
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Sequential View with Proper Effects}

%%@UserManualDocumentation: print_code_proper_effects
Display the code decorated with the proper effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_proper_effects       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
\end{verbatim}

%%@UserManualDocumentation: print_code_proper_references
Display the code decorated with the proper references.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_proper_references       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_references
\end{verbatim}

\subsubsection{Sequential View with Cumulated Effects}

%%@UserManualDocumentation: print_code_cumulated_effects
Display the code decorated with the cumulated effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_cumulated_effects    > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

%%@UserManualDocumentation: print_code_cumulated_references
Display the code decorated with the cumulated references.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_cumulated_references    > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_references
\end{verbatim}


\subsubsection{Sequential View with IN Effects}
%%@UserManualDocumentation: print_code_in_effects
Display the code decorated with its IN effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_in_effects       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.in_effects
        < MODULE.in_summary_effects
\end{verbatim}

\subsubsection{Sequential View with OUT Effects}
%%@UserManualDocumentation: print_code_out_effects
Display the code decorated with its OUT effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_out_effects       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.out_effects
        < MODULE.out_summary_effects
\end{verbatim}

\subsubsection{Sequential View with Proper Reductions} 

%%@UserManualDocumentation: print_code_proper_reductions
Display the code decorated with the proper reductions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_proper_reductions > MODULE.printed_file
  < PROGRAM.entities
  < MODULE.code
  < MODULE.proper_reductions
\end{verbatim}

\subsubsection{Sequential View with Cumulated Reductions}

%%@UserManualDocumentation: print_code_cumulated_reductions
Display the code decorated with the cumulated reductions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_cumulated_reductions > MODULE.printed_file
  < PROGRAM.entities
  < MODULE.code
  < MODULE.cumulated_reductions
  < MODULE.summary_reductions
\end{verbatim}


\subsubsection{Sequential View with Static Control Information}

%%@UserManualDocumentation: print_code_static_control
Display the code decorated with the static control.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_static_control       > MODULE.printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.static_control
\end{verbatim}

\subsection{Printed Files with the Intraprocedural Control Graph}

%%@UserManualDocumentation: graph_printed_file
These are files containing a pretty-printed version of code to be
displayed with its intraprocedural control graph as a graph, for
example using the \PdaVinci{} program.

The Fortran statements may be decorated with complexities,
preconditions, transformers, regions,\ldots{} depending on the printer
used to produce this file.
%%ÿUserManualDocumentation

\subsubsection{Menu for Graph Views}

\begin{verbatim}
alias graph_printed_file 'Control Graph Sequential View'

alias print_code_as_a_graph 'Graph with Statements Only'
alias print_code_as_a_graph_transformers 'Graph with Statements & Transformers'
alias print_code_as_a_graph_complexities 'Graph with Statements & Complexities'
alias print_code_as_a_graph_preconditions 'Graph with Statements & Preconditions'
alias print_code_as_a_graph_total_preconditions 'Graph with Statements & Total Preconditions'
alias print_code_as_a_graph_regions 'Graph with Statements & Regions'
alias print_code_as_a_graph_in_regions 'Graph with Statements & IN Regions'
alias print_code_as_a_graph_out_regions 'Graph with Statements & OUT Regions'
alias print_code_as_a_graph_proper_effects 'Graph with Statements & Proper Effects'
alias print_code_as_a_graph_cumulated_effects 'Graph with Statements & Cumulated Effects'
\end{verbatim}

\subsubsection{Standard Graph View}

%%@UserManualDocumentation: print_code_as_a_graph
Display the code without any decoration.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph                      > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

\subsubsection{Graph View with Transformers}

%%@UserManualDocumentation: print_code_as_a_graph_transformers
Display the code decorated with the transformers.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_transformers         > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Graph View with Complexities}

%%@UserManualDocumentation: print_code_as_a_graph_complexities
Display the code decorated with the complexities.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_complexities         > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.complexities
        < MODULE.summary_complexity
\end{verbatim}

\subsubsection{Graph View with Preconditions}

%%@UserManualDocumentation: print_code_as_a_graph_preconditions
Display the code decorated with the preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_preconditions        > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.preconditions
        < MODULE.summary_precondition
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Graph View with Preconditions}

%%@UserManualDocumentation: print_code_as_a_graph_preconditions
Display the code decorated with the preconditions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_total_preconditions        > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.total_preconditions
        < MODULE.summary_total_postcondition
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Graph View with Regions}

%%@UserManualDocumentation: print_code_as_a_graph_regions
Display the code decorated with the regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_regions              > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Graph View with IN Regions}

%%@UserManualDocumentation: print_code_as_a_graph_in_regions
Display the code decorated with the IN regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_in_regions              > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Graph View with OUT Regions}

%%@UserManualDocumentation: print_code_as_a_graph_out_regions
Display the code decorated with the OUT regions.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_out_regions              > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code 
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Graph View with Proper Effects}

%%@UserManualDocumentation: print_code_as_a_graph_proper_effects
Display the code decorated with the proper effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_proper_effects       > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{Graph View with Cumulated Effects}

%%@UserManualDocumentation: print_code_as_a_graph_cumulated_effects
Display the code decorated with the cumulated effects.
%%ÿUserManualDocumentation

\begin{verbatim}
print_code_as_a_graph_cumulated_effects    > MODULE.graph_printed_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}


\subsection{Parallel Printed Files}
\label{subsection-parallel-printed-files}

%%@UserManualDocumentation: parallelprinted_file
File containing a pretty-printed version of a
\verb+parallelized_code+. Several versions are available. The first one is
based on Fortran-77, extended with a DOALL construct. The second one is
based on Fortran-90. The third one generates CRAY Research directives as
comments if and only if the correspondent parallelization option was
selected (see Section{subsection-parallelization}).

No one knows why there is no underscore between parallel and printed...

The first function \verb+print_parallelized_code+ can compute either one
depending on the property variable \verb+PRETTYPRINT_FORTRAN90+ (out of
date). The result is stored in a file suffixed by \verb+.parf+.
%%ÿUserManualDocumentation

\subsubsection{Menu for Parallel View}

\begin{verbatim}
alias parallelprinted_file 'Parallel View'

alias print_parallelized77_code 'Fortran 77'
alias print_parallelizedHPF_code 'HPF directives'
alias print_parallelizedOMP_code 'OMP directives'
alias print_parallelized90_code 'Fortran 90'
alias print_parallelizedcray_code 'Fortran Cray'
\end{verbatim}

\subsubsection{Fortran 77 Parallel View}

%%@UserManualDocumentation: print_parallelized77_code
Output a Fortran-77 code extended with {\tt DOALL} parallel constructs.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelized77_code       > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code
\end{verbatim}

%% print_parallelized_code       > MODULE.parallelprinted_file
%%        < PROGRAM.entities
%%        < MODULE.parallelized_code

\subsubsection{HPF Directives Parallel View}

%%@UserManualDocumentation: print_parallelizedHPF_code
Output the code decorated with HPF or OMP directives.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelizedHPF_code     > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code

print_parallelizedOMP_code     > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code
\end{verbatim}

\subsubsection{Fortran 90 Parallel View}

%%@UserManualDocumentation: print_parallelized90_code
Output the code with some Fortran-90 array construct style.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelized90_code       > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code
\end{verbatim}

\subsubsection{Cray Fortran Parallel View}

%%@UserManualDocumentation: print_parallelizedcray_code
Output the code decorated with parallel Cray directives. Note that the
Cray parallelization algorithm should have been used in order to match
Cray directives for parallel vector processors.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelizedcray_code     > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.parallelized_code
        < MODULE.cumulated_effects
\end{verbatim}

\subsection{Call Graph Files}
\label{subsection-call-graph-files}
\index{Call Graph}

%%@UserManualDocumentation: callgraph_file
This kind of file contains the sub call graph of a module. Of course,
the call graph associated to the MAIN module is the program call graph.

Each module can be decorated by {\em summary} information computed by
{\em one} of \PIPS{} analyses.

If one module has different callers, its sub call tree is replicated
once for each caller. No fun, but how could we avoid it with a text
output?
%%ÿUserManualDocumentation

The resource defined in this section is \verb/callgraph_file/ (note the
missing underscore between call and graph in callgraph...). This is a {\em
  file} resource which cannot be loaded in memory by {\em pipsdbm}.

Aliases for call graphs must de different from aliases for
interprocedural control flow graphs (ICFG). A simple trick, a trailing
SPACE character, is used.

Note that input resource lists could be reduced to one resource, the
decoration. {\em pipsmake} would deduce the other ones. There is no need
for a transitive closure, but some people like it that way to make
resource usage verification possible...

\subsubsection{Menu for Call Graphs}

\begin{verbatim}

alias callgraph_file 'Callgraph View'

alias print_call_graph 'Calls'
alias print_call_graph_with_complexities 'Calls & Complexities'
alias print_call_graph_with_preconditions 'Calls & Preconditions'
alias print_call_graph_with_total_preconditions 'Calls & Total Preconditions'
alias print_call_graph_with_transformers 'Calls & Transformers'
alias print_call_graph_with_proper_effects 'Calls & Proper effects'
alias print_call_graph_with_cumulated_effects 'Calls & Cumulated effects'
alias print_call_graph_with_regions 'Calls & Regions'
alias print_call_graph_with_in_regions 'Calls & In Regions'
alias print_call_graph_with_out_regions 'Calls & Out regions'
\end{verbatim}

\subsubsection{Standard Call Graphs}

%%@UserManualDocumentation: print_call_graph
To have the call graph without any decoration.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph                         > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
\end{verbatim}

\subsubsection{Call Graphs with Complexities}

%%@UserManualDocumentation: print_call_graph_with_complexities
To have the call graph decorated with the complexities.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_complexities     > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.summary_complexity
        < MODULE.complexities
\end{verbatim}

\subsubsection{Call Graphs with Preconditions}

%%@UserManualDocumentation: print_call_graph_with_preconditions
To have the call graph decorated with the preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_preconditions      > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < MODULE.preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Call Graphs with Total Preconditions}

%%@UserManualDocumentation: print_call_graph_with_total_preconditions
To have the call graph decorated with the total preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_total_preconditions      > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.summary_total_postcondition
        < MODULE.summary_effects
        < MODULE.total_preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Call Graphs with Transformers}

%%@UserManualDocumentation: print_call_graph_with_transformers
To have the call graph decorated with the transformers.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_transformers       > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.summary_transformer
        < MODULE.summary_effects
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Call Graphs with Proper Effects}

%%@UserManualDocumentation: print_call_graph_with_proper_effects
To have the call graph decorated with the proper effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_proper_effects     > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{Call Graphs with Cumulated Effects}

%%@UserManualDocumentation: print_call_graph_with_cumulated_effects
To have the call graph decorated with the cumulated effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_cumulated_effects  > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Call Graphs with Regions}

%%@UserManualDocumentation: print_call_graph_with_regions
To have the call graph decorated with the regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_regions            > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Call Graphs with IN Regions}

%%@UserManualDocumentation: print_call_graph_with_in_regions
To have the call graph decorated with the IN regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_in_regions         > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Call Graphs with OUT Regions}

%%@UserManualDocumentation: print_call_graph_with_out_regions
To have the call graph decorated with the OUT regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_call_graph_with_out_regions        > MODULE.callgraph_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.callgraph_file
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsection{daVinci Interprocedural Control Flow Graph Files (DVICFG)}

%%@UserManualDocumentation: dvicfg_file
This is the file icfg with format of graph daVinci

%%ÿUserManualDocumentation

\subsubsection{Menu for DVICFG's}
\begin{verbatim}
alias dvicfg_file 'DVICFG View'

alias print_dvicfg_with_filtered_proper_effects 'Graphical Calls & Filtered proper effects'
\end{verbatim}

\subsubsection{Minimal ICFG with graphical filtered Proper Effects}
%%@UserManualDocumentation: print_dvicfg_with_filtered_proper_effects
Display the ICFG graphically decorated with the write proper effects filtered for a variable.
%%ÿUserManualDocumentation
\begin{verbatim}
print_dvicfg_with_filtered_proper_effects           > MODULE.dvicfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.dvicfg_file
        < MODULE.proper_effects
        < CALLEES.summary_effects
\end{verbatim}

\subsection{Interprocedural Control Flow Graph Files (ICFG)}

%%@UserManualDocumentation: icfg_file
This kind of file contains a more or less precise interprocedural
control graph. The graph can be restricted to call sites only, to call
sites and enclosing DO loops or to call sites, enclosing DO loops and
controlling IF tests. This abstraction option is orthogonal to the set
of decorations, but {\em pipsmake} does not support this
orthogonality. All combinations are listed below.

Each call site can be decorated by associated information computed by one
of \PIPS{} analyses.



%%ÿUserManualDocumentation

\subsubsection{Menu for ICFG's}

Note: In order to avoid conflicts with callgraph aliases, a space
character is appended at each alias shared with call graph related
functions (Guillaume Oget).

\begin{verbatim}
alias icfg_file 'ICFG View'

alias print_icfg 'Calls '
alias print_icfg_with_complexities 'Calls & Complexities '
alias print_icfg_with_preconditions 'Calls & Preconditions '
alias print_icfg_with_total_preconditions 'Calls & Total Preconditions '
alias print_icfg_with_transformers 'Calls & Transformers '
alias print_icfg_with_proper_effects 'Calls & Proper effects '
alias print_icfg_with_filtered_proper_effects 'Calls & Filtered proper effects '
alias print_icfg_with_cumulated_effects 'Calls & Cumulated effects '
alias print_icfg_with_regions 'Calls & Regions '
alias print_icfg_with_in_regions 'Calls & In Regions '
alias print_icfg_with_out_regions 'Calls & Out regions '

alias print_icfg_with_loops 'Calls & Loops'
alias print_icfg_with_loops_complexities 'Calls & Loops & Complexities'
alias print_icfg_with_loops_preconditions 'Calls & Loops & Preconditions'
alias print_icfg_with_loops_total_preconditions 'Calls & Loops & Total Preconditions'
alias print_icfg_with_loops_transformers 'Calls & Loops & Transformers'
alias print_icfg_with_loops_proper_effects 'Calls & Loops & Proper effects'
alias print_icfg_with_loops_cumulated_effects 'Calls & Loops & Cumulated effects'
alias print_icfg_with_loops_regions 'Calls & Loops & Regions'
alias print_icfg_with_loops_in_regions 'Calls & Loops & In Regions'
alias print_icfg_with_loops_out_regions 'Calls & Loops & Out regions'

alias print_icfg_with_control 'Calls & Control'
alias print_icfg_with_control_complexities 'Calls & Control & Complexities'
alias print_icfg_with_control_preconditions 'Calls & Control & Preconditions'
alias print_icfg_with_control_total_preconditions 'Calls & Control & Total Preconditions'
alias print_icfg_with_control_transformers 'Calls & Control & Transformers'
alias print_icfg_with_control_proper_effects 'Calls & Control & Proper effects'
alias print_icfg_with_control_cumulated_effects 'Calls & Control & Cumulated effects'
alias print_icfg_with_control_regions 'Calls & Control & Regions'
alias print_icfg_with_control_in_regions 'Calls & Control & In Regions'
alias print_icfg_with_control_out_regions 'Calls & Control & Out regions'
\end{verbatim}

\subsubsection{Minimal ICFG}

%%@UserManualDocumentation: print_icfg
Display the plain ICFG, without any decoration.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg                      > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
\end{verbatim}

\subsubsection{Minimal ICFG with Complexities}

%%@UserManualDocumentation: print_icfg_with_complexities
Display the ICFG decorated with complexities.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_complexities            > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_complexity
        < MODULE.complexities
\end{verbatim}

\subsubsection{Minimal ICFG with Preconditions}

%%@UserManualDocumentation: print_icfg_with_preconditions
Display the ICFG decorated with preconditions. They are expressed in the
\emph{callee} name space to evaluate the interest of cloning, depending on
the information available to the callee at a given call site.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_preconditions            > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_precondition
        < MODULE.summary_effects
        < MODULE.preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Minimal ICFG with Preconditions}

%%@UserManualDocumentation: print_icfg_with_total_preconditions
Display the ICFG decorated with total preconditions. They are expressed in the
\emph{callee} name space to evaluate the interest of cloning, depending on
the information available to the callee at a given call site.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_total_preconditions            > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_total_postcondition
        < MODULE.summary_effects
        < MODULE.total_preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Minimal ICFG with Transformers}

%%@UserManualDocumentation: print_icfg_with_transformers
Display the ICFG decorated with transformers.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_transformers             > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Minimal ICFG with Proper Effects}

%%@UserManualDocumentation: print_icfg_with_proper_effects
Display the ICFG decorated with the proper effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_proper_effects           > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{Minimal ICFG with filtered Proper Effects}
%%@UserManualDocumentation: print_icfg_with_filtered_proper_effects
Display the ICFG decorated with the write proper effects filtered for a variable.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_filtered_proper_effects           > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.proper_effects
        < CALLEES.summary_effects
\end{verbatim}

\subsubsection{Minimal ICFG with Cumulated Effects}

%%@UserManualDocumentation: print_icfg_with_cumulated_effects
Display the ICFG decorated with cumulated effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_cumulated_effects        > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{Minimal ICFG with Regions}

%%@UserManualDocumentation: print_icfg_with_regions
Display the ICFG decorated with regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_regions                  > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Minimal ICFG with IN Regions}

%%@UserManualDocumentation: print_icfg_with_in_regions
Display the ICFG decorated with IN regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_in_regions               > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{Minimal ICFG with OUT Regions}

%%@UserManualDocumentation: print_icfg_with_out_regions
Display the ICFG decorated with OUT regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_out_regions              > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops}

%%@UserManualDocumentation: print_icfg_with_loops 
Display the plain ICFG with loops, without any decoration.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops                    > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
\end{verbatim}

\subsubsection{ICFG with Loops and Complexities}

%%@UserManualDocumentation: print_icfg_with_loops_complexities
Display the ICFG decorated with loops and complexities.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_complexities       > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_complexity
        < MODULE.complexities
\end{verbatim}

\subsubsection{ICFG with Loops and Preconditions}

%%@UserManualDocumentation: print_icfg_with_loops_preconditions
Display the ICFG decorated with preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_preconditions      > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_precondition
        < MODULE.preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops and Total Preconditions}

%%@UserManualDocumentation: print_icfg_with_loops_total_preconditions
Display the ICFG decorated with total preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_total_preconditions      > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_total_postcondition
        < MODULE.total_preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops and Transformers}

%%@UserManualDocumentation: print_icfg_with_loops_transformers
Display the ICFG decorated with transformers.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_transformers       > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops and Proper Effects}

%%@UserManualDocumentation: print_icfg_with_loops_proper_effects
Display the ICFG decorated with proper effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_proper_effects     > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{ICFG with Loops and Cumulated Effects}

%%@UserManualDocumentation: print_icfg_with_loops_cumulated_effects
Display the ICFG decorated with cumulated effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_cumulated_effects        > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{ICFG with Loops and Regions}

%%@UserManualDocumentation: print_icfg_with_loops_regions
Display the ICFG decorated with regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_regions            > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops and IN Regions}

%%@UserManualDocumentation: print_icfg_with_loops_in_regions
Display the ICFG decorated with IN regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_in_regions         > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Loops and OUT Regions}

%%@UserManualDocumentation: print_icfg_with_loops_out_regions
Display the ICFG decorated with the OUT regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_loops_out_regions        > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control}

%%@UserManualDocumentation: print_icfg_with_control
Display the plain ICFG with loops, without any decoration.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control         > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
\end{verbatim}

\subsubsection{ICFG with Control and Complexities}

%%@UserManualDocumentation: print_icfg_with_control_complexities
Display the ICFG decorated with the complexities.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_complexities    > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_complexity
        < MODULE.complexities
\end{verbatim}

\subsubsection{ICFG with Control and Preconditions}

%%@UserManualDocumentation: print_icfg_with_control_preconditions
Display the ICFG decorated with the preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_preconditions   > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_precondition
        < MODULE.preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control and Total Preconditions}

%%@UserManualDocumentation: print_icfg_with_control_total_preconditions
Display the ICFG decorated with the preconditions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_total_preconditions   > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.summary_total_postcondition
        < MODULE.total_preconditions
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control and Transformers}

%%@UserManualDocumentation: print_icfg_with_control_transformers
Display the ICFG decorated with the transformers.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_transformers    > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.transformers
        < MODULE.summary_transformer
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control and Proper Effects}

%%@UserManualDocumentation: print_icfg_with_control_proper_effects
Display the ICFG decorated with the proper effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_proper_effects  > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.proper_effects
\end{verbatim}

\subsubsection{ICFG with Control and Cumulated Effects}

%%@UserManualDocumentation: print_icfg_with_control_cumulated_effects
Display the ICFG decorated with the cumulated effects.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_cumulated_effects   > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.cumulated_effects
        < MODULE.summary_effects
\end{verbatim}

\subsubsection{ICFG with Control and Regions}

%%@UserManualDocumentation: print_icfg_with_control_regions
Display the ICFG decorated with the regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_regions         > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.regions
        < MODULE.summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control and IN Regions}

%%@UserManualDocumentation: print_icfg_with_control_in_regions
Display the ICFG decorated with the IN regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_in_regions      > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.in_regions
        < MODULE.in_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsubsection{ICFG with Control and OUT Regions}

%%@UserManualDocumentation: print_icfg_with_control_out_regions
Display the ICFG decorated with the OUT regions.
%%ÿUserManualDocumentation
\begin{verbatim}
print_icfg_with_control_out_regions     > MODULE.icfg_file
        < PROGRAM.entities
        < MODULE.code
        < CALLEES.icfg_file
        < MODULE.out_regions
        < MODULE.out_summary_regions
        < MODULE.preconditions
        < MODULE.transformers
        < MODULE.cumulated_effects
\end{verbatim}

\subsection{Dependence Graph File}
\label{subsection-dependence-graph-file}
\index{DG}
\index{Dependence Graph}

%%@UserManualDocumentation: dg_file
This file shows the dependence graph.

Known bug: there is no precise relationship between the dependence graph
seen by the parallelization algorithm selected and any of its view...
%%ÿUserManualDocumentation

Two formats are available: the default format which includes
dependence cone and a SRU format which packs all information about one
arc on one line and which replaces the dependence cone by the
dependence direction vector (DDV). The line numbers given with this
format are in fact relative (approximatively...) to the statement line
in the \PIPS{} output.  The SRU format was defined by researchers at
Slippery Rock University (PA). The property
\begin{center}
\verb/PRINT_DEPENDENCE_GRAPH_USING_SRU_FORMAT/
\end{center}
is set to FALSE by default.

\subsubsection{Menu For Dependence Graph Views}

\begin{verbatim}
alias dg_file 'Dependence Graph View'

alias   print_effective_dependence_graph    'Default'
alias   print_loop_carried_dependence_graph 'Loop Carried Only'
alias   print_whole_dependence_graph        'All arcs'
alias   print_chains_graph                  'Chains'
alias   print_filtered_dependence_graph     'Filtered Arcs'
alias   print_filtered_dependence_daVinci_graph   'Filtered Arcs Output to daVinci'
alias   impact_check                        'Check alias impact'
\end{verbatim}

\subsubsection{Effective Dependence Graph View}

%%@UserManualDocumentation: print_effective_dependence_graph
Display dependence levels for loop-carried and non-loop-carried dependence
arcs due to non-privatized variables. Do not display dependence cones.
%%ÿUserManualDocumentation

\begin{verbatim}
print_effective_dependence_graph          > MODULE.dg_file
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Loop-Carried Dependence Graph View}

%%@UserManualDocumentation: print_loop_carried_dependence_graph
Display dependence levels for loop-carried dependence arcs only. Ignore
arcs labeled by private variables and do not print dependence cones.
%%ÿUserManualDocumentation

\begin{verbatim}
print_loop_carried_dependence_graph          > MODULE.dg_file
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Whole Dependence Graph View}

%%@UserManualDocumentation: print_whole_dependence_graph
Display dependence levels and dependence polyhedra/cones for all
dependence arcs, whether they are loop carried or not, whether they are
due to a private variable (and ignored by parallelization algorithms) or
not. Dependence cones labeling arcs are printed too.
%%ÿUserManualDocumentation

\begin{verbatim}
print_whole_dependence_graph          > MODULE.dg_file
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Filtered Dependence Graph View}

%%@UserManualDocumentation: print_filtered_dependence_graph
Same as print\_whole\_dependence\_graph but it's filtered by some variables.
%%ÿUserManualDocumentation

\begin{verbatim}
print_filtered_dependence_graph          > MODULE.dg_file
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Filtered Dependence daVinci Graph View}

%%@UserManualDocumentation: print_filtered_dependence_daVinci_graph
Same as print\_filtered\_dependence\_graph but its output is daVinci format.
%%ÿUserManualDocumentation

\begin{verbatim}
print_filtered_dependence_daVinci_graph          > MODULE.dvdg_file
        < PROGRAM.entities 
        < MODULE.code
        < MODULE.dg
\end{verbatim}

\subsubsection{Filtered Dependence Graph View}

%%@UserManualDocumentation: impact_check
Check impact of alias on the dependance graphe
%%ÿUserManualDocumentation

\begin{verbatim}
impact_check    > MODULE.code
        < PROGRAM.entities 
        < MODULE.alias_associations
        < MODULE.cumulated_effects
    < MODULE.summary_effects
        < MODULE.proper_effects
    < MODULE.preconditions
    < MODULE.summary_precondition
        < MODULE.dg
        < ALL.code
\end{verbatim}

\subsubsection{Chains Graph View}

\begin{verbatim}
print_chains_graph      > MODULE.dg_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.chains
\end{verbatim}




\section{Feautrier Methods (a.k.a. Polyhedral Method)}
\label{section-feautrier-methods}

This part of \PIPS{} was implemented at Centre d'Etudes Atomiques,
Limeil-Brévannes, by Benoît de Dinechin, Arnauld Leservot and Alexis
Platonoff.

\subsection{Static Control Detection}
\label{subsection-static-control-detection}

%%@UserManualDocumentation: static_controlize
\verb+static_controlize+ transforms all the loops in order to have steps
equal to one. Only loops with constant step different than one are
normalized.  Normalized loop counters are instantiated as a new kind of
entity: \verb+NLC+.  This entity is forwarded in the inner
statements. It also gets the structural parameters and makes new ones
when it is possible (``NSP''). It detects enclosing loops, enclosing
tests and the \verb+static_control+ property for each statement. Those
three informations are mapped on statements. Function
\verb+static_controlize+ also modifies code (\verb+> MODULE.code+). It
is not specified here for implementation bug purpose.

The definition of a static control program is given in~\cite{Fea91}.
%%ÿUserManualDocumentation

\begin{verbatim}
alias static_controlize 'Static Controlize'
static_controlize               > MODULE.static_control
        < PROGRAM.entities
        < MODULE.code
\end{verbatim}

See the alias \verb|print_code_static_control| and function
\verb|print_code_static_control| in
Section~\ref{sec:parsed_printed_files} and so on.

\subsection{Array Data Flow Graph}
\label{subsection-array-data-flow-graph}
\index{DFG}
\index{Array Data Flow Graph}

Function \verb+array_dfg+ computes an Array Data Flow Graph, according to
Feautrier's methods (see~\cite{Fea91}). This method can only be applied
on static-control code, otherwise an error occurs. Function
\verb+print_array_dfg+ prints the Data Flow Graph.

In the ouput produced by the array DFG analysis, 
each statement is renamed ``ins\_'' followed by the statement number it had in the original
program and by a digit representing its position among the different
statements coming from the same statement of the original program.

The following describes the output of an Array DFG analysis:

\paragraph{\tt W: }  Statement examined. It can be ``ENTRY'' 
\paragraph{\tt Execution domain:} The conditions on the surrouding loop
counters for which W is executed at least once  
\paragraph{\tt ----Def-Use- > R:} Statement reading a value produced by an
execution of W
\paragraph{\tt Reference:}  Expression of the variable read at statement R.
\paragraph{\tt Transformation:} Transformation that must be applied on the
loop counters of R to find those of W for which there is dependence
\paragraph{\tt Governing predicate:} Conditions on the loop counters of the loops surrounding
R for which there is a dependence
\paragraph{\tt Execution domain:} Conditions on the loop counters for which
there is an execution of R.

Known bug: what happens if the input is not a static control program?

\begin{verbatim}

array_dfg                       > MODULE.adfg
        < PROGRAM.entities
        < MODULE.code
        < MODULE.static_control
        < MODULE.dg
        < MODULE.preconditions
\end{verbatim}


\begin{verbatim}

alias adfg_file 'Array Data Flow Graph'

print_array_dfg                 > MODULE.adfg_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.adfg
\end{verbatim}

\subsection{Scheduling}
\label{subsection-scheduling}
\index{Scheduling}

Function \texttt{scheduling} computes a schedule, called {\em Base De
Temps} in French, for each assignment instruction of the program. This
computation is based on the Array Data Flow Graph (see~\cite{Fea92a,Fea92b}).

The output of the scheduling is of the following form:
(the statements are named in the same manner as in the array DFG)

\paragraph{\tt W:} Statement examined 
\paragraph{\tt  pred:} Conditions for which the following schedule is valid
\paragraph{\tt  dims:} Time at which the execution of W is schedule, in function
of the loop counters of the surrounding loops. 


\begin{verbatim}

scheduling              > MODULE.bdt
        < PROGRAM.entities
        < MODULE.code
        < MODULE.static_control
        < MODULE.adfg
\end{verbatim}

\begin{verbatim}

alias bdt_file 'Time stamps'

print_bdt              > MODULE.bdt_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.bdt
\end{verbatim}

\subsection{Mapping (a.k.a. Placement)}

Function \verb+prgm_mapping+ computes one mapping for
each assignment instruction of the program. Each iteration of the
assignment is mapped onto a processor. The set of processors is a grid,
as in HPF.

These mappings are computed from the array data flow graph and the timing
function. The implementation contains the extensions developed by Alexis
Platonoff (see~\cite{Fea93,Pla95b}), who also implemented this analysis.

The output of the placement is:
(the statements are named in the same manner as in the array DFG)

\paragraph{\tt S:} Statement examined 
\paragraph{\tt (..,..,..)}  Coordinates of the execution of the statement on a processor
grid, in function of the loop counters of the surrounding loops.


\begin{verbatim}
prgm_mapping            > MODULE.plc
        < PROGRAM.entities
        < MODULE.code
        < MODULE.static_control
        < MODULE.adfg
        < MODULE.bdt
\end{verbatim}

\begin{verbatim}

alias plc_file 'Placement'

print_plc               > MODULE.plc_file
        < PROGRAM.entities
        < MODULE.code
        < MODULE.plc
\end{verbatim}

\subsection{Code Generation}

Function \texttt{reindexing} transforms the code using the schedule
(\texttt{bdt}) and the mapping (\texttt{plc}) (see~\cite{Col93,Pla95a}). The
result is a new resource named \verb/reindexed_code/.

\begin{verbatim}
reindexing            > MODULE.reindexed_code
        < PROGRAM.entities
        < MODULE.code
        < MODULE.static_control
        < MODULE.adfg
        < MODULE.bdt
        < MODULE.plc
\end{verbatim}

\subsection{Prettyprinters for and CM Fortran}

How to get a pretty-printed version of \verb+reindexed_code+ ? Two
prettyprinters are available. The first one produces CM Fortran and the
result is stored in a file suffixed by \verb+.fcm+. The second one
produces CRAFT Fortran and the result is stored in a file suffixed by
\verb+.craft+.

\begin{verbatim}
alias print_parallelizedCMF_code 'CM Fortran'
alias print_parallelizedCRAFT_code 'CRAFT Fortran'
\end{verbatim}

%%@UserManualDocumentation: print_parallelizedCMF_code
Use the polyhedric method to parallelize the code and display the
reindexed code in a CMF (parallel Fortran extension from TMC, Thinking
Machine Corporation) style.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelizedCMF_code       > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.adfg
        < MODULE.bdt
        < MODULE.plc
        < MODULE.reindexed_code
\end{verbatim}

%%@UserManualDocumentation: print_parallelizedCRAFT_code
Use the polyhedric method to parallelize the code and display the
reindexed code in a CRAFT (parallel Fortran used on the Cray T3 serie)
style.
%%ÿUserManualDocumentation

\begin{verbatim}
print_parallelizedCRAFT_code     > MODULE.parallelprinted_file
        < PROGRAM.entities
        < MODULE.adfg
        < MODULE.bdt
        < MODULE.plc
        < MODULE.reindexed_code
\end{verbatim}


\subsection{Prettyprinters for C}

A very basic and experimental C dumper. This is not f2c!

\begin{verbatim}
cprinted_file > MODULE.crough
              < PROGRAM.entities
              < MODULE.code

cindent_file  > MODULE.c
              < MODULE.crough
\end{verbatim}




\section{User Interface Menu Layouts}
\label{sec:menu_layout}
\label{section-user-interface-menu-layouts}

For presentation issues, it is useful to select only the features that
are needed by a user and to display them in a comprehensive order. For
that purpose, a layout description mechanism is used here to pick
among the \PIPS{} phases described above.

For each menu, the left part before the arrow, \verb|->|, is the menu
item title and the right part is the \PIPS{} procedure to be called when
the item is selected. For the view menu (section \label{view_menu},
there is two display methods to view resources separated by a comma,
the first one is the method for \WPIPS, the second one is the one
used in \EPIPS, followed by the icon to use.

Use a blank line to insert a menu separator.

\subsection{View menu}
\label{sec:view_menu}

The view menu is displayed according to the following layout and
methods (\WPIPS{} method, \EPIPS{} method, icon name for the frame):
\begin{PipsMenu}{View}
  printed_file -> wpips_display_plain_file,epips-display-fortran-file,sequential
  parsed_printed_file -> wpips_display_plain_file,epips-display-fortran-file,user
  alias_file -> wpips_display_plain_file,epips-display-plain-file,-
  graph_printed_file -> wpips_display_graph_file_display,epips-display-graph-file,-

  dg_file -> wpips_display_plain_file,epips-display-plain-file,DG

  adfg_file -> wpips_display_plain_file,epips-display-plain-file,-
  bdt_file -> wpips_display_plain_file,epips-display-plain-file,-
  plc_file -> wpips_display_plain_file,epips-display-plain-file,-

  callgraph_file -> wpips_display_plain_file,epips-display-xtree-file,callgraph
  dvcg_file -> wpips_display_graph_file_display,epips-display-graph-file,callgraph
  icfg_file -> wpips_display_plain_file,epips-display-plain-file,ICFG

  wp65_compute_file -> wpips_display_WP65_file,epips-display-distributed-file,WP65_PE
  parallelprinted_file -> wpips_display_plain_file,epips-display-fortran-file,parallel

  flinted_file -> wpips_display_plain_file,epips-display-plain-file,-
\end{PipsMenu}%{View} important for generate_all_menu_documentation


\subsection{Transformation menu}
\label{sec:transformation_menu}

The transformation menu is displayed as here:
\begin{PipsMenu}{Transformations}
  distributer
  full_unroll
  unroll
  loop_interchange
  loop_normalize
  strip_mine
  loop_tiling
  tiling_sequence

  privatize_module
  array_privatizer
  declarations_privatizer

  restructure_control
  unspaghettify
  suppress_dead_code
  partial_eval
  use_def_elimination
  stf
  freeze_variables
  partial_redundancy_elimination 

  array_bound_check_bottom_up
  array_bound_check_top_down
  array_bound_check_interprocedural

  array_resizing_bottom_up
  array_resizing_top_down

  alias_check

  atomizer
  new_atomizer

  clone
  clone_substitute
  clone_on_argument

  clean_declarations
  unsplit

  static_controlize
\end{PipsMenu}%{Transformations} important for generate_all_menu_documentation

%%  optimize_expressions

At the end of this menu is added a special entry in \WPIPS, the ''Edit'' line
that allows the user to edit the original file. It is seen as a very
special transformation, since the user can apply whatever
transformation (s)he wants...







\section*{Conclusion}

New functionalities can easily be added to \PIPS{}. The new function names
must be declared somewhere in this file as well as the resources
required and produced. Then, {\tt make} must be run in the {\tt
Documentation} directory and the pipsmake library must be recompiled and
\PIPS{} interfaces (pips, tpips, wpips) linked with the new C modules.

It is much more difficult to add a new type of resources, because \PIPS{}
database manager, \texttt{pipsdbm}, is not as automatized as
\texttt{pipsmake}. This is explained in~\cite{I94}.







\section*{Known Problems}

\begin{enumerate}

\item {\em pipsmake} behavior may be erratic if files are accessed
across a NFS network of non-synchronized workstations (see for instance
UNIX \texttt{rdate} command).

\item \texttt{STOP} statements in subroutines (i.e. control effects and
control dependencies) are not taken into account when parallelizing the
caller.

\end{enumerate}

\newpage

\begin{thebibliography}{99}

\bibitem{Aho86} Aho, Sethi, Ullman,
{\it Compilers. Principles, techniques, and Tools},
Addison-Wesley, (1986)

\bibitem{AK87} J. Allen, K. Kennedy,
{\em Automatic Translation of {FORTRAN} Programs to Vector Form},
TOPLAS, V. 9, n. 4, 1987

  \bibitem{AI91} C. Ancourt, F. Irigoin,
{\em Scanning Polyhedra With DO Loops},
PPoPP'91 Principle and Practice of Parallel Programming, Williamsburg, USA,
April 1991

   \bibitem{AIY94} C. Ancourt, F. Irigoin, Y. Yang,
{\em Minimal Data Dependence Abstractions for Loop Transformations},
Seventh Annual Workshop on Languages and Compilers for Parallel
Computing, Ithaca (NY), August 1994

  \bibitem{B91} B. Baron,
{\em Construction flexible et cohérente pour la compilation interprocédurale},
Rapport interne EMP-CRI-E157, juillet 1991

  \bibitem{BIJ91} B. Baron, F. Irigoin, P. Jouvelot,
{\em Projet PIPS. Manuel utilisateur du pa\-ral\-l\'e\-liseur batch},
Rapport interne EMP-CRI-E144, janvier 1991

  \bibitem{B90} P. Berthomier,
{\em Static Comparison of Different Program versions},
Rapport interne EMP-CRI-E130, septembre 1990

  \bibitem{C90} P. Chassany,
{\em Les m\'ethodes de parall\'elisation interproc\'edurales},
Rapport interne EMP-CRI-E129, septembre 1990

  \bibitem{C93} F. Coelho,
{\em Étude et réalisation d'un compilateur pour le {\em High
Performance Fortran}},
Rapport interne EMP-CRI-A238, juin 1993

  \bibitem{CI95} Béatrice Creusillet, François Irigoin, {\em
Interprocedural Array Region Analyses}, Workshop on Languages and
Compilers for Parallel Computing, LCPC'95, Colombus, OHIO, USA, 10-12
Août 1995 (also available as TR A/270).

\bibitem{CI96} Béatrice Creusillet, François Irigoin, {\em Interprocedural
    Array Region Analyses}, International Journal on Parallel Programming
  (special issue on Languages and Compilers for Parallel Computing, LCPC'95),
  24(6), (also available as TR A/282).

  \bibitem{CCKT86} C. D. Callahan, K. D. Cooper, K. Kennedy and L. Torczon,
Interprocedural Constant Propagation,
in the {\em Proceedings of the ACM
Symposium on Compiler Construction}, (1986).

\bibitem{Col93} J.-F. Collard, Code generation in automatic
  parallelizers, Technical Report 93-21, LIP-IMAG, July 1993.

  \bibitem{Fea91} P. Feautrier, {Dataflow Analysis of Array and Scalar
    References}, {\em Int. Journal of Parallel Programming}, 20(1):23--53,
    February 1991.

\bibitem{Fea92a} P. Feautrier, {Some Efficient Solutions to the Affine
  Scheduling Problem, Part I : One-dimensional Time}, {\em Int. J. of
  Parallel Programming}, 21(5):313--348, October 1992.

\bibitem{Fea92b} P. Feautrier, {Some Efficient Solutions to the Affine
  Scheduling Problem, Part II : Multidimensional Time}, {\em Int. J. of
  Parallel Programming}, 21(6):389--420, December 1992.

\bibitem{Fea93} P. Feautrier, {Toward Automatic Partitioning of Arrays on
  Distributed Memory Computers}, In {\em ACM ICS'93}, pages 175--184,
  Tokyo, July 1993.

  \bibitem{HC78} N. Halbwachs and P. Cousot, Automatic Discovery of Linear
Restraints Among Variables of a Program, in the {\em Conference Record
of the Tenth ACM Annual Symposium on Principles of Programming
Languages}, (1978).

  \bibitem{IJT91} F. Irigoin, P. Jouvelot, R. Triolet,  {\em Semantical
Interprocedural Parallelization: An Overview of the PIPS Project},
1991 International Conference on Supercomputing, Cologne, June 1991

  \bibitem{IJT92} F. Irigoin, P. Jouvelot, R. Triolet, {\em PIPS:
Internal Representation of Fortran Code}, Technical Report E/166, May
1992. This report is constantly updated and available on-line.

  \bibitem{I87} F. Irigoin,
{\em Partitionnement des boucles imbrique'es. Une tech\-nique 
d'opti\-mi\-sation des programmes scientifiques},
Thèse de doctorat de l'université Pierre et Marie Curie, juin 1987

  \bibitem{IT87a} F. Irigoin, R. Triolet,
{\em Automatic DO-Loop Partitioning for Improving
Data Locality in Scientific Programs}, Vector and Parallel Processors
for Scientific Computation 2, Rome, Sept.~21-23, Italie, 1987 (invite') \\
Disponible comme rapport CAI-E93

  \bibitem{IT87b} F. Irigoin, R. Triolet,
{\em Computing Dependence Direction Vectors and Dependence Cones with
Linear Systems}, Rapport CAI-E94, September 1987

  \bibitem{IT88a} F. Irigoin, R. Triolet,
{\em Supernode Partitioning},
POPL'88 - Fifteenth Annual ACM
Symposium on Principles of Programming Languages, San Diego, California,
January 13-15, pp. 319-329, 1988

  \bibitem{IA91} F. Irigoin, C. Ancourt,
{\em Final Report on Software Caching for Simulated Global Memory},
PUMA ESPRIT 2701, Deliberable 6.5.1, Tech. Report EMP-CRI-E155, November 1991

  \bibitem{IA92a} F. Irigoin, C. Ancourt, 
{\em Compilation pour machines à mémoire répartie},
Algorithmique Parallèle, Cosnard, Nivat, Robert Eds, Masson,
Ecole de Printemps du LITP, mai 1992

  \bibitem{IA92b} F. Irigoin, C. Ancourt, 
{\em Automatic Code Distribution},
Third International Workshop on Compilers for Parallel Computers, Vienne,
July, 1992

  \bibitem{Ir92} F. Irigoin,
{\em Interprocedural Analyses for Programming Environments},
J.J.~Dongarra and B.~Tourancheau Eds, Elsevier,
Workshop CNRS-NSF, Saint-Hilaire du Touvet, Sept. 1992

  \bibitem{I94} F. Irigoin, \& al.,
{\em Projet PIPS. Environnement de développement},
Rapport interne EMP-CRI-E146, novembre 1994. This report is available
on-line and regularly updated.

\bibitem{Karr76} M. Karr, Affine Relationships among Variables of a Program,
{\em Acta Informatica}, (1976).

\bibitem{Much97} Steven S. Muchnick,
  {\it Advanced Compiler Design Implementation}
  Morgan Kaufmann Publishers, 1997
  
\bibitem{Ost83} L.~J.~Osterweil, TOOLPACK - An Experimental Software
    Development Environment Research Project,
{\em IEEE TOSE}, Vol. 9, No. 6, pp.673-685 (1983).

\bibitem{toolpack} A.~A.~Pollicini, Using Toolpack Software Tools, in {\em
  ISPRA Courses on Information Sciences 1986}, ISPRA, Kluwer Academic,
  1989

\bibitem{Pla90} A. Platonoff, {\em Calcul des effets des procédures au
  moyen des régions}, Rapport interne EMP-CAII-I132, juin 1990

\bibitem{Pla95a} A. Platonoff, {\em Contribution à la Distribution
  Automatique des Données pour Machines Massivement Parallèles},
  Thèse de doctorat de l'université Pierre et Marie Curie, 9 mars
  1995.

\bibitem{Pla95b} A. Platonoff, Automatic Data Distribution for Massively
  Parallel Computers, in {\em 5th International Workshop on Compilers for
  Parallel Computers}, Malaga, Spain, June 1995.

  \bibitem{T84} R. Triolet,
{\em Contribution à la parallélisation automatique de programmes
Fortran comportant des appels de procédure},
Thèse de docteur-ingénieur, Université Pierre et Marie Curie,
décembre 1984

  \bibitem{TIF86} R. Triolet, F. Irigoin, P. Feautrier,
{\em Direct Parallelization of Call Statements},
ACM SIGPLAN'86 Symposium on Compiler Construction, Hyatt Rickeys Hotel, Palo
Alto, June 23-27, 1986

  \bibitem{Y93} Y. Yang,
{\em Tests des dépendances et transformations de programme},
Thèse de doctorat de l'Université Pierre et Marie Curie, 
15 Novembre 1993, rapport A/242.

  \bibitem{Z94} L. Zhou,
{\em Analyse
statique et dynamique de la complexité des programmes 
scientifiques},
Thèse de doctorat de l'Université Pierre et Marie Curie, 
14 Septembre 1994, technical report A/255.

\end{thebibliography}

\newpage

% Cross-references for points and keywords

\input{pipsmake-rc.ind}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
