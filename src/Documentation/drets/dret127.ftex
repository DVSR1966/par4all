\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\titre}{RAPPORT D'AVANCEMENT No 6 (LOT 7)\\
                    ANALYSEUR S\'EMANTIQUE ET D\'ETECTEUR DE PARALL\'ELISME}
\newcommand{\auteur}{
        Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{8 Mars 1990}
\newcommand{\numero}{E127}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\SEC{Introduction}
\PAR{}
Ce rapport interme'diaire donne l'e'tat d'avancement de nos travaux sur
l'analyse se'mantique et la de'tection du paralle'lisme.

\paragraph{}
Dans le cadre de l'analyse se'mantique, la repre'sentation interme'diaire
a tout d'abord e'te' tre`s le'ge`rement modifie'e pour augmenter la
quantite' d'information porte'e par les pre'conditions. Cette me^me
analyse se'mantique a aussi e'te' mieux inte'gre'e au prettyprinter
de manie`re a` pouvoir afficher les re'sultats d'une
manie`re confortable pour l'utilisateur. Trois nouvelles fonctionnalite's ont
e'te' ajoute'es: le traitement des tests, le traitement des {\em bonnes
boucles} (au sens de la the`se de Re'mi Triolet) et la prise en compte pre'cise
des effets des proce'dures appele'es gra^ce a` un me'canisme de traduction
des transformers. Enfin, un syste`me d'option a e'te' ajoute' de manie`re
a` permettre aux usagers de choisir le compromis vitesse-pre'cision
le plus adapte' a leurs besoins.

\paragraph{}
La phase de paralle'lisation a aussi e'te' conside'rablement ame'liore'e.
Tout d'abord, un certain nombre d'erreurs ont e'te' corrige'es ce qui a 
permis d'analyser comple`tement un des benchmarks de l'ONERA, {\em tmines.f}.
Ces premie`res analyses comple`tes ont mis en e'vidence des lenteurs dans
PIPS qui ont e'te' largement re'duites en remaniant les parties 
critiques du code. Ces travaux n'apportent pas de nouvelles fonctionalite's
a` PIPS mais ils sont indispensables pour le rendre utilisable. Co^te'
fonctionalite', un premier niveau de paralle'lisation interproce'durale
base'e sur les correspondances entre vecteurs et colonnes ou
sous-colonnes de matrice a e'te' imple'mente'. D'autre part, l'imple'mentation
des algorithmes de bases ne'cessaires a` l'e'change de boucles et au loop
skewing (me'thode hyperplane re'duite de Michael Wolfe) a commence'.

\section{Analyse se'mantique}

\subsection{Modification de la repre'sentation interme'diaire}

\paragraph{}
Les me'thodes d'analyse se'mantiques usuelles calculent des pre'dicats
sur les e'tats me'moires ({\em store}) associe's a` chaque instruction.
Ces pre'dicats sont appele's {\em pre'conditions} et sont utilise's,
par exemple, pour ve'rifier que les indices de tableaux appartiennent
bien a` l'intervalle de de'claration.

\paragraph{}
Ce type d'information n'est pas le mieux adapte' au calcul de de'pendance
pour lequel deux et non une instruction sont prises en compte. Ide'alement,
il faudrait un pre'dicat portant sur les relations entre les valeurs des
variables avant l'exe'cution de ces deux instructions.

\paragraph{}
Le nombre de tels pre'dicats augmente malheureusement comme le carre'
du nombre d'instructions et il ne semble pas rentable de les calculer.
Par contre, il est possible d'ajouter un peu d'information aux pre'conditions
usuelles en les remplac,ant par une caracte'risation de la relation entre
les valeurs initiales a` l'entre'e d'un module et les valeurs associe'es
a' chaque instruction.

\paragraph{}
Ceci permet par exemple de savoir que la variable {\tt N}, utilise'e dans
des bornes de boucle, est (ou n'est pas) constante sur tout un module.
Cette information est cruciale pour le test de de'pendance et pour le
calcul des re'gions selon l'algorithme de Triolet.

\paragraph{}
Dans le domaine {\tt statement} de la repre'sentation interme'diaire, le
champ {\tt precondition} a donc e'te' rede'fini comme {\tt transformer}
au lieu de {\tt predicate}.

\subsection{Impression des re'sultats}

\paragraph{}
Le prettyprinter a e'te' modifie' pour permettre l'impression des
pre'conditions et transformers associe's aux statements et au code
d'une proce'dure. Deux nouvelles options ont e'te' ajoute'es:
\begin{itemize}
  \item {\tt -t} pour les transformers
  \item {\tt -c} pour les pre'conditions (c est a` me'moriser comme {\em
contexte} d'exe'cution)
\end{itemize}
Ces deux options s'ajoutent aux deux pre'ce'dentes, {\tt -s} pour obtenir
l'impression de la version se'quentielle du code et {\tt -p} pour la
version paralle`le.

\subsection{Nouvelles fonctionalite's}

\paragraph{}
Tout d'abord, les tests structure's sont correctement pris en compte. Pour
e'viter une explosion exponentielle de la longueur des expressions,
les postconditions obtenues sur les deux branches du test sont unifie'es
en en prenant l'enveloppe convexe comme propose' par Cousot et Halbwachs.

\paragraph{}
Ensuite, les contraintes sur les indices de boucle, que l'on peut facilement
de'river des bornes donne'es dans les instructions DO (me'thode dite
{\em des bonnes boucles} de Re'mi Triolet) et qui permettent de traiter
les boucles triangulaires, sont correctement calcule'es et invalide'es
si les expressions de bornes ne sont pas invariantes.

\paragraph{}
Enfin, les transformers globaux des modules appele's sont utilise'es
lors de l'analyse des modules appelants apre`s avoir e'te' traduits
dans le nouveau contexte. Ceci est effectue' lors de la phase {\em bottom-up}
de l'analyse se'mantique et permet de prendre en compte les initialisations
et les modifications de parame`tres survenant dans des modules appele's.

\subsection{Options d'analyse}

\paragraph{}
Chacune des nouvelles fonctionalite's ne'cessite davantage de temps
calcul mais n'apporte pas force'ment davantage d'information pertinente.
L'utilisateur peut donc choisir de les utiliser ou non. L'option minimale
de base comprend la propagation {\em flow-insensitive} des constantes
symboliques (i.e. propagation des valeurs constantes) et l'analyse
des bonnes boucles DO. Les options restantes sont, pour le moment:
\begin{itemize}
  \item {\tt -f} (f comme flow-sensitive): utilisation de l'enveloppe
	convexe pour traiter les tests
  \item {\tt -i} (i comme interproce'durale): utilisation des transformers
	globaux des modules appele's dans l'analyse du module appelant
\end{itemize}

\section{De'tection du paralle'lisme}

\subsection{Robustesse du paralle'liseur}

\paragraph{}
La taille des programmes traite's a e'te' augmente'e re'gulie`rement
pour pouvoir traiter comple`tement un des benchmarks de l'ONERA, {\tt
tmines.f}. Cela a ne'cessite' du travail de mise au point sur le parser,
le linker et le paralle'liseur.

\subsection{Vitesse du paralle'liseur}

\paragraph{}
L'augmentation de la taille des programmes traite's a permis de faire
apparai^tre les premiers goulots d'e'tranglements. Apre`s profiling,
plusieurs algorithmes de base portant sur l'imple'mentation des
ensembles et des mappings (i.e. fonctions a` support borne') ont e'te'
modifie's.

\subsection{Paralle'lisation interproce'durale}

\paragraph{}
Le calcul des effets des instructions a e'te' modifie' pour imple'menter
un premier algorithme de paralle'lisation interproce'durale. 

\paragraph{}
Jusqu'a` pre'sent, les effets des instructions call n'e'taient calcule's
que dans le cas ou` la fonction appele'e e'tait un ope'rateur ou un
intrinsic. La phase de calcul des effets se terminait donc anormalement
dans le cas d'une instruction du genre \verb/CALL P/ ou` \verb/P/ e'tait
un module de'fini dans le programme en cours de traitement.

\paragraph{}
Cette phase a donc e'te' modifie'e pour
\begin{itemize}
  \item calculer le re'sume' des effets d'un module sur les variables du
        programme, 
  \item de'duire du re'sume' associe' a` un module les effets d'une
        instruction d'appel a` ce module.
\end{itemize}

\subsubsection{Calcul du re'sume' des effets d'un module}
\paragraph{}
Le calcul des re'sume's n'a pas pose' de proble`mes puisque les effets
des instructions e'le'mentaires (affectation, entre'es-sorties, ...)
d'un module sont {\em remonte's} sur les instructions non e'le'mentaires
(tests, blocs, boucles, ...); il en re'sulte que tous les effets d'un
module sont associe's au statement bloc de ce module. Le calcul du
re'sume' a simplement consiste' a` dupliquer les effets associe's a` ce
bloc en y e'liminant les effets sur les variables locales du module. 

\paragraph{}
Dans cette premie`re version du re'sume' des effets, les tableaux sont
conside're's comme des entite's, ce qui signifie que la consultation
(resp. la modification) d'un seul e'le'ment du tableau implique que la
totalite' du tableau est conside're'e comme consulte'e (resp.
modifie'e). Il en re'sulte que le re'sume' ne comporte que des effets
dont la re'fe'rence n'a pas d'expressions d'indices. Ce choix a pour
conse'quence de diminuer conside'rablement la taille du re'sume' et
d'accroitre la rapidite' de Pips.

\paragraph{}
Il est important de noter que le calcul du re'sume' n'est fait qu'une
seule fois pour chaque module, quel que soit le nombre des appels aux
diffe'rents modules.

\subsubsection{Calcul des effets d'un call a` un module}
\paragraph{}
Les effets d'une instruction call a` un module P sont de'duits des
effets re'sume's de P de la manie`re suivante.

\paragraph{}
Les effets sur les variables communes et statiques se trouvant dans le
re'sume' de P sont duplique's et associe's a` l'instruction call. Les
effets sur les parame`tres formels de P sont traduits en des effets sur
les arguments re'els de l'appel; ces effets traduits sont ajoute's a` la
liste des effets de l'instruction call.

\paragraph{}
La traduction est imme'diate dans le cas ou` le parame`tre re'el est une
expression: il n'y a pas d'effet traduit.

\paragraph{}
La traduction est simple dans le cas ou` le parame`tre re'el et le
parame`tre formel ont le me^me rang (nombre de dimensions). Dans ce cas,
l'effet traduit est identique a` l'effet re'sume' mis a` part que la
variable formelle est remplace'e par la variable re'elle dans la
re'fe'rence de l'effet traduit.

\paragraph{}
Deux cas peuvent se pre'senter lorsque le parame`tre re'el et le
parame`tre formel n'ont pas le me^me rang:
\begin{itemize}
\item 
 le parame`tre formel est un scalaire et le parame`tre ree'l est un
 e'le'ment de tableau; dans ce cas, la re'fe'rence de l'effet traduit
 est la re'fe'rence a` l'e'le'ment de tableau, et les autres champs de
 l'effet traduit sont identiques a` ceux de l'effet re'sume'.

\item les parame`tres re'els et formels sont des tableaux de tailles
        diffe'rentes. 
\end{itemize}

\paragraph{}
Dans ce dernier cas, notre algorithme tente de de'tecter les situations
ou` l'effet sur la variable formelle peut e^tre traduit en un effet plus
pre'cis que la totalite' du tableau re'el. C'est notament le cas lorsque
le parame`tre formel est un vecteur (tableau a` une dimension) associe'
a` une colonne d'une matrice (tableau a` deux dimensions). Lorsqu'une
telle situation est de'tecte'e, nous utilisons les ranges dans les
expressions d'indice pour indiquer qu'une colonne d'une matrice a e'te'
change'e; ainsi, la lecture de la J+1 e`me colonne d'une matrice 100x100
sera repre'sente'e par l'effet:
\begin{verbatim}
{ MAT(1:100,J+1) , {is_action_read, UU} , {is_approximation_must , UU} } 
\end{verbatim}

\paragraph{}
Pour avoir le droit de ge'ne'rer ce genre d'effet, il faut s'assurer que
la taille du tableau formel est infe'rieure ou e'gale a` la taille de la
re'gion correspondante du tableau re'el; il faut par exemple ve'rifier
que la taille d'un vecteur est bien infe'rieure a` la taille d'une
colonne d'une matrice. Pour effectuer cette ve'rification, nous formons
un syste`me d'e'quations et d'ine'quations line'aires qui n'est faisable
que s'il y a effectivement de'passement de la zone re'elle par le
tableau formel, puis nous prouvons que ce syste`me est infaisable.

\paragraph{}
La souplesse de notre repre'sentation interne et l'extre`me qualite' de
notre code font que nous n'avons pas eu a` modifier la moindre ligne de
code dans le calcul des de'pendances pour prendre en compte ce nouveau
genre d'effets et paralleliser ainsi des boucles contenant des appels de
proce'dure. 

\paragraph{}
L'exemple suivant est un re'sultat de Pips qui montre la puissance de
notre calcul d'effet interproce'dural. La boucle sur J du module MM03
contient un appel a` SAXPY qui ne modifie que la J ie`me colonne de C.
Notre calcul d'effet s'en rend compte gra^ce a` une analyse des effets
de SAXPY et une traduction de ces effets pour le call concerne'; ce
re'sultat permet a` notre algorithme de paralle'lisation de transformer
la boucle se'quentielle sur J en une boucle paralle`le.
\begin{verbatim}
      SUBROUTINE MM03(N, A, B, C)
      ...
      DOALL J = 1,N,1
         PRIVATE K
         DO K = 1,N,1
            CALL SAXPY(N, C(1,J), A(1,K), B(K,J))                            11
         ENDDO
      ENDDO
      ...
      END

      SUBROUTINE SAXPY(N, X, Y, S)
C     
      INTEGER N
      REAL*8 X(N), Y(N), S
C     
      M = MOD(N,4)
      DO I = 1, M
         X(I) = X(I) + S*Y(I)
      ENDDO
C     
      DO I = M+1, N, 4
         X(I) = X(I) + S*Y(I)
         X(I+1) = X(I+1) + S*Y(I+1)
         X(I+2) = X(I+2) + S*Y(I+2)
         X(I+3) = X(I+3) + S*Y(I+3)
      ENDDO
C
      RETURN
      END
\end{verbatim}

\subsection{Echange de boucles et loop skewing}

\paragraph{}
L'e'change de boucle ge'ne'ralise' et la version re'duite de la me'thode
hyperplane propose'e par Michael Wolfe, le {\em loop skewing}, ne'cessitent
des calculs de base et de changement de base. Le codage de ces algorithmes
d'alge`bre line'aire a de'bute'.

\section{Conclusion}

\paragraph{}
Le travail sur Pips s'est poursuivi normalement durant les trois derniers
mois. La phase d'analyse se'mantique a e'te' comple'te'e par
l'ajout d'options d'exe'cutions, par le traitement
des tests et par un traitement pre'cis des appels de proce'dure.

\paragraph{}
La phase de paralle'lisation a e'te' rendue plus robuste. Il est maintenant
possible d'exe'cuter PIPS sur un des benchmark de l'ONERA, tmines.f.
Le calcul des de'pendances a
par ailleurs e'te' ame'liore' pour prendre en compte les effets
interproce'duraux et pour permettre ainsi un premier niveau de paralle'lisation
interproce'durale.

\paragraph{}
Ceci a permis de se rendre compte que le Fortran re'duit, de'fini a` partir
des benchmarks de l'ONERA, e'tait adapte' a` d'autres benchmarks comme ceux
du CEA pourvu que les modules BLOCKDATA soient re'incorpore's.

\end{document}
\end
