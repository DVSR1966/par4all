%
% Documentation de l'environnement de de'veloppement PIPS
%
% $RCSfile: dret146.ftex,v $ ($Date: 1994/05/20 12:32:36 $) version $Revision$, got on %D%, %T%
% %A%
%

\documentstyle[12pt,french]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

% pour importer des structures de donne'es Newgen
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}

\newcommand{\titre}{PROJET PIPS \\
		ENVIRONNEMENT DE DE'VELOPPEMENT\\
		{\em Version $Revision$}
}

\newcommand{\auteur}{
        	Franc,ois IRIGOIN \\ 
        	Pierre JOUVELOT \\
			Re'mi TRIOLET \\
			Arnauld LESERVOT \\
			Alexis PLATONOFF \\
			Ronan KERYELL \\
			Fabien COELHO \\
			Be'atrice APVRILLE 
}
%\newcommand{\docdate}{7 octobre 1993}
\newcommand{\docdate}{$Date: 1994/05/20 12:32:36 $}

\begin{document}

% conflit avec french.sty :
\renewcommand{\numero}{E146}

\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

% Pour mettre des petites choses rapidement en \tt :
\catcode `\"=\active
\edef"{\noexpand\verb\string"}

\tableofcontents

\newpage

\section*{Introduction}

Il n'est pas possible de pre'senter line'airement en une seule passe
l'ensemble des informations qui sont utiles au de'veloppeur PIPS.

La pre'sentation est pluto^t statique -- quels sont les fichiers utilise's
et comment sont-ils organise's -- que dynamique -- que faire pour ajouter
une nouvelle bibliothe`que? que faire pour recompiler PIPS avec d'autres
options de compilations? --

Il sera toujours possible d'ajouter de nouveaux chapitres quand des
re'dacteurs volontaires se pre'senteront.

L'usage d'emacs est obligatoire, ne serait-ce que pour be'ne'ficier
pleinement du me'canisme des tags et des buffers multiples.

\section{Organisation ge'ne'rale des re'pertoires de Pips}

Le re'pertoire racine du logiciel Pips s'appelle \verb+~pips/Pips+. Elle
est la proprie'te' de l'usager {\tt pips}.

Le de'coupage en sous-re'pertoires de ce re'pertoire racine est le
suivant.

\begin{itemize}

\item {\tt \bf Development.}
Ce re'pertoire contient les versions en cours de mise au point.

\begin{itemize}

\item {\tt \bf Passes.}
Ce re'pertoire contient les sources des diffe'rentes passes dans des
sous-re'pertoires portant les noms des passes. 

\item {\tt \bf Lib.}
Ce re'pertoire contient les sources des diffe'rentes bibliothe`ques dans des
sous-re'pertoires portant les noms des bibliothe`ques. Il contient aussi
un makefile permettant de recompiler toutes les bibliothe`ques. Ce makefile
n'est pas ge'ne're' automatiquement et il n'est donc pas force'ment a` jour.

\item {\tt \bf Runtime.}
Ce re'pertoire contient les sources des bibliothe`ques utilise'es a`
l'exe'cution des codes ge'ne're's par le PIPS.

\end{itemize}

\item {\tt \bf Documentation.}
Ce re'pertoire contient la documentation du projet Pips: les rapports
DRET, les lettres, les compte-rendus de discussions ou d'analyses, les
descriptions des repre'sentations internes, etc. Certains de ces
documents sont utilise's pour construire des fichiers de configuration
du projet. Un sous-re'pertoire, {\tt \bf Documentation/Newgen} contient
les descriptions en Latex des structures de donne'es utilise'es dans le
projet, telles qu'elles sont utilise'es a` la fois dans l'environnement
Production et dans l'environnement Development, mais pas dans
l'environnement Release. Ceci est du^ a` la non-modularite' introduite
par NewGen: il n'est pas possible de linker sans risques majeurs des
modules produits avec des passes inde'pendantes de NewGen.

\item {\tt \bf Production.}
Ce re'pertoire contient les versions temporairement de'clare'es comme
e'tant au point.

\begin{itemize}

\item {\tt \bf Src/Passes.}
Ce re'pertoire contient les sources des diffe'rentes passes dans des
sous-re'pertoires portant les noms des passes.

\item {\tt \bf Src/Lib.}
Ce re'pertoire contient les sources des diffe'rentes bibliothe`ques dans des
sous-re'pertoires portant leurs noms.

\item  {\tt \bf Src/Runtime.}
Ce re'pertoire contient les sources des diffe'rentes bibliothe`ques et
autres codes utilise's a` l'exe'cution par les codes produits.

\item {\tt \bf Bin.}
Ce re'pertoire contient les versions exe'cutables des passes de Pips ainsi
que ceux des {\em mains} se trouvant dans les bibliothe`ques.

\item {\tt \bf Lib.}
Ce re'pertoire
contient les bibliothe`ques elles-me^mes. Il contient aussi les
versions de re'fe'rence de fichiers de parame'trage, {\tt pipsmake.rc}
qui est automatiquement de'rive' d'un fichier contenu dans {\bf Documentation}
et {\tt properties.rc} qui ne se trouve nul part ailleurs\footnote{Ca
devrait changer. On pourrait tre`s bien l'extraire d'un fichier latex comme
pipsmake.rc.}.

\item {\tt \bf Include.}
Ce re'pertoire contient les fichiers ente^tes de Pips. Certains de ces
fichiers sont ge'ne're's automatiquement par la proce'dure
d'installation des makefiles de la partie Development. D'autres sont
cre'e's par des Makefile se trouvant dans {\bf Documentation} ou
{\bf Documentation/Newgen}.

\end{itemize}

\item {\tt \bf Release.}
Ce re'pertoire contient les binaires d'une version cohe'rente de tout le
logiciel Pips. Cette version sert pour les installations et pour les
de'monstrations.

{\em Ne semble plus utilise' depuis 1990... }
\begin{itemize}
\item {\tt \bf Config.}
Ce re'pertoire contient les scripts qui permettent de positionner toutes
les variables d'environnement. Certaines de ces variables sont
utilise'es par Pips, d'autres par le serveur X ou NeWS.

\item {\tt \bf Spec.}
Ce re'pertoire contient les fichiers de spe'cification de la
repre'sentation interne de Pips. Ces fichiers sont lus dynamiquement par
toutes les passes de Pips.

\item {\tt \bf Bin.}
Ce re'pertoire contient les versions exe'cutables des passes de Pips.

\item {\tt \bf Lib.}
Ce re'pertoire contient \verb+properties.rc+, \verb+pips_help.txt+ et
\verb+pips.icon+. Il faudra peut-e^tre y ajouter \verb+makefile.rc+.

\item {\tt \bf OpenWindow.}
Ce re'pertoire contient les fonts OpenWindows utilise'es par l'interface
graphique de Pips.

\end{itemize}

\item {\tt \bf Externals.}
Ce re'pertoire contient les bibliothe`ques de'veloppe'es au CRI et
utilise'es par Pips. Il s'agit principalement des bibliothe`ques\verb+Newgen+
et\verb+ Linear+. Seules les versions exe'cutables sont stocke'es ici, accompagne'es
des fichiers {\em headers} correspondants.

\item {\tt \bf Utilities.}
Ce re'pertoire contient tous les outils et scripts qui facilitent la
gestion de Pips et le recompilation de Pips, les bibliothe`ques Newgen
et Linear.
\begin{itemize}

  \item \verb+clean-pips+: destruction de fichiers inutiles

  \item \verb+make-pips+: cf. section Modification...

  \item \verb+recompile-pips(newgen, linear)+: cf. section Modification...

  \item \verb+search-pips+: recherche et, e'ventuellement, destruction
	 de fichiers auxiliaires comme les \verb+database+; exemple:
	destruction de toutes les bases non utilise'es depuis un
	mois:
	\begin{quote}
	\verb+search-pips -w -m -D+
	\end{quote}

  \item \verb+fetch-linear+: put in Externals the linear library and
	the related headers

  \item \verb+fetch-newgen+: put in Externals the NewGen library
	and its related headers

  \item \verb+analyze_libraries+: cf. section De'pendance entre Bibliothe`ques

  \item \verb+order_libraries+: cf. section De'pendance entre Bibliothe`ques

  \item \verb+tape-pips+: extraction d'une partie des fichiers de pips pour
	effectuer une installation ou une demonstration a` l'exterieur; les
	fichiers sont naturellement pris dans \verb+Production+; ne pas
	oublier de faire les installations ne'cessaires auparavant. Voir aussi:
	\verb+bar+, \verb+eject+, \verb+fdformat+ et \verb+tar+. Pour utiliser
	le floppy: \verb+/dev/rfd0+.

  \item \verb+make-pipsrc.csh+: derivation de \verb+pipsrc.csh+ a` partir
	de \verb+pipsrc.sh+. Ce shell-script est appele' dans
	\verb+$PIPSDIR/Makefile+.

  \item	\verb+make-pipsrc.sh+: derivation de \verb+pipsrc.sh+ a` partir
	de \verb+pipsrc.ref+. Ce shell-script est appele' dans
	\verb+$PIPSDIR/Makefile+.

  \item \verb+Validate+: non-regression test; see ?!?;

	The arguments are names of subdirectories in
	\verb+Pips/Tests/Validation+.

	Tests are organized on a library basis in \verb+Pips/Tests/Validation+
	while bugs are reported in the same way in \verb+Pips/Tests/Bugs+.
	Bugs and non-regression tests are characterized by one or more Fortran
	programs which either core dump (for bugs) or must have a known
	result (tests).

	set
	\verb+PIPSDBM_DEBUG_LEVEL+ to 5 to check data structures when they are
	stored and to 9 to check them when they are delivered; some data
	structures are not checked, among them, all that contain external
	types;

	use \verb+accept+ to update reference files for validation; can be
	used with \verb+/usr/ucb/mail+: \verb+| xx accept+ where \verb+xx+
	is the message number;

	To run it in background, redirect stderr on /dev/null. Example:
	\begin{quote}
	\verb+Validate DemoStd 2>/dev/null &+
	\end{quote}

	When a bug is corrected, run \verb+bug-to-validate+ to move the
	bug case from \verb+Bugs/xxx+ to \verb+Validation/xxx+.

	Do not forget to update \verb+Documentation/pips-bugs.f.tex+.

  \item \verb+Init, Select, Perform, Display, Pips+: batch interface
	for PIPS; it is described in ???

  \item \verb+stf-workspace+: calls Toolpack restructurer \verb+stf+ on each
	Fortran file in a workspace;

  \item \verb+pips-experiment+: runs the same analyses and
	transformations on each module in a workspace

  \item \verb+print-dg-statistics+: exploits some of the statistics
	generated by the dependence graph computation when a specific
	property is true (\verb+RICE_DG_PROVIDE_STATISTICS+);

\end{itemize}

  \item \verb+Experiments+ is a large piece of disk space to be used
	temporarily to analyze large programs and to core dump large
	pips processes; no permanent, non-deductible information should
	be stored there;

\end{itemize}

Il manque actuellement un re'pertoire {\tt \bf Backup} permettant
de de'sinstaller une bibliothe`que ou une passe moins au point que
son de'veloppeur ne le croyait.

L'impression du code de sortie peut-etre ameliore'e en utilisant \verb+tgrind+:
\begin{verbatim}
tgrind -lf extr_doall.f
\end{verbatim}

\section{Environnement shell (sh, csh, ksh, tcsh)}

  De nombreuses variables d'environnement sont utilise'es par les
proce'dures et les exe'cutables PIPS, qu'ils soient contenus dans {\tt
\bf Utilities} ou dans {\tt \bf Bin}. Ces variables sont initialise'es
par le script {\tt Pips/pipsrc.sh} (de'rive' de {\tt Pips/pipsrc.ref})
pour sh et ksh et par le script {\tt Pips/pipsrc.csh} pour csh et tcsh qui
est de'rive' automatiquement du pre'ce'dent (voir
\verb+$UTILDIR/make-pipsrc.csh+, ou plus simplement exe'cuter {\tt make}
sous \verb+$PIPSDIR+). Elles de'crivent essentiellement la structure des
re'pertoires PIPS et les options de compilation.

\section{NewGen}

NewGen est l'outil de ge'nie logiciel avec lequel sont ge're'es
(presque) toutes les structures de donne'es du projet PIPS. Il est
de'crit dans ???, rapport CAII-????.

NewGen a le me^me statut que {\tt cc}, {\tt ld} ou {\tt make}, ce qui
signifie qu'il est conside're' comme un outil externe et qu'il ne fait
pas partie du projet PIPS.

Ne'ammoins, comme cet outil demande encore de la mise au point, les
bibliothe`ques qui en proviennent, {\tt genC.a, hash.a, set.a,...}, sont
copie'es (et non pas linke'es par {\tt ln} ou {\tt ln -s}) dans le
re'pertoire {\tt Externals}. Cette ope'ration doit e^tre effectue'e
manuellement a` chaque modification de Newgen. Un utilitaire, {\tt
Utilities/fetch-newgen}, permet de l'effectuer sans rien oublier.

Les fichiers headers correspondants sont copie's dans le me^me re'pertoire,
{\tt Externals}.

Les sources de NewGen, qu'il est parfois utile d'aller consulter, se
trouvent dans \verb+$NEWGENDIR+.

Plusieurs fonctionalite's sont utiles lors de la mise au point:
\begin{itemize}

  \item \verb+gen_consistent_p()+ permet de verifier qu'une structure
	de donne'es NewGen existante est (re'cursivement) bien construite;

  \item \verb+gen_defined_p()+ permet de verifier qu'une structure
	de donne'es NewGen existante est (re'cursivement) comple`tement de'finie;

  \item \verb+gen_debug+ est une variable externe qui permet de ve'rifier
	dynamiquement lors de leur construction et lors de leur
	parcours re'cursif que les structures de donne'es NewGen
	sont cohe'rentes. Activation:
	\begin{quote}
	\verb+ gen_debug |= GEN_DBG_CHECK;+
	\end{quote}
	Arre^t:
	\begin{quote}
	\verb+ gen_debug &= ~GEN_DBG_CHECK;+
	\end{quote}
	En desespoir de cause:
	\begin{quote}
	\verb+ gen_debug = GEN_TRAV_OBJ+
	\end{quote}

  \item pour imprimer le nume'ro du type NewGen d'un objet
	\verb+obj+, faire sous \verb+dbx+:
	\begin{quote}
	\verb|(dbx) print obj->i|
	\end{quote}

  \item pour imprimer le nom d'une entite' \verb+e+, faire:
	\begin{quote}
	\verb|(dbx) print (e+2)->s|
	\end{quote}

  \item pour imprimer l'e'tiquette d'un statement \verb+stmt+, faire:
	\begin{quote}
	\verb|(dbx) print ((stmt+1)->p+2)->s|
	\end{quote}

  \item pour imprimer le domaine d'un objet Newgen par partie de son
	numero (\verb+obj->i+):
	\begin{quote}
	\verb|(dbx) print Domains[obj->i].name|
	\end{quote}

\end{itemize}

Il est pre'vu de de'finir des macros {\tt gdb} compatibles avec les
macros C.

\section{Bibliothe`que Line'aire}

La bibliothe`que d'alge`bre line'aire a e'te' de'veloppe'e
inde'pendamment du projet PIPS, avec un financement CNRS.

La bibliothe`que line'aire a le me^me statut que la libC, ce qui
signifie qu'elle est conside're'e comme une bibliothe`que externe.

Ne'ammoins, comme cette bibliothe`que demande encore de la mise au
point, ses diffe'rents constituants {\tt arithmetique.a, vecteur.a, ...}
sont copie's (et non pas linke's) dans le re'pertoire {\tt Externals}.
Cette ope'ration devrait e^tre effectue'e manuellement a` chaque modification.
Un utilitaire, {\tt Utilities/fetch-linear}, permet de l'effectuer.

Comme la bibliothe`que {\tt \bf C3/Linear} est organise'e d'une manie`re
assez similaire a` Newgen, il ne faut pas avoir oublie' d'effectuer une
installation, apre`s une modification des sources dans {\tt \bf
C3/Linear/Developement}. A ce niveau, des makefiles permettent de
recompiler toutes les sous-bibliothe`ques.

Les fichiers headers correspondants sont copie's dans le me^me re'pertoire,
{\tt \bf Externals}.

\section{Makefiles}

L'utilitaire {\tt make} est utilise' extensivement pour assurer la cohe'rence
des composantes de pips. Cependant, la plupart des makefiles ne sont pas
e'crits a` la main mais de'rive's automatiquement de fichiers appele's
{\tt config.makefile}. Cette de'rivation automatique, assure'e par
l'utilitaire {\tt pips-makemake}, permet de garantir le bon e'tat
des de'pendances et des proce'dures d'installation.

Il faut penser a` refaire des {\tt make depend} de temps a` autres
pour assurer la mise a` jour des de'pendances entre fichiers. Il est
indispensable que le fichier header de la bibliothe`que ou de la passe
existe dans la directory courante, sans quoi make depend va selectionner
la version se trouvant dans \verb+Production/Include+ et le header ne
sera me^me pas recre'e'.

L'entre'e \verb+test+ permet de cre'er une version de \verb+pips+ utilisant
la version locale de la bibliothe'que (i.e. du re'pertoire) courante. Ceci
permet de ve'rifier que l'e'dition de liens fonctionne bien et que les
nouveaux modules ont le comportement souhaite' dans l'environnement pips.

\newpage

Voici un exemple typique de config.makefile:

\begin{verbatim}
...
AR=		$(PIPS_AR)
ARFLAGS=	$(PIPS_ARFLAGS)
CC=		$(PIPS_CC)
CFLAGS=		$(PIPS_CFLAGS)
CPPFLAGS=	$(PIPS_CPPFLAGS)
LD=		$(PIPS_LD)
LDFLAGS=	$(PIPS_LDFLAGS)
LEX=		$(PIPS_LEX)
LFLAGS=		$(PIPS_LFLAGS)
LINT=		$(PIPS_LINT)
LINTFLAGS=	$(PIPS_LINTFLAGS)
YACC=		$(PIPS_YACC)
YFLAGS=		$(PIPS_YFLAGS)
#
# The following macros define your pass.
#
# Name of the target
TARGET= 	parallelize
#
# Source, header and object files used to build the target
TARGET_CFILES=	kennedy.c scan.c util.c dependence.c algebre.c \
		divar.c debug.c codegen.c scc.c
TARGET_HEADERS=	includes.h
TARGET_OBJECTS=	kennedy.o scan.o util.o dependence.o algebre.o \
		divar.o debug.o codegen.o scc.o
#
# List of libraries used to build the target
TARGET_LIBS=	-lprivatize -lusedef -lprettyprint -lsemantics -ltransformer \
		 -lcontrol -leffects -lnormalize \
		-lsc -lcontrainte -lvecteur -larithmetique \
		-lri-util -lmisc -lproperties -lgenC /usr/lib/debug/malloc.o \
		-lproperties

\end{verbatim}

\section{Organisation d'une bibliothe`que}

Les fichiers sources de la bibliothe`que {\tt b} se trouve dans le re'pertoire
{\tt Development/Lib/b}.

Un fichier config.makefile doit e^tre cre'e' dans ce me^me re'pertoire;
il doit e^tre mis a` jour avec les noms des fichiers sources et objets de la
bibliothe`que, plus quelques autres. Il peut aussi e^tre augmente'
de re`gles et de de'finitions compatibles avec la syntaxe de {\tt make}.

Le fichier config.makefile permet a` la commande {\tt pips-makemake -l}
de cre'er automatiquement un fichier Makefile aux normes Pips (les
normes Pips sont tout a` fait stables...). Ce fichier Makefile contient
notamment une entre'e install pour installer la bibliothe`que dans la
partie production. Un fichier header est cre'e' a` l'installation.

Un soin tout particulier doit e^tre apporte' a` la cre'ation automatique
du fichier header {\tt b.h} de'crivant cette bibliothe`que. Ce fichier
automatiquement ge'ne're' est la concate'nation d'une part de
l'e'ventuel fichier {\tt b-local.h} contenant les macros, types et
autres de'finitions ne'cessaires pour utiliser la bibliothe`que, et
d'autre part du fichier extern.h cre'e' automatiquement par la commande
{\tt new-make-extern}.

La concate'nation de ces deux fichiers est faite automatiquement sur
de'cision du programmeur par la commande '{\tt make b.h}' ou lors d'une
mise a` jour de {\tt b-local.h} mais pas lorsque {\tt extern.h} varie;
ceci permet d'e'viter les recompilations intempestives en pe'riode de
mise au point de la bibliothe`que. Une e'ventuelle incohe'rence avec
{\tt extern.h} peut conduire a` des diagnostics de compilation relatifs
aux types des fonctions de la bibliothe`que b lorsqu'elles sont
utilise'es dans le corps d'autres fonctions de b.

Le fichier {\tt b.h} est syste'matiquement cre'e' a` chaque commande '{\tt
make install}', avant la copie dans la partie production.

En d'autres termes, il ne faut jamais modifier directement le fichier
{\tt b.h} quoiqu'aucun warning ne soit prefixe' (bug a` corriger). Il
faut toujours e'diter {\tt b-local.h}.

Si un programme principal permettant de tester ou d'utiliser la
bibliothe`que existe, ce programme a ne'cessairement le statut de passe.
La raison est que l'expe'rience montre que soit ce programme existe et
est effectivement une passe (prettyprinter, controlizer, privatizer,
...) ou bien n'existe pas et est alors re'duit a` {\tt main(){}}.

En fait, cette re`gle n'est pas respecte'e et cela provoque des cycles
en cas de recompilation globale.

\subsection{Relation entre bibliothe`ques et structures de donne'es}

Les structures de donne'es du projet PIPS sont ge're'es par NewGen
qui de'rive pour chacune d'entre elles un fichier header. Par
exemple, la repre'sentation interne (i.e. l'abstract syntax tree)
est appele'e ri. Elle est initialement de'crite dans un fichier de
documentation {\tt ri.f.tex} stocke' dans {\tt \bf Documentation/Newgen},
puis mise en format NewGen dans {\tt ri.newgen} et enfin exploite' par
NewGen pour produire un fichier de description interne {\tt ri.spec}
et un fichier C {\tt ri.h} ne'cessaire aux programmeurs voulant utilise'
cette structure {\tt ri}.

Il n'est donc pas possible de de'velopper une bibliothe`que de modules
de base, plus e'volue's que ceux que fournit NewGen, ope'rant sur cette
structure de donne'es {\tt ri} et de lui donner le nom {\tt ri}. Ceci
est vrai non seulement pour la structure {\tt ri}, mais pour toutes les
structures construites a` l'aide de NewGen. Les noms des bibliothe`ques
associe'es sont donc ge'ne'ralement suffixe's par {\tt -util}, ce qui
donne {\tt libri-util.a} et {\tt ri-util.h}. Il y a malheureusement
de nombreuses exceptions...

Pour des raisons historiques, beaucoup de modules de base ne se trouvent pas
la` ou` on les attendrait mais dans la premie`re bibliothe`que ou` ils
se sont ave're's ne'cessaires ({\tt syntax}, le parser, en est le cas le
plus flagrant).

\subsection{Tags}

  Vu le tre`s grand nombre de macros et de fonctions utilise'es dans le projet,
il faut utiliser le me'canisme de tags pour retrouver le code source
sous EMACS\footnote{Il y a aussi des tags pour {\tt vi}.}.

  Les tags sont recalcule's pe'riodiquement par l'utilitaire PIPS
\verb+make-tags+ qui utilise la variable
d'environnement \verb+PIPS_ETAGS+ (qui pointe sur une commande
\verb+etags+), et stocke's dans {\tt Pips/Tags/TAGS}. Ils correspondent a`
la version {\tt Development}.  Les fonctions provenant des bibliothe`ques
externes n'en font pas toujours partie, mais chacun peut se construire son
propre fichier de tags, y compris en concate'nant simplement divers
fichiers de tags.

\subsection{De'pendance entre bibliothe`ques}

Il faut e'viter de cre'er des cycles de de'pendance entre bibliothe`ques.
Une situation ou` la bibliothe`que $A$ contient un module $a$ appelant un module
$b$ de la bibliothe`que $B$ qui appelle lui-me^me un module $a'$ de $A$ ne
permet pas d'effectuer des links simples. Cette situation refle`te aussi une
mauvaise organisation logique des bibliothe`ques. 

Les bibliothe`ques de PIPS doivent {donc}, en principe, former une structure
de DAG, i.e. posse'der un ordre partiel.

Des utilitaires, dont les principaux sont {\tt analyze\_libraries, \tt
order\_libraries}, permettent de determiner les {\tt uses} et les {\tt
defs}, un ordre total des bibliothe`ques compatible avec leur ordre partiel et les cycles e'ventuels.Les re'sultats des analyses sont stocke's dans {\tt /tmp/libs.?} ou` le point d'interrogation peut prendre diffe'rentes valeurs:
\begin{itemize}
  \item u: uses, listes des modules utilise's par une bibliothe`que
  \item d: defs, listes des modules de'finis par une bibliothe`que
  \item j: join entre uses et defs
  \item o: ordre entre bibliothe`ques
  \item etc...
\end{itemize}

\subsection{Mise en place d'une nouvelle phase/biblioth\`eque}

Les fonctionalite's offertes par certaines bibliothe`ques sont
parfois directement visibles des utilisateurs par le biais de
\verb+pipsmake+. La suite de ce paragraphe ne se comprend qu'apre`s
avoir pris connaissance de la documentation correspondante.

Une biblioth\`eque {\em mylib} de Pips est repr\'esent\'ee par une fonction C
(nomm\'ee {\tt mylib}) n'ayant qu'un argument en entr\'ee, une cha\^{\i}ne de
caract\`eres repr\'esentant le nom d'un module Fortran \`a analyser.
Elle doit mettre en place les variables globales ne'cessaires a` son
exe'cution a` l'aide des \verb+properties+ et acque'rir les resources
ne'cessaires par des appels a` \verb+pipsdbm+. Aucun appel a` \verb+pipsmake+
n'est (pour le moment) autorise' a` ce niveau.

Voici, les \'etapes \`a suivre pour installer la nouvelle
biblioth\`eque {\em mylib}~:

\begin{itemize}

\item cr\'eer un r\'epertoire {\tt mylib} dans {\tt \$DEVEDIR/Lib} contenant 
les fichiers {\tt mylib.c} (o\`u se trouve le code de la fonction C {\tt 
mylib()}) et {\tt main.c} (contenant une fonction {\tt main()} vide).

\item dans le r\'epertoire {\tt \$DEVEDIR/Lib/mylib}~:

\begin{itemize}

\item cr\'eer un fichier {\tt config.makefile} en s'inspirant
d'une autre biblioth\`eque.

\item ex\'ecuter la commande {\tt pips-makemake} (option -l) pour
construire le fichier {\tt Makefile} automatiquement.

\item ex\'ecuter les commandes {\tt make libmylib.a} et {\tt make install},
pour que cette nouvelle fonction soit ``{visible}'' par les autres
biblioth\`eques et passes, {\em i.e.} pour installer cette biblioth\`eque dans
le r\'epertoire {\tt \$PRODDIR} et copier les fichier {\tt mylib.h} et {\tt
libmylib.a} dans, respectivement, {\tt \$INCLUDEDIR} et {\tt \$LIBDIR}.

Il important de signaler que le {\tt Makefile} utilise la commande {\tt
cproto} (variable d'environnement \verb+PIPS_PROTOIZE+)
(qui se trouve dans le r\'epertoire {\tt \$UTILDIR}) qui permet de construire
automatiquement le fichier {\tt mylib.h}. Pour obtenir une reconstruction
explicite de ce fichier, il suffit d'ex\'ecuter successivement les deux
commandes {\tt touch mylib-local.h} et {\tt make mylib.h}.

\end{itemize}

\item dans le r\'epertoire {\tt \$PIPSDIR}~:

\begin{itemize}

\item mettre \`a jour le fichier d'initialisation des variables
d'environnement Shell pour Pips {\tt pipsrc.ref}. Cela consiste \`a rajouter
la cha\^{\i}ne de caract\`eres {\tt -lmylib} dans la variable {\tt
\$PIPS\_LIBS} (l'ordre des biblioth\`eques est important, il faut placer cette
nouvelle biblioth\`eque apr\`es les bi\-blio\-th\`eques qui utilisent les
fonctions qu'elle d\'efinies et avant celles dont elle utilise les fonctions).

\item ex\'ecuter la commande {\tt make} qui met alors
automatiquement \`a jour les fichiers d'initialisation des variables
d'environnement {\tt pipsrc.sh} et {\tt pipsrc.csh}.

\end{itemize}

\item dans le r\'epertoire {\tt \$DOCDIR}~:

\begin{itemize}

\item d\'eclarer l'existence de cette nouvelle biblioth\`eque en modifiant le 
fichier de r\`egles {\tt pipsmake-rc.f.tex}. Chaque r\`egle indique les 
d\'ependances sur les ressources en entr\'ee et en sortie de chaque 
biblioth\`eque. Dans la pratique, il faut s'inspirer des autres r\`egles 
d\'ej\`a d\'efinies dans le fichier. On peut y ajouter une d\'eclaration 
d'alias pour obtenir de plus jolis menus sous \verb+wpips+, l'interface 
multifene^tre.

Par exemple, pour une biblioth\`eque {\em lib} qui lit une ressource {\em res1}
et \'ecrit une ressource {\em res2} du module cela donne~:

\begin{verbatim}
lib                            > MODULE.res2
        < PROGRAM.entities
        < MODULE.res1
\end{verbatim}

Il faut noter qu'en r\`egle g\'en\'erale, une biblioth\`eque utilise toujours
les {\em entities} du programme.

\item Une se'rie de nouvelles ``{properties}'' peut e^tre ne'cessaire pour le 
fonctionnement de cette nouvelle phase. Il ne faut pas oublier de les de'clarer
dans le fichier de re'fe'rence des properties, {\tt properties-rc.f.tex}.

\item ex\'ecuter la commande {\tt make all} pour d\'eriver de ce fichier de 
r\`egles les fichiers {\tt phases.h} et {\tt resources.h} {\tt builder-map.h}
plac\'es dans {\tt \$INCLUDEDIR}, et les fichiers {\tt pipsmake.rc}, {\tt
wpips.rc} et {\tt properties.rc} plac\'es dans {\tt \$LIBDIR}.


\end{itemize}

\item dans le r\'epertoire {\tt \$BINSRCDIR/pips}, ex\'ecuter successivement 
les commandes {\tt make clean}, {\tt make production-depend} et {\tt make 
\$BINDIR/pips}, qui recompilent et installent une nouvelle version de 
l'ex\'ecutable {\tt pips}.

\end{itemize}

Il peut aussi s'ave'rer ne'cessaire de mettre a` jour les script shell
qui se trouvent dans \verb+Utilities+ (Build, Init, Select, Perform).

Cette section ne traitait pas le cas o\`u une nouvelle ressource doit \^etre
introduite, c'est l'objet de la section suivante.

\subsection{Mise en place d'une nouvelle ressource}

Une ressource {\em myres} de Pips est d\'eclar\'ee par son utilisation ou sa 
production par l'une des r\`egles du fichier {\tt pipsmake-rc.f.tex} (cf. 
ci-dessous). Voici, les \'etapes \`a suivre pour installer la nouvelle 
ressource {\em myres}~:

\begin{itemize}

\item dans le r\'epertoire {\tt \$DOCDIR}~:

\begin{itemize}

\item d\'eclarer l'existence de cette nouvelle ressource en modifiant le 
fichier de r\`egles {\tt pipsmake-rc.f.tex}. Chaque r\`egle indique les 
d\'ependances sur les ressources en entr\'ee et en sortie de chaque 
biblioth\`eque. Dans la pratique, il faut s'inspirer des autres r\`egles 
d\'ej\`a d\'efinies dans le fichier.

\item ex\'ecuter la commande {\tt make all} pour d\'eriver de ce fichier de 
r\`egles les fichiers {\tt phases.h} et {\tt resources.h} plac\'es dans {\tt 
\$INCLUDEDIR}, et les fichiers {\tt pipsmake.rc} et {\tt wpips.rc} plac\'es 
dans {\tt \$LIBDIR}.

\end{itemize}

\item dans le r\'epertoire {\tt \$DEVEDIR/Lib/pipsdbm}~: il faut d\'eclarer 
l'existence de cette nouvelle ressource {\em myres} au gestionnaire des 
ressources {\em pipsdbm}~:

\begin{itemize}

\item mettre \`a jour le fichier {\tt module.c} en ajoutant une ligne contenant
\verb+DBR_MYRES,+ dans le tableau {\tt load\_order[]} qui d\'efinit les
ressources \`a d\'echarger lors de la fermeture d'un module.

\item mettre \`a jour le fichier {\tt methods\_io.c} en augmentant le tableau
{\tt method\_map[]} de la ligne suivante~:

{
\begin{verbatim}
{DBR_MYRES,(chunk *(*)()) undefined_method, undefined_method,
     undefined_method, (bool (*)()) undefined_check},
\end{verbatim}
}

Les arguments correspondent aux fonctions de lecture, d'\'ecriture, de
destruction et de test de cette ressource (ici, elles sont non
d\'efinies).

\item mettre a` jour les fichiers {\tt disk.c} et {\tt module.c} si la
nouvelle ressource est un fichier et non une structure de donne'es.

\item ex\'ecuter les commandes {\tt make libpipsdbm.a} et {\tt make install}
afin de mettre \`a jour {\em pipsdbm} et de l'installer.

\end{itemize}

\item dans le r\'epertoire {\tt \$BINSRCDIR/pips}, ex\'ecuter successivement 
les commandes {\tt make clean}, {\tt make production-depend} et {\tt make 
\$BINDIR/pips}, qui recompilent et installent une nouvelle version de 
l'ex\'ecutable {\tt pips}.

\end{itemize}


\subsection{Modification ou ajout d'une structure de donne'es NewGen}

Les structures de donn\'ees NewGen sont d\'efinies dans un fichier \LaTeX{} se 
trouvant dans le r\'etertoire {\tt \$DOCDIR/Newgen}. A partir de ces fichiers, 
nous pouvons obtenir automatiquement les fichiers DDL\footnote{Les types NewGen
sont apple\'es {\em domaines} et sont d\'efinis \`a partir d'un langage de haut
niveau appel\'e DDL, pour {\em Doamin Definition Language}.}. Lors de la 
d\'eclaration d'une nouvelle structure deux cas se pr\'esentent~:

\begin{enumerate}

\item Cette structure est d\'efinie dans un nouveau fichier ({\tt
mysd.f.tex})~:

dans ce cas, quelques manipulations pr\'ealables sont alors n\'ecessaires avant
l'installation~; en effet, la cr\'eation d'un nouveau fichier n\'ecessite la
mise \`a jour du fichier {\tt Makefile} qui se trouve dans le r\'epertoire {\tt
\$DOCDIR/Newgen}, dans lequel il faut compl\'eter les deux listes {\tt
SOURCE\_FILES} et {\tt NEWGEN\_FILES} avec respectivement {\tt mysd.f.tex} et
{\tt mysd.newgen}, et cr\'eer la d\'ependance correspondant \`a ce nouveau
fichier (en s'inspirant des d\'ependances sur les autres fichiers)~:

\begin{verbatim}
mysd.newgen: mysd.f.tex
        remove-latex-comments mysd.f.tex
        cp mysd.newgen $(NEWGEN_DIR)/mysd.newgen
\end{verbatim}

De plus, il faut ajouter un ``{include}'' du ``header'' de cette structure 
({\tt mysd.h}) dans le fichier {\tt newgen.c} du r\'epertoire {\tt 
\$DEVEDIR/top-level} et dans les fichiers {\tt module.c} et {\tt methods\_io.c}
du r\'epertoire {\tt \$DEVEDIR/pipsdbm}. Il n'est pas obligatoire d'ex\'ecuter 
imm\'ediatement la commande {\tt make install} dans ces deux r\'epertoires, 
n\'eanmoins cela sera n\'ecessaire juste avant la recompilation compl\`ete de 
{\tt \$PRODDIR} (cf. ci-dessous), sinon ces modifications ne seront pas prises 
en compte.

Enfin, dans le r\'epertoire {\tt \$INCLUDEDIR} (o\`u se trouve les fichiers DDL
de toutes les structures de donn\'ees Newgen utilis\'ees dans Pips, les ``{\tt 
*.newgen}''), modifier dans le fichier {\tt constants.h} la valeur de la 
``macro'' {\tt ALL\_SPECS} qui donne l'ordre dans lequel les fichiers DDL ont 
\'et\'e pris en compte et qui est utilis\'ee pour l'initialisation de Newgen 
\`a l'ex\'ecution. Cet ordre est donn\'e par le r\'esultat affich\'e par la 
commande {\tt make c\_internal\_representation} (cf. ci-dessous).

Par exemple, si avant l'installation de ce nouveau fichier cette macro est
d\'efinie comme suit~:

\begin{verbatim}
#define ALL_SPECS \
        sd1_spec , \
        sd2_spec , \
        sd3_spec
\end{verbatim}

et si le r\'esultat de cette commande est le suivant~:

\begin{verbatim}
sd1_spec
mysd_spec
sd2_spec
sd3_spec
\end{verbatim}

alors, il faut modifier cette macro comme suit~:

\begin{verbatim}
#define ALL_SPECS \
        sd1_spec , \
        mysd_spec , \
        sd2_spec , \
        sd3_spec
\end{verbatim}

\item Cette structure est d\'efinie dans un fichier d\'ej\`a existant ({\tt 
mysd.f.tex})~: dans ce cas, il suffit alors juste de modifier ce fichier {\tt 
mysd.f.tex} comme n\'ecessaire.

\end{enumerate}

Ensuite, dans tous les cas, il faut suivre les \'etapes suivantes~:

\begin{itemize}

\item dans le r\'epertoire {\tt \$DOCDIR/Newgen}, ex\'ecuter la commande {\tt 
make} (\'equivalent \`a {\tt make c\_internal\_representation}), qui construit 
le fichier DDL {\tt mysd.newgen}, le copie dans le r\'epertoire {\tt 
\$INCLUDEDIR}, puis dans ce dernier r\'epertoire, ex\'ecute la commande {\tt 
newgen -c *.newgen}, qui reconstruit le ``header'' de chaque structure de 
donn\'ees. Cette commande reconstruit \'egalement pour chaque fichier DDL le 
fichier de sp\'ecification correspondant, les ``{\tt *.spec}''~; ces fichier ne
sont plus utilis\'es.

\item Comme NewGen exploite globalement toutes les structures de donn\'ees 
d\'efinies dans le projet, toute modification de l'une d'entre elles entrai^ne 
potentiellement la modification de toutes leurs interfaces. Il est donc 
n\'ecessaire de recompiler\footnote{Au pr\'ealable, il ne faut pas oublier 
d'ex\'ecuter {\tt make install} dans {\tt \$DEVEDIR/Lib/top-level} et {\tt 
\$DEVEDIR/Lib/pipsdbm} si les fichiers {\tt newgen.c}, {\tt module.c} et {\tt 
methods\_io.c} ont \'et\'e modifi\'es (cf.ci-dessus).} tout {\tt \$PRODDIR}. 
Deux scripts shell se trouvant dans {\tt \$UTILDIR} nous permettent de 
r\'ealiser cette recompilation globale~:

\begin{itemize}

\item {\tt make-pips}~: ex\'ecute un make dans toutes les biblioth\`eques et 
dans toutes les passes composant pips~; l'option -d recompile dans {\tt 
Development}, alors que l'option -p recompile dans {\tt Production} et installe
la librairie dans {\tt \$LIBDIR} ({-p} par d\'efaut)~; l'option -n, identique a` 
celle de make, permet de voir ce qui n'est pas a` jour~; l'option -r 
(recompile) associ\'ee a` -p, ex\'ecute {\tt make clean} puis {\tt make 
production-depend} avant l'ex\'ecution du {\tt make}~; c'est l'option qui 
permet l'installation initiale ou la recompilation totale.

Le recalcul des d\'ependances d\'eriv\'ees automatiquement dans chaque Makefile
est indispensable quand on installe {\tt pips} sur un nouveau syste`me dont la 
structure de r\'epertoires est a` peu pre`s toujours diff\'erente parce que les
d\'ependances sont exprim\'ees avec des noms de fichiers absolus. La 
destruction des fichiers d\'eriv\'es est indispensable en cas de changement 
d'option de compilation (par exemple, un essai {\tt -O3} pour ameliorer les 
temps d'ex\'ecution ou {\tt -p} pour faire du profiling).

\item {\tt recompile-pips}~: cette commande est obsole`te. Elle est remplac\'ee
par l'une des options de la commande pr\'ec\'edente, {\tt make-pips -r}.

\end{itemize}

\end{itemize}

\subsection{Changement de la bibliothe`que d'allocation dynamique}

Les erreurs les plus difficiles a` trouver sont g\'ene'ralement des
erreurs d'allocation dynamique d'espace me'moire. La zone alloue'e
peut e^tre utilise'e apres avoir e'te' libe're'e ({\em dangling pointer}).
Une zone supe'rieure a` la zone alloue'e a pu e^tre utilise'e (copie
d'une chaine de caracte`res trop longue).

Un premier niveau de ve'rification est possible en utilisant un
ensemble de primitives de debug SUN ({man malloc.h}) et en linkant
les programmes avec \verb+/usr/lib/debug/malloc.o+. La modification
est a` effectuer dans \verb+pipsrc.ref+ ou dans l'environnement courant
(sans garantie quant aux possibles {\em undef} trouve's par l'e'diteur
de lien).

Un deuxie`me niveau, beaucoup plus efficace mais aussi beaucoup plus lent,
est offert par une bibliothe`que du domaine public, \verb+malloclib-pl11+.
Cette bibliothe`que re'e'crit syste'matiquement un motif spe'cial dans
les zones libe're'es et ve'rifie que les ope'rations sur les chai^nes
de caracte`res sont valides. Elle permet aussi de savoir dans quelle
proce'dure de quel fichier les allocations (et les libe'rations) ont e'te'
effectue's.

Pour la mettre en oeuvre efficacement, il faut que tous les fichiers
sources utilisant des fonctions de ce type incluent \verb+malloc.h+ avec
des double quotes (et non des crochets).  Ceci est obtenu dans la
plupart des cas parce que \verb+genC.h+, qui est indispensable pour
Newgen, inclut \verb+malloc.h+. Il faut quand me^me penser a` des
fichiers n'effectuant que des manipulations de chai^nes de caracte`res
et qui n'ont, a priori, pas besoin d'include
\verb+malloc.h+.

Puis il faut recompiler l'ensemble de PIPS (voir \verb+make-pips+) et
des bibliothe`ques contenues dans
\verb+Externals+, apre`s avoir fait un renommage ({\tt mv}) de
\verb+dbmalloc.h+ en \verb+malloc.h+ dans \verb+External+ et dans les
re'pertoires contenant les sources des bibliothe`ques externes (\verb+Newgen+
et \verb+C3/Linear+). Avant de faire des e'ditions de liens, il faut avoir
modifie' la variable \verb+PIPS_LIBS+ dans l'environnement courant ou
dans \verb+pipsrc.ref+ (et exe'cute' dans ce deuxie`me cas un
\verb+Pips/make+) pour inclure la bonne bibliothe`que.

Il est
conseille' de conserver une version de \verb+pips+ linke' avec une
bibliothe`que raisaonnablement rapide de manie`re a` pouvoir cre'er
des bases de donne'es de bonne taille pour les tests. 
Pour e'viter d'avoir trop de choses a` recompiler chaque fois, il
est aussi conseiller de modifier les variables shell \verb+$BINDIR+ et 
\verb+$LIBDIR+ pour conserver en paralle`le
les versions compilees et linkees avec et sans bibliothe`que de mise au
point.

\subsection{Variables globales, modifications}

A e'viter ou a documenter soigneusement, surtout quand on ajoute des
variables globales au risque de perturber les programmes de'ja`
existants.

Si on a besoin de nouvelles fonctionalite's, il vaut mieux essayer de ne
pas modifier le module existant mais d'en ajouter un nouveau avec un
autre nom.

Pour les variables globales, il faut penser a` procurer une routine
d'initialisation, une routine d'acces et une routine de remise en
veille.  Il ne faut pas oublier que plusieurs reque^tes peuvent avoir a`
e^tre traite'es sous \verb+wpips+ ou \verb+tpips+ alors que les tests se
font avec \verb+build+, qui a un fonctionnement batch beaucoup plus simple.

\section{Organisation d'une passe}

Les fichiers sources de la passe p se trouve dans le re'pertoire
{Development/Passes/p}. Une passe, pas opposition a` une bibliothe`que,
correspond a` un fichier exe'cutable, visible par les utilisateurs.

Un fichier config.makefile doit e^tre cre'e' dans ce me^me re'pertoire;
il doit e^tre mis a` jour avec les noms des fichiers sources de la
passe.

Le fichier config.makefile permet a` la commande {\tt pips-makemake -p}
de cre'er automatiquement un fichier Makefile aux normes Pips (les
normes Pips sont tout a` fait stables ...). Ce fichier Makefile contient
notamment une entre'e install pour installer la passe dans la partie
production.


Les bibliothe`ques utilise'es pour fabriquer la passe sont recherche'es
dans les re'pertoires {\tt Production/Libs} et {\tt Externals}. Les
headers correspondants sont recherche'es dans les re'pertoires {\tt
Production/Include} et {\tt Externals}.

Pour une re'utilisation optimum du code, il est conseille' de limiter le
de'veloppement de code au niveau des passes a` ce qui leur est
spe'cifique. Tout le reste doit e^tre dans les bibliothe`ques (cf.
top-level).

Au niveau d'une bibliothe`que, il est possible de cre'er un exe'cutable
avec \verb+make test+ (cf. section Makefile).

Si une passe et une bibliothe`que sont de'veloppe'es simultane'ment,
{\tt misc.a} et {\tt parallelize} par exemple, il va e^tre ne'cessaire de
rechercher misc.h et libmisc.a non plus dans {\tt
Production/Libs/misc} mais dans le re'pertoire {\tt
Development/Libs/misc}. Ceci peut e^tre fait un peu de frais en
modifiant le config.makefile et en de'signant directement les bibliothe`ques
qu'il faut utiliser:
\begin{verbatim}
...
# List of libraries used to build the target
TARGET_LIBS=	-lprivatize -lusedef -lprettyprint -lsemantics -ltransformer \
		 -lcontrol -leffects -lnormalize \
		-lsc -lcontrainte -lvecteur -larithmetique \
		-lri-util ../../Libs/libmisc.a \
		-lproperties -lgenC /usr/lib/debug/malloc.o \
		-lproperties

$(TARGET): ../Lib/misc/misc.a
\end{verbatim}

\section{Conventions}

Les bibliothe`ques ont un nom de la forme \verb|libXXX.a|
ou` \verb|XXX| est le nom
logique de la bibliothe`que: {\tt prettyprint, vecteur, {misc},} etc.

Il est the'oriquement inutile de mettre les bibliothe`ques dans les
de'pendances des makefiles car les headers ge'ne're's automatiquement
sont dans les de'pendances et ces fichiers sont syste'matiquement
modifie's chaque fois qu'une nouvelle installation est faite. \,Ca ne
marche cependant pas au niveau 2: si la passe {\tt p} appelle la
bibliothe`que {\tt a} qui a besoin de la bibliothe`que {\tt b} et que la
passe {\tt p} n'a pas besoin directement de cette deuxie`me bilbiothe`que,
les modifications de {\tt b} ne provoqueront pas de relinkage de la
passe {\tt p}.

Chaque bibliothe`que importante utilise une variable d'environnement
appele'e \verb+XXX_DEBUG_LEVEL+ pour contro^ler l'e'mission de messages
de mise au point. \verb+XXX+ est le nom de la bibliothe`que. Un niveau
de 0 correspond au fonctionnement normal. Le niveau le plus e'leve'
normal est 8. 

Il faut faire attention au placement dans le code C des appels
\verb+debug_on()+ \verb+debug_off()+ pour que la pile des niveaux de
debug soit correctement maintenue. Il ne faut pas non plus activer
inintentionnellement le debug d'une bibliotheque quand on appelle une
fonction d'une autre bibliothe`que.

Il existe une exception a` cette re`gle de nommage:
\verb+PARSER_DEBUG_LEVEL+ est le nom de la variable associe'e a` la
bibliothe`que \verb+syntax+.

\section{Correction et de'tection de bugs}

\subsection{De'tection d'un bug}

Lorsqu'un bug a e'te' de'tecte', il faut trouver un petit exemple
fortran simple re'alisant ce bug. Soit bug.f cet exemple.

Si on arrive a` de'terminer que la bibliothe`que xxx est responsable de
l'apparition de ce bug, a` l'aide de \verb+XXX_DEBUG_LEVEL+ et ou d'un
debugger, installer bug.f dans ~/Tests/Bugs/xxx/.

Enregistrer ce nouveau  bug dans pips-bugs.f.tex.

\subsection{Correction de bug}

Se placer sous ~/Tests/Bugs/xxx/ et, afin d'utiliser le pips en de'veloppement associe' a` la bibliothe`que
xxx, cre'er un lien symbolique avec lui. Voici les diffe'rentes ope'rations a` effectuer :

Trouver et corriger les sources de la bibliothe`que responsables du bug.
On suppose dans la suite que ces corrections ne touchent qu'une
bibliothe`que ; le cas de plusieurs bibliothe`ques implique'es est
traite' plus bas.

Lancer \verb+make test+ sous /Development/Lib/xxx.
Revenir sous /Tests/Bugs/xxx et lancer :
\begin{verbatim}
Init -f bug.f bug
Display -m -v bug
\end{verbatim}
ve'rifier que la correction a e'limine' le bug.

Dans la suite, nous nous placerons dans la bibliothe`que en
developpement : ~/Development/Lib/xxx/.

Lancer \verb+Validate xxx+ pour ve'rifier la cohe'rence de la
bibliothe`que xxx avec notre correction.
Lancer (the'oriquement...) \verb+Validate Pips+.
Lancer \verb+make install+, afin de compiler les diffe'rentes sources et
de les passer dans la nouvelle version en production. Attention :
actuellement (07.09.92), cette commande ne produit pas une nouvelle
version de pips dans production !

Une fois ces ope'rations effectue'es, il s'agit de rajouter le programme
bug.f, le test qui porte dessus, ainsi que les re'sultats obtenus, dans
/Tests/Validation/xxx/ afin de se cre'er une bibliothe`que de validation
pour les futurs changements dans xxx.
Pour cela, la commande \verb+bug-to-validate bug.f+ est couramment
utilise'e. Cette commande effectue les transferts ci-dessus mentionne's
depuis le repertoire Tests/Bugs/xxx/ vers Tests/Validation/xxx.
Attention : \verb+bug-to-validate+ est un script-shell (dans
~/Utilities) qui fournit une simple paralle'lisation de bug.f (voir
paragraphe suivant) ! 
Pour effectuer le transfert dans Validation d'un re'pertoire entier qui a
e'te' teste', lancer \verb+dir-to-validate+. Cette commande peut e^tre tre`s
pratique dans le cas d'utilisation de fichiers tests par de'faut : voir
la partie sur \verb+default_test+ dans << Le repertoire Validation >>.

Il faut alors, officiellement, relier le nouveau pips dans
Production/Src/Passes/pips. En fait, on fait une installation
pe'riodique de Development/Passes/pips en Production en le supposant stable.

Remarque : dans le cas ou` la correction du bug porte atteinte a`
plusieurs bibliothe`ques, avant toute ope'ration, il faudra :
se placer sur xxx1 et lui lier toutes les bibliothe`ques concerne'es
xxxi. Sans oublier finalement d'appliquer \verb+make install+ a` toutes
ces bibliothe`ques.

\subsection{Le re'pertoire Validation}

On peut y trouver \verb+bug.test, bug.f+ ainsi que le sous re'pertoire
\verb+bug.result+ ; ces deux derniers provenants de
\verb+bug-to-validate bug.f+, comme vu pre'cedemment.
Le sous-repertoire contiendra les re'sultats d'une simple
paralle'lisation (Display -v -m bug). 
Si l'on souhaite d'autres types de re'sultats, il s'agira de se cre'er
un script-shell a` l'instar de \verb+bug-to-validate+, afin de
transfe'rer les fichiers ade'quats dans Validation/xxx/.
Puis ensuite de cre'er bug.test (comprenant toutes les ope'rations
pips effectue'es : voir les /Validation/xxx/*.test), afin d'indiquer a`
\verb+Validate+ le test correct a` effectuer.
Si le test est commun a` tout un repertoire (ex : /Validation/Flint), il faut
creer dans ce repertoire le fichier ge'ne'rique \verb+default_test+. Dans ce
fichier, a` l'image de bug.test, les noms ge'ne'riques de'signant les
programmes concerne's sont : \verb+tested_file+ et \verb+TESTED_FILE+. Voici par
exemple le \verb+default_test+ de \verb+Validation/Flint+ :

\begin{verbatim}
#!/bin/sh
Init -d -f $PIPSDIR/Tests/Validation/Flint/tested_file.f tested_file 2>/dev/null >/dev/null
Perform -m tested_file flinter 2>/dev/null 
cat tested_file.database/TESTED_FILE.flinted 
Delete tested_file 2>/dev/null
\end{verbatim}

Il est a` noter qu'un test local au fichier (bug.test) sera e'xe'cute'
prioritairement a` ce test par de'faut : la priorite'e va du local au
ge'ne'ral.

\subsection{Autre validation}

Une commande \verb+Validate+ permet de mesurer l'impact de modifications
par rapport au comportement pre'ce'dent de PIPS.

To use it to check the parallelization process, put your test file, say
mytest.f which contains the main program MAIN and a subroutine SUB, into
one of the directories in
\verb+~pips/Pips/Tests/Validation+ directory. You can also create your own
directory there if you want to ensure that a particular aspect of PIPS
behaves the correct way.

Once mytest.f is in such a directory, say kludge, you should do the
following thing.

\begin{verbatim}
Validation/kludge: Init -f mytest.f mytest
Validation/kludge: mkdir mytest.result
Validation/kludge: Display -m main > mytest.result/MAIN
Validation/kludge: Display -m sub > mytest.result/SUB
Validation/kludge: Delete mytest
\end{verbatim}

Check that the output in the MODULE1, MODULE2, ... files is what you
want ... and that's it!

After a while, if you want to check that PIPS still does that it was
supposed to do, go into Validation and type

\begin{verbatim}
Validate kludge
\end{verbatim}

If there is any problem, you will get a mail message that tells you want
the problem is. You can also type

	Validate

to check everything.

\begin{itemize}
  \item \verb+Validate+ sans argument valide les re'pertoires qui se trouvent
  dans le fichier Validation/defaults.

  \item Quand on valide un sous-directory de Validation, si pour le programme
  foo.f existe un fichier foo.test, celui est execute' et son output est
  compare' a` foo.result/test (qui doit avoir etre cre'e' au prealable).
  Ceci permet de faire d'autres tests que de simplement regarder que les
  versions paralleles de chaque module sont correctes.
\end{itemize}

Voir l'exemple de Bruno dans \verb+Validation/DemoStd+.

\subsection{Mise au point en ge'ne'ral}

Un certain nombre d'informations sont contenues dans ce qui pre'ce`de.

\subsubsection{\'Edition de liens locales}

Il est possible de compiler "pips" et "wpips" avec les bibliothe`ques
du re'pertoire courant.

Pour se faire le "Makefile" de PIPS contient les re`gles "test" et
"wtest" dont l'effet est de re'cupe'rer les morceaux ne'cessaire a` la
confection de "pips" et "wpips" localement.

Attention ensuite de ve'rifier que c'est bien la version locale du
programme qu'on est en train de faire tourner...

\section{Sauvegardes et Restauration}

Le syste`me de sauvegardes des automatiques informations calcule'es au
cours des exe'cutions de pips cre'e de nombreux fichiers et
sous-repertoires. Les phases en cours de mise au point conduisent
parfois a` la cre'ation de gros fichiers {\tt core}. Il faut donc faire
le me'nage de temps a` autre pour re'cupe'rer de l'espace disque.
Plusieurs proce'dures sont disponibles dans \verb+~pips+: \verb+clean+,
\verb+clean-before-backup+ et \verb+clean-before-tar+.

Le sauvegardes ge'ne'rales sont effectue'es les mardi et vendredi comme
pour les autres partitions du syste`me a` l'aide de \verb+/etc/dump+.
Les fichiers peuvent e^tre restaure's a` l'aide de \verb+/etc/restore+.


\end{document}
\end
