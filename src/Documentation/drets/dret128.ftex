\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\titre}{RAPPORT D'AVANCEMENT No 7 \\
                    ANALYSEUR S\'EMANTIQUE ET D\'ETECTEUR DE PARALL\'ELISME \\
                    (LOT 8)}
\newcommand{\auteur}{
        Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{8 Juin 1990}
\newcommand{\numero}{E128}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

\section{Introduction}

\paragraph{}
Ce rapport interme'diaire donne l'e'tat d'avancement de nos travaux sur
l'analyse se'man\-tique et la de'tection du paralle'lisme.

\paragraph{}
Ces travaux ont e'te' quelque peu retarde's principalement a` cause du
{\em Workshop on Compilers for Parallel Computers} que l'Ecole des Mines
de Paris organise conjointement avec le laboratoire MASI et pour lequel
de nombreux de'placements et travaux d'organisation ont e'te'
ne'cessaires.  Les vacances ont bien sur influence' le rythme de
l'avancement des travaux.

\section{Analyse se'mantique}

\paragraph{}
Les travaux sur l'analyse se'mantique ont e'te' laisse' de co^te'
temporairement car cette phase d'analyse avait e'te' l'objet d'efforts
soutenus pendant les derniers mois, notamment pour la de'monstration du
mois d'Avril. 

\paragraph{}
Il est ne'cessaire d'interfacer le calcul des {\tt pre-conditions} et
des {\tt transformers} avec les autres phases d'analyse avant de
continuer les travaux. L'utilisation des {\tt pre-conditions} pour le
calcul des re'gions et pour le test de de'pendance permettra de tester
l'analyse se'mantique en vraie grandeur et sans doute de de'couvrir des
proble`mes. C'est a` partir de ce moment la` que les travaux pourront
reprendre.

\section{De'tection du paralle'lisme}

\subsection{De'composition de la phase de de'tection du paralle'lisme}

\paragraph{}
La phase de de'tection du paralle'lisme e'tait jusqu'a` pre'sent
compose'e d'une seule passe. Cette passe effectuait en se'quence le
calcul du graphe des de'pendances, la de'composition de ce graphe en
composantes fortement connexes, la distribution des boucles autour de
ces composantes, et enfin la paralle'lisation des boucles ainsi
distribue'es lorsque les de'pendances l'autorisaient.

\paragraph{}
Ce sche'ma monolithique e'tait tout a` fait incompatible avec l'approche
{\em base de transformations et d'analyse de programmes} choisie pour
Pips. En effet, il e'tait souhaitable que le graphe des de'pendances
soit calcule' se'paremment de fac,on a` ce qu'il soit re'utilisable par
d'autres transformations telles que l'e'change de boucles ou la me'thode
hyperplane. De me^me, il e'tait inte'ressant que la distribution de
boucles devienne une phase a` part entie`re de fac,on a` pouvoir
e^tre applique'e se'paremment pour obtenir, par exemple, des nids de
boucles parfaitement imbrique'es ou` l'e'change de boucles et la me'thode
hyperplane peuvent e^tre effectue's sans restriction.

\paragraph{}
La de'composition de la phase de paralle'lisation a donc e'te'
effectue'e. La phase {\tt kennedy} a donne' naissance aux trois phases
suivantes.

\begin{itemize}

\item La phase {\tt ricedg} calcule un graphe de de'pendances ou` les
arcs sont labelle's par les niveaux des de'pendances selon la
de'finition de Kennedy (Rice University). Ce calcul est effectue' a`
partir des {\tt Use-Def Chains} qui forment la premie`re approximation
du graphe. La phase {\tt ricedg} est donc en fait une phase de
raffinement du graphe des de'pendances.

\item La phase {\tt distribute} utilise le graphe des de'pendances
calcule' par {\tt ricedg} pour effectuer la distribution des boucles.
L'algorithme de Kennedy et Allen est utilise', mais la toute dernie`re
phase est inhibe'e. Il s'agit de la phase ou` les composantes fortement
connexes sont analyse'es pour voir si elles contiennent des de'pendances
empe^chant la paralle'lisation.

\item La phase {\tt rice} utilise le graphe des de'pendances
calcule' par {\tt ricedg} pour effectuer la distribution et la
paralle'lisation des boucles. L'algorithme de Kennedy et Allen est donc
utilise' dans son inte'gralite'.

Rappelons que cet algorithme a e'te' le'ge`rement ame'liore' de fac,on a
pouvoir profiter des re'sultats de la privatisation. Il s'agit de savoir
ignorer certaines de'pendances au moment de la paralle'lisation sans
pour autant les ignorer au moment de la distribution. En effet, le cycle
cre'e' par les de'pendances sur {\tt temp} dans:
\begin{verbatim}
        DO I = 1,10
           DO J = 1,10
              TEMP = 0.0
              DO K = 1, 10
                 TEMP = TEMP + A(I,K)*B(K,J)
              ENDDO
              C(I,J) = TEMP
           ENDDO
        ENDDO
\end{verbatim}
ne doit pas freiner la paralle'lisation des boucles sur {\tt I} et {\tt
J}, mais doit empe^cher leur distribution.
\end{itemize}

\subsection{De'tection des indices vivants en sortie de boucle}

\paragraph{}
L'algorithme de calcul des de'pendances doit tenir compte des indices de
boucles. En effet, si les re`gles standards de calcul sont applique'es
aux de'pendances sur les indices, toute boucle reste ne'cessairement
se'quentielle car il y a un cycle sur cet indice cre'e' par
l'incre'mentation de chaque tour de boucle.

\paragraph{}
Kennedy et Allen contournent le proble`me en ignorant purement et
simplement toutes les de'pendances cre'e'es par les indices de boucles.
Cette solution a he'las l'inconve'nient majeur de conduire a` des
re'sultats dont la correction de'pend de la se'mantique de la boucle
DOALL. En effet, la boucle DO Fortran se'quentielle garantit que
l'indice conserve la valeur qu'il avait au dernier tour de boucle en
sortie de la boucle. Certains programmeurs peuvent avoir tire' profit de
cette proprie'te' en re'utilisant la valeur de l'indice apre`s la
boucle; c'est particulie`rement ne'cessaire dans le cas de sortie
pre'mature'e de la boucle. Si une telle boucle est paralle'lise'e, et
que la se'mantique du DOALL est diffe'rente de celle du DO se'quentiel,
le programme devient incorrect.

\paragraph{}
Nous avons donc choisi dans Pips de ne pas ignorer les de'pendances sur
les indices des boucles dont l'indice est vivant en sortie, i.e. dont la
valeur peut e^tre utilise'e (un {\em use}) avant d'e^tre tue'e (un {\em
kill}).

\paragraph{}
La de'tection des boucles a` indice vivant est faite par une phase de
privatisation qui n'explore que les indices de boucles. Il suffit,
apre`s calcul des Use-Def Chains, de ve'rifier pour chaque boucle si les
re'-utilisations potentielles de l'indice ont lieu a` l'inte'rieur ou a`
l'exte'rieur de la boucle. L'indice est privatise' pour la boucle si
aucune re'-utilisation n'a lieu a` l'exte'rieur, ce qui est vrai dans la
tre`s grande majorite' des cas.

\subsection{Diminution du nombre de de'pendances}

\paragraph{}
Nous avons vu que Kennedy et Allen ont choisi d'ignorer toutes les
de'pendances cre'e'es par les indices de boucles.  Cette solution a pour
avantage qu'un tre`s grand nombre de de'pendances n'apparaissent plus
dans le graphe, ce qui re'duit conside'rablement la complexite' des
algorithmes de calcul et de tri des composantes fortement connexes.

\paragraph{}
Notre solution garantit la correction des programmes, mais elle augmente
conside'ra\-ble\-ment le nombre des de'pendances re'pertorie'es dans le
graphe. Il suffit de constater que chaque indice est de'fini par la
boucle puis utilise' une ou plusieurs fois dans pratiquement toutes les
re'fe'rences aux e'le'ments de tableaux qui apparaissent dans la
boucle.

\paragraph{}
Cependant, la plupart de ces de'pendances ne servent a` rien car elles
expriment une contrainte d'ordonnancement des instructions que les
algorithmes de paralle'lisation ne tentent pas de violer: que
l'instruction boucle qui de'cide de l'ite'ration a` exe'cuter soit
effectivement exe'cute'e avant les instructions du corps de la boucle
pour cette ite'ration la` !!!

\paragraph{}
Nous avons donc choisi de ne pas ajouter au graphe les de'pendances
cre'e'es par un indice de boucle lorsqu'une des deux instructions
concerne'es est une boucle qui englobe la seconde instruction. Cette
optimisation respecte la correction du programme tout en diminuant
conside'rablement le volume final du graphe.

\section{Conclusion}

\paragraph{}
Si les spe'cifications pre'ce'dentes ont toutes e'te' imple'mente'es, de
nouveaux travaux sont en cours d'e'laboration concernant l'analyse
se'mantique et la de'tection du paralle'lisme. En particulier, un module
de de'tection des {\em re'ductions} (i.e., des ope'rations
paralle'lisables telle que la somme d'un vecteur ou les variables
d'induction) est en cours de prototypage en CommonLISP. Ceci est rendu
possible dans PIPS du fait de la compatibilite' avec C offerte par
NewGen.

\paragraph{}
L'inte'gration de ces diffe'rents modules dans PIPS devrait permettre de
tester l'utilite' pratique de ces algorithmes, parfois complexes, dans
les cas re'e'ls que sont les benchmarks des utilisateurs.

\end{document}
\end
