\documentstyle[12pt]{farticle}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS-CRAY \\
                RAPPORT INTERMEDIAIRE
}

\newcommand{\auteur}{
                Bruno BARON \\
                Franc,ois IRIGOIN \\
                Pierre JOUVELOT \\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01.018 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}

% pour importer des structures de donne'es Newgen
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\docdate}{7 Avril 1992}
\newcommand{\numero}{E/163/CRI}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01.018 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\vspace{2cm}

\tableofcontents

\newpage

\section*{Introduction}
Commence' depuis six mois, le contrat Pips-Cray a de'ja`
conside'rablement progresse'. Outre les re'sultats pre'sente's dans le
pre'ce'dent e'tat d'avancement,
% il s'agit du document dret161.f.tex
nous avons aussi re'alise' les points
suivants, de'veloppe's dans ce rapport interme'diaire:
\begin{itemize}
\item
        la ge'ne'ration de code avec directives Cray CFT77, 
\item
        le remplacement des constantes associe' a` l'e'valuation
partielle pour simplifier les expressions,
\item
        une premie`re de'tection des re'ductions ge'ne'ralise'es,
\item
        l'exe'cution de quelques programmes simples sur un Cray X-MP.
\end{itemize}

\section{Ge'ne'ration de code avec directives Cray CFT77}
Une premie`re se'lection du paralle'lisme a e'te' effectue'e, selon une
me'thode simple de'veloppe'e dans le pre'ce'dent e'tat d'avancement.
En re'sume', nous limitons le paralle'lisme d'un nid de boucle a` un
maximum de deux boucles imbrique'es: la boucle la plus interne si elle
est vectorisable, ainsi que la boucle paralle`le la plus externe pour le
microtasking. Toutes les autres boucles restent se'quentielles.  

Afin de pouvoir exe'cuter le code transforme' par PIPS sur des machines
Cray, il fallait encore ge'ne'rer des directives qui spe'cifient le mode
d'exe'cution des boucles au compilateur CFT77 du Cray. Nous l'avons
re'alise' dans une phase d'impression nomme'e:
\begin{quote}
PRINT\_PARALLELIZEDCRAY\_CODE
\end{quote}
Cette phase ajoute les directives au format CFT77, c'est-a`-dire dans un
commentaire pre'ce'dant le code de la boucle a` laquelle la directive
s'applique.

Les directives ge'ne're'es sont donc de deux types: les directives de
vectorisation pour les boucles vectorielles, et les directives de
microtasking pour les boucles dont les ite'rations doivent s'exe'cuter
de fac,on re'partie sur plusieurs processeurs.

\subsection{Directives de vectorisation}
Pour les boucles vectorielles, nous ge'ne'rons la directive de
vectorisation:
\begin{verbatim}
CDIR$ IVDEP
\end{verbatim}

\subsection{Directives de microtasking}
Pour les boucles microtaske'es, nous ge'ne'rons la directive de
microtasking
\begin{verbatim}
CMIC$ DO ALL PRIVATE(<private>) SHARED(<shared>) 
\end{verbatim}
\verb+<private>+ e'tant la liste des variables prive'es, c'est-a`-dire
locales a` la boucle, \verb+<shared>+ e'tant la liste des variables
partage'es par l'ensemble des processeurs et utilise'es dans la boucle.
Ainsi des processeurs disponibles sont alloue's pour exe'cuter en
paralle`le (sans synchronisation) les ite'rations de la boucle.

Il faut noter que la ge'ne'ration des listes de variables prive'es et
partage'es n'est pas imme'diate. Pour ge'ne'rer la liste des variables
partage'es dans une boucle, nous avons simplement accumule' les entite's
qui apparaissent dans les {\em effets cumule's} du corps de la boucle et
qui ne font pas partie des \verb+loop_locals+.

Pour ge'ne'rer la liste des variables prive'es dans une boucle, il
fallait tenir compte de plusieurs facteurs:
\begin{itemize}
  \item certains algorithmes de privatisation ne placent dans
\verb+loop_locals+ que les entite's qui sont imme'diatement utilise'es,
mais pas celles qui sont prive'es pour des boucles internes. Comme les
boucles internes a` une boucle paralle`le ne sont jamais paralle`les, il
faut donc de'clarer prive'es toutes les entite's qui apparaissent dans
les \verb+loop_locals+ des boucles internes. Sur l'exemple suivant, {\tt
J} devient ainsi une variable prive'e pour la boucle externe:

\begin{verbatim}
     DO I = 1, 10             CMIC$ DO ALL PRIVATE(I,J) SHARED(A)
         PRIVATE I                 DO I = 1, 10
         DO J = 1, 10         CDIR$ IVDEP
             PRIVATE J                 DO J = 1, 10
             A(I,J)=0.                     A(I,J)=0.
         ENDDO                         ENDDO
     ENDDO                         ENDDO
\end{verbatim}

  \item apre`s certaines transformations comme la distribution (qui est
abondamment utilise'e par l'algorithme de Kennedy et Allen), certaines
entite's se trouvent dans la liste \verb+loop_locals+ alors qu'elles ne
font plus partie du corps de la boucle. Il faut donc les filtrer pour
e'conomiser une allocation en pile inutile et pour ame'liorer la
lisibilite' du source produit.
\end{itemize}

\subsection{Commentaires}
Par ces directives, le re'sultat des analyses et les transformations
re'alise'es par PIPS est transmis au compilateur Cray CFT77.

% Peut-on faire ce genre de commentaires ici??
Au sujet du code ge'ne're' par PIPS, il faut noter que l'absence de
directives pour allouer plusieurs processeurs pour le programme (section
paralle`le) limite l'efficacite' d'exe'cution des exemples re'els. En
effet, sans cela, le surcou^t implique' par l'allocation et la
libe'ration de processeurs doit e^tre supporte' au niveau de chaque
boucle.

\section{Remplacement des constantes et e'valuation partielle}
La phase {\tt partial\_eval} re'alise en un seul parcours du code le
remplacement des constantes entie`res et l'e'valuation partielle des
expressions pour re'aliser des simplifications.  Voir l'exemple en
Annexe A.

\subsection{Remplacement des re'fe'rences par des constantes entie`res}
Les analyses se'mantiques interproce'durales re'alise'es dans Pips
permettent de connai^tre les valeurs de variables scalaires entie`res en
certains points du programme. Ces analyses ge'ne'ralisent donc ce qu'on
appelle la {\em propagation des constantes} au contexte
interproce'dural.

Les variables entie`res dont la valeur est connue par re'solution du
syste`me de pre'conditions peuvent e^tre remplace'es par leur valeur.
C'est l'objectif de la phase de remplacement de constantes, pre'vue par
ce contrat.

Cette phase remplace les constantes dans les expressions suivantes:
\begin{itemize}
  \item la condition de l'instruction \verb+IF+\footnote{
Seules les constantes entie`res sont de'tecte'es pour l'instant; il
faudrait y ajouter les constantes boule'ennes puis effectuer
l'e'limination du code mort lorsque la condition du test est une
constante.}, 
  \item les bornes et l'incre'ment des boucles \verb+DO+
  \item les expressions arguments des instructions \verb+CALL+.
\end{itemize}
Toutes les re'fe'rences a` des scalaires entiers lue dans cette
instruction sont candidates au remplacement. En utilisant les {\em effets
propres}, nous empe^chons le remplacement des re'fe'rences qui peuvent
e^tre e'crites.

Ensuite ces re'fe'rences scalaires entie`res sont e'value'es a` partir
des pre'conditions associe'es a` l'instruction dont fait partie la
re'fe'rence. Pour cela, la fonction {\tt sc\_minmax\_of\_variable}
projette les e'quations du syste`me de pre'conditions sur la dimension
associe'e a` la variable pour obtenir un intervalle de variation re'duit
a` un e'le'ment pour les constantes et e'gal a` $Z\!\!\!Z$ pour les
re'fe'rences dont on ne sait rien.

Cette phase de remplacement des constantes est inclue dans l'e'valuation
partielle des expressions, qui utilise les valeurs trouve'es pour
effectuer des simplifications.

\subsection{Evaluation partielle des expressions}
L'algorithme d'e'valuation partielle des expressions e'crit
re'cursivement les expressions sous la forme 
\verb#ICOEF*SUBEXPR + ISHIFT#, ou` \verb+ICOEF+ et \verb+ISHIFT+ 
sont des constantes nume'riques entie`res et \verb+SUBEXPR+ est de type
expression. Il commence par e'valuer les expressions feuilles qui sont
soit des constantes nume'riques entie`res, soit des constantes entie`res
remplac,ables par leur valeur. Dans la mesure du possible, il re'alise
ensuite quelques simplifications au fur et a` mesure qu'il remonte dans
les expressions, c'est-a`-dire lorsqu'il e'value l'addition, la
soustraction, la multiplication ou la division entie`re, ainsi que le
modulo et le moins unaire. Lorsqu'on a termine' l'e'valuation de
l'expression, ou lorsqu'on ne peut l'e'valuer (lors d'un appel a` une
fonction externe par exemple), il faut restaurer une expression sous
forme normale. Pour cela, ou bien l'expression sous la forme ci-dessus
est rege'ne're'e (au cas ou` il y a eu simplification), ou bien elle
est concerve'e.

Les hypothe`ses pour l'imple'mentation sont les suivantes:
\begin{itemize}
  \item \verb+eformat+ est une structure C qui contient les champs
\verb+icoef+, \verb+expr+ et \verb+ishift+, ainsi que le boole'en
\verb+simpler+.

  \item Toute fonction d'e'valuation partielle retourne
\verb+eformat_undefined+ lorsqu'elle n'a rien e'value' (par exemple lors
d'un appel d'une fonction externe).

  \item \verb+eformat.expr+ {\em ne doit jamais} partager de structures
avec le code.  Par contre, une expression de'tache'e du code peut
appartenir a` \verb+eformat.expr+.

  \item Lorsqu'une expression est de'tache'e du code, il faut prendre
garde a` lui substituer \verb+expression_undefined+, de sorte qu'un free
(dans {\tt regenerate\_expression}) puisse s'exe'cuter sans proble`me.

  \item Si une information est ajoute'e a` \verb+eformat_undefined+,
alors l'expression est {\em recopie'e}. Pourtant, \verb+eformat.simpler+
reste {\tt FALSE} et l'expression d'origine n'est pas de'salloue'e, car
une seule information ne permet aucune simplification.  A partir de la
prise en compte de la seconde information, de`s que \verb+eformat+ est
simplifie', alors \verb+eformat.simpler+ devient vrai. L'expression
d'origine sera alors de'salloue'e au prochain {\tt
regenerate\_expression}.

  \item De`s que l'e'valuation n'est plus possible, il faut rege'ne'rer
l'expression.

\end{itemize}

\section{Re'ductions Ge'ne'ralise'es}

L'imple'mentation d'un premier prototype en CommonLISP du module de
de'tection des re'ductions ge'ne'ralise'es s'est poursuivie, permettant
de pre'senter de'ja` quelques re'sultats sur des programmes simples.

Base'e sur les re'sultats de'crits dans ``Jouvelot, P., and Dehbonei, B.
{\em A Unified Semantic Approach for the Vectorization and
Parallelization of Generalized Reductions}, 1989 ACM SIGARCH Int. Conf.
on Supercomputing, Crete, Jun.89'', cette me'thode permet, dans un cadre
unifie', de de'tecter les invariants de boucle, les affectations
redondantes, les variables d'induction et les ope'rations de re'duction
comme la de'termination du maximum d'un tableau ou le produit scalaire
de vecteurs.

L'analyse d'un module se fait par e'valuation symbolique des corps de
boucle et reconnaissance de patterns dans une base de connaissance
d'idiomes de re'ductions ge'ne'ralise'es.  Nous donnons ci-dessous un
exemple de pattern, celui de'crivant le maximum d'un e'le'ment de
tableau.
\begin{verbatim}
;;; Case for IF( T[I].GT.X ) X=T[I]

;; ARRAY-MAX-CODE is the RI code generator when a max reduction is
;; detected. 
;;
;; VAR is the reduced variable, COND the conditional test, 
;; PARAM the right-hand side of the OP operator used when COND is true.
;; The CONTEXT gives the LOOP indices.
;;
(defun array-max-code (var cond param op context loop)
    (let ((range (loop-range loop)))
        (make-statement-call 
         entity[array-max]
         `(,(make-expression-reference var '())
           ,(make-expression-reference 
             (expression-reference-variable param) '())
           ,(range-lower range)
           ,(range-upper range)
           ,(range-increment range)))))

;; The ARRAY-MAX-REDUCTION template describes the associated reduction. 
;; The :PATTERN describes the arguments to be passed to the code
;; :GENERATOR, while the :VALUE is instantiated and passed as 
;; PARAM to the code generator.
;; 
;; Unification variables are used to allow pattern recognition to be
;; independant from the actual reference variables used in the analyzed
;; program. 
;;
(defparameter array-max-reduction
    (let ((t[i] (make-expression-reference
                 (make-unification-variable 2)
                 `(,(make-expression-reference
                     (make-unification-variable 3) '())))))
        (make-template
         :pattern 
         (make-pattern :variable (make-unification-variable 1)
                       :condition (make-expression-call
                                   (function-entity[] ".GT.")
                                   `(,t[i]
                                     ,(make-expression-reference
                                       (make-unification-variable 1) '())))
                       :parameter t[i]
                       :operator entity[fun-xy.y]
                       :indices `(,(make-unification-variable 3)))
         :generator #'array-max-code
         :value (make-expression-reference
                 (make-unification-variable 2) '()))))
\end{verbatim}
Les patterns de'crivant les re'ductions sont regroupe's dans une base de
templates qui contiennent, pour chaque pattern, la fonction a` appeler
pour ge'ne'rer le code de re'duction et la valeur du parame`tre a`
instancier (cette valeur est fournie au ge'ne'rateur de code comme le
champ {\tt param}).  Une dernie`re phase e'limine les instructions du
corps de boucle qui font re'fe'rence a` des variables ayant e'te'
de'tecte'es comme des re'ductions ge'ne'ralise'es.

A titre d'exemple, le programme de test suivant a e'te' utilise':
\begin{verbatim}
      program reduction
      real a(10),b(10)
      do 10 i=1,10
         s = 2
         f = g*f
         t = t
         v = v + 3
         w = w * 4
         x = x+a(i)
         y = y+a(i)*b(i)
         if( a(i).gt.z ) z = a(i)
 10   continue
      end
\end{verbatim}
Apre`s e'valuation symbolique et de'tection des re'ductions
correspondant aux valeurs symboliques de chaque variable, le programme
re'siduel suivant est ge'ne're':
\begin{verbatim}
      PROGRAM REDUCTION
      REAL A(10),B(10)
      DO I = 1, 10
         F = G*F                                                        0004
      ENDDO
      CALL CONSTANT(S, 2, 1, 10, 1)
      CALL SUM(V, 3, 1, 10, 1)
      CALL PRODUCT(W, 4, 1, 10, 1)
      CALL ARRAYSUM(X, A, 1, 10, 1)
      CALL INNER(Y, A, B, 1, 10, 1)
      CALL ARRAYMAX(Z, A, 1, 10, 1)
      RETURN
      GOTO 99997
99997 CONTINUE
      END
\end{verbatim}
La se'mantique des diffe'rentes fonctions bibliothe`ques est donne'e
ci-dessous:
\begin{description}
\item[{\tt CONSTANT}] 
        {\tt S} est une constante, de valeur {\tt 2},
\item[{\tt SUM}] 
        {\tt V} est une variable d'induction, par pas de {\tt 3},
\item[{\tt PRODUCT}] 
        {\tt W} est une variable de progression ge'ome'trique, de raison
{\tt 4},
\item[{\tt ARRAYSUM}]
        {\tt X} est la somme des e'le'ments du tableau {\tt A},
\item[{\tt INNER}]
        {\tt Y} est le produit scalaire des tableaux {\tt A} et {\tt B},
\item[{\tt ARRAYMAX}]
        {\tt Z} est l'e'le'ment maximum du tableau {\tt A}.
\end{description}
On notera que les bornes de boucles sont passe'es a` chaque fonction
bibliothe`que.  Ceci permet de de'tecter des ope'rations sur des
sous-tableaux des tableaux passe's en argument et, e'galement, de
ve'rifier a` l'exe'cution que la boucle est bien exe'cute'e (test des
bornes de boucles). Dans la majorite' des cas, cette deuxie`me analyse
pourrait e^tre effectue'e au moment de la compilation par une
de'termination un peu plus fine des bornes.

\section{Exe'cution de tests sur un Cray X-MP}
L'acce`s a` un Cray X-MP est finalement possible. Nous avons donc
re'alise' quelques tests pour ve'rifier que le code ge'ne're' est
correct, ainsi que pour comparer le code en sortie de PIPS avec le code
en sortie de FPP. Dans un premier temps, ces tests nous permettent de
re'aliser la mise au point du code paralle`le ge'ne're' par PIPS, et de
se'lectionner d'autres transformations qu'il nous faudra re'aliser.

\section{Conclusion}

L'e'tat d'avancement du projet Pips-Cray est satisfaisant et conforme au
plan initial.  Nous poursuivons les expe'riences en grandeur re'elle sur
le Cray, dans le but d'obtenir la` une validation effective des
capacite's de PIPS.

\newpage

\section*{Annexe A}
\subsection*{Exemple de remplacement des constantes et e'valuation
partielle}
\subsubsection*{Exemple 1}
Le programme {\tt exemple} illustre diverses fonctionnalite's de
l'e'valuation partielle. Soit le code initial:
\begin{verbatim}
      PROGRAM EXEMPLE
C     
      I = 5                                                             0001
      J = 2*I                                                           0002
      N = (4*M+I-4)/2+MOD(3*J+1, 4)-10/3                                0003
      I = I+J+1                                                         0004
      CALL EFFET(I, J)                                                  0005
      M = J                                                             0006
      END
C
      SUBROUTINE EFFET(NR, NW)
      NW = NR+1                                                         0001
      RETURN
      END
\end{verbatim}
Le module {\tt EXEMPLE} apre`s e'valuation partielle:

\begin{verbatim}
      PROGRAM EXEMPLE
C     
      I = 5                                                             0001
      J = 10                                                            0002
      N = (4*M+1)/2                                                     0003
      I = I+11                                                          0004
      CALL EFFET(16, J)                                                 0005
      M = 17                                                            0006
      END
\end{verbatim}
Remarquer que {\tt J} n'est pas remplace' a` l'instruction 5, car
cette variable est e'crite. De me^me pour {\tt I} a` l'instruction 4,
mais une analyse plus fine devrait permettre de remplacer le {\tt I} du
membre de droite.

\newpage

\subsubsection*{Exemple 2}
Ce code est extrait du module ROMAT du programme tmines.f de l'ONERA. On
constate que toutes les bornes de boucles sont remplace'es par leur
valeur. Le code initial, modifie' pour ne garder que les parties
inte'ressantes, est:

\begin{verbatim}
      DO K = 1, KMM                                                     0045
C     
         DO LB = 1, 37                                                  0047
            DO I = 1, IMM                                               0049
               DO J = 1, JMM                                            0051
                  BEL(LB,I,J) = BELK(LB,I,J,K)                          0052
               ENDDO
            ENDDO
         ENDDO
C     
         DO J = 1, JMM                                                  0055
            DO I = 1, IMM                                               0057
               PH(I,1) = PHI(I,J,K)                                     0058
               PH(I,2) = PHI(I+1,J,K)                                   0059
C              ... (partie supprimee)
            ENDDO
         ENDDO
      ENDDO
\end{verbatim}
Il devient apre`s e'valuation partielle:
\begin{verbatim}
      DO K = 1, 24                                                      0045
C
         DO LB = 1, 37                                                  0047
            DO I = 1, 80                                                0049
               DO J = 1, 14                                             0051
                  BEL(LB,I,J) = BELK(LB,I,J,K)                          0052
               ENDDO
            ENDDO
         ENDDO
C
         DO J = 1, 14                                                   0055
            DO I = 1, 80                                                0057
               PH(I,1) = PHI(I,J,K)                                     0058
               PH(I,2) = PHI(I+1,J,K)                                   0059
C              ... (partie supprimee)
            ENDDO
         ENDDO
      ENDDO
\end{verbatim}
Ces transformations sont tre`s utiles pour de'cider de l'opportunite'
d'une inversion de boucle ou d'un ``loop coalescing''.

\end{document}
