
\documentclass[12pt]{article}

% \input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\title{RAPPORT D'AVANCEMENT No 2 \\
                    ANALYSE SYNTAXIQUE ET SEMANTIQUE \\
RT EMP 105}
\author{Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\date{Mars 1988}
%\newcommand{\titre}{RAPPORT D'AVANCEMENT No 2 \\
%                    ANALYSE SYNTAXIQUE ET SEMANTIQUE}
%\newcommand{\auteur}{Franc,ois IRIGOIN \\
%        Pierre JOUVELOT \\
%        Re'mi TRIOLET}
%\newcommand{\docdate}{Mars 1988}
%\newcommand{\numero}{E105}

%\setlength{\parindent}{0cm}

\begin{document}
%\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\maketitle

\section{Introduction}

Ce rapport interme'diaire est consacre' a` la description de la
repre'sentation interme'diaire que nous avons choisie pour stocker les
programmes scientifiques qui seront soumis a` PIPS. Rappelons que ces
programmes sont e'crits dans un sous-ensemble du langage Fortran que
nous avons de'fini dans un pre'ce'dant rapport\footnote{Ce rapport est
en cours d'e'tude par l'e'quipe de Pierre Leca, a` l'O.N.E.R.A.}.

Tout programme Fortran doit avoir une repre'sentation interme'diaire
se'mantiquement e'quivalente a` son texte Fortran. 

Cette repre'sentation interme'diaire doit permettre d'effectuer
facilement des transformations et des analyses de programmes.


Le de'veloppement de PIPS est en partie  base' sur un outil de ge'nie
logiciel que nous avons de'veloppe' au CAII. Cet outil s'appelle NewGen,
il est pre'sente' dans la premie`re partie de ce rapport.


La repre'sentation interme'diaire est de'crite dans la seconde partie. Nous
expliquons notamment comment un programme Fortran est mappe' sur cette
repre'sentation interme'diaire.


La troisie`me partie de ce rapport est consacre'e a` l'analyse se'mantique.
Nous y pre'sentons d'abord les objets utilise's pour re'soudre les e'quations
aux polye`dres propres a` la me'thode de Cousot et Halbwachs, puis la
structure de donne'es repre'sentant un tel syste`me d'e'quations pour un
module quelconque.

\section{Pre'sentation de NewGen}
\subsection{Introduction}

{\em NewGen} est un outil de ge'nie logiciel de'veloppe' au CAII pour
faciliter l'e'criture de gros logiciels tels que PIPS. NewGen est
de'rive' de deux outils ante'rieurs, dont il est une ame'lioration:

\begin{itemize}
\item GenPgm, de'veloppe' au CAII par Re'mi Triolet,
\item MetaGen, de'veloppe' au groupe Bull par Pierre Jouvelot.
\end{itemize}

NewGen facilite a` la fois la de'finition et l'imple'mentation des
structures de donne'es qui sont ge'ne'ralement utilise'es pour re'aliser
des logiciels complexes. L'utilisation de Newgen se fait de la fac,on
suivante.

\begin{enumerate}
\item les types de donne'es que l'on souhaite utiliser pour de'velopper
      un logiciel (par exemple PIPS) sont de'finies a` l'aide d'un langage de
      haut niveau appele' {\em ``langage de de'finition de domaines''}.
\item la de'finition des domaines est compile'e par NewGen, ce qui a
      pour effet de:
      \begin{itemize}
      \item ge'ne'rer une imple'mentation des types de donne'es en
            langage C ou en langage Lisp;
      \item ge'ne'rer des fonctions de cre'ation, destruction et mise a` jour
            d'objets de ces types;
      \item ge'ne'rer des fonctions d'e'criture et de lecture d'objets de ces
            types sur fichiers.
      \end{itemize}
\end{enumerate}

Le logiciel peut ensuite e^tre de'veloppe' en tirant profit des
fonctions et de'finitions de types qui ont e'te' ge'ne're'es
automatiquement. Les re'percussions sur le de'veloppement sont
nombreuses.

\paragraph{Un langage plus riche}

Quel que soit le langage de de'veloppement utilise' (Lisp ou C), NewGen
l'enrichit de nouvelles constructions: les fonctions de cre'ation,
destruction et mise a` jour d'objets.

Cet enrichissement a plusieurs conse'quences. Tout d'abord, tous les
membres d'une e'quipe de de'veloppement utilisent les me^mes fonctions
et les me^mes types de donne'es, ce qui a pour effet d'uniformiser la
fac,on de programmer.  Ensuite, la disponibilite' de ces fonctions
permet a` chacun de programmer plus vite, de comprendre plus facilement
le code des autres, et de diminuer la quantite' de commentaires
ne'cessaires.

\paragraph{Ve'rification dynamique de types}

Les fonctions de cre'ation, destruction et mise a` jour d'objets sont
cre'e'es par NewGen de telle sorte qu'une ve'rification dynamique soit
effectue'e. Par exemple, un appel a` la fonction \verb/employe_nom/ sur
un objet \verb/e/ ve'rifie d'abord que \verb/e/ est un objet de type
\verb/employe/, si oui renvoie le \verb/nom/ de cet employe' et si non
aborte avec un message d'erreur.  Bien e'videmment, cette ve'rification
dynamique est optionnelle, de sorte que les programmes corrects ne sont
pas ralentis.

\paragraph{Communications inter-passes par fichiers}

Les fonctions d'entre'es-sorties ge'ne're'es par NewGen permettent
d'e'crire ou de lire sur fichier un objet aussi complique' qu'une
repre'sentation interme'diaire de programme Fortran, a` l'aide d'{\em une}
ligne de C ou de Lisp. Ceci a plusieurs conse'quences.


Les gros logiciels tels que PIPS sont ge'ne'ralement constitue's de
plusieurs passes. Il y a des de'pendances entre passes, par exemple quand
une passe utilise les re'sultats d'une autre passe. Certaines passes
sont obligatoires, d'autres sont optionnelles (comme par exemple la
phase d'optimisation dans les compilateurs).


L'organisation ge'ne'ralement adopte'e est celle ou` chaque passe est
une proce'dure appele'e par un {\em ``driver''} que l'utilisateur
commande soit de fac,on interactive soit par des lignes de contro^le
dans le programme source, ou bien encore par des options de lancement.


L'organisation choisie pour PIPS est radicalement diffe'rente. Gra^ce a`
NewGen nous avons la possibilite' de rendre chaque passe inde'pendante:
chaque passe lit un ou plusieurs fichiers de donne'es a` l'aide des
fonctions NewGen, effectue ses calculs, puis produit a` son tour un
fichier re'sultat. Les donne'es stocke'es sur un fichier peuvent e^tre
arbitrairement complexes (structures, tableaux, listes, graphes) car les
fonctions ge'ne're'es par NewGen prennent en compte ce genre de
donne'es. Le driver n'est alors plus ne'cessaire, quelques script-shells
suffisent.


Avec une telle organisation, le de'veloppement est conside'rablement
simplifie', car on est amene' a` de'velopper N petits logiciels pluto^t
qu'un unique gros. La mise au point est plus simple, les temps de
compilation plus courts, le partage du travail facilite'. Enfin, il est
tre`s facile d'utiliser plus d'un langage de programmation car un
fichier de donne'es e'crit par une passe C peut e^tre lu par une passe
Lisp, et ce {\em sans aucune modification du fichier ou des passes.}

\subsection{De'finition des domaines NewGen}


Les types de donne'es NewGen sont appele's des domaines, et la
spe'cification d'une structure de donne'es NewGen est constitue'e d'une
liste de de'finitions de domaines. Les de'finitions de donne'es peuvent
e^tre re'cursives (ou cycliques), c'est a` dire qu'un domaine peut e^tre
de'fini en fonction de lui-me^me, directement ou indirectement.


Les domaines sont de'finis a` partir de deux constructeurs, l'union
\verb/+/ et le produit \verb/x/, de deux ite'rateurs, le tableau
\verb/[]/ et la liste \verb/*/, et enfin de domaines pre'de'finis qui
correspondent a` peu pre`s aux types simples de C ou Lisp.


A chaque domaine correspond un ensemble de valeurs qui sont les valeurs
que peut prendre un objet de ce domaine. Ainsi, les valeurs du domaine
pre'de'fini \verb/int/ sont les entiers relatifs de $\cal Z$. 

Nous allons de'finir constructeurs et ite'rateurs en fonction de ces
ensembles de valeurs.

\subsubsection{Le produit}

Un domaine \verb/D/ est le produit de \verb/n/ domaines \verb/SD1, SD2, ..., SDn/ si
\verb/D/ est de'fini par:

\begin{verbatim}
D = SD1 x SD2 x ... x SDn ;
\end{verbatim}

Les \verb/SDi/ sont appele's les sous-domaines de \verb/D/. Un
sous-domaine peut e^tre un sous-domaine de base, un sous-domaine simple,
un sous-domaine liste ou un sous-domaine tableau (voir plus loin).


L'ensemble des valeurs de \verb/D/ est le produit carte'sien des
ensembles de valeurs des sous-domaines \verb/SDi/.

\subsubsection{L'union}

Un domaine \verb/D/ est l'union de \verb/n/ domaines 
\verb/SD1, SD2,..., SDn/ si \verb/D/ est de'fini par:

\begin{verbatim}
D = SD1 + SD2 + ... + SDn ;
\end{verbatim}

De me^me, les \verb/SDi/ sont appele's les sous-domaines de \verb/D/. 


L'ensemble des valeurs de \verb/D/ est l'union des ensembles de valeurs
des sous-domaines \verb/SDi/.

\subsubsection{Sous-domaines de base}

Un sous-domaine de base est de la forme:

\begin{verbatim}
nom:dpd
\end{verbatim}
ou` \verb/nom/ est le nom du sous-domaine et \verb/dpd/ est un domaine
pre'-de'fini: \verb/unit/ , \verb/bool/ , \verb/char/ , \verb/string/ ,
\verb/int/ et \verb/float/. 


L'ensemble des valeurs d'un sous-domaine de base est e'gal a` l'ensemble
des valeurs du domaine pre'-de'fini. Les types pre'-de'finis autres que
\verb/unit/ ont des ensembles de valeurs qui de'pendent du langage
utilise'. Par exemple, le sous-domaine \verb/float/ correspond aux
nombres re'els.


Le type pre'-de'fini \verb/unit/ a un ensemble de valeurs re'duit a` un
e'le'ment, conventionnellement note' \verb%UU%. Ce type est utile avec le
constructeur \verb/+/, dans le cas ou` le nom du sous-domaine a` lui
seul porte toute l'information utile.


Exemples:
\begin{verbatim}
employe = nom:string x age:int x salaire:float
complex = i:float x r:float
projet = pips:unit + vast:unit + paf:unit
\end{verbatim}

\subsubsection{Sous-domaine simple}
 
Un sous-domaine simple est de la forme:
\begin{verbatim}
nom:dom
\end{verbatim}
ou` \verb/nom/ est le nom du sous-domaine et \verb/dom/ le nom d'un
domaine {\em construit} par \verb/+/ ou \verb/x/, dont la de'finition
doit se trouver dans le me^me fichier de spe'cifications (les
re'fe'rences en avant sont admises) ou doit e^tre importe'e depuis un
autre fichier par la commande \verb/import/. Il est possible d'e'crire
\verb/nom/ a` la place de \verb/nom:nom/.


L'ensemble des valeurs du sous-domaine \verb/nom/ est e'gal a` l'ensemble des
valeurs du domaine \verb/dom/.


Dans les exemples suivants, \verb/annee, mois, naissance, .../ sont des
sous-domaines simples.

\begin{verbatim}
date = annee:int x mois:int x jour:int
employe = nom:string x naissance:date x salaire:float

import expression from "expression.spec"
dimension = lower:expression x upper:expression
\end{verbatim}

\subsubsection{Sous-domaine liste}

Un sous-domaine liste est de la forme:
\begin{verbatim}
nom:dom*
\end{verbatim}
ou` \verb/nom:dom/ est un sous-domaine de base ou un sous-domaine simple.


L'ensemble des valeurs du sous-domaine \verb/nom/ est e'gal aux listes a` ze'ro
ou plus e'le'ments dont chaque e'le'ment a` une valeur dans l'ensemble
des valeurs du domaine \verb/dom/.


Dans les exemples suivants, \verb/args/ et \verb/block/ sont des
sous-domaines listes.
\begin{verbatim}
call = function:entity x args:expression*
instruction = block:statement* + loop:loop + ...
\end{verbatim}

\subsubsection{Sous-domaine tableau}

Un sous-domaine tableau est de la forme:

\begin{verbatim}
nom:dom[d1][d2]...[dl]
\end{verbatim}
ou` \verb/nom:dom/ est un sous-domaine de base ou un sous-domaine simple et 
\verb/d1, d2, ..., dl/ sont l constantes entie`res.

L'ensemble des valeurs du sous-domaine \verb/nom/ est e'gal aux tableaux a` l
dimensions \verb/d1, d2, ..., dl/ d'e'le'ments. Chaque e'le'ment du
tableau ayant une valeur dans l'ensemble des valeurs du domaine \verb/dom/.

\subsection{Exemple: La repre'sentation interme'diaire de PIPS}

Les deux constructeurs \verb/+/ et \verb/x/, les deux ite'rateurs \verb/[]/ et \verb/*/ et
les domaines pre'de'finis propose's par NewGen permettent de de'finir
simplement toutes les structures de donne'es.

Voici un exemple important: la repre'sentation interme'diaire des
programmes Fortran pour PIPS. La liste des domaines est donne'e par
ordre alphabe'tique; une pre'sentation structure'e en est faite dans la
seconde partie. Il est recommande' d'avoir cet exemple a` porte'e de
main pour lire la suite de ce rapport.

\begin{verbatim}
array       = basic x dimensions:dimension* ;
basic       = int:int + float:int + logical:int + overloaded:unit + 
              complex:int + string:value ;
call        = function:entity x arguments:expression* ;
code        = declarations:entity* x statement ;
constant    = int + litteral:unit ;
dimension   = lower:expression x upper:expression ;
entity      = name:string x type x storage x initial:value ;
expression  = syntax ;
formal      = function:entity x offset:int ;
functional  = parameters:parameter* x result:type ;
instruction = block:statement* + test + loop + goto:statement + call ;
loop        = index:entity x range x body:statement x label:entity ;
mode        = value:unit + reference:unit ;
parameter   = type x mode ;
pgm         = modules:entity*
ram         = function:entity x section:entity x offset:int ;
range       = lower:expression x upper:expression x increment:expression ;
reference   = variable:entity x indices:expression* ;
statement   = label:entity x instruction ;
storage     = return:entity + ram + formal + rom:unit ;
symbolic    = expression x constant ;
syntax      = reference + range + call ;
test        = condition:expression x true:statement x false:statement ;
type        = statement:unit + area:int + array + functional + 
              unknown:unit + void:unit ;
value       = code + symbolic + constant + intrinsic:unit + unknown:unit ;
\end{verbatim}


Certaines de'finitions sont simples a` comprendre. Par exemple, une
variable Fortran est repre'sente'e par un objet de type \verb/array/, qui se
compose d'un type de base \verb/basic/ et d'une liste de dimensions
\verb/dimensions:dimension*/ (rappelons que \verb/basic/ est une
abbre'viation de \verb/basic:basic/).


Un programme \verb/pgm/ se compose d'une liste \verb/modules/ de
fonctions, chaque fonction e'tant repre'sente'e par un objet de type
\verb/entity/.


Le mode de passage des parame`tres est un \verb/mode/ qui vaut soit
\verb/value/ soit \verb/reference/.

\subsection{Imple'mentation C de NewGen}

Nous allons a` pre'sent e'tudier les fonctions ge'ne're'es par NewGen-C,
l'imple'mentation de NewGen pour le langage C. Nous ne de'crirons pas
NewGen-Lisp car cette seconde imple'mentation est tout a` fait
similaire.


Les fonctions que nous de'crivons dans la suite sont ge'ne're'es par
NewGen-C lors de la compilation d'un fichier de spe'cifications. Ces
fonctions sont accessibles depuis un programme C a` la condition
d'inclure un fichier header nomme' \verb/file.C_adt/ si \verb/file/
contient les spe'cifications\footnote{si l'ordre \texttt{import} est
utilise', il faut inclure plusieurs fichiers header; la liste des
fichiers a` inclure et l'ordre dans lequel ils doivent e^tre inclus sont
donne's par NewGen-C au moment de la compilation.}. Il faut en outre
utiliser une bibliothe`que lors de l'e'dition de liens.

\subsubsection{De'finitions de types - De'clarations d'objets}

Pour chaque domaine produit ou union \verb/dom/, une directive
\verb/typedef/ est ge'ne're'e. Ceci permet de de'clarer tre`s simplement
des objets de type
\verb/dom/:
\begin{verbatim}
#include "ri.C_adt"
...
dom d ;                 /* declare une variable d de type dom */

extern dom f() ;        /* definit une fonction f renvoyant 
                           un objet de type dom */ 
\end{verbatim}


Exemples:
\begin{verbatim}
dimension d ;
entity e;
extern constant EvalExpr() ;
\end{verbatim}

\subsubsection{Fonction de cre'ation - Domaines Produits}

Une fonction de cre'ation \verb/make_dom/ est cre'e'e pour chaque domaine
produit \verb/dom/. Cette fonction prend autant d'arguments qu'il y a de
sous-domaines dans la de'finition de \verb/dom/; chaque argument est un objet
du sous-domaine concerne' que l'on veut stocker dans l'objet en cours de
cre'ation. Les proble`mes d'allocation me'moire sont ge're's par Newgen-C.


Une valeur spe'ciale \verb/dom_undefined/ existe pour chaque domaine
\verb/dom/.


Exemples
\begin{verbatim}
d = make_dimension(l,u) ;
e = make_entity("+", type_undefined, storage_undefined, value_undefined) ;
\end{verbatim}

\subsubsection{Fonction de cre'ation - Domaine union}

Une fonction de cre'ation \verb/make_dom/ est ge'ne're'e pour chaque domaine union
\verb/dom/. Cette fonction prend 2 arguments:

\begin{itemize}
\item une e'tiquette de la forme \verb/is_dom_sdom/ qui indique a` quel
      sous-domaine appartient l'objet \verb/s/ que l'on veut stocker dans l'objet
      nouvellement cre'e'.
\item l'objet \verb/s/ appartenant a` un des sous-domaines de \verb/dom/, dont le
      type s'accorde avec l'e'tiquette \verb/is_dom_sdom/ de'crite ci-dessus.
\end{itemize}

Les e'tiquettes \verb/is_dom_sdom/ sont automatiquement cre'e'es par
NewGen-C. 


Exemples:
\begin{verbatim}
syntax s = make_syntax(is_syntax_call, make_call(f, args)) ; 
value  v = make_value(is_value_constant, 
                      make_constant(is_constant_int, 3)) ;
\end{verbatim}

\subsubsection{Fonctions d'acce`s et de modification - Domaines produits}

Si \verb/dom/ est un domaine produit, une fonction d'acce`s
\verb/dom_sdom/ est cre'e'e pour chaque sous-domaine \verb/sdom/ de
\verb/dom/. Le type de cette fonction est celui du sous-domaine
\verb/sdom/. Applique'e a` un objet \verb/d/ de type \verb/dom/, elle
retourne l'objet de type \verb/sdom/ stocke' dans \verb/d/.

Cette fonction est imple'mente'e de telle sorte qu'elle puisse e^tre
utilise'e en partie droite d'une affectation - pour acce'der a` la
valeur du sous-domaine - ou en partie gauche - pour changer la valeur du
sous-domaine.


Exemples:
\begin{verbatim}
constant c = EvalExpr(dimension_upper(d)) ;  
fprintf(fd, "%s" , entity_name(e)) ;
constant_int(value_constant(v)) += 1;
\end{verbatim}

\subsubsection{Fonctions d'acce`s - Domaines Unions}

Soit \verb/dom/ un domaine union. L'acce`s a` la valeur d'un sous-domaine
stocke' dans un objet \verb/d/ de type \verb/dom/ ne'cessite de connai^tre le type
du sous-objet contenu dans \verb/d/.  La fonction \verb/or_tag/ permet de
connai^tre ce type.


Par exemple, la fonction \verb/or_tag/ applique'e a` l'objet \verb/v/ de type
\verb/value/ cre'e' auparavant fournit la valeur \verb/is_value_constant/,
c'est-a`-dire la valeur de l'e'tiquette passe'e en parame`tre au moment
de la cre'ation de \verb/v/.


Une fois le type connu gra^ce a` la fonction \verb/or_tag/ la fonction
d'acce`s \verb/dom_sdom/ peut e^tre utilise'e comme pour les domaines produits.


Exemple:
\begin{verbatim}
if (or_tag(v) == is_value_constant) {
        constant c = value_constant(v) ;
        if (or_tag(c) == is_constant_int) {
                int valeur = constant_int(c) ;
                ...
        }
        ...
}
\end{verbatim}


Le pre'dicat \verb/dom_sdom_p(x)/ est e'quivalent a`
\verb/(or_tag(x)==is_dom_sdom)/ 
et est de'fini pour chaque sous-domaine \verb/sdom/. Il permet de
simplifier l'e'criture des programmes.


Exemple:
\begin{verbatim}
        if(value_constant_p(v) ) {
                ....
        }
\end{verbatim}

La fonction \verb/or_tag/ est ne'ammoins utile pour l'instruction C
\verb/switch/.

\subsubsection{Imple'mentation des listes}

La liste vide est note'e \verb/NIL/. Les listes sont constitue'es a` l'aide de
cellules que nous nommons \verb/cons/, par re'fe'rence a` Lisp. Une
variable devant contenir une liste doit e^tre de'clare'e de type
\verb/cons */.


Un \verb/cons/ se compose d'un e'le'ment \verb/car/ permettant de
stocker un objet \verb/d/ quel que soit le type de cet objet, et d'un
e'le'ment \verb/cdr/ permettant de pointer vers une autre cellule
\verb/cons/.


Le type C de l'e'le'ment \verb/car/ est unique; appelons le
\verb/chunk/. Comme cet e'le'ment est susceptible de contenir un objet de
n'importe quel domaine, une fonction d'insertion/extraction \verb/DOM/
est construite par NewGen-C pour chaque domaine \verb/dom/. Cette macro
permet de convertir un objet de type \verb/dom/ en un objet de type
\verb/chunk/, {\em et re'ciproquement}.


On ajoute un e'le'ment \verb/d/ de type \verb/dom/ a` une liste \verb/l/
(\verb/l/ peut valoir \verb/NIL/) gra^ce a` la fonction \verb/CONS/ dont
le type vaut \verb/cons*/ et qui prend 3 arguments:
\begin{itemize}
\item la fonction de conversion \verb/DOM/,
\item l'objet a` inse'rer \verb/d/ de type \verb/dom/,
\item la liste \verb/l/.
\end{itemize}

La fonction \verb/CONS/ retourne en re'sultat la nouvelle liste, qui comporte
l'e'le'ment en te^te de liste.\\


Dans l'exemple suivant, \verb/f/ est une \verb/entity/, \verb/e1/ et
\verb/e2/ des expressions:
\begin{verbatim}
cons *la;

call c = make_call(f, NIL);
la = CONS(EXPRESSION , e1 , NIL) ;
call_arguments(c) = CONS(EXPRESSION , e2 , la) ;
\end{verbatim}

La valeur de l'objet \verb/d/ de type \verb/dom/ contenu dans une
cellule \verb/cons/ est obtenue par la fonction \verb/CAR/ dont le type
est le type de l'e'le'ment \verb/car/, c'est-a`-dire \verb/chunk/. Le
re'sultat de \verb/CAR/ doit donc e^tre converti en un objet de type
\verb/dom/ gra^ce a` la macro d'insertion-extraction \verb/DOM/.


Exemple:
\begin{verbatim}
expression e = EXPRESSION(CAR(call_arguments(c))) ;
\end{verbatim}


La cellule suivant une cellule \verb/cons/ s'obtient par la fonction
\verb/CDR/ de type \verb/cons*/. La fonction \verb/CDR/ peut e^tre
utilise'e en partie gauche ou droite des affectations.


Exemple:
\begin{verbatim}
cons * pc ;
for (pc = call_arguments(c) ; pc != NIL ; pc = CDR(pc)) {
        constant c ;

        c = EvalExpression(EXPRESSION(CAR(pc))) ;
        ...
}
\end{verbatim}

\subsubsection{Imple'mentation des tableaux}

L'acce`s a` un e'le'ment d'un tableau se fait avec des \verb/[]/. Comme
pour les listes, les objets d'un tableau sont stocke's dans des
e'le'ments de type \verb/chunk/. La macro d'insertion-extraction
\verb/DOM/ doit donc encore e^tre utilise'e pour chaque acce`s au
tableau.


Exemple: soit la spe'cification suivante:

\begin{verbatim}
#define N 10
system = a:int[N][N] x b:int[N] ;
\end{verbatim}

Le domaine \verb/system/ s'utilise alors de la fac,on suivante:
\begin{verbatim}
main( )
{
   system s ;

   s = make_system(NIL, NIL) ;

   for (i = 0 ; i < 10 ; i++) {
      for (j = 0 ; j < 10 ; j++) {
         INT(system_a(s)[i][j]) = i*j;
      }
   }

   print_matrice(system_a(s)) ;
}

print_matrice(mat)
chunk mat[N][N] ;
{
   ...
}
\end{verbatim}

\subsubsection{Fonction d'Entre'es-Sorties}

Si \verb/d/ est un objet du domaine \verb/dom/, \verb/d/ peut e^tre e'crit sur fichier
par un appel a` la fonction \verb/gen_write/.


Cette fonction reconnai^t le type de \verb/d/ (\verb/dom/) gra^ce a` une
information cache'e dans \verb/d/, et lui applique le traitement
approprie'. Chaque sous-domaine est e'crit par un appel re'cursif a`
\verb/gen_write/, le processus se terminant avec les domaines
pre'de'finis, pour lesquels la valeur est e'crite. La fonction
\verb/gen_write/ ge`re les listes et les tableaux.


Un objet e'crit sur fichier par \verb/gen_write/ peut e^tre lu par
\verb/gen_read/. Un appel a` \verb/gen_read/ a pour effet de recre'er un
objet \verb/d'/ de type \verb/dom/ identique a` l'objet initial \verb/d/
aux adresses me'moire pre`s.


Il peut arriver que deux objets partagent le me^me espace me'moire,
comme par exemple dans le cas d'un graphe dont deux noeuds ont un me^me
successeur. On parle alors de {\em sharing}. Un autre cas de sharing
arrive avec les listes circulaires, lorsque le dernier e'le'ment pointe
vers le premier. Le sharing et les listes circulaires sont parfaitement
ge're's par \verb/gen_write/ et \verb/gen_read/.  L'objet recre'e'
\verb/d'/ par \verb/gen_read/ comportera le me^me sharing et les me^mes
listes circulaires que \verb/d/.


Un objet peut e^tre de'truit par \verb/gen_free/, fonction qui a le me^me
comportement que \verb/gen_write/: tous les sous-domaines sont re'cursivement
de'truits.


Exemple: le parseur de pips a un programme principal e'quivalent a`:
\begin{verbatim}
{
        FILE * fd ;
        pgm p ;

        p = parse_program() ;

        fd  = fopen("exemple.ri", "w") ;
        gen_write(fd, p) ;
        gen_free(p) ;
}
\end{verbatim}

Le paralle'liseur a un programme principal e'quivalent a`:\\
\begin{verbatim}
{
        FILE * fd ;
        pgm p ;

        fd  = fopen("exemple.ri", "r") ;
        pgm p = (pgm) gen_read(fd) ;
        pretty_print(parallelize_program(p)) ;
}
\end{verbatim}

Lorsque tout marchera correctement, il sera possible de cre'er un unique
programme pour e'conomiser les acce`s au fichier \verb/fd/:
\begin{verbatim}
pretty_print(parallelize_program(parse_program())) ;
\end{verbatim}

Dans ce cas, les modifications a` apporter aux programmes sont nulles.

\subsection{Remarques sur l'imple'mentation}

L'imple'mentation de NewGen-C est particulie`rement efficace, et
notamment:

\begin{itemize}
\item 
  les domaines pre'-de'finis sont expanse's dans les domaines
  produits et unions, dans les listes et dans les tableaux; il n'y a donc
  pas de gaspillage de me'moire ni d'indirection superflue;

  par exemple, l'imple'mentation d'une liste d'entiers est conforme a`
  ce que tout programmeur e'crirait: chaque \verb/cons/ contient un entier
  et un pointeur sur le \verb/cons/ suivant;

\item 
  la plupart des fonctions sont en fait des macros, d'ou` un gain en
  taille me'moire car il y a moins de fonctions, et un gain en rapidite';

\item 
  les tests dynamiques de types et de cohe'rence des structures de
  donne'es peuvent e^tre inhibe's pour ame'liorer la rapidite' des parties
  du projet correctes.
\end{itemize}
\section{Description de la repre'sentation interme'diaire}

\subsection{Principe ge'ne'raux}


Cette repre'sentation interme'diaire de programmes proce'duraux a e'te' de'finie
pour traiter des programmes Fortran mais nous avons pris soin de nous
appuyer sur les ide'es ge'ne'rales de la se'mantique de'notationnelle pour
obtenir une repre'sentation a` la fois concise, solide, extensible et
aussi inde'pendante de Fortran que possible.


Cette repre'sentation interme'diaire ne vise pas a rendre compte de tous les
proble`mes lie's aux traitements interproce'duraux qui seront effectue's
dans le cadre du projet PIPS. Elle a pour but de repre'senter d'une
manie`re se'mantiquement e'quivalente un programme principal, une
subroutine ou une function.

La conservation de la se'mantique peut e^tre estime'e en essayant d'e'crire
un interpre'teur Fortran base' sur cette repre'sentation.


Il ne faut pas perdre de vue que cette repre'sentation interme'diaire, comme
toute structure de donne'es, n'est que le squelette et que les
proce'dures utilisant des informations issues d'elle ne verront en
principe que la chair, c'est a` dire les fonctions et proce'dures qui
s'y appliqueront (e'valuateur d'adresse, e'valuateur d'expression,
etc...) et qui utiliseront e'ventuellement d'au\-tres structures de
donne'es prive'es.


Le pre'sent document repre'sente le re'sultat d'une premie`re phase.
La repre'sentation interme'diaire sera ensuite augmente'e pour prendre en compte
les besoins de l'analyse interproce'durale ou du calcul des de'pendances.

\subsection{Spe'cification NewGen de la repre'sentation interme'diaire}


Le fichier de spe'cifications NewGen de la ri est donne'e ci apre`s.  La
liste de'finitions de domaines n'est pas donne'e dans un ordre logique,
mais plus simplement par ordre alphabe'tique.

\begin{verbatim}
array       = basic x dimensions:dimension* ;
basic       = int:int + float:int + logical:int + overloaded:unit + 
              complex:int + string:value ;
call        = function:entity x arguments:expression* ;
code        = declarations:entity* x statement ;
constant    = int + litteral:unit ;
dimension   = lower:expression x upper:expression ;
entity      = name:string x type x storage x initial:value ;
expression  = syntax ;
formal      = function:entity x offset:int ;
functional  = parameters:parameter* x result:type ;
instruction = block:statement* + test + loop + goto:statement + call ;
loop        = index:entity x range x body:statement x label:entity ;
mode        = value:unit + reference:unit ;
parameter   = type x mode ;
ram         = function:entity x section:entity x offset:int ;
range       = lower:expression x upper:expression x increment:expression ;
reference   = variable:entity x indices:expression* ;
statement   = label:entity x instruction ;
storage     = return:entity + ram + formal + rom:unit ;
symbolic    = expression x constant ;
syntax      = reference + range + call ;
test        = condition:expression x true:statement x false:statement ;
type        = statement:unit + area:int + array + functional + 
              unknown:unit + void:unit ;
value       = code + symbolic + constant + intrinsic:unit + unknown:unit ;
\end{verbatim}

\subsection{Analyse de la repre'sentation interme'diaire}


Dans cette section, nous allons montrer comment cette repre'sentation
interme'diaire permet de repre'senter les diffe'rents objets manipule's par un
programme Fortran.

\subsubsection{Domaines}


Nous allons tout d'abord examiner chaque domaine pour expliquer
brie`vement a` quoi il sert.

\paragraph{Entity = name:string x type x storage x initial:value}

Tout objet ayant un nom dans un programme Fortran est repre'sente' par
une \verb/entity/. Un tel objet peut e^tre un module, une variable, un
common, un ope'rateur, une constante, un label, etc. Pour chaque objet,
le sous-domaine \verb/name/ de l'entite' donne le nom de l'objet tel qu'il
apparait dans le texte source du programme, le sous-domaine \verb/type/ donne
le type de l'entite', le sous-domaine \verb/storage/ le genre d'allocation
me'moire utilise' pour l'entite', et finalement, le sous-domaine
\verb/initial/ donne la valeur initiale, si elle est connue, de l'entite'. Le
terme valeur initiale a ici un sens assez large, puisqu'il s'agit par
exemple du code pour les entite's repre'sentant des modules.

\paragraph{Type = statement:unit + area:int + array + functional +
unknown:unit + void:unit} 

Le domaine \verb/type/ repre'sente le type d'une entite'.  Le
sous-domaine \verb/statement/ est utilise' pour les labels
d'instruction.  Le sous-domaine \verb/area/ est utilise' pour les
commons.  Le sous-domaine \verb/array/ est utilise' pour toutes les
variables, y compris les parame`tres formels et le re'sultat d'une
fonction.  Le sous-domaine \verb/functional/ est utilise' pour les
fonctions, pour les subroutines et pour le programme principal.  Le
sous-domaine \verb/void/ est utilise' pour le re'sultat d'une subroutine
ou d'un programme principal.

\paragraph{Array = basic x dimensions:dimension*}

Le domaine \verb/array/ repre'sente le type d'une variable.  Le
sous-domaine \verb/basic/ donne le type Fortran de la variable.  Le
sous-domaine \verb/dimensions/ donne la liste des dimensions de la variable.
Un scalaire est un tableau de ze'ro dimension.


Chaque dimension est une expression, qui n'est pas ne'cessairement
constante dans le cas des tableaux formels. La constante pre'de'finie de
nom '*D*' est utilise'e pour les tableaux de taille non de'finie
(\verb/DIMENSION T(*)/).

\paragraph{Basic = int:int + float:int + logical:int + overloaded:unit + 
complex:int + string:value}

Le domaine \verb/basic/ permet de repre'senter un type Fortran tel que
INTEGER ou REAL. La valeur de ce domaine donne la longueur en octets de
la zone me'moire occuppe'e par une variable de ce type.

\paragraph{Dimension = lower:expression x upper:expression}

Le domaine \verb/dimension/ permet de repre'senter une dimension d'un
tableau, c'est a` dire un couple borne infe'rieure -- sous-domaine
\verb/lower/ -- borne supe'rieure -- sous-domaine \verb/upper/.

\paragraph{Functional = parameters:parameter* x result:type}

Le domaine \verb/functional/ repre'sente le type d'un module, c'est
a` dire une fonction, une subroutine ou un programme principal. Le
sous-domaine \verb/parameters/ donne le type et le mode de passage de chaque
parame`tre, et le sous-domaine \verb/result/ donne le type du re'sultat. Ce
dernier type vaut \verb/void/ pour les subroutines et les programmes
principaux. 

\paragraph{Parameter = type x mode}

Le domaine \verb/parameter/ repre'sente le type et le mode de passage d'un
parame`tre formel de module. 

\paragraph{Mode = value:unit + reference:unit}

Le domaine \verb/mode/ repre'sente le mode de passage d'un parame`tre
formel de module. Le domaine contient un objet du domaine \verb/value/
pour le mode de passage par valeur et \verb/reference/ pour le passage
par adresse.

\paragraph{Storage = return:entity + ram + formal + rom:unit}

Le domaine \verb/storage/ permet de pre'ciser dans quelle zone de la me'moire
est stocke'e une entite'. Il y a plusieurs zones, qui ne correspondent
pas ne'cessairement a` la re'alite', c'est a` dire aux zones de me'moire
qui seraient affecte'es par un compilateur.


Le sous-domaine \verb/return/ permet de repre'senter les variables ayant
pour nom le nom d'une fonction et auxquelles on affecte la valeur que la
fonction doit retourner. L'entite' pointe'e par \verb/return/ est la
fonction concerne'e.


Le sous-domaine \verb/ram/ est reserve' aux variables ayant une adresse
en me'moire. Il permet de pre'ciser dans quelle fonction et
e'ventuellement dans quelle common ces variables ont e'te' de'clare'es.


Le sous-domaine \verb/formal/ est re'serve' aux parame`tres formels des
modules.


Le sous-domaine \verb/rom/ est utilise' pour toutes les entite's dont la
valeur n'est pas modifiable, telles que les fonctions, les labels, les
ope'rateurs, etc.

\paragraph{Ram = function:entity x section:entity x offset:int}

Le domaine \verb/ram/ permet de pre'ciser la de'claration d'une
variable. Le sous-domaine \verb/function/ indique dans quel module une
entite' est de'clare'e. Le sous-domaine \verb/section/ indique dans
quelle aire une entite' est stocke'e; il y a une aire par common
de'clare' et deux aires spe'ciales nomme'es \verb/_STATIC/ et
\verb/_DYNAMIC/ pour les entite's locales. Enfin, le sous-domaine
\verb/offset/ donne l'adresse dans l'aire de la variable.

\paragraph{Formal = function:entity x offset:int}

Le domaine \verb/formal/ indique le module dans lequel un parame`tre formel
est de'clare' gra^ce le sous-domaine \verb/function/, et le rang de ce
parame`tre dans la liste des parame`tres gra^ce au sous-domaine \verb/offset/.

\paragraph{Value = code + instruction + symbolic + constant + intrinsic:unit + 
unknown:unit}

Le domaine \verb/value/ permet de repre'senter les valeurs initiales des
entite's. Le sous-domaine \verb/code/ est utilise' pour les entite's
modules. Le sous-domaine \verb/symbolic/ est utilise'
pour les entite's constantes symboliques. Le sous-domaine
\verb/constant/ est utilise' pour les entite's constantes. Le
sous-domaine \verb/intrinsic/ est utilise' pour toutes les entite's qui
ne de'pendent que du langage, telles que les intrinsics Fortran, les
ope'rateurs, les instructions, etc. Enfin le sous-domaine
\verb/unknown/ est utilise' pour les valeurs initiales inconnues.

\paragraph{Symbolic = expression x constant}

Le domaine \verb/symbolic/ est utilise' pour repre'senter la valeur
initiale d'une entite' constante symbolique, c'est a` dire les PAAMETER
de Fortran ou les CONST de Pascal. Le sous-domaine \verb/expression/ permet
de stocker l'expression qui a permis d'e'valuer la valeur initiale
contenue dans le sous-domaine \verb/constant/. Le sous-domaine \verb/expression/
n'est utile qui si on cherche a` reproduire un texte source fide`le.

\paragraph{Constant = int + litteral:unit}

Le domaine \verb/constant/ est utilise' pour repre'senter la valeur
initiale des entite's constantes. Seules les entite's de type entier
nous inte'ressent, ce qui explique qu'une constante puisse e^tre soit un
\verb/int/ soit un \verb/litteral/ dont on ne garde pas la valeur (type unit).

\paragraph{Code = declarations:entity* x statement}

Le domaine \verb/code/ est utilise' pour stocker le corps des modules. Le
sous-domaine \verb/declarations/ contient une liste d'entite's qui sont les
variables et commons de'clare's dans la fonction. Le sous-domaine
\verb/statement/ contient la se'quence d'instructions du module.

\paragraph{Statement = label:entity x instruction}

Le domaine \verb/statement/ permet de repe'rer les instructions d'un module.
Le sous-domaine \verb/label/ contient une entite' qui de'finit le label. Le
sous-domaine \verb/instruction/ contient le corps de l'instruction.

\paragraph{Instruction = block:statement* + test + loop + goto:statement + call}

Le domaine \verb/instruction/ permet de repre'senter les instructions
d'un module. Une instruction peut e^tre un sous-domaine \verb/block/,
c'est a` dire une liste de \verb/statement/, un sous-domaine \verb/test/
pour les instructions de test, un sous-domaine \verb/loop/ pour les
boucles, un sous-domaine \verb/goto/ pour les goto qui contient le
\verb/statement/ vers lequel le goto se branche, ou un sous-domaine
\verb/call/ pour toutes les autres instructions: affectation, appel de
subroutine, entre'es-sorties, return, stop, etc. Toutes ces instructions
sont repre'sente'es par des appels a` des fonctions pre'de'finies dont
nous e'tudierons la nature plus loin.

\paragraph{Test = condition:expression x true:statement x false:statement}

Le domaine \verb/test/ permet de repre'senter toutes les instructions a` base
de contro^le. Le sous-domaine \verb/condition/ contient l'expression a`
tester, et les deux sous-domaines \verb/true/ et \verb/false/ contiennent les
instructions a` exe'cuter selon la valeur du test. 

Il faut noter que chaque instruction de contro^le de Fortran,
a` l'exception de l'instruction \verb/DO/, est
transforme'e en une combinaison se'mantiquement e'quivalente de \verb/test/s
et de \verb/goto/s.

\paragraph{Loop = index:entity x range x body:statement x label:entity}

Le domaine \verb/loop/ permet de repre'senter les boucles du type DO Fortran
ou FOR Pascal. Le sous-domaine \verb/index/ contient l'entite' indice de
boucle, le sous-domaine \verb/range/ contient les bornes de la boucle, le
sous-domaine \verb/body/ contient le corps de la boucle, c'est a` dire un
\verb/statement/, le sous-domaine \verb/label/ contient le label de fin de boucle,
c'est a` dire une entite'.

\paragraph{Range = lower:expression x upper:expression x increment:expression}

Le domaine \verb/range/ permet de repre'senter les bornes des boucles DO
Fortran. Il y a trois sous-domaines \verb/lower/, \verb/upper/ et \verb/increment/ de
type \verb/expression/ qui sont respectivement la borne infe'rieure, la borne
supe'rieure et l'incre'ment.

\paragraph{Call = function:entity x arguments:expression*}

Le domaine \verb/call/ permet de repre'senter les appels de fonctions.
Les fonctions jouent un ro^le important dans notre repre'sentation
interme'diaire puisque les ope'rateurs et les instructions Fortran
(READ, WRITE, RETURN, ...) sont repre'sente'es par des fonctions
pre'de'finies.

Le sous-domaine \verb/function/ est une entite' qui de'finit la fonction
appele'e. Le sous-domaine \verb/arguments/ est une liste de sous-domaines
\verb/expression/ qui repre'sente les arguments d'appel de la fonction.

\paragraph{Expression = syntax}

Le domaine \verb/expression/ permet de stocker les expressions.
Pour l'instant, ce domaine ne se compose que d'un unique sous-domaine
\verb/syntax/, mais nous pensons ajouter ulte'rieurement d'autres
sous-domaines, notamment pour conserver avec chaque expression line'aire
un forme compile'e, peut-e^tre sous forme d'un vecteur.

Le sous-domaine \verb/syntax/ contient l'expression avec la me^me
structure que celle du code source.

\paragraph{Syntax = reference + range + call}

Le domaine \verb/syntax/ permet de repre'senter les expressions telles
qu'elles apparaissent dans le texte source du programme. Un
\verb/syntax/ est soit une \verb/reference/ a` un e'le'ment de tableau
(on rappelle que les scalaires sont des tableaux a` 0 dimension) , soit
un \verb/call/ a` une fonction (les ope'rateurs sont repre'sente's par
des fonctions pre'-de'finies), soit un \verb/range/, dans le cas des
expressions bornes de boucles.


\paragraph{Re'fe'rence = variable:entity x indices:expression*}

Le domaine \verb/reference/ est utilise' pour repre'senter une re'fe'rence a`
un e'le'ment de tableau. Le sous-domaine \verb/variable/ contient une entite'
de'finissant la variable re'fe'rence'e. Le sous-domaine \verb/indices/
contient une liste expressions qui sont les indices de la re'fe'rence.

\subsubsection{Objets du langage Fortran}


Nous montrons a` pre'sent comment les diffe'rents objets manipule's dans
un programme Fortran sont traduits dans notre repre'sentation interme'diaire.

\paragraph{Module}

Un module est un programme principal, une fonction ou une subroutine. 


Un module est repre'sente' par une \verb/entity/ dont le \verb/name/ est le nom du
module, le \verb/type/ est un \verb/functional/ qui indique le type des
parame`tres formels et du re'sultat, le \verb/storage / vaut \verb/rom/ et le
\verb/initial/ est un \verb/code/ qui contient le corps du module.

Les subroutines et le programme principal n'ont pas d'argument et
retournent un \verb/void/. Les noms des modules sont pre'fixe's par des
'\_' et le nom du programme principal est prefixe' par un '\_\_' pour le
diffe'rencier d'une subroutine.

\paragraph{Commons et aires}

Une aire repre'sente une partie de la me'moire ou` sont range'es les
variables. Les commons sont des aires (voir plus loin).


Deux aires spe'ciales sont cre'e'es pour les variables qui
n'appartiennent pas a` un common (variables locales). Ces deux aires
sont des entite's qui ont pour \verb/name/ \verb/_STATIC/ et
\verb/_DYNAMIC/, pour \verb/type/ un \verb/area/ qui donne la longueur
de l'aire, pour \verb/storage/ un \verb/rom/ et comme \verb/initial/ une
\verb/value/ de type \verb/unknown/. 


L'appartenance d'une variable ou d'un common a` l'une des ces deux aires
spe'ciales indique si cette variable ou ce common est statique ou
dynamique.


Un common est repre'sente' par une \verb/entity/ dont le \verb/name/ est
le nom du common, le \verb/type/ est un \verb/area/ qui donne la
longueur du common en octets, le \verb/storage/ est un \verb/ram/ qui
indique la fonction ou` le common est declare' (\verb/function/) et
l'aire ou` le common est range' (\verb/section/)..


Le nom des commons est pre'fixe' par un '\_', comme les autres
identificateurs globaux.

\paragraph{Variables -- Ge'ne'ralite's}

Les variables scalaires sont traite'es comme des tableaux a` 0 dimension.


Une variable est repre'sente'e par une \verb/entity/ dont le \verb/name/ est le
nom de la variable. 

\paragraph{Variables -- Types}

Le \verb/type/ d'une entite' ``variable{''} est un \verb/array/ qui donne le type
fortran des e'le'ments (\verb/basic/), le nombre de dimensions (longueur de
la liste \verb/dimensions/) et les bornes de chaque dimension.

\paragraph{Variables -- Allocation me'moire}

Le \verb/storage/ d'une entite' ``variable re'sultat de fonction'' est un
\verb/return/ qui indique la fonction contenant cette variable.


Le \verb/storage/ d'une entite' ``variable parame`tre formel'' est un
\verb/formal/ qui indique la fonction contenant ce parame`tre et le rang de
ce parame`tre dans la liste des parame`tres formels.


Le \verb/storage/ d'une entite' ``variable locale ou globale{''} est un \verb/ram/
qui indique dans quelle fonction la variable est de'clare'e
(\verb/function/), a` quelle aire (common ou aire spe'ciale) elle appartient
(\verb/section/) et quelle est son adresse dans ce common (\verb/offset/).

\paragraph{Variable -- Valeur initiale}

Le \verb/initial/ d'une entite' ``variable{''} vaut \verb/unknown/ sauf
si cette variable est de type entier et est initialise'e par data. Dans
le cadre de la paralle'lisation, on ne s'inte'resse pas aux autres variables.

\paragraph{Constantes nume'riques et symboliques}

Les constantes sont conside're'es comme des fonctions. Elles sont donc
repre'sente'es par des entite's dont le \verb/name/ est le nom de la
constante (\verb/12/, \verb/13.56E12/, \verb/'*NOMBRE DE FACETTES:*'/, \verb/PI/, \verb/MAXITER/,
etc.), dont le \verb/type/ est un \verb/functional/ a` 0 parame`tre et 1
re'sultat qui donne le type de la constante, dont le \verb/storage/ est un
\verb/rom/ et dont le \verb/initial/ est un \verb/constant/ pour les constantes
nume'riques et un \verb/symbolic/ pour les constantes symboliques.

\paragraph{Ope'rateurs}

Les ope'rateurs Fortran sont conside're's comme des fonctions. Ils sont
donc repre'sente's par des entite's dont le \verb/name/ est le nom de
l'ope'rateur, et dont le \verb/type/ est un \verb/functional/ qui indique l'arite'
de l'ope'rateur (longueur de la liste \verb/parameters/) mais qui n'indique
pas le type des parame`tres ou du re'sultat car le sous-domaine \verb/basic/
vaut toujours \verb/overloaded/. Le storage d'un ope'rateur est un \verb/rom/ et
son initial un \verb/intrinsic/.

\paragraph{Intrinsics}

Les intrinsics Fortran (MAX, MIN, ABS, etc.) sont traite's comme des
ope'rateurs. 

\paragraph{Labels}

Les labels sont repre'sente's par des entite's dont le \verb/name/ est
le nom du label pre'fixe' par un '\verb/@/', dont le \verb/type/ vaut
\verb/statement/, dont le \verb/storage/ vaut \verb/rom/ et dont le
\verb/initial/ est une constante litterale.

\paragraph{Instructions simples}

Les instructions simples de Fortran telles que RETURN, CONTINUE, STOP,
READ, WRITE, PAUSE, END, ... sont conside're'es comme des fonctions
intrinse`ques.  Elles sont donc repre'sente'es par des entite's qui ont
les me^mes caracte'ristiques qu'un ope'rateur a` 0 parame`tre. On ne
tient pas a jour le nombre de parame`tres car il ne sert a` peu pre`s a`
rien et que de toute fac,on, il est variable.


L'instruction PRINT est transforme'e en WRITE.

\paragraph{Instructions de contro^le}

Toutes les instructions de contro^le du sous-Fortran que nous acceptons
en entre'e, a` l'exception de l'instruction \verb/DO/, sont
transforme'es {\em automatiquement} en se'quences e'quivalentes de tests
a` deux branches (une vraie et une fausse), de branchements
inconditionnels et de boucles do.


\begin{verbatim}
      IF (I) 10, 20, 30
\end{verbatim}
devient
\begin{verbatim}
      IF (I.LT.0) THEN
         GOTO 10
      ELSE
         IF (I.EQ.0) THEN
             GOTO 20
          ELSE
             GOTO 30
          ENDIF
      ENDIF
\end{verbatim}


\begin{verbatim}
      IF (I.GT.J) I = I-J
\end{verbatim}
devient
\begin{verbatim}
      IF (I.GT.J) THEN
         I=I-J
      ELSE
        CONTINUE
      ENDIF
\end{verbatim}

\paragraph{Arguments des instructions d'entre'es-sorties}

Les arguments des instructions d'entre'es-sorties sont soit des
informations de contro^le (unite', format, longueur des enregistrements,
etc.), soit des re'fe'rences a` lire ou des expressions a` e'crire. 


Dans notre repre'sentation, les arguments des instructions
d'entre'es-sorties sont des listes de couples d'expressions. La
premie`re expression du couple est une constante chaine de caracte`res
qui indique la nature de l'argument qui apparaissait dans l'instruction
Fortran (\verb/UNIT=/, \verb/FORMAT=/, \verb/RECL=/, ...). La seconde
expression est la valeur de cet argument.


Le dernier couple de la liste d'un READ ou d'un WRITE n'est pas un vrai
couple: le premier e'le'ment est une expression constante qui vaut
\verb/IOLIST=/, et le second e'le'ment est une liste d'expressions qui sont
les re'fe'rences a` lire ou les expressions a` e'crire.

\paragraph{Boucles implicites}

Les boucles do implicites dans les entre'es-sorties sont repre'sente'es
par des appels a` un ope'rateur pre'de'fini (en fait une fonction) de
nom \verb/IMPLIED-DO/, qui prend comme arguments une entite' qui de'finit
l'indice de la boucle, une expression \verb/range/ qui de'finit les bornes de
la boucle, et une liste d'expressions.

\paragraph{Formats}

Les formats sont conserve's sous forme d'expressions constantes chaines
de caracte`res. La constante de nom '*F*' est pre'de'finie pour les
formats libres (list-directed).


Voici un exemple d'instruction d'entre'es-sorties.
\begin{verbatim}
      READ(2,'(5E16.6)') (IMD(I),I=1,NDOM), K
\end{verbatim}

devient
\begin{verbatim}
      (READ 'FMT=' '(5E16.6)' 'UNIT=' 2 
            'IOLIST=' (IMPLIED-DO I 1,NDOM,1 IMD(I)) K)
\end{verbatim}

\section{Structures de donne'es de l'analyse se'mantique intraproce'durale}

Le but de cette section est de pre'senter les structures de donne'es
utilise'es pour imple'menter les deux premie`res phases de la me'thode
d'analyse se'mantique de Cousot et Halbwachs. Ces deux premie`res
phases, traduction du graphe de contro^le en un syste`me aux polye`dres
et re'solution de ce syste`me, ont e'te' introduites dans le pre'ce'dent
rapport interme'diaire.

Les ensembles de valeurs entie`res que peuvent prendre les variables
scalaires entie`res des modules en chaque point de contro^le sont
approxime's par des polye`dres a` bornes {\em rationnelles} et non
entie`res pour diminuer la complexite' des calculs.

Ces polye`dres peuvent e^tre de'finis de deux manie`res
e'quivalentes:
\begin{itemize}
  \item implicitement, par un syste`me d'e'galite's et d'inegalite's line'aires
        ve'rifie' par les points appartenant au polye`dre,
  \item ou explicitement, par un syste`me ge'ne'rateur forme' de sommets,
        rayons et droites dont les combinaisons line'aires sont les
        points du polye`dre.
\end{itemize}
Ces deux repre'sentations, qui font l'objet des deux premie`res
sous-sections, sont utilise'es simultane'ment parce que certaines
ope'rations s'effectuent mieux avec l'une qu'avec l'autre (intersection
par syste`me d'e'quations, union par syste`me ge'ne'rateur) et parce
qu'on les utilise toutes les deux pour e'liminer la redondance qui
apparai^t au fur et a` mesure des calculs. Les polye`dres que nous
manipulerons comporterons donc deux parties, l'une donnant la
repre'sentation par syste`me d'e'quations et l'autre la repre'sentation
par syste`me ge'ne'rateur.

La dernie`re sous-section est consacre' a` la repre'sentation du
syste`me d'e'quations aux polye`dres construit a` partir de la 
repre'sentation interme'diaire produite par l'analyse syntaxique
et a` partir de son graphe de contro^le.

\subsection{Repre'sentation des syste`mes d'e'galite's et d'ine'galite's 
line'aires}

Le syste`me de contraintes est repre'sente' par la matrice de ses
coefficients et par un vecteur de termes constants. Cette matrice,
e'tant ge'ne'ralement tre`s creuse, est repre'sente'e par des vecteurs
creux et par lignes.  En effet, il faut choisir entre une
repre'sentation par ligne et par colonne, et on effectue plus souvent
des combinaisons line'aires de lignes dans l'algorithme de test de 
de'pendance qui partage cette structure de donne'es avec l'analyse se'mantique.

Chaque colonne de la matrice correspond a` une variable scalaire entie`re
du module analyse', une entite' de la repre'sentation interne. Ces
entite's sont renomme'es 1, 2,... pour les traitements mathe'matiques
mais on conserve un tableau de correspondance permettant de passer
du nume'ro d'une variable a` l'entite' correspondante.

On comple`te chaque ligne de la matrice de contraintes par le terme
constant qui rec,oit conventionnellement le nume'ro de variable 0.

\subsubsection{Vecteur}

Un vecteur est une liste de couples (nume'ro de variable, valeur).
Cette liste de couples n'est pas trie'e dans la premie`re imple'mentation
qui est fai^te car nous faisons l'hypothe`se que le nombre de coefficients
non nuls restera tre`s faible tout au long des calculs. 

Le vecteur nul est repre'sente' par une liste vide.

Ce type {\em vecteur} est utilise' pour repre'senter les contraintes,
les sommets, les rayons et les droites.

\subsubsection{Contrainte}

Une contrainte est soit une e'galite', soit une ine'galite' (on ne sait pas
faire la distinction a` ce niveau). Elle contient donc implicitement
un terme constant associe' a` la variable de nume'ro 0.

On associe a` chaque contrainte de type ine'galite' les e'le'ments du syste`me
ge'nerateur qui la sature au moyen de tableaux d'entiers.

Chaque contrainte contient aussi un pointeur vers une autre contrainte
pour pouvoir constituer directement les deux listes d'e'galite's et
d'ine'galite's d'un syste`me.

\subsubsection{Syste`me}

Un syste`me line'aire est constitue' de deux listes de contraintes,
e'galite's et ine'galite's. C'est a` ce niveau que l'on dispose de
l'information n'ecessaire pour savoir comment traiter les termes constants.
Il contient aussi le nombre de ces e'galite's
et de ces ine'galite's, ainsi que le nombre de variables du syste`me.

Pour permettre la sortie de messages compre'hensifs, chaque syste`me
contient aussi un pointeur vers un tableau d'entiers permettant de
retrouver les nume'ros d'entite's correspondant a` chacune de ses variables.

\subsection{Repre'sentation des syste`mes ge'ne'rateurs}

\subsubsection{De'finition d'un syste`me ge'ne'rateur}

Comme les syste`mes ge'ne'rateurs sont moins connus que les syste`mes
d'ine'galite's, nous rappelons que ce sont des triplets de trois ensembles
appele's respectivement sommets, rayons et droites. Le polye`dre $P$
ge'ne're' par un syste`me $S=\{\{\vec{s_i}\},\{\vec{r_j}\},\{\vec{d_k}\}\}$
est de'fini par l'e'quation:
\[
P = \left\{ { \vec{v} / 
        \exists \lambda_i \geq 0 \; \wedge \; \sum_i \lambda_i = 1 \;
                \exists \mu_j \geq 0 \;
                \vec{v} = \sum_i \lambda_i \vec{s_i} +
                \sum_j \mu_j \vec{r_j} +
                \sum_k \nu_k \vec{d_k} 
        }\right\}
\]

\subsubsection{Sommets}

Comme nous approximons les ensembles de valeurs entie`res par des
ensembles de valeurs rationnelles, il se peut que les sommets aient
des coordonne'es rationnelles. Ils sont donc repre'sente's
par un vecteur a` coefficients entiers et par un unique de'nominateur.

On associe aussi a` chaque sommet un tableau des e'quations qu'il
sature (i.e. ve'rifie).

Enfin, chaque sommet contient un lien vers un sommet suivant, qui permet
de constituer l'ensemble des sommets d'un syste`me ge'ne'rateur.

Au plus haut niveau, on garde un pointeur vers le premier
sommet, ainsi que le nombre total de sommets de la liste.

\subsubsection{Rayons et droites}

Les rayons et les droites sont des objets identiques. Seule change
l'interpre'tation qu'on en donne et la manie`re dont on les traite.

Ils sont repre'sente's comme les sommets, mais ne contiennent pas
de champs de'nominateur puisqu'ils sont de'finis a` une constante
multiplicative pre`s.
A chacun d'eux est associe' un vecteur,
un ensemble de nume'ro d'e'quations sature'es, et un pointeur
vers l'e'le'ment suivant. En te^te de liste, on conserve le
nombre d'e'le'ments.

\subsubsection{Syste`me ge'ne'rateur}

Un syste`me ge'ne'rateur comporte donc trois champs, qui sont les te^tes
de liste des sommets, des rayons et des droites.

\subsection{Repre'sentation d'un syste`me d'e'quations aux polye`dres}

Un syste`me d'e'quations aux polye`dres est une structure de donne'es complexe
qui me'rite une description en plusieurs e'tapes.

\subsubsection{Repre'sentation d'un polye`dre}

Un polye`dre est repre'sente' par une paire de pointeurs, un vers
le syste`me ge'ne'rateur du polye`dre, l'autre vers son syste`me
d'ine'galite's et e'galite's.

\subsubsection{Le syste`me}

Un syste`me d'e'quations aux polye`dres comprend
quatre champs. Le premier champ permet de passer des nume'ros
de variables propres aux routines mathe'matiques aux nume'ros
d'entite' de'finis par l'analyseur syntaxique.

Le second champs permet de connai^tre le nombre des variables
effectivement utilise'es dans l'analyse se'mantique. Le
troisie`me champ est le syste`me d'ine'galite's qui de'finit l'e'tat
initial du module.

Enfin le quatrie`me champ est compose' d'une liste ge'ne'ralise'e
d'e'quations se'mantiques. Les e'le'ments primitifs sont
les e'quations se'mantiques, mais les e'quations relatives aux
instructions d'un corps de boucle sont regroupe'es en une sous-liste,
et ce, re'cursivement.

Cette structuration hie'rarchique des e'quations, qui refle`te la
structure du graphe de contro^le, permettra de rechercher d'abord
les points fixes du syste`me sur les boucles les plus internes.

\subsubsection{Equation se'mantique}

Une e'quation se'mantique a cinq champs. Le premier est le
polye`dre $P$ caracte'risant les valeurs des variables en ce point du 
programme. Le second donne la liste des parame`tres permettant de
calculer $P$ en fonction des autres polye`dres $P_i$ et le troisie`me
le type de relation existant entre $P$ et les $P_i$. Le quatrie`me
champ permet de savoir si ce polye`dre doit e^tre conserve' ou non
pour e^tre ulte'rieurement utilise' dans le processus de paralle'lisation.
Le cinquie`me et dernier champ permet de savoir a` quel point de contro^le
du module il faut rattacher l'information $P$.

\subsubsection{Divers types d'e'quations se'mantiques}

Les diffe'rents types d'e'quations que nous savons traiter sont:
\begin{itemize}
  \item les affectations non-line'aires (\verb%I=J**2%),
  \item les affectations line'aires inversibles (\verb%I=I+1%),
  \item les affectations line'aires non-inversibles (\verb%I=J%),
  \item les tests non line'aires,
  \item les tests line'aires de type ine'galite' pour les branches
        vrai et faux (\verb%I.LE.J-3%),
  \item les tests line'aires a` e'galite', branches vrai et faux
        (\verb%I.EQ.0%),
  \item les noeuds de jonction qui sont les noeuds du graphe de contro^le
        qui ont plus d'un ante'ce'dent (regroupement apre`s un \verb%IF%,
        ou en te^te de \verb%DO%, ou encore sur un \verb%CONTINUE% a` cause
        d'un \verb%GOTO%),
  \item les noeuds d'e'largissements, qui caracte'risent les boucles
        et qui permettent d'e'viter les ite'rations infinies vers un
        point fixe (ope'rateur d'e'largisssement de'fini par Cousot).
\end{itemize}
A chaque type d'e'quations est associe' une structure de donne'es 
diffe'rentes dont les champs contiennent exactement les parame`tres
ne'cessaires: polye`dre(s) en entre'e, variable modifie'e, expression
line'aire, etc...

\section{Conclusion}

Les structures de donne'es pre'sente'es dans ce rapport d'avancement 
nume'ro 2 permettent de construire les premiers programmes du
projet PIPS. Notons que celles qui sont relatives a` l'analyse
se'mantique seront probablement modifie'es pour diminuer le
temps d'exe'cution, qui est le talon d'Achille de la me'thode
d'analyse de Cousot et d'Halbwachs.

\end{document}
