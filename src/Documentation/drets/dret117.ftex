\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\titre}{RAPPORT FINAL \\
                    ANALYSE SYNTAXIQUE INTER-PROC\'EDURALE}
\newcommand{\auteur}{Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{Septembre 1989}
\newcommand{\numero}{E117}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\PAR{}
L'analyse syntaxique inter-proce'durale (analyse syntaxique au niveau
programme) est re'alise'e par un programme nomme' {\em linker}, qui fait
a` peu pre`s la me^me chose qu'un e'diteur de liens classique, mais au
niveau de la repre'sentation abstraite du programme et non pas au niveau
du code assembleur ou machine. Ce rapport a pour objet de de'crire les
structures de donne'es et les algorithmes mis en oeuvre pour la
re'alisation du linker.

\SEC{Objectif}
\PAR{}
Un programme Fortran se compose de un ou plusieurs fichiers, chaque
fichier contenant un ou plusieurs modules (function, main ou
subroutine). Nous avons vu dans les rapports pre'ce'dents que Pips
attache plusieurs informations a` chaque module: type du module, nombre
de parame`tres formels, type des parame`tres formels, instructions du
corps du module, etc.

\PAR{}
Le linker a pour objectif de permettre un acce`s direct a` ces
informations a` partir de toute re'fe'rence a` l'entite' repre'sentant
ce module.  Il s'agit donc d'avoir une repre'sentation interne ou`
chaque entite' n'a qu'une seule de'finition. Par exemple, si le module
{\tt P} contient un appel au module {\tt Q}, nous voulons que l'entite'
re'fe'rence'e dans l'instruction {\tt CALL} de {\tt P} soit la me^me
entite' que celle cre'e'e lors de l'analyse de {\tt Q}. Ceci permet un
acce`s direct depuis cette instruction {\tt CALL} aux diverses
informations associe'es a` {\tt Q}, et notamment le code de {\tt Q}.

\PAR{}
Ceci n'est possible qu'apre`s une phase d'e'dition de liens, puisque
{\tt P} et {\tt Q} peuvent parfaitement e^tre de'finis dans deux
fichiers diffe'rents, et que nous n'imposons aucun ordre pour soumettre
les diffe'rents fichiers d'un programme Fortran au parser.

\SEC{Rappels sur le Parser}
\PAR{}
Quelques rappels sur les caracte'ristiques du parser sont ne'cessaires
pour bien comprendre la suite de ce document.

\PAR{}
Soient {\tt p.f} un fichier contenant le texte Fortran du module {\tt
P}. Deux fichiers sont cre'e's pour ce module par le parser:
\BIT
\item un fichier d'entite's de nom {\tt TOP-LEVEL:P.entities},
\item un fichier de code de nom {\tt TOP-LEVEL:P.code}.
\EIT

\PAR{}
Le fichier d'entite's contient exactement une entite' globale, de nom
{\tt TOP-LEVEL:P}, qui de'finit le module correspondant. Les autres
entite's sont locales.

\PAR{}
Une entite' est locale si elle correspond a` une variable ou une
constante de'finie dans un module, comme dans la de'claration suivante: 
\begin{verbatim}
        INTEGER T(10)
\end{verbatim}
Une telle entite' restera locale.

\PAR{}
Une entite' est locale si elle correspond a` une fonction externe non
de'finie dans le module analyse', comme dans:
\begin{verbatim}
        CALL Q(I,J,K)
\end{verbatim}
Dans le module {\tt P}, l'entite' de'finissant le module {\tt Q} a pour
nom {\tt P:Q}, son type est celui que le parser aura pu de'duire des
appels a` {\tt Q} contenus dans {\tt P}, son storage sera {\tt rom} et
son initial-value vaut {\tt unknown} car le code de {\tt Q} n'e'tait pas
disponible pour le parser au moment du traitement de {\tt P}. L'entite'
{\tt P:Q} est donc {\em incomple`tement de'finie}.

\PAR{}
Les fonctions externes ne sont pas les seules a` e^tre incomple`tement
de'finies apre`s qu'un module ait e'te' parse'. Il en est de me^me pour
toutes les fonctions intrinse`ques.

\SEC{Utilisation des autres phases de PIPS}

\PAR{}
Apre`s le passage du parser, l'application d'une des phases de PIPS sur
un module {\tt P} ne'cessite le chargement par cette phase du domaine
des entite's, puis du code du module {\tt P}; c'est ce que nous appelons
activer le module {\tt P}. Il est important de se souvenir que la
repre'sentation interne a e'te' conc,ue de telle sorte que les objets
contenus dans le code d'un module (objets des domaines {\tt statement,
instruction, block, test, loop, goto, call, etc.}) re'fe'rencent les
objets contenus dans les entite's du module (objets des domaines {\tt
value, type, storage, ram, symbolic{,} etc.}) mais que le contraire
ne soit pas vrai.

\PAR{}
C'est cette caracte'ristique de la repre'sentation interne, ajoute' a`
la se'paration des fichiers {\tt .code} et {\tt .entities}, qui permet
le me'canisme d'activation et de de'sactivation d'un module.

\PAR{}
Avant le passage du linker, le domaine des entite's d'un module
quelconque {\tt M} est contenu dans le fichier {\tt
TOP-LEVEL:M.entities}, et le code de {\tt M} est contenu dans {\tt
TOP-LEVEL:M.code}. Ce code ne peut e^tre charge' qu'apre`s chargement du
domaine des entite's correspondant.  Nous verrons que les choses sont
diffe'rentes apre`s le passage du linker sur le programme contenant ce
module {\tt M}.

\PAR{}
Les phases suivantes sont en cours de de'veloppement: un pretty-printer, un
analyseur de flot de donne'es, un paralle'liseur, etc.

\SEC{Pre'sentation du linker}

\PAR{}
Le linker doit donc faire l'union au sens ensemblistes des diffe'rents
fichiers d'entite's tels que {\tt TOP-LEVEL:M.entities}, puis de'truire
les entite's incomple`tement de'finies telles que {\tt P:Q} lorsque
l'entite' de'finie {\tt TOP-LEVEL:Q} est disponible, et enfin remplacer
dans le code de tous les modules (fichiers {\tt TOP-LEVEL:*.code})
toutes les re'fe'rences aux entite's incomple`tes par des re'fe'rences
aux entite's comple`tes.

\SSE{Arguments du linker}

\PAR{}
Les arguments du linker sont le nom du programme et les noms des modules
a` linker. Par exemple
\begin{verbatim}
        $ linker linear MATMUL INIT LINEAR
\end{verbatim}

\PAR{}
Le nom du programme sert uniquement a` calculer le nom du nouveau
fichier d'entite's, qui contiendra l'union de tous les fichiers
d'entite's des modules linke's.  Ce nom peut donc e^tre quelconque, mais
il est conseille' d'utiliser les minuscules pour les noms de programme
afin de ne pas risquer de collisions entre un nom de programme et un nom
de module.

\PAR{}
Le linker de PIPS est incre'mental, ce qui signifie qu'un programme de
plusieurs modules, par exemple {\tt MATMUL, INIT, LINEAR, MEAN} et {\tt
PRMAT}, peut e^tre linke' en plusieurs fois, comme dans:
\begin{verbatim}
        $ linker linear MATMUL INIT LINEAR
        $ ...
        $ linker linear MEAN PRMAT
\end{verbatim}

\PAR{}
Le linker ve'rifie que l'utilisateur ne demande pas de linker un module
de'ja` traite', ce qui est interdit avec la version actuelle du linker.

\SEC{Algorithme}

\SSE{Initialisation du domaine des entite's}

\PAR{}
On suppose dans la suite que le linker est appele' avec trois arguments:
{\tt pgm, P,} et {\tt Q}. 

\PAR{}
Si le programme cible {\tt pgm} n'existe pas, le linker initialise le
domaine des entite's avec les entite's globales pre'de'finies par
Fortran, c'est-a`-dire:
\BIT
\item les ope'rateurs: {\tt + , - , .LT. , .NEQV. , ...}
\item les instructions: {\tt READ , WRITE , RETURN , ...}
\item les intrinse`ques: {\tt MIN , MAX , ...}
\EIT
Ces entite's pre'-de'finies sont contenues dans le fichier {\tt
TOP-LEVEL:bootstrap.entities}, qui est donc lu par le linker. Ce fichier
est cre'e' par le programme {\tt bootstrap} a` partir d'une table
de'crivant ope'rateur, intrinse`ques et instructions Fortran (Voir le
programme bootstrap dans l'annexe 1). Le programme bootstrap doit e^tre
re'-exe'cute' chaque fois que cette table est modifie'e.

\PAR{}
Si le programme cible {\tt pgm} existe de'ja`, cela signifie que ce
programme a e'te' pre'alablement linke', de fac,on partielle. Le linker
initialise alors le domaine des entite's avec la valeur qu'il avait a`
la fin du pre'ce'dent link pour ce programme, ce qui est fait en lisant
la version courante du fichier {\tt TOP-LEVEL:pgm.entities}.

\SSE{Union avec les entite's des modules a` linker}

\PAR{}
Une fois le domaine des entite's initialise', il faut lire les domaines
des entite's contenus dans les fichiers ``{\tt .entities}'' des modules a`
linker, {\tt P} et {\tt Q} dans notre exemple. Nous obtenons ainsi un
domaine des entite's unique qui contient toutes les entite's de tous les
modules de'ja` linke's et de ceux en cours de link.

\SSE{Recherche des modules dont le code doit e^tre mis a` jour}

\PAR{}
Il faut ensuite rechercher parmi tous les modules connus ---les anciens
et les nouveaux--- ceux dont le code doit e^tre linke', c'est-a`-dire
ceux pour lesquels toute re'fe'rence a` une entite' telle que {\tt P:Q}
doit e^tre remplace'e par une re'fe'rence a` {\tt TOP-LEVEL:Q}.

\PAR{}
Tous les nouveaux modules doivent bien su^r e^tre mis a` jour. Il en est
de me^me pour tous les modules de'ja` linke's qui contiennent au moins
une re'fe'rence a` un des nouveaux modules, car le link pre'ce'dent d'un
tel module avait ne'cessairement e'te' partiel.

\SSE{Calcul des associations entite's locales - entite's globales}

\PAR{}
L'e'tape suivante consiste a` construire une table de hashcode associant
les entite's externes incomple`tement de'finies telles que {\tt P:Q} aux
entite's globales parfaitement de'finies telles que {\tt TOP-LEVEL:Q}
que le linker a charge'es dans le domaine des entite's lors de la
deuxie`me phase de l'algorithme.

\PAR{}
C'est pendant cette e'tape que sont de'tecte'es les re'fe'rences non
re'solues. En effet, toute re'fe'rence a` une entite' non de'finie telle
que {\tt Q:R} (cre'e'e par exemple par un appel a` la fonction {\tt R}
dans la subroutine Q) pour laquelle on ne trouve pas d'entite' de nom
{\tt TOP-LEVEL:R}, est une re'fe'rence non re'solue.

\SSE{Mise a` jour du code des modules}

\PAR{}
L'e'tape de mise a` jour des codes des modules est la plus longue. Pour
chaque module trouve' durant la troisie`me e'tape, il faut:
\BIT
\item activer le module, c'est-a`-dire charger son code en me'moire,
\item examiner ce code, instruction par instruction, expression par
expression, re'fe'rence par re'fe'rence, pour y remplacer toute
re'fe'rence aux entite's inde'finies par des re'fe'rences aux entite's
de'finies donne'es par la table de hash code calcule'e pre'ce'demment,
\item de'sactiver le module, c'est-a`-dire ranger son code sur disque,
dans le fichier ``.code{''} associe' au module.
\EIT

\SSE{Sauvegarde du nouveau domaine des entite's}

\PAR{}
L'e'tape finale du linker consiste a` de'truire les entite's qui ne sont
plus re'fe'rence'es une fois le code des modules mis a` jour, comme par
exemple l'entite' {\tt P:Q}, puis, a` stocker sur disque le domaine des
entite's dans le fichier {\tt pgm.entities}.

\SEC{Conclusion}

\PAR{}
Apre`s exe'cution du linker sur une collection de modules, les fichiers
``.entities'' de ces modules peuvent e^tre de'truits puisqu'ils sont
remplace's par le fichier unique du programme, {\tt pgm.entities} par
exemple. 

\PAR{}
Si tous les modules d'un programme ont e'te' linke's ensemble, toutes
les entite's re'fe'rence'es dans ce programme sont comple`tement
de'finies dans ce fichier, sauf les entite's correspondant aux modules
du programme pour lesquelles le champs {\tt code} n'est de'fini que si
le module correspondant est active', c'est-a`-dire charge' en me'moire.

\newpage
\SEC{ANNEXE 1 --- PROGRAMME BOOTSTRAP}
\PAR{}
Cette annexe contient le listing des programmes sources du programme bootstrap.

\newpage
\SEC{ANNEXE 2 --- PROGRAMME LINKER}
\PAR{}
Cette annexe contient le listing des programmes sources du programme linker.

\end{document}
\end
