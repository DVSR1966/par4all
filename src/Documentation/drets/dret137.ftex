\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

% pour importer des structures de donne'es Newgen
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}

\newcommand{\titre}{PROJET PIPS \\
		ANALYSEUR SEMANTIQUE \\
		RAPPORT DE SYNTHESE }
\newcommand{\auteur}{
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT \\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}
\newcommand{\docdate}{De'cembre 1990}
\newcommand{\numero}{E137}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\vspace{2cm}

\tableofcontents

\newpage

\section*{Introduction}

L'analyseur se'mantique contient des phases tre`s diverses permettant
aussi le bien le calcul des {\em use-def chains} qui sont un
pre'liminaire a` l'optimisation globale classique et au calcul du graphe
de de'pendance que le calcul de pre'dicats et la propagation
interproce'durale de constante qui sont des pre'-requis du test de
de'pendance et des transformations de programmes.

Toutes ces phases supposent connu le graphe de contro^le des modules a`
analyser et fournissent des re'sultats d'autant meilleurs que ce graphe
est plus structure'. Elles sont donc pre'ce'de'es d'une phase d'analyse
du contro^le qui isole autant que possible les zones structure'es qui
peuvent e^tre conserve'es en l'e'tat, des zones non structure'es qui
ne'cessitent la construction effective d'un graphe de contro^le.
Cette analyse est pre'sente'e en premier.

La construction interproce'durale des {\em use-def chains} repose sur
phases d'analyse qui seront de'taille'es dans le me^me ordre:
\begin{itemize}
  \item calcul des effets {\em read} et {\em write} 
	des instructions sur la me'moire,
	en pre'servant l'information {\em may/must};
  \item calcul des effets cumule's a` toute une proce'dure et
	restriction a` leur sous-ensemble visible interproce'duralement;
  \item calcul les trois ou quatre diffe'rents type de
	{\em use-def chains} ({\em use-def}, {\em def-use}, {\em def-def} et,
	facultativement, {\em use-use}) qui sont classiquement utilise's en
	compilation.
\end{itemize}

Le calcul intraproce'dural des pre'dicats et la propagation
interproce'durale des constantes n'ont pas e'te' imple'mente's comme
deux phases d'analyse inde'pendantes mais regroupe'es en une unique
phase plus ge'ne'rale, qui est appele'e {\em analyse se'mantique}.
Elle calcule des relations line'aires entre variables scalaires, intra-
et inter-proce'duralement.

Ce rapport ne contient pas directement les descriptions des structures
de donne'es utilise'es parce qu'elles sont toutes incluses directement avec la
repre'sentation interne des programmes (structure de donne'es {\em ri})
qui est fournie en annexe.

\newpage

\section{Calcul du graphe de contro^le}

La majorite' des programmes utilisateurs sont (ou devraient) e^tre
structure's. Prenant ce fait en conside'ration, nous avons conc,u le
graphe de contro^le comme une extension de l'arbre de syntaxe abstrait.
Les structures de donne'es structure'es (i.e., boucle, conditionnelle,
se'quence et instruction e'le'mentaire) sont pre'serve'es telles quelles
dans le graphe de contro^le tandis que seuls les branchements
``cassent'' cette structure hie'rarchique pour cre'er un graphe
oriente'. Ceci permettra de traiter de manie`re simple les parties
paralle'lisables d'un programme, puisque les ruptures de contro^le
empe^chent ge'ne'ralement toute paralle'lisation (mais voir ci-dessous).
Un tel graphe de contro^le est appele' {\em Structured Control Graph}.
Cette inte'gration du graphe de contro^le avec les instructions du
programme se refle`te dans sa description re'cursive dans le fichier de
description NewGen:

\begin{verbatim}
control = statement x predecessors:control* x successors:control* ;
instruction = block:statement* + test + loop + ploop + goto:statement + 
              call + unstructured:control ;
statement = label:entity x number:int x ordering:int x comments:string x
            instruction ;
\end{verbatim}

Dans un noeud du graphe de contro^le, le champ {\tt statement} sera toujours
structure'; cet invariant est introduit par l'algorithme de cre'ation du
graphe de contro^le. Dans la majorite' des cas, les champs {\tt
predecessors} et {\tt successors} auront des listes re'duites a` un
e'le'ment. Seule une instruction de branchement conditionnelle (dont le
{\tt statement} est un {\tt test}) cre'era une liste {\tt successors}
ayant plus d'un e'le'ment, le premier correspondant au branchement dans
le cas ou` la condition est ve'rifie'e. Des noeuds de jointure pourront
avoir plus d'un pre'de'cesseur.

La liste des types d'instructions possibles d'un programme a e'te'
augmente'e d'un champ {\tt unstructured} qui apparai^tra apre`s
construction du graphe de contro^le; il n'est jamais introduit par les
phases pre'ce'dentes de PIPS.

Ce graphe de contro^le imple'mente la notion importante de {\em
masquage de contro^le}. Par exemple, si une boucle utilise un corps qui
comporte des branchements locaux (ceci est ve'rifie' au cours de la
construction du graphe), alors, vue de l'exte'rieur, cette boucle sera
conside're'e comme structure'e. Dans le cas d'une imple'mentation
paralle`le, la rupture de se'quence dans une ite'ration est en effet
inde'pendante des autres ite'rations et n'empe^che en rien l'exe'cution
paralle`le du programme. 

\subsection{Un exemple simple}
Dans le programme:
\begin{verbatim}
       do 10 i=1,n
       t(i) = i
       if ( i .le. m ) goto 20
           t(i) = i
20     continue
10     continue
\end{verbatim}
le corps de la boucle sera conside're' comme un graphe compose', entre
autres, d'un noeud d'affectation et d'un noeud de contro^le qui
correspond au saut conditionnel. Ceci est visible dans le pretty-print
du graphe de contro^le donne' ci-dessous:
\begin{verbatim}
Graph 60a48
           --> Node 60a48
           statement 61508
           Preds: 
           Succs: 
           Code of 60a48:
           DO @10 I = 1,N,1
               Graph 60c40
                   --> Node 60c40
                   statement 5d718
                   Preds: 
                   Succs: 60ca8 
                   Code of 60c40:
                   =(T(I),I)
                   End of code of 60c40
                   --> Node 60ca8
                   statement 5ff98
                   Preds: 60c40 
                   Succs: 60d38 60d50 
                   Code of 60ca8:
                   IF (.LE.(I,M)) THEN
                       GOTO @20
                   ELSE
                       CONTINUE()
                   ENDIF
                   End of code of 60ca8
                   --> Node 60d38
                   statement 60e70
                   Preds: 60ca8 
                   Succs: 608e0 
                   Code of 60d38:
                   End of code of 60d38
                   --> Node 608e0
                   statement 61300
                   Preds: 61180 60d38 
                   Succs: 
                   Code of 608e0:
20                 CONTINUE()
10                 CONTINUE()
                   End of code of 608e0
                   --> Node 61180
                   statement 61160
                   Preds: 60da0 
                   Succs: 608e0 
                   Code of 61180:
                   =(T(I),I)
                   End of code of 61180
                   --> Node 60da0
                   statement 60d80
                   Preds: 60d50 60e40 
                   Succs: 61180 
                   Code of 60da0:
                   End of code of 60da0
                   --> Node 60d50
                   statement 61098
                   Preds: 60ca8 
                   Succs: 60da0 
                   Code of 60d50:
                   CONTINUE()
                   End of code of 60d50
                   --> Node 60e40
                   statement 60e20
                   Preds: 
                   Succs: 60da0 
                   Code of 60e40:
                   End of code of 60e40
               End of graph 60c40
           ENDDO
00000      CONTINUE()
           End of code of 60a48
End of graph 60a48
\end{verbatim}

\subsection{Construction du graphe}
La routine principale de construction du graphe de contro^le prend en
entre'e un {\tt statement} et retourne le graphe de contro^le
correspondant. Comme pre'cise' pre'ce'demment, si le statement en
question est comple`tement structure', le graphe de contro^le sera
limite' a` un noeud; cela sera le cas, par exemple, de la routine de
multiplication de matrices.

L'algorithme utilise' est de'fini par induction sur la structure d'arbre
abstrait du programme. La routine re'cursive principale est {\tt
controlize} qui, pour un statement {\tt st} ayant {\tt pred} pour noeud
pre'decesseur et {\tt succ} pour noeud successeur, retourne dans {\tt
c\_res} le noeud de contro^le correspondant et met a` jour l'argument
{\tt used\_labels} qui contient la liste des occurrences des e'tiquettes
utilise'es dans une instruction (ceci est utilise' dans
l'imple'mentation du masquage de contro^le).

Le but essentiel de {\tt controlize} est d'e'liminer les {\tt goto} et
de les remplacer par des arcs dans le graphe de contro^le. Ceci est fait
via deux structures de donne'es (imple'mente'es par des tables de
hachage); {\tt label\_statements} associe a` tout nom d'e'tiquette la
liste des instructions qui la re'fe'rencent, tandis que {\tt
label\_control} associe a` tout nom d'e'tiquette le noeud de contro^le
correspondant (qui est utilise' dans le cas de branchement en avant).
Ces deux structures de donne'es sont construites lors d'un premier
parcours de {\tt st} par la routine {\tt create\_statements\_of\_labels}.

Le masquage de contro^le ne'cessite de compactifier les graphes de
contro^le des composantes d'une instruction en vue de les remplacer par
un seul noeud. La routine de test principale est {\tt covers\_labels\_p}
qui ve'rifie si les occurrences des e'tiquettes utilise'es dans
l'instruction repre'sentent toutes les apparences possibles de ces
e'tiquettes, auquel cas les branchements correspondants sont locaux et
pourront e^tre ne'glige's dans les instructions englobantes. Une e'tape
de compaction importante est {\tt compact\_list} correspondant aux
se'quences; elle permet de regrouper dans des sous-se'quences (i.e.,
{\em basic blocs}) les instructions qui ne comportent pas de
branchement.

Une conse'quence de la construction du graphe de contro^le est la
possibilite' de de'tecter les instructions du pogramme qui correspondent
a` du ``code mort''. Si cette information est inutile a` la
paralle'lisation proprement dite, elle peut indiquer une erreur de
conception du programme d'applications et est donc indique'e a`
l'utilisateur.

\section{Calcul des effets des instructions}

Les de'pendances utilisent la notion de conflit entre instructions.
Celui-ci est de'termine' par les effets des instructions sur l'e'tat
me'moire: quelles variables ou e'le'ments de tableaux sont-ils lus et/ou
modifie's par chaque instruction du module?

En vue de traiter le proble`me dans son cas le plus ge'ne'ral (et, {donc},
interproce'dural), les effets des instructions sont cumule's selon la
structure syntaxique du programme a` paralle'liser. Comme la
de'termination exacte des effets d'une instruction est un proble`me non
de'cidable (penser aux tests, par exemple), nous avons e'tendu la
de'finition d'un effet pour prendre en compte le type d'{\em
approximation} connu (cf. la de'finition de la repre'sentation
interme'diaire de PIPS en annexe). Ainsi, un effet est caracte'rise'
par:
\begin{itemize}
\item la variable ou l'e'le'ment de tableau re'fe'rence': une {\tt
reference};

\item l'attribut permettant de savoir si cet effet est une lecture ou
une e'criture: une {\tt action}; 

\item l'attribut permettant de savoir si cet effet est certain ou
seulement possible: une {\tt approximation};
\end{itemize}

Ceci s'e'crit en NewGen:
\begin{verbatim}
effect =  reference x action x approximation x context:transformer ;
effects =  effects:effect* ;
action = read:unit + write:unit ;
approximation = may:unit + must:unit ;
\end{verbatim}
Le champ \verb+context+ n'est pas utilise' dans le cadre du contrat PIPS.

L'effet de l'exemple suivant sur {\tt T} est {\tt <T(I), WRITE, MUST>}
car la premie`re instruction est effectue'e a` coup su^r alors que
l'effet sur {\tt M} est {\tt <M(I,J), READ, MAY>} a` cause du test.
\begin{verbatim}
        T(I) = 0.0
        IF (I .EQ. J) PRINT *, M(I,J)
\end{verbatim}

L'information {\tt approximation} est de plus ne'cessaire pour calculer
les chai^nes {\em use-def} de manie`re pre'cise car elle permet de
savoir si une affectation a` une variable ``{tue}'' ou non toutes les
de'finitions pre'ce'dentes de cette variable.

\section{Calcul des {\em Summary Data Flow Information} ({\em SDFI})}

Le calcul des {\em Summary Data Flow Information} ne pose pas de
proble`mes particuliers. Comme indique' pre'ce'demment, il faut
consolider les effets partiels en mettant a` jour les informations {\em
may/must} et les filtrer au niveau module pour ne conserver que les
effets visibles interproce'duralement. 

Cependant, l'algorithme traditionnel a e'te' modifie' pour imple'menter
un algorithme de paralle'lisation interproce'durale. 

Jusqu'a` pre'sent, les effets des instructions call n'e'taient calcule's
que dans le cas ou` la fonction appele'e e'tait un ope'rateur ou un
intrinsic. La phase de calcul des effets se terminait donc anormalement
dans le cas d'une instruction du genre \verb/CALL P/ ou` \verb/P/ e'tait
un module de'fini dans le programme en cours de traitement.

Cette phase a donc e'te' modifie'e pour
\begin{itemize}
  \item calculer le re'sume' des effets d'un module sur les variables du
        programme, 
  \item de'duire du re'sume' associe' a` un module les effets d'une
        instruction d'appel a` ce module.
\end{itemize}

\subsubsection{Calcul du re'sume' des effets d'un module}

Le calcul des re'sume's n'a pas pose' de proble`mes puisque les effets
des instructions e'le'mentaires (affectation, entre'es-sorties, ...)
d'un module sont {\em remonte's} sur les instructions non e'le'mentaires
(tests, blocs, boucles, ...); il en re'sulte que tous les effets d'un
module sont associe's au statement bloc de ce module. Le calcul du
re'sume' a simplement consiste' a` dupliquer les effets associe's a` ce
bloc en y e'liminant les effets sur les variables locales du module. 

Dans cette premie`re version du re'sume' des effets, les tableaux sont
conside're's comme des entite's, ce qui signifie que la consultation
(resp. la modification) d'un seul e'le'ment du tableau implique que la
totalite' du tableau est conside're'e comme consulte'e (resp.
modifie'e). Il en re'sulte que le re'sume' ne comporte que des effets
dont la re'fe'rence n'a pas d'expressions d'indices. Ce choix a pour
conse'quence de diminuer conside'rablement la taille du re'sume' et
d'accroi^tre la rapidite' de Pips.

Il est important de noter que le calcul du re'sume' n'est fait qu'une
seule fois pour chaque module, quel que soit le nombre des appels aux
diffe'rents modules.

\subsubsection{Calcul des effets d'un call a` un module}

Les effets d'une instruction call a` un module P sont de'duits des
effets re'sume's de P de la manie`re suivante.

Les effets sur les variables communes et statiques se trouvant dans le
re'sume' de P sont duplique's et associe's a` l'instruction call. Les
effets sur les parame`tres formels de P sont traduits en des effets sur
les arguments re'els de l'appel; ces effets traduits sont ajoute's a` la
liste des effets de l'instruction call.

La traduction est imme'diate dans le cas ou` le parame`tre re'el est une
expression: il n'y a pas d'effet traduit.

La traduction est simple dans le cas ou` le parame`tre re'el et le
parame`tre formel ont le me^me rang (nombre de dimensions). Dans ce cas,
l'effet traduit est identique a` l'effet re'sume' mis a` part que la
variable formelle est remplace'e par la variable re'elle dans la
re'fe'rence de l'effet traduit.

Deux cas peuvent se pre'senter lorsque le parame`tre re'el et le
parame`tre formel n'ont pas le me^me rang:
\begin{itemize}
\item 
 le parame`tre formel est un scalaire et le parame`tre re'el est un
 e'le'ment de tableau; dans ce cas, la re'fe'rence de l'effet traduit
 est la re'fe'rence a` l'e'le'ment de tableau, et les autres champs de
 l'effet traduit sont identiques a` ceux de l'effet re'sume'.

\item les parame`tres re'els et formels sont des tableaux de tailles
        diffe'rentes. 
\end{itemize}

Dans ce dernier cas, notre algorithme tente de de'tecter les situations
ou` l'effet sur la variable formelle peut e^tre traduit en un effet plus
pre'cis que la totalite' du tableau re'el. C'est notamment le cas
lorsque le parame`tre formel est un vecteur (tableau a` une dimension)
associe' a` une colonne d'une matrice (tableau a` deux dimensions).
Lorsqu'une telle situation est de'tecte'e, nous utilisons les
intervalles (i.e.  {\em ranges}) dans les expressions d'indice pour
indiquer qu'une colonne d'une matrice a e'te' change'e; ainsi, la
lecture de la J+1 e`me colonne d'une matrice 100x100 sera repre'sente'e
par l'effet:
\begin{verbatim}
{ MAT(1:100,J+1) , {is_action_read, UU} , {is_approximation_must , UU} } 
\end{verbatim}

Pour avoir le droit de ge'ne'rer ce genre d'effet, il faut s'assurer que
la taille du tableau formel est infe'rieure ou e'gale a` la taille de la
re'gion correspondante du tableau re'el; il faut par exemple ve'rifier
que la taille d'un vecteur est bien infe'rieure a` la taille d'une
colonne d'une matrice. Pour effectuer cette ve'rification, nous formons
un syste`me d'e'quations et d'ine'quations line'aires qui n'est faisable
que s'il y a effectivement de'passement de la zone re'elle par le
tableau formel, puis nous prouvons que ce syste`me est infaisable.

La souplesse de notre repre'sentation interne et l'extre^me qualite' de
notre code font que nous n'avons pas eu a` modifier la moindre ligne de
code dans le calcul des de'pendances pour prendre en compte ce nouveau
genre d'effets et paralle'liser ainsi des boucles contenant des appels de
proce'dure. 

L'exemple suivant est un re'sultat de Pips qui montre la puissance de
notre calcul d'effet interproce'dural. La boucle sur J du module MM03
contient un appel a` SAXPY qui ne modifie que la J ie`me colonne de C.
Notre calcul d'effet s'en rend compte gra^ce a` une analyse des effets
de SAXPY et une traduction de ces effets pour le call concerne'; ce
re'sultat permet a` notre algorithme de paralle'lisation de transformer
la boucle se'quentielle sur J en une boucle paralle`le.
\begin{verbatim}
      SUBROUTINE MM03(N, A, B, C)
      ...
      DOALL J = 1,N,1
         PRIVATE K
         DO K = 1,N,1
            CALL SAXPY(N, C(1,J), A(1,K), B(K,J))                            11
         ENDDO
      ENDDO
      ...
      END

      SUBROUTINE SAXPY(N, X, Y, S)
C     
      INTEGER N
      REAL*8 X(N), Y(N), S
C     
      M = MOD(N,4)
      DO I = 1, M
         X(I) = X(I) + S*Y(I)
      ENDDO
C     
      DO I = M+1, N, 4
         X(I) = X(I) + S*Y(I)
         X(I+1) = X(I+1) + S*Y(I+1)
         X(I+2) = X(I+2) + S*Y(I+2)
         X(I+3) = X(I+3) + S*Y(I+3)
      ENDDO
C
      RETURN
      END
\end{verbatim}

\section{Calcul des {\em Use-Def Chains}}

Les chai^nes {\em use-def}, telles que de'finies dans les ouvrages
classiques de compilation, permettent de relier toute utilisation d'une
variable a` la liste des de'finitions qui sont susceptibles de lui
correspondre. Nous avons e'tendu de manie`re naturelle cet algorithme
classique a` notre GCS; ceci implique une nouvelle strate'gie de calcul
de point-fixe pour de'terminer la solution des e'quations {\em
data-flow} dans le cas de programmes non-structure's. Des travaux sont
en cours pour de'montrer la correction de notre me'thode dans le cas
ge'ne'ral (les cas pratiques e'tant pour leur part presque toujours
trivialement corrects e'tant donne' la simplicite' des graphes de
contro^le rencontre's).

Si les chai^nes {\em use-def} sont bien adapte'es aux me'thodes
d'optimisation rencontre'es dans les compilateurs, elles ne sont pas
suffisantes pour traiter tous les cas de de'pendance qu'il est
ne'cessaire de prendre en compte pour pre'server la se'mantique
se'quentielle d'un programme au cours de sa paralle'lisation (le
graphe de de'pendance est calcule' a` partir des chaines {\em use-def},
cf. ci-dessous). Ainsi, outre les de'finitions de variables, il nous
faut propager e'galement leur utilisation en vue de pouvoir
ulte'rieurement calculer les de'pendances de type {\em anti}. Cette
adaptation a e'galement e'te' imple'mente'e.

Le re'sultat du calcul des chai^nes {\em use-def} est une premie`re
version, extre^mement fruste, du graphe de de'pendances, base'e
uniquement sur les conflits entre variables, inde'pendamment des indices
de tableaux e'ventuels; a` noter que les notions d'e'quivalence sont
traite'es dans cette phase. Ce premier graphe de de'pendance est
ulte'rieurement affine' en prenant en compte la notion de niveau 
ne'cessaire pour l'algorithme d'Allen et Kennedy et en utilisant les
tests de de'pendance de type Banerjee et Fourier-Motzkin.

Les deux structures de donne'es utilise'es pour repre'senter les {\em
use-def chains} sous forme de graphe sont {\em graph}, qui est une
structure de donne'es ge'ne'rique, et sa spe'cialisation {\em dg} ({\em
Dependence Graph}).

\subsection{Structure de donne'es {\em Graph}}

\input{graph.datastructure}

\subsection{Structure de donne'es {\em DG}}

\input{dg.datastructure}

\section{Calcul de relations line'aires entre variables scalaires}

Un des objectifs du projet PIPS est d'e'tudier l'inte're^t d'une
analyse se'mantique approfondie pour la paralle'lisation
interproce'durale. La me'thode choisie, de'veloppe'e par P. Cousot
et N. Halbwachs, fournit des e'galite's et ine'galite's line'aires
entre variables scalaires entie`res. Ces e'galite's et ine'galite's
ge'ne'ralisent les techniques habituelles en optimisation globale:
propagation de constante, de'tection de variables inductives,
de'tection d'e'galite's line'aires entre variables, indices
appartenant a` l'intervalle de'fini par les bornes de boucles. Ces
e'galite's et ine'galite's line'aires ont de plus l'avantage de
pouvoir e^tre aise'ment utilise'es dans le calcul du graphe de
de'pendance. Rappelons que cette analyse de'taille'e n'e'tait
pre'vue qu'au niveau intra-proce'dural et qu'une nouvelle technique a
permis de l'e'largir au niveau interproce'dural.

En effet, une premie`re imple'mentation de la me'thode intraproce'durale
de Cousot \& Halbwachs en a fait ressortir un certain nombre de de'fauts
qui ont du^ e^tre corrige's dans la mesure du possible ou contourne's.
Ces proble`mes ont e'te' pre'sente's en de'tail dans le rapport
EMP-CAI-I~E/109. Les deux plus importants e'taient que:
\begin{itemize}
  \item la complexite' est
exponentielle par rapport au niveau d'imbrication des boucles alors que
certains programmes de tests fournis par l'ONERA comptent jusqu'a` 7 niveaux
d'imbrications;
  \item les pre'dicats portant sur les e'tats
en un unique point du programme sont mal adapte's au calcul des de'pendances.
\end{itemize}

La deuxie`me imple'mentation repose sur trois bibliothe`ques. La
plus grosse des trois (environ 20000 lignes de C), la bibliothe'que
d'alge`bre line'aire de base, n'a pas e'te' de'veloppe'e dans le cadre
de ce contrat. Elle est disponible sous forme objet sur la cassette de
livraison mais les sources ne sont pas disponibles dans ce rapport. Les
deux autres bibliothe`ques, {\em Semantics} et {\em Transformer}, sont 
par contre partie inte'grante du projet PIPS et leurs fichiers sources sont
imprime's ci-dessous. La premie`re contient les modules efectuant
l'interpre'tation abstraite d'un programme dans le formalisme de
Cousot/Halbwachs. La seconde est une bibliothe`que d'accompagnement de
la structure de donne'es {\em transformer} (voir la documentation sur la
{\em ri}).

Nous pre'sentons successivement les modifications apporte'es a` l'algorithme
de Halbwachs, les structures de donne'es {\em transformer} et {\em
precondition} puis les structures de donne'es propres a` l'alge`bre line'aire.
Nous terminons en donnant la liste des principales fonctions lie'es
aux {\em transformers} ainsi que la liste des options d'analyse.

\subsection{Modification de l'algorithme de Halbwachs}

\paragraph{Notion de variable}

L'algorithme pre'sente' dans la the`se de N. Halbwachs ne prend pas en
compte ni l'aliasing implicite entre parame`tres formels ou entre
parame`tres formels et variables globales, ni l'aliasing explicite (i.e.
intra-proce'dural) cre'e' par la de'claration {\tt EQUIVALENCE}. Nous
proposons de suivre la norme Fortran~77 qui e'limine l'aliasing
implicite pour conside'rer que le premier proble`me ne se pose pas
(ANSI~X3.9-1978 section~15.9.3.6 et 15.9.4). Pour
traiter l'aliasing explicite nous prendrons ale'atoirement une des
variables scalaires en alias, si plusieurs scalaires sont concerne's. En
cas d'alias entre tableaux et scalaires, les instructions d'affectation
au tableau seront conside're'es comme des {\em kill}'s de la variable.
Cette re`gle pourrait e^tre ame'liore'e ulte'rieurement par un test de
de'pendance si le besoin s'en fait sentir. Ces proble`mes sont traite's
dans le module \verb+value.c+ de la bibliothe`que {\em transformer}.

\paragraph{Re'duction de la complexite'}

Le comportement exponentiel de l'algorithme de re'solution de'crit
dans la the`se de Halbwachs et imple'mente' dans le prototype d'analyseur
se'mantique est inacceptable pour des programmes scientifiques.

Nous avons donc de'coupe' la re'solution globale du syste`me aux
polye`dres en des re'solutions partielles, dont la combinaison risque
bien su^r de donner des re'sultats moins pre'cis mais dont le temps
d'exe'cution devrait e^tre a` peu pre`s line'aire par rapport a`
la taille du programme.

L'ide'e consiste a` calculer pour chaque composante du graphe de
contro^le structure' (cf. section~3) une relation, appele'e {\em
relation de transfert} dans la suite et imple'mente'e par la structure
de donne'es {\em transformer}, entre le pre'dicat d'entre'e
(pre'condition) et le pre'dicat de sortie (post-condition). Les
relations de transfert sont propage'es de base en haut en fonction des
ope'rateurs de structuration du graphe de contro^le: se'quence (composition),
test (enveloppe convexe), boucle (e'largissement) et control (pour les
parties non structure'es du programme analyse'). Cette phase de
propagation montante est imple'mente'e dans le module
\verb+ri_to_transformers.c+ qui se trouve dans la bibliothe`que {\em
semantics}.

Chaque boucle a une profondeur d'imbrication de 1, car les boucles
internes auront e'te' pre'ce'demment transforme'es en relation de
transfert.  Le placement des ope'rations d'e'largissement ne'cessaires
a` la convergence est trivial, ainsi que celui des ope'rations de
fermeture convexe. 

Seules les parties non structure'es du graphe de contro^le ne'cessitent
l'application de l'algorithme initial, mais elles sont maintenant
re'duites a` quelques noeuds par la phase de structuration et le graphe
de contro^le hie'rarchique et elles ne correspondent plus qu'a` des
zones de programmes qui ne peuvent pas e^tre paralle'lise'es. Leur
traitement n'apporte donc aucune information utile au processus de
paralle'lisation et il n'est donc pas effectue' ainsi.  Nous effectuons
a` la place une projection des variables {\em tue'es} par les statements
correspondants.  L'analyse des parties structure'es e'ventuellement
pre'sentes sous cette zone control est naturellement reprise
normalement.

Les instructions e'le'mentaires (call assign, call read, call min,...)
fournissent les relations de transfert de base.

Une fois la relation de transfert calcule'e de bas en haut, il ne reste
plus qu'a` propager les invariants de haut en bas du graphe de contro^le
du module analyse'.  Cette deuxie`me phase est imple'mente'e par le
module \verb+ri_to_preconditions+.

Cette approche s'applique aussi d'une manie`re interproce'durale en
ajoutant une traduction de la relation de transfert globale d'une
proce'dure a` chacun de ses sites d'appel. Ceci alourdit l'analyse et
n'est effectue' que sur reque^te explicite de l'utilisateur. Par de'faut,
les appels de proce'dures sont pris en compte en utilisant les {\em
SDFI} pour e'liminer par projection les variables modifie'es par l'appel.

Cette approche permettrait e'ventuellement d'ajouter un peu
d'information lors de la constitution du syste`me de de'pendance entre
deux re'fe'rences, en profitant de la pre'sence de la relation de
transfert entre les deux statements contenant ces re'fe'rences, mais
cette possibilite' ne s'est pas ave're'e inte'ressante sur les
programmes tests de l'ONERA.

L'inconve'nient essentiel de cet algorithme est qu'il de'pend de la nature
des relations de transfert choisies. Pour obtenir les me^mes re'sultats
qu'avec l'algorithme d'Halbwachs, il faudrait au moins avoir des relations
de transfert {\em conditionnelles} ou` les conditions d'application
partielles et les relations de transfert partielles seraient de'finies
par des polye`dres\footnote{Ceci est plus ge'ne'ral que les formules
conditionelles utilise'es en e'valuation symbolique dans le projet
VELOURS et que la ge'ne'ralisation de la propagation de constantes
propose'e par Jean Goubault.}. Pour acce'le'rer l'exe'cution,
nous avons re'duit cette union de relations de transfert
partielles en une unique relation de transfert inconditionnelle par
fermeture convexe. Cette simplification n'a pose' de proble`mes sur
aucun des programmes teste's.

\subsection{Notions de {\em transformer} et de {\em precondition}}

Ces deux notions, {\em transformer} et {\em precondition}, sont toutes
les deux imple'mente'es par une unique structure de donne'es,
malheureusement appele'e elle-aussi {\em transformer}. Cette confusion
vient du ro^le particulier que jouent les pre'conditions dans le test de
de'pendance.

Les tests de de'pendance ne s'effectue pas sur une unique instruction
mais sur un {\em couple} d'instructions. Dans ces conditions, il est
beaucoup plus important de connai^tre les relations existant entre les
pre'conditions de chacune des instructions. Par exemple, la valeur de la
variable \verb+L+ n'est peut-e^tre connue dans aucune des deux
pre'conditions alors qu'on peut voir qu'elle est {\em identique}.

Une application directe de cette remarque conduirait au calcul d'un nombre
de relations proportionnel au carre' du nombre d'instructions. Pour
e'viter cette explosion tout en traitant le cas cite' ci-dessus, les
pre'conditions qui ont e'te' choisies caracte'risent la relation
existant entre les valeurs des variables a` l'entre'e du module et leurs
valeurs juste avant l'exe'cution d'une instruction.

Formellement, il s'agit donc bien de {\em transformers} bien qu'elles
n'encodent pas le me^me type d'information que ce qui e'tait appele'
{\em transformer} dans la section pre'ce'dente.

Voici la de'claration NewGen de la structure de donne'es {\em transformer},
telle qu'elle figure dans la {\em RI}:
\domain{Transformer = arguments:entity* x relation:predicate}
{
Le domaine {\tt transformer} de'finit une relation entre deux e'tats
me'moire. Cette relation
porte sur les valeurs des variables scalaires entie`res d'un module ou
des variables globales au programme.
}

Les variables qui apparaissent dans la liste des arguments sont celles
qui ont e'te' modifie'es entre les deux e'tats. Deux valeurs
sont donc associe'es a` chacune d'entre elles: la pre- et la
post-valeur.  Les post-valeurs sont porte'es par les entite's
elles-me^mes. Les pre'-valeurs sont porte'es par des entite's
spe'ciales. Les variables scalaires entie`res qui ne sont pas modifie'es
et qui n'apparaissent donc pas dans la liste des arguments n'ont qu'une
seule valeur, porte'e par l'entite' correspondant a` la variable.

La relation est de'finie par des e'galite's et des ine'galite's
line'aires entre valeurs.

Pour re'sumer, deux types de transformers sont utilise's. Le premier,
aussi appele' transformer, est propre a` un {\tt statement} et donne une
abstraction de son effet sur les variables entie`res. Les variables qui
apparaissent dans la liste des arguments sont celles qui sont affecte'es
lors de son exe'cution.  Le second, aussi associe' a` un {\tt statement}
mais appele' {\em precondition}, donne une relation entre l'e'tat
initial d'un module et l'e'tat pre'ce'dent l'exe'cution de ce {\tt
statement}. Les variables qui apparaissent dans la liste des arguments
sont celles qui sont affecte'es entre le point d'entre'e du module et
son exe'cution.

Les transformers a` proprement parler ne sont disponibles qu'apre`s une
phase d'analyse se'mantique (\verb+ri_to_transformers+). Les
pre'conditions ne le sont qu'apre`s la deuxie`me phase
(\verb+ri_to_preconditions+). Les transformer et precondition attache's
a` un statement peuvent e^tre obtenus par le biais d'une table de hash code.

Le deuxie`me champ de la structure {\em transformer} est aussi de'clare'
en NewGen:
\domain{Predicate = system:Psysteme}
{
Le domaine {\tt predicate} de'finit une relation entre valeurs de
variables scalaires entie`res.
}

Ce n'est qu'un renommage d'une structure de donne'es {\em Psysteme} qui
est importe'e de la bibliothe`que d'alge`bre line'aire du CAII. Bien
qu'elle ne soit pas couverte par le contrat PIPS, ses structures de
donne'es sont de'crites ci-dessous pour mate'rialiser la notion de {\em
Predicate}.

\subsection{Structures de donne'es lie'es a` l'alge`bre line'aire}

Le but de cette section est de pre'senter les structures de donne'es
utilise'es pour imple'menter la me'thode d'analyse se'mantique de Cousot
et Halbwachs ainsi que la ge'ne'ralisation qui en a e'te' effectue'e
pour acce'le'rer le calcul des pre'dicats et prendre en compte les
appels de proce'dures.

Les ensembles de valeurs entie`res que peuvent prendre les variables
scalaires entie`res des modules en chaque point de contro^le sont
approxime's par des polye`dres a` bornes {\em rationnelles} et non
entie`res pour diminuer la complexite' des calculs.

Ces polye`dres peuvent e^tre de'finis de deux manie`res
e'quivalentes:
\begin{itemize}
  \item implicitement, par un syste`me d'e'galite's et d'ine'galite's
	line'aires
        ve'rifie' par les points appartenant au polye`dre,
  \item ou explicitement, par un syste`me ge'ne'rateur forme' de sommets,
        rayons et droites dont les combinaisons line'aires sont les
        points du polye`dre.
\end{itemize}
Ces deux repre'sentations, qui font l'objet des deux premie`res
sous-sections, sont utilise'es simultane'ment parce que certaines
ope'rations s'effectuent mieux avec l'une qu'avec l'autre (intersection
par syste`me d'e'quations, union par syste`me ge'ne'rateur) et parce
qu'on les utilise toutes les deux pour e'liminer la redondance qui
apparai^t au fur et a` mesure des calculs. Les polye`dres que nous
manipulerons comporteront donc deux parties, l'une donnant la
repre'sentation par syste`me d'e'quations et l'autre la repre'sentation
par syste`me ge'ne'rateur.

\subsection{Repre'sentation des syste`mes d'e'galite's et d'ine'galite's 
line'aires}

Le syste`me de contraintes est repre'sente' par la matrice de ses
coefficients et par un vecteur de termes constants. Cette matrice,
ge'ne'ralement tre`s creuse, est repre'sente'e par des vecteurs
creux et par lignes.  En effet, il faut choisir entre une
repre'sentation par ligne et par colonne, et on effectue plus souvent
des combinaisons line'aires de lignes dans l'algorithme de test de 
de'pendance qui partage cette structure de donne'es avec l'analyse se'mantique.

Chaque colonne de la matrice correspond a` la valeur d'une variable
scalaire entie`re du module analyse', une entite' de la repre'sentation
interne. Trois types de valeurs sont distingue's:
\begin{itemize}
  \item les valeurs initiales
  \item les valeurs finales
  \item les valeurs interme'diaires
\end{itemize}
Les valeurs finales sont directement porte'es par l'entite' concerne'e
et visualise'es tel que. Les valeurs initiales et interme'diaires sont
porte'es par des entite's spe'ciales, propres au package {\em transformer}
(voir \verb+value.c+). Les valeurs initiales sont visualise'es en suffixant
la chai^ne \verb+#INIT+ au nom de l'entite' correspondante. Les valeurs
interme'diaires ne sont jamais visualise'es, sauf dans des impressions
de mise au point ou` elles apparaissent avec le suffixe \verb+#TMP+.

Dans tous les cas, le nume'ro de colonne (aussi appele' nume'ro de
variable) est donne' par l'adresse de l'entite' choisie.  Des tableaux
de correspondance permettent de passer des entite's aux valeurs et des
valeurs aux entite's et a` leurs noms (voir \verb+value.c+).

On comple`te chaque ligne de la matrice de contraintes par le terme
constant (\verb+TCST+) qui rec,oit conventionnellement le nume'ro de
variable 0 (i.e. l'adresse 0, puisqu'il s'agit de pointeurs).

\subsubsection{Vecteur}

Un vecteur est une liste de couples (nume'ro de variable, valeur).
Cette liste de couples n'est pas ordonne'e dans la premie`re imple'mentation
qui est faite car nous faisons l'hypothe`se que le nombre de coefficients
non nuls restera tre`s faible tout au long des calculs. 

Le vecteur nul est repre'sente' par une liste vide.

Ce type {\em vecteur} est utilise' pour repre'senter les contraintes,
les sommets, les rayons et les droites, ainsi que les expressions
line'arise'es de la repre'sentation interne.

\subsubsection{Contrainte}

Une contrainte est soit une e'galite', soit une ine'galite' (on ne sait pas
faire la distinction a` ce niveau). Elle contient donc implicitement
un terme constant associe' a` la variable de nume'ro 0.

On associe a` chaque contrainte de type ine'galite' les e'le'ments du syste`me
ge'nerateur qui la sature au moyen de tableaux d'entiers.

Chaque contrainte contient aussi un pointeur vers une autre contrainte
pour pouvoir constituer directement les deux listes d'e'galite's et
d'ine'galite's d'un syste`me.

\subsubsection{Syste`me}

Un syste`me line'aire est constitue' de deux listes de contraintes,
e'galite's et ine'galite's. C'est a` ce niveau que l'on dispose de
l'information ne'cessaire pour savoir comment traiter les termes constants.
Il contient aussi le nombre de ces e'galite's
et de ces ine'galite's, ainsi que le nombre de variables du syste`me.

\subsection{Repre'sentation des syste`mes ge'ne'rateurs}

\subsubsection{De'finition d'un syste`me ge'ne'rateur}

Comme les syste`mes ge'ne'rateurs sont moins connus que les syste`mes
d'ine'galite's, nous rappelons que ce sont des triplets de trois ensembles
appele's respectivement sommets, rayons et droites. Le polye`dre $P$
ge'ne're' par un syste`me $S=\{\{\vec{s_i}\},\{\vec{r_j}\},\{\vec{d_k}\}\}$
est de'fini par l'e'quation:
\[
P = \left\{ { \vec{v} / 
        \exists \lambda_i \geq 0 \; \wedge \; \sum_i \lambda_i = 1 \;
                \exists \mu_j \geq 0 \;
                \exists \nu_k \;
                \vec{v} = \sum_i \lambda_i \vec{s_i} +
                \sum_j \mu_j \vec{r_j} +
                \sum_k \nu_k \vec{d_k} 
        }\right\}
\]

\subsubsection{Sommets}

Comme nous approximons les ensembles de valeurs entie`res par des
ensembles de valeurs rationnelles, il se peut que les sommets aient
des coordonne'es rationnelles. Ils sont donc repre'sente's
par un vecteur a` coefficients entiers et par un unique de'nominateur.

On associe aussi a` chaque sommet un tableau des e'quations qu'il
sature (i.e. ve'rifie).

Enfin, chaque sommet contient un lien vers un sommet suivant, qui permet
de constituer l'ensemble des sommets d'un syste`me ge'ne'rateur.

Au plus haut niveau, on garde un pointeur vers le premier
sommet, ainsi que le nombre total de sommets de la liste.

\subsubsection{Rayons et droites}

Les rayons et les droites sont des objets identiques. Seule change
l'interpre'tation qu'on en donne et la manie`re dont on les traite.

Ils sont repre'sente's comme les sommets, mais ne contiennent pas de
champs de'nominateur puisqu'ils sont de'finis a` une constante
multiplicative pre`s.  A chacun d'eux est associe' un vecteur, un
ensemble de nume'ros d'e'quations sature'es, et un pointeur vers
l'e'le'ment suivant. En te^te de liste, on conserve le nombre
d'e'le'ments.

\subsubsection{Syste`me ge'ne'rateur}

Un syste`me ge'ne'rateur comporte donc trois champs, qui sont les te^tes
de liste des sommets, des rayons et des droites.

\subsection{Syste`me d'e'quations aux polye`dres}

\subsubsection{Divers types d'e'quations se'mantiques}

Les diffe'rents types d'e'quations que nous savons traiter sont:
\begin{itemize}
  \item les affectations non-line'aires (\verb%I=J**2%),
  \item les affectations line'aires inversibles (\verb%I=I+1%),
  \item les affectations line'aires non-inversibles (\verb%I=J%),
  \item les tests non line'aires,
  \item les tests line'aires de type ine'galite' pour les branches
        vrai et faux (\verb%I.LE.J-3%),
  \item les tests line'aires a` e'galite', branches vrai et faux
        (\verb%I.EQ.0%),
  \item les noeuds de jonction qui sont les noeuds du graphe de contro^le
        qui ont plus d'un ante'ce'dent (regroupement apre`s un \verb%IF%,
        ou en te^te de \verb%DO%, ou encore sur un \verb%CONTINUE% a` cause
        d'un \verb%GOTO%),
  \item les noeuds d'e'largissements, qui caracte'risent les boucles
        et qui permettent d'e'viter les ite'rations infinies vers un
        point fixe (ope'rateur d'e'largisssement de'fini par Cousot).
\end{itemize}

\subsection{Fonctions principales sur les {\em transformers}}

Les routines essentielles pour l'analyse se'mantique par polye`dre sont:
\begin{itemize}
  \item {\em affectation}, qui calcule l'effet d'une affectation affine
         sur un polye`dre
        (i.e. sur son syste`me de contraintes et sur son syste`me ge'nerateur);
  \item {\em projection}, qui calcule l'effet d'une affectation non line'aire;
  \item {\em intersection\_demi}, qui calcule le nouveau pre'dicat d'une
        branche de test de la forme {\tt I.GE.J} 
        ({\em demi} signifie demi-espace);
  \item {\em intersection\_hyperplan}, qui calcule le nouveau pre'dicat
        d'une branche de test vraie de la forme {\tt I.EQ.J};
  \item {\em enveloppe}, qui calcule l'enveloppe convexe de deux pre'dicats
        sur les points de jonction du graphe de contro^le (fin d'un test,
        boucle);
  \item {\em e'largissement}, qui permet de calculer un polye`dre point fixe
        pour les boucles (ope'rateur $\nabla$ de la the`se de Halbwachs);
  \item {\em sc\_to\_sg}, qui permet de passer d'un syste`me de contraintes
        a` un syste`me ge'ne'rateur;
  \item {\em normalisation}, qui permet d'e'liminer les contraintes 
        et les e'le'ments du syste`me ge'ne'rateur qui sont redondants;
\end{itemize}
Ces fonctions sont construites a` partir de fonctions similaires sur les
syste`mes de contraintes et sur les syste`mes ge'ne'rateurs.

\subsection{Options d'analyse et impression des re'sultats}

Diverses options permettent d'effectuer plus ou rapidement et plus ou
moins pre'cise'ment l'analyse se'mantique. La version la plus rapide est
insensible au flow de donne'es et n'effectue qu'une simple propagation
de constante intra-proce'durale. La version la plus pre'cise applique un
calcul d'enveloppe convexe en sortie des tests (elle est donc {\em flow
sensitive}) et exploite les transformers associe's aux modules appele's
(elle est donc aussi interproce'durale).

\section{Conclusion}

Les diffe'rentes analyses pre'vues dans le contrat PIPS ont e'te'
imple'mente'es en prenant en compte les difficulte's rencontre'es sur
les programmes fournis par l'ONERA. Cette confrontation avec la
re'alite' a permis de se'parer l'utile de l'inutile et d'adapter les
algorithmes pre'vus initialement pour tirer le maximum d'information
possible avant d'aborder la phase de paralle'lisation.

\newpage

\section{Annexe: Description des structures de donne'es dans la {\em RI}}

\input{ri.datastructure}

\end{document}
