\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\titre}{DEFINITION DU SOUS-FORTRAN PIPS \\
                    RESTRICTIONS ET EXTENSIONS}
\newcommand{\auteur}{R\'emi TRIOLET}
\newcommand{\docdate}{Mars 1988}
\newcommand{\numero}{E103}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\section{Pr\'esentation des programmes}

L'ONERA nous a fourni les quatre programmes suivants:

\begin{itemize}
\item AILE: \'ecoulement 3d transonique autour d'une aile en fl\`eche;
\item CR2CNF: calcul des matrices sans bulles;
\item OA118: \'equations int\'egrales;
\item TMINES: programme de calcul de l'\'ecoulement potentiel dans une tuy\`ere
      \`a section rectangulaire variable.
\end{itemize}

Les tailles des ces quatre programmes sont donn\'ees par le tableau suivant:
\begin{verbatim}
        Fichier   Nombre de Lignes   Taille en octets

        aile.f          3011              92107
        cr2cnf.f         989              31956
        oa118.f         1449              39003
        tmines.f        1042              25873

        total           6491             188939
\end{verbatim}

Le nombre et les noms des modules -- FUNCTIONS ou SUBROUTINES --
composant ces quatre programmes sont donn\'es par le tableau suivant:
\begin{verbatim}
Programme   Functions   Subroutines   Noms

AILE        1                         D
                        25            CHRONO CLCOUPJ CLCOUPK CLGLISJ
                                      CLGLISK CLGLISP CLINJEC CLNOREF
                                      CLTANGT COEF CORREC DISSB
                                      DISSIP DIST EDITION EFFORTS
                                      EXTR F GEOM INIT NORM POUSSE
                                      PREDIC PVN RESIDU

CR2CNF      3                         DPHI PHI SDOT
                        23            CHOLES DESCEN FRONT IMPFRO
                                      IMPRIF IMPRIM INITB INITBM
                                      INVFRO INVOPT MATELT MBTELT MXV
                                      MXVADD NBDIAG OASSEM TESFRO
                                      TRANSP VCLR VMOV VSUB ZASSEM
                                      ZPROAX

OA118       1                         SDOT
                        9             GRAD1 SOLV SOLV3 OAMAT1 OAMET
                                      OAVITEL PHWAK PHWPAN PMAT

TMINES      0
                        10            CALCG CALMAT DES MAILLA POLTRI
                                      PREPCG PROD REP RESUL ROMAT
\end{verbatim}

\section{Restrictions et extensions}

Aucune des restrictions que nous souhaitons faire \`a Fortran n'est
pr\'esente dans ces quatre programmes, \`a l'exception de l'utilisation
des constantes Hollerith.

Cela signifie que les restrictions que nous proposons dans la suite de
ce document n'entrainent pratiquement pas de modifications des
programmes originaux.

\paragraph{}

Trois de ces quatre programmes sont parfaitement compatibles avec la
norme Fortran 77 (Norme ANSI X3.9-1978). Par contre, le programme AILE
utilisent les entr\'ees sorties asynchrones BUFFER~IN et BUFFER~OUT,
ainsi que la fonction INIT qui permet d'attendre la fin d'un \'echange
asynchrone.

Ces extensions sont admises par la plupart des grands constructeurs
(IBM, CDC, CRAY, etc.), et de plus, elle sont relativement utiles. En
cons\'equence, elles risquent d'\^etre pr\'esentes dans d'autres
programmes scientifiques, et c'est pourquoi nous avons d\'ecid\'e de les
incorporer \`a notre sous-ensemble de Fortran.

Il en est de m\^eme pour l'extension classique qui consiste \`a
permettre au programmeur de sp\'ecifier la longueur en unit\'es de
longueur num\'eriques (g\'en\'eralement des octets) de chaque
type de donn\'ees num\'erique: LOGICAL*1 BOOL, REAL*8 MAT(N,N), ...

\paragraph{}

La d\'efinition de notre sous ensemble de Fortran, not\'e Fortran PIPS
dans la suite de ce document, est conforme \`a la norme ANSI X3.9-1978,
\`a l'exception des restrictions cit\'ees dans la
section~\ref{restrictions}  et des extensions cit\'ees dans la
section~\ref{extensions}.

Nous donnons en annexe les SYNTAX CHARTS de la norme ANSI modifi\'es en
tenant compte des restrictions et des extensions. Les restrictions sont
surlign\'ees en vert. Les extensions ont e'te' dessine'es en respectant
le format de la norme; elles sont signale'es par un trait vertical bleu
dans la marge.

\subsection{Restrictions}
\label{restrictions}

\paragraph{Instruction ENTRY.}

L'instruction ENTRY permet de sp\'ecifier des points d'entr\'ee
multiples pour un module. Son utilisation cr\'ee des difficult\'es pour
un analyseur automatique car le graphe des appels -- graphe qui permet
de savoir quels modules sont appel\'es par un module donn\'e -- peut
devenir tr\`es complexe.

Cette instruction est peu utilis\'ee, et de toute mani\`ere peut \^etre
elimin\'ee facilement en dupliquant les modules contenant des ENTRYs.

\paragraph{Module BLOCK DATA.}

Les modules BLOCK DATA permettent de regrouper les initialisations par
DATA des variables globales. Fortran ne perd rien \`a sa
g\'en\'eralit\'e si on interdit les BLOCK DATA et si on ins\`ere dans le
PROGRAM les initialisations contenues dans ceux-ci.

\paragraph{Instructions ASSIGN et GOTO nom-de-variable.}

L'instruction ASSIGN permet de stocker dynamiquement un label dans une
variable de type INTEGER. L'instruction GOTO nom-de-variable permet
d'ex\'ecuter un branchement vers le label contenu dans une variable.

Un programme contenant ces deux instructions est particuli\`erement
difficile \`a lire pour un programmeur, car le saut peut aboutir
n'importe o\`u. Dans le cas d'une analyse automatique, l'utilisation des
ces constructions va r\'esulter en un graphe de contr\^ole complexe qui
fera apparaitre de nombreuses d\'ependances de contr\^ole. Les
transformations de parall\'elisation seront tr\`es improbables.

Ces deux instructions peuvent \^etre \'elimin\'ees en rempla\c{c}ant les
instructions \verb+ASSIGN label TO variable+ par des affectations
\verb+variable = label+, et les instructions \verb+GOTO variable+ par
une suite d'instructions \verb+IF (variable .EQ. label) GOTO label+.

\paragraph{Instruction RETURN expression.}

Les retours secondaires de subroutine permettent d'ex\'ecuter un
branchement apr\`es une instruction CALL dont la destination d\'epend
d'une valeur transmise au moment de l'ex\'ecution du RETURN dans la
proc\'edure appel\'ee.

Cette construction pose les m\^emes probl\`emes de complexit\'e du
graphe de contr\^ole que pr\'ec\'edemment. Elle peut \^etre remplac\'ee
en transformant la subroutine en fonction et en ex\'ecutant apr\`s le
CALL un branchement vers un label calcul\'e \`a partir du r\'esultat
renvoy\'e par la fonction.

\paragraph{Instruction COMPUTED GOTO.}

Cette instruction permet d'ex\'ecuter un branchement vers un label dont
la valeur d\'epend de la valeur d'une expression enti\`ere.

Cette construction pose les m\^emes probl\`emes de complexit\'e du
graphe de contr\^ole que pr\'ecedemment. Elle peut \^etre remplac\'ee
par une suite d'instructions \verb+IF (variable .EQ. valeur) GOTO label+.

\paragraph{Instruction INQUIRE.}

L'instruction INQUIRE permet d'interroger le syst\`eme d'exploitation
sur les caract\'eristiques d'un fichier.

Elle est tr\`es peu utilis\'ee, et n'a aucun impact sur la
parall\'elisation automatique.

\paragraph{Extraction de sous-chaines.}

Fortran 77 permet de d\'eclarer des variables chaines de caract\`eres,
puis de r\'ef\'erencer des portions de ces variables. Cette
possibilit\'e augmente la complexit\'e des programmes d'analyse de la
repr\'esentation interne.

Cette construction est tr\`es peu utilis\'ee et n'a aucun impact sur la
parall\'elisation. Nous conservons donc le type chaine de caract\`eres,
mais interdisons la possibilit\'e d'utiliser des sous-chaines.

\subsection{Extensions}
\label{extensions}

Nous introduisons dans le Fortran PIPS la possibilit\'e de pr\'eciser le
nombre d'octets utilis\'es par les types de donn\'ees, comme dans:

\begin{verbatim}
        REAL*4 T1,T2,TMP(2),TL1,TL2,ETIME
        REAL*4 T1,T2,TMP(2),ETIME
        REAL*8 FUNCTION PHI(J,X)
\end{verbatim}

Nous introduisons d'autre part les instructions d'entr\'ees-sorties
asynchrones BUFFER IN et BUFFER OUT, dont la syntaxe est la suivante:

\begin{verbatim}
        BUFFER IN  (UNIT, MODE) (BBLOCK, EBLOCK)
        BUFFER OUT (UNIT, MODE) (BBLOCK, EBLOCK)
\end{verbatim}

o\`u UNIT est le num\'ero de l'unit\'e d'entr\'e-sortie, MODE est une
constante sp\'ecifiant le mode d'entr\'ee-sortie, BBLOCK et EBLOCK
sont des noms de variables ou d'\'el\'ements de tableaux indiquant la
zone \`a tranf\'erer.

\subsection{Mise en conformit\'e des programmes de l'ONERA}

Les programmes de l'ONERA n'ont presque pas \'et\'e modifi\'es.
L'utilitaire UNIX \verb+diff+ a \'et\'e utilis\'e pour obtenir les
diff\'erences suivantes.

\paragraph{Programme CR2CNF.} Aucune modification.

\paragraph{Programme TMINES.} Aucune modification.

\paragraph{Programme OA118.} Ajout d'une fonction CLOCK pour simuler
l'appel syst\`eme CLOCK, inexistant sous Sun OS.

\begin{verbatim}
En plus: INTEGER*4 FUNCTION CLOCK() 
         CLOCK = TIME()
         RETURN
         END
\end{verbatim}

\paragraph{Programme AILE.} Remplacement des constantes Hollerith
utilis\'ees dans des initialisations par DATA par les constantes chaines
de caract\`eres \'equivalentes; rappelons que les constantes Hollerith
ont \'et\'e \'elimin\'ees de la norme Fortran en 1978.

Suppression des param\`etres formels du programme principal; ceux-ci
sont utilis\'es comme interface avec le syst\`eme d'exploitation chez
certains constructeurs, et ne sont d'aucun int\'er\^et pour la
parall\'elisation.

\begin{verbatim}
Avant    PROGRAM AILE(INPUT=129,OUTPUT,TAPE1=INPUT,TAPE2=OUTPUT,TAPE4,
        1        TAPE5=0,TAPE6=0,TAPE7=0,TAPE8=0,TAPE9=0)

Apres    PROGRAM AILE



Avant    DATA TIT/10H        MA,10HCH        ,
        1         10H      ENTR,10HOPIE      ,
        2         10H  PRESSION,10H STATIQUE ,
        3         10H         R,10HO         ,
        4         10H    ANGLE ,10H(OX,OY)   ,
        5         10H    ANGLE ,10H(OX,OZ)   ,
        6         10H PAS DE TE,10HMPS X 1000/

Apres    DATA TIT/'        MA','CH        ',
        1         '      ENTR','OPIE      ',
        2         '  PRESSION',' STATIQUE ',
        3         '         R','O         ',
        4         '    ANGLE ','(OX,OY)   ',
        5         '    ANGLE ','(OX,OZ)   ',
        6         ' PAS DE TE','MPS X 1000'/
\end{verbatim}

\section{Probl\`emes divers}

Les probl\`emes suivants devront \^etre abord\'es lors de la
premi\`ere r\'eunion avec l'ONERA.

\paragraph{Ex\'ecution des programmes.}

Il est important pour le projet PIPS de pouvoir ex\'ecuter les
programmes de l'ONERA pour v\'erifier, avec les r\'esultats, que les
transformations effectu\'ees n'ont pas modifi\'e la s\'emantique des
programmes. 

Les programmes OA118 et AILE ne peuvent actuellement pas \^etre
ex\'ecut\'es: OA118 lit un fichier OARES inexistant, et AILE fait des
E/S asynchrones. Les deux autres programmes peuvent \^etre ex\'ecut\'es,
mais en un temps tr\`es long.

Il faudrait donc d'une part trouver une solution pour les programmes non
ex\'ecutables, et d'autre part, que les chercheurs de l'ONERA nous
indiquent quelles variables il faut modifier pour obtenir des temps
d'ex\'ecution raisonnables.

\paragraph{Variables statiques.}

Il faudra v\'erifier avec les chercheurs de l'ONERA que les programmes
fournis ne sont pas bas\'es sur le fait que les variables locales sont
statiques, ce qui est contraire \`a la norme mais h\'elas dans les
usages, et qui fait perdre beaucoup de parall\'elisme interproc\'edural.

\section{Conclusion}

Les restrictions pr\'esent\'es dans ce document ne suppriment aucune
difficult\'e, mais limitent le volume de code \`a \`ecrire pour le
projet PIPS. Les points clef tels que COMMON, EQUIVALENCE, fonction
pass\'ee en param\`etre, etc. sont tous pris en compte.

\end{document}
\end
