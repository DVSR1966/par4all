\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\titre}{RAPPORT FINAL \\
                    ANALYSE LEXICALE \\
		    ANALYSE SYNTAXIQUE INTRA-PROC\'EDURALE}
\newcommand{\auteur}{Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{Mai 1989}
\newcommand{\numero}{E110}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\PAR{Introduction} 
\PAR{}
L'analyse lexicale et l'analyse syntaxique intra-proce'durale sont
re'alise'es par un programme nomme' {\em parser}. Ce rapport a pour
objet de de'crire les structures de donne'es et les algorithmes mis en
oeuvre pour la re'alisation de parser.

\PAR{}
Ce rapport reprend des parties de pre'ce'dents rapports interme'diaires.
Nous de'crivons dans la section 1 l'organisation ge'ne'rale de parser,
ce qu'il prend comme donne'es et ce qu'il produit comme re'sultats. La
section 2 de'crit en de'tail la structure de la repre'sentation
interme'diaire, et montre comment elle permet de repre'senter les
diffe'rents objets manipule's par un programme Fortran. La section 3
de'crit les programmes qui composent parser, et indique quels outils UNIX
qui ont e'te' utilise's. Enfin nous donnons en annexe l'inte'gralite'
des programmes sources de parser.


\SEC{Organisation ge'ne'rale de parser}
\PAR{}
L'objet du programme parser est de construire une repre'sentation
interme'diaire pour chaque module Fortran (subroutine, function ou main
program) qui lui est soumis.

\PAR{}
Parser prend en entre'e un fichier contenant des modules
Fortran. Le nom de ce fichier doit avoir une extension ``\verb/.f/''.
Parser effectue le me^me traitement sur chaque module, a` savoir:
\begin{itemize}
\item construction en me'moire d'une repre'sentation interme'diaire;
\item stockage sur fichiers disque de cette repre'sentation interme'diaire.
\end{itemize}
Le re'sultat de parser est identique si on lui soumet un unique fichier
contenant plusieurs modules, ou plusieurs fichiers contenant chacun un
unique module. Nous supposons donc dans la suite que parser est
exe'cute' sur un fichier de nom \verb/m.f/ contenant un module de nom
\verb/M/. 

\PAR{}
Sous ces hypothe`ses, le re'sultat de parser se compose de deux
fichiers: 
\begin{itemize}
\item un fichier de nom \verb/TOP-LEVEL:M.entities/ qui contient la
de'finition de toutes les entite's apparaissant dans M,
\item un fichier de nom \verb/TOP-LEVEL:M.code/ qui contient le code de M.
\end{itemize}

\PAR{}
Les entite's de'finies dans le fichier \verb/TOP-LEVEL:M.entities/ sont
les entite's locales de M, et l'entite' M elle-me^me. Les entite's
globales telles que les commons ou les autres modules appele's par M
sont conside're'es comme locales a` M\footnote{La phase ulte'rieure d'e'dition
de liens aura pour but de repe'rer ces entite's, de les transformer en
entite's globales, et de faire en sorte qu'une entite' globale ne soit
de'finie qu'une seule fois et que tous les modules fassent re'fe'rence
aux me^mes de'finitions.}.

\PAR{}
Les entite's locales a` M ont un nom pre'fixe' par \verb/M:/, ou`
\verb/M/ est le nom du package de M et \verb/:/ un se'parateur. Les
entite's qui sont re'ellement locales sont comple`tement de'finies, mais
ceci n'est pas vrai pour les entite's globales declare'es dans M. Ainsi,
la valeur initiale d'une entite' de type \verb/function/ sera inconnue
alors qu'elle devrait avoir pour valeur le code de la fonction. La
valeur est inconnue car le code des modules appele's n'est pas
disponible tant que ceux-ci n'ont pas e'te' soumis a` parser.

\PAR{}
L'entite' de'finissant le module M lui-me^me a pour nom
\verb/TOP-LEVEL:M/, ce qui signifie qu'elle appartient au package de
plus haut niveau: \verb/TOP-LEVEL/. Cette entite' est parfaitement
de'finie puisque son code est disponible dans le fichier \verb/m.f/ qui
est soumis a` parser. Ce code n'est cependant pas stocke' dans le
fichier \verb/TOP-LEVEL:M.entities/ mais dans le fichier
\verb/TOP-LEVEL:M.code/. Les raisons qui nous ont conduit a` se'parer
code et entite's seront expose'es ulte'rieurement.

\PAR{}
La repre'sentation interme'diaire de parser est une structure de
donne'es Newgen. Cela signifie que sa de'finition est faite a` l'aide du
langage de de'finition de domaines (DDL) pre'sente' dans le document
E-105. Cela signifie aussi que les programmes qui composent parser
utilisent les macros et fonctions automatiquement ge'ne're's par Newgen:
fonctions de cre'ation d'objets, fonctions d'acce`s aux champs des objets,
fonctions de lecture et e'criture disque, fonctions de libe'ration
me'moire, etc.

\SEC{Description de la repre'sentation interme'diaire}

\SSE{Principe ge'ne'raux}

\PAR{}
Cette repre'sentation interme'diaire de programmes proce'duraux a e'te'
de'finie pour traiter des programmes Fortran mais nous avons pris soin
de nous appuyer sur les ide'es ge'ne'rales de la se'mantique
de'notationnelle pour obtenir une repre'sentation a` la fois concise,
solide, extensible et aussi inde'pendante de Fortran que possible.

\PAR{}
Cette repre'sentation interme'diaire ne vise pas a rendre compte de tous les
proble`mes lie's aux traitements interproce'duraux qui seront effectue's
dans le cadre du projet PIPS. Elle a pour but de repre'senter d'une
manie`re se'mantiquement e'quivalente un module: programme principal,
subroutine ou function.

\PAR{}
Le pre'sent document repre'sente le re'sultat d'une premie`re phase.  La
repre'sentation interme'diaire sera ensuite augmente'e pour prendre en
compte les besoins de l'analyse interproce'durale ou du calcul des
de'pendances.

\SSE{Spe'cification NewGen de la repre'sentation interme'diaire}

\PAR{}
Le fichier de spe'cifications NewGen de la ri est donne'e ci apre`s.  La
liste de'finitions de domaines n'est pas donne'e dans un ordre logique,
mais plus simplement par ordre alphabe'tique.

\begin{verbatim}
array       = basic x dimensions:dimension* ;
basic       = int:int + float:int + logical:int + overloaded:unit + 
              complex:int + string:value ;
call        = function:entity x arguments:expression* ;
code        = declarations:entity* x statement ;
constant    = int + litteral:unit ;
dimension   = lower:expression x upper:expression ;
entity      = name:string x type x storage x initial:value ;
expression  = syntax ;
formal      = function:entity x offset:int ;
functional  = parameters:parameter* x result:type ;
instruction = block:statement* + test + loop + goto:statement + call ;
loop        = index:entity x range x body:statement x label:entity ;
mode        = value:unit + reference:unit ;
parameter   = type x mode ;
ram         = function:entity x section:entity x offset:int ;
range       = lower:expression x upper:expression x increment:expression ;
reference   = variable:entity x indices:expression* ;
statement   = label:entity x instruction ;
storage     = return:entity + ram + formal + rom:unit ;
symbolic    = expression x constant ;
syntax      = reference + range + call ;
test        = condition:expression x true:statement x false:statement ;
type        = statement:unit + area:int + array + functional + 
              unknown:unit + void:unit ;
value       = code + symbolic + constant + intrinsic:unit + unknown:unit ;
\end{verbatim}

\SSE{Analyse de la repre'sentation interme'diaire}

\PAR{}
Dans cette section, nous allons montrer comment cette repre'sentation
interme'diaire permet de repre'senter les diffe'rents objets manipule's par un
programme Fortran.

\SSS{Domaines}

\PAR{}
Nous allons tout d'abord examiner chaque domaine pour expliquer
brie`vement a` quoi il sert.

\PAR{Entity = name:string x type x storage x initial:value}
\PAR{}
Tout objet ayant un nom dans un programme Fortran est repre'sente' par
une \verb/entity/. Un tel objet peut e^tre un module, une variable, un
common, un ope'rateur, une constante, un label, etc. Pour chaque objet,
le sous-domaine \verb/name/ de l'entite' donne le nom de l'objet tel
qu'il apparait dans le texte source du programme pre'fixe' par le nom du
package dans lequel l'entite' est de'clare'e, le sous-domaine
\verb/type/ donne le type de l'entite', le sous-domaine \verb/storage/
le genre d'allocation me'moire utilise' pour l'entite', et finalement,
le sous-domaine \verb/initial/ donne la valeur initiale, si elle est
connue, de l'entite'. Le terme valeur initiale a ici un sens assez
large, puisqu'il s'agit par exemple du code pour les entite's
repre'sentant des modules.

\PAR{Type = statement:unit + area:int + array + functional +
unknown:unit + void:unit} 
\PAR{}
Le domaine \verb/type/ repre'sente le type d'une entite'.  Le
sous-domaine \verb/statement/ est utilise' pour les labels
d'instruction.  Le sous-domaine \verb/area/ est utilise' pour les
commons.  Le sous-domaine \verb/array/ est utilise' pour toutes les
variables, y compris les parame`tres formels et le re'sultat d'une
fonction.  Le sous-domaine \verb/functional/ est utilise' pour les
fonctions, pour les subroutines et pour le programme principal.  Le
sous-domaine \verb/void/ est utilise' pour le re'sultat d'une subroutine
ou d'un programme principal.

\PAR{Array = basic x dimensions:dimension*}
\PAR{}
Le domaine \verb/array/ repre'sente le type d'une variable.  Le
sous-domaine \verb/basic/ donne le type Fortran de la variable.  Le
sous-domaine \verb/dimensions/ donne la liste des dimensions de la variable.
Un scalaire est un tableau de ze'ro dimension.

\PAR{}
Chaque dimension est une expression, qui n'est pas ne'cessairement
constante dans le cas des tableaux formels. La constante pre'de'finie de
nom '*D*' est utilise'e pour les tableaux de taille non de'finie
(\verb/DIMENSION T(*)/).

\PAR{Basic = int:int + float:int + logical:int + overloaded:unit + 
complex:int + string:value}
\PAR{}
Le domaine \verb/basic/ permet de repre'senter un type Fortran tel que
INTEGER ou REAL. La valeur de ce domaine donne la longueur en octets de
la zone me'moire occuppe'e par une variable de ce type.

\PAR{Dimension = lower:expression x upper:expression}
\PAR{}
Le domaine \verb/dimension/ permet de repre'senter une dimension d'un
tableau, c'est a` dire un couple borne infe'rieure -- sous-domaine
\verb/lower/ -- borne supe'rieure -- sous-domaine \verb/upper/.

\PAR{Functional = parameters:parameter* x result:type}
\PAR{}
Le domaine \verb/functional/ repre'sente le type d'un module, c'est
a` dire une fonction, une subroutine ou un programme principal. Le
sous-domaine \verb/parameters/ donne le type et le mode de passage de chaque
parame`tre, et le sous-domaine \verb/result/ donne le type du re'sultat. Ce
dernier type vaut \verb/void/ pour les subroutines et les programmes
principaux. 

\PAR{Parameter = type x mode}
\PAR{}
Le domaine \verb/parameter/ repre'sente le type et le mode de passage d'un
parame`tre formel de module. 

\PAR{Mode = value:unit + reference:unit}
\PAR{}
Le domaine \verb/mode/ repre'sente le mode de passage d'un parame`tre
formel de module. Le domaine contient un objet du domaine \verb/value/
pour le mode de passage par valeur et \verb/reference/ pour le passage
par adresse.

\PAR{Storage = return:entity + ram + formal + rom:unit}
\PAR{}
Le domaine \verb/storage/ permet de pre'ciser dans quelle zone de la me'moire
est stocke'e une entite'. Il y a plusieurs zones, qui ne correspondent
pas ne'cessairement a` la re'alite', c'est a` dire aux zones de me'moire
qui seraient affecte'es par un compilateur.

\PAR{}
Le sous-domaine \verb/return/ permet de repre'senter les variables ayant
pour nom le nom d'une fonction et auxquelles on affecte la valeur que la
fonction doit retourner. L'entite' pointe'e par \verb/return/ est la
fonction concerne'e.

\PAR{}
Le sous-domaine \verb/ram/ est reserve' aux variables ayant une adresse
en me'moire. Il permet de pre'ciser dans quelle fonction et
e'ventuellement dans quelle common ces variables ont e'te' de'clare'es.

\PAR{}
Le sous-domaine \verb/formal/ est re'serve' aux parame`tres formels des
modules.

\PAR{}
Le sous-domaine \verb/rom/ est utilise' pour toutes les entite's dont la
valeur n'est pas modifiable, telles que les fonctions, les labels, les
ope'rateurs, etc.

\PAR{Ram = function:entity x section:entity x offset:int}
\PAR{}
Le domaine \verb/ram/ permet de pre'ciser la de'claration d'une
variable. Le sous-domaine \verb/function/ indique dans quel module une
entite' est de'clare'e. Le sous-domaine \verb/section/ indique dans
quelle aire une entite' est stocke'e; il y a une aire par common
de'clare' et deux aires spe'ciales nomme'es \verb/STATIC/ et
\verb/DYNAMIC/ pour les entite's locales. Enfin, le sous-domaine
\verb/offset/ donne l'adresse dans l'aire de la variable.

\PAR{Formal = function:entity x offset:int}
\PAR{}
Le domaine \verb/formal/ indique le module dans lequel un parame`tre formel
est de'clare' gra^ce le sous-domaine \verb/function/, et le rang de ce
parame`tre dans la liste des parame`tres gra^ce au sous-domaine \verb/offset/.

\PAR{Value = code + instruction + symbolic + constant + intrinsic:unit + 
unknown:unit}
\PAR{}
Le domaine \verb/value/ permet de repre'senter les valeurs initiales des
entite's. Le sous-domaine \verb/code/ est utilise' pour les entite's
modules. Le sous-domaine \verb/symbolic/ est utilise'
pour les entite's constantes symboliques. Le sous-domaine
\verb/constant/ est utilise' pour les entite's constantes. Le
sous-domaine \verb/intrinsic/ est utilise' pour toutes les entite's qui
ne de'pendent que du langage, telles que les intrinsics Fortran, les
ope'rateurs, les instructions, etc. Enfin le sous-domaine
\verb/unknown/ est utilise' pour les valeurs initiales inconnues.

\PAR{Symbolic = expression x constant}
\PAR{}
Le domaine \verb/symbolic/ est utilise' pour repre'senter la valeur
initiale d'une entite' constante symbolique, c'est a` dire les PARAMETER
de Fortran ou les CONST de Pascal. Le sous-domaine \verb/expression/ permet
de stocker l'expression qui a permis d'e'valuer la valeur initiale
contenue dans le sous-domaine \verb/constant/. Le sous-domaine \verb/expression/
n'est utile qui si on cherche a` reproduire un texte source fide`le.

\PAR{Constant = int + litteral:unit}
\PAR{}
Le domaine \verb/constant/ est utilise' pour repre'senter la valeur
initiale des entite's constantes. Seules les entite's de type entier
nous inte'ressent, ce qui explique qu'une constante puisse e^tre soit un
\verb/int/ soit un \verb/litteral/ dont on ne garde pas la valeur (type unit).

\PAR{Code = declarations:entity* x statement}
\PAR{}
Le domaine \verb/code/ est utilise' pour stocker le corps des modules. Le
sous-domaine \verb/declarations/ contient une liste d'entite's qui sont les
variables et commons de'clare's dans la fonction. Le sous-domaine
\verb/statement/ contient la se'quence d'instructions du module.

\PAR{Statement = label:entity x instruction}
\PAR{}
Le domaine \verb/statement/ permet de repe'rer les instructions d'un module.
Le sous-domaine \verb/label/ contient une entite' qui de'finit le label. Le
sous-domaine \verb/instruction/ contient le corps de l'instruction.

\PAR{Instruction = block:statement* + test + loop + goto:statement + call}
\PAR{}
Le domaine \verb/instruction/ permet de repre'senter les instructions
d'un module. Une instruction peut e^tre un sous-domaine \verb/block/,
c'est a` dire une liste de \verb/statement/, un sous-domaine \verb/test/
pour les instructions de test, un sous-domaine \verb/loop/ pour les
boucles, un sous-domaine \verb/goto/ pour les goto qui contient le
\verb/statement/ vers lequel le goto se branche, ou un sous-domaine
\verb/call/ pour toutes les autres instructions: affectation, appel de
subroutine, entre'es-sorties, return, stop, etc. Toutes ces instructions
sont repre'sente'es par des appels a` des fonctions pre'de'finies dont
nous e'tudierons la nature plus loin.

\PAR{Test = condition:expression x true:statement x false:statement}
\PAR{}
Le domaine \verb/test/ permet de repre'senter toutes les instructions a` base
de contro^le. Le sous-domaine \verb/condition/ contient l'expression a`
tester, et les deux sous-domaines \verb/true/ et \verb/false/ contiennent les
instructions a` exe'cuter selon la valeur du test. 

Il faut noter que chaque instruction de contro^le de Fortran,
a` l'exception de l'instruction \verb/DO/, est
transforme'e en une combinaison se'mantiquement e'quivalente de \verb/test/s
et de \verb/goto/s.

\PAR{Loop = index:entity x range x body:statement x label:entity}
\PAR{}
Le domaine \verb/loop/ permet de repre'senter les boucles du type DO Fortran
ou FOR Pascal. Le sous-domaine \verb/index/ contient l'entite' indice de
boucle, le sous-domaine \verb/range/ contient les bornes de la boucle, le
sous-domaine \verb/body/ contient le corps de la boucle, c'est a` dire un
\verb/statement/, le sous-domaine \verb/label/ contient le label de fin de boucle,
c'est a` dire une entite'.

\PAR{Range = lower:expression x upper:expression x increment:expression}
\PAR{}
Le domaine \verb/range/ permet de repre'senter les bornes des boucles DO
Fortran. Il y a trois sous-domaines \verb/lower/, \verb/upper/ et \verb/increment/ de
type \verb/expression/ qui sont respectivement la borne infe'rieure, la borne
supe'rieure et l'incre'ment.

\PAR{Call = function:entity x arguments:expression*}
\PAR{}
Le domaine \verb/call/ permet de repre'senter les appels de fonctions.
Les fonctions jouent un ro^le important dans notre repre'sentation
interme'diaire puisque les ope'rateurs et les instructions Fortran
(READ, WRITE, RETURN, ...) sont repre'sente'es par des fonctions
pre'de'finies.

Le sous-domaine \verb/function/ est une entite' qui de'finit la fonction
appele'e. Le sous-domaine \verb/arguments/ est une liste de sous-domaines
\verb/expression/ qui repre'sente les arguments d'appel de la fonction.

\PAR{Expression = syntax}
\PAR{}
Le domaine \verb/expression/ permet de stocker les expressions.
Pour l'instant, ce domaine ne se compose que d'un unique sous-domaine
\verb/syntax/, mais nous pensons ajouter ulte'rieurement d'autres
sous-domaines, notamment pour conserver avec chaque expression line'aire
un forme compile'e, peut-e^tre sous forme d'un vecteur.

Le sous-domaine \verb/syntax/ contient l'expression avec la me^me
structure que celle du code source.

\PAR{Syntax = reference + range + call}
\PAR{}
Le domaine \verb/syntax/ permet de repre'senter les expressions telles
qu'elles apparaissent dans le texte source du programme. Un
\verb/syntax/ est soit une \verb/reference/ a` un e'le'ment de tableau
(on rappelle que les scalaires sont des tableaux a` 0 dimension) , soit
un \verb/call/ a` une fonction (les ope'rateurs sont repre'sente's par
des fonctions pre'-de'finies), soit un \verb/range/, dans le cas des
expressions bornes de boucles.


\PAR{Re'fe'rence = variable:entity x indices:expression*}
\PAR{}
Le domaine \verb/reference/ est utilise' pour repre'senter une re'fe'rence a`
un e'le'ment de tableau. Le sous-domaine \verb/variable/ contient une entite'
de'finissant la variable re'fe'rence'e. Le sous-domaine \verb/indices/
contient une liste expressions qui sont les indices de la re'fe'rence.

\SSS{Objets du langage Fortran}

\PAR{}
Nous montrons a` pre'sent comment les diffe'rents objets manipule's dans
un programme Fortran sont traduits dans notre repre'sentation interme'diaire.

\PAR{Module}
\PAR{}
Un module est un programme principal, une fonction ou une subroutine. 

\PAR{}
Un module est repre'sente' par une \verb/entity/ dont le \verb/name/ est
le nom du module pre'fixe' par le nom du package de plus haut niveau
\verb/TOP-LEVEL/, le \verb/type/ est un \verb/functional/ qui indique le
type des parame`tres formels et du re'sultat, le \verb/storage / vaut
\verb/rom/ et le \verb/initial/ est un \verb/code/ qui contient le corps du module.

Les subroutines et le programme principal n'ont pas d'argument et
retournent un \verb/void/. Le nom du programme principal est prefixe'
par un '\_' pour le diffe'rencier d'une subroutine.

Tous les autres objets sont conside're's au niveau du parser comme des
objets locaux. Leur nom est donc pre'fixe' par le nom du package
associe' au module, a` savoir le nom du module lui-me^me.

\PAR{Commons et aires}
\PAR{}
Une aire repre'sente une partie de la me'moire ou` sont range'es les
variables. Les commons sont des aires (voir plus loin).

\PAR{}
Deux aires spe'ciales sont cre'e'es pour les variables qui
n'appartiennent pas a` un common (variables locales). Ces deux aires
sont des entite's qui ont pour \verb/name/ \verb/STATIC/ et
\verb/DYNAMIC/, pour \verb/type/ un \verb/area/ qui donne la longueur
de l'aire, pour \verb/storage/ un \verb/rom/ et comme \verb/initial/ une
\verb/value/ de type \verb/unknown/. 

\PAR{}
L'appartenance d'une variable ou d'un common a` l'une des ces deux aires
spe'ciales indique si cette variable ou ce common est statique ou
dynamique.

\PAR{}
Un common est repre'sente' par une \verb/entity/ dont le \verb/name/ est
le nom du common, le \verb/type/ est un \verb/area/ qui donne la
longueur du common en octets, le \verb/storage/ est un \verb/ram/ qui
indique la fonction ou` le common est declare' (\verb/function/) et
l'aire ou` le common est range' (\verb/section/)..

\PAR{Variables -- Ge'ne'ralite's}
\PAR{}
Les variables scalaires sont traite'es comme des tableaux a` 0 dimension.

\PAR{}
Une variable est repre'sente'e par une \verb/entity/ dont le \verb/name/ est le
nom de la variable. 

\PAR{Variables -- Types}
\PAR{}
Le \verb/type/ d'une entite' ``variable{''} est un \verb/array/ qui donne le type
fortran des e'le'ments (\verb/basic/), le nombre de dimensions (longueur de
la liste \verb/dimensions/) et les bornes de chaque dimension.

\PAR{Variables -- Allocation me'moire}
\PAR{}
Le \verb/storage/ d'une entite' ``variable re'sultat de fonction'' est un
\verb/return/ qui indique la fonction contenant cette variable.

\PAR{}
Le \verb/storage/ d'une entite' ``variable parame`tre formel'' est un
\verb/formal/ qui indique la fonction contenant ce parame`tre et le rang de
ce parame`tre dans la liste des parame`tres formels.

\PAR{}
Le \verb/storage/ d'une entite' ``variable locale ou globale{''} est un \verb/ram/
qui indique dans quelle fonction la variable est de'clare'e
(\verb/function/), a` quelle aire (common ou aire spe'ciale) elle appartient
(\verb/section/) et quelle est son adresse dans ce common (\verb/offset/).

\PAR{Variable -- Valeur initiale}
\PAR{}
Le \verb/initial/ d'une entite' ``variable{''} vaut \verb/unknown/ sauf
si cette variable est de type entier et est initialise'e par data. Dans
le cadre de la paralle'lisation, on ne s'inte'resse pas aux autres variables.

\PAR{Constantes nume'riques et symboliques}
\PAR{}
Les constantes sont conside're'es comme des fonctions. Elles sont donc
repre'sente'es par des entite's dont le \verb/name/ est le nom de la
constante (\verb/12/, \verb/13.56E12/, \verb/'*NOMBRE DE FACETTES:*'/, \verb/PI/, \verb/MAXITER/,
etc.), dont le \verb/type/ est un \verb/functional/ a` 0 parame`tre et 1
re'sultat qui donne le type de la constante, dont le \verb/storage/ est un
\verb/rom/ et dont le \verb/initial/ est un \verb/constant/ pour les constantes
nume'riques et un \verb/symbolic/ pour les constantes symboliques.

\PAR{Ope'rateurs}
\PAR{}
Les ope'rateurs Fortran sont conside're's comme des fonctions. Ils sont
donc repre'sente's par des entite's dont le \verb/name/ est le nom de
l'ope'rateur, et dont le \verb/type/ est un \verb/functional/ qui indique l'arite'
de l'ope'rateur (longueur de la liste \verb/parameters/) mais qui n'indique
pas le type des parame`tres ou du re'sultat car le sous-domaine \verb/basic/
vaut toujours \verb/overloaded/. Le storage d'un ope'rateur est un \verb/rom/ et
son initial un \verb/intrinsic/.

\PAR{Intrinsics}
\PAR{}
Les intrinsics Fortran (MAX, MIN, ABS, etc.) sont traite's comme des
ope'rateurs. 

\PAR{Labels}
\PAR{}
Les labels sont repre'sente's par des entite's dont le \verb/name/ est
le nom du label pre'fixe' par un '\verb/@/', dont le \verb/type/ vaut
\verb/statement/, dont le \verb/storage/ vaut \verb/rom/ et dont le
\verb/initial/ est une constante litterale.

\PAR{Instructions simples}
\PAR{}
Les instructions simples de Fortran telles que RETURN, CONTINUE, STOP,
READ, WRITE, PAUSE, END, ... sont conside're'es comme des fonctions
intrinse`ques.  Elles sont donc repre'sente'es par des entite's qui ont
les me^mes caracte'ristiques qu'un ope'rateur a` 0 parame`tre. On ne
tient pas a jour le nombre de parame`tres car il ne sert a` peu pre`s a`
rien et que de toute fac,on, il est variable.

\PAR{}
L'instruction PRINT est transforme'e en WRITE.

\PAR{Instructions de contro^le}
\PAR{}
Toutes les instructions de contro^le du sous-Fortran que nous acceptons
en entre'e, a` l'exception de l'instruction \verb/DO/, sont
transforme'es {\em automatiquement} en se'quences e'quivalentes de tests
a` deux branches (une vraie et une fausse), de branchements
inconditionnels et de boucles do.

\PAR{}
\begin{verbatim}
      IF (I) 10, 20, 30
\end{verbatim}
devient
\begin{verbatim}
      IF (I.LT.0) THEN
         GOTO 10
      ELSE
         IF (I.EQ.0) THEN
             GOTO 20
          ELSE
             GOTO 30
          ENDIF
      ENDIF
\end{verbatim}

\PAR{}
\begin{verbatim}
      IF (I.GT.J) I = I-J
\end{verbatim}
devient
\begin{verbatim}
      IF (I.GT.J) THEN
         I=I-J
      ELSE
        CONTINUE
      ENDIF
\end{verbatim}

\PAR{Arguments des instructions d'entre'es-sorties}
\PAR{}
Les arguments des instructions d'entre'es-sorties sont soit des
informations de contro^le (unite', format, longueur des enregistrements,
etc.), soit des re'fe'rences a` lire ou des expressions a` e'crire. 

\PAR{}
Dans notre repre'sentation, les arguments des instructions
d'entre'es-sorties sont des listes de couples d'expressions. La
premie`re expression du couple est une constante chaine de caracte`res
qui indique la nature de l'argument qui apparaissait dans l'instruction
Fortran (\verb/UNIT=/, \verb/FORMAT=/, \verb/RECL=/, ...). La seconde
expression est la valeur de cet argument.

\PAR{}
Le dernier couple de la liste d'un READ ou d'un WRITE n'est pas un vrai
couple: le premier e'le'ment est une expression constante qui vaut
\verb/IOLIST=/, et le second e'le'ment est une liste d'expressions qui sont
les re'fe'rences a` lire ou les expressions a` e'crire.

\PAR{Boucles implicites}
\PAR{}
Les boucles do implicites dans les entre'es-sorties sont repre'sente'es
par des appels a` un ope'rateur pre'de'fini (en fait une fonction) de
nom \verb/IMPLIED-DO/, qui prend comme arguments une entite' qui de'finit
l'indice de la boucle, une expression \verb/range/ qui de'finit les bornes de
la boucle, et une liste d'expressions.

\PAR{Formats}
\PAR{}
Les formats sont conserve's sous forme d'expressions constantes chaines
de caracte`res. La constante de nom '*F*' est pre'de'finie pour les
formats libres (list-directed).

\PAR{}
Voici un exemple d'instruction d'entre'es-sorties.
\begin{verbatim}
      READ(2,'(5E16.6)') (IMD(I),I=1,NDOM), K
\end{verbatim}

devient
\begin{verbatim}
      (READ 'FMT=' '(5E16.6)' 'UNIT=' 2 
            'IOLIST=' (IMPLIED-DO I 1,NDOM,1 IMD(I)) K)
\end{verbatim}

\SEC{Imple'mentation de parser}
\PAR{}
Le programme parser se compose d'un analyseur lexical et d'un analyseur
syntaxique.

\SSE{Analyse lexicale}

\PAR{}
L'analyse lexicale de Fortran pose quelques proble`mes puisque ce
langage ne contient pas de mots clefs re'serve's comme c'est le cas de
langages plus re'cents tels que Pascal ou C.

\PAR{}
Par exemple, on de'tecte que l'instruction suivante est une affectation
car le caracte`re qui suit la parenthe`se fermant la re'fe'rence au
tableau IF est le caracte`re '='.
\begin{verbatim}
IF(I, J, K) = 6.66
\end{verbatim}

\PAR{}
En conse'quence, l'utilitaire {\em lex}, disponible sous UNIX, ne
permet pas de re'aliser un analyseur lexical pour Fortran. Une
premie`re solution consistait donc a` e'crire comple`tement un
analyseur lexical pour Fortran, ce qui aurait repre'sente' beaucoup de
travail.

\PAR{}
Nous avons pre'fe're' de'composer l'analyse lexicale de Fortran en
deux parties, une premie`re partie ayant pour objet de lever les
ambiguite's contenues dans un programme Fortran gr\^ace a` une
pre'-analyse qui introduit des mots clefs au de'but de chaque
instruction, et une seconde partie, beaucoup plus simple car base'e sur
lex, qui re'alise l'analyse syntaxique du Fortran avec mots clefs produit
par la premie`re partie.

\SSS{Pre'-analyseur lexical}

\PAR{}
La premie`re partie revient a` fournir a` l'utilitaire {\em lex} une
fonction ``\verb/getc/''qui permette de lever les difficulte's lie'es a`
Fortran.

\PAR{}
La nouvelle fonction \verb/getc/ fonctionne de la fac,on suivante.  Elle
lit d'un seul coup toutes les lignes d'une instruction Fortran, c'est a`
dire la ligne initiale et les 19 e'ventuelles lignes de continuation, et
les stocke dans le buffer ``\verb/Stmt/''.  Au vol, \verb/getc/ repe`re
le label, enle`ve tous les blancs, de'tecte les caracte`res entre
simples quotes, transforme les minuscules en majuscules, et met a` jour
4 variables externes, qui repre'sentent pour l'instruction courante les
nume'ros de la premie`re et de la dernie`re ligne commentaire, et de la
premie`re et de la dernie`re ligne source.  Ensuite, le contenu du
buffer /verb/Stmt/ est analyse' pour y de'tecter les mot clefs, c'est a`
dire traiter les cas des instructions IF, ELSEIF, ASSIGN, DO, des
de'claratives IMPLICIT et FUNCTION, et des operateurs {\em .XX.} (.EQ.,
.NEQV., ...).

\PAR{}
Lorsqu'un mot clef est de'tecte', il est mis en miniscules dans le
texte source, sauf la premie`re lettre qui reste en majuscule.  Ainsi,
lex peut faire la diffe'rence entre le mot clef 'Assign' et
l'identificateur 'ASSIGN'.  Gr\^ace a` la premie`re lettre, lex peut
de'tecter deux mots clef successifs, me^me sans blanc pour les
se'parer, comme dans 'IntegerFunctionASSIGN(X)'.

\PAR{}
Lorsqu'un ope'rateur .XX. est de'tecte', il est remplace' dans le
source par \verb+_XX_+.  Ainsi, lex peut faire la difference entre une
constante re'elle et un ope'rateur, comme dans \verb/(X+1._EQ_5)/.

\PAR{}
Les sources du pre-analyseur lexical se trouvent dans les fichiers suivants:
\begin{itemize}
\item f77keywords: les mots clef du sous-Fortran reconnu par PIPS;
\item f77symboles: les symboles (ope'rateurs, signes de ponctuation,
...) du sous-Fortran reconnu par PIPS;
\item reader.c: code de la nouvelle fonction getc.

\end{itemize}

\SSS{Post-analyseur lexical}

\PAR{}
La seconde partie est tout a` fait classique, c'est une spe'cification
d'analyseur lexical, dans le langage propose' par lex. Cette
spe'cification se compose d'une liste d'expressions re'gulie`res
correspondant aux tokens du langage, ave{c}, pour chacune d'entre elles,
le code du token a` renvoyer a` yacc lorsqu'un token de ce type est
de'tecte' dans le programme source.

\PAR{}
Les sources du post-analyseur lexical se trouvent dans le fichier
scanner.l. 

\SEC{Analyse syntaxique}

\PAR{}
L'analyse syntaxique de PIPS est re'alise'e avec l'utilitaire yacc. Cet
utilitaire permet de de'finir une grammaire par un ensemble de re`gles
construites sur les tokens du langage et sur d'autres symboles appele's
symboles non terminaux. Voici quelques exemples de re`gles.
\begin{verbatim}
linstruction: instruction TK_EOS
        | linstruction instruction TK_EOS
        ;

expression: reference
        | call
        | constante
        | signe expression
        | expression TK_PLUS expression
        | expression TK_MINUS expression
        | ...
        ;
\end{verbatim}

La premie`re re`gle signifie qu'une liste d'instructions est compose'e
de plusieurs instructions se'pare'es par des tokens \verb+TK_EOS+ (token
end-of-statement). La seconde re`gle signifie qu'une expression est soit
une re'fe'rence, soit un call, soit une constante, soit un signe suivie
d'une expression, soit la somme ou la diffe'rence de deux expressions.
Les symboles call, constante, reference, ... sont des non-terminaux, et
doivent donc e^tre de'finis plus loin en fonction des tokens du langage.

\paragraph{}
Yacc permet en plus d'associer a` chaque re`gle une portion de code
e'crit en langage C, qui est exe'cute'e chaque fois que la re`gle en
question est reconnue dans le programme Fortran soumis a` l'analyseur.
L'exemple suivant montre une partie de la re`gle instruction, et la
portion de code associe'e; il s'agit dans ce cas d'un appel de fonction
pour chainer l'instruction que l'on vient de reconnaitre au bloc
d'instructions courant.
\begin{verbatim}
instruction: return_inst
            { LinkInstToCurrentBlock($1); }
        | ...
        ;
\end{verbatim}

\paragraph{}
L'analyseur syntaxique se compose donc d'un ensemble de re`gles et d'un
ensemble de fonctions C. Les sources de l'analyseur syntaxique se
composent des fichiers dont la description suit.
\begin{itemize}

\item gram.y: fichier contenant la spe'cification des re`gles de la
      grammaire du sous-Fortran PIPS et les actions associe'es. La
      plupart des ces actions consistent en des appels de fonctions C
      de'finies dans les fichiers \verb/*.c/.

\item declaration.c: fonctions C appele'es par les re`gles d'analyse des
      de'clarations d'un module Fortran.

\item equivalence.c: fonctions C appele'es par les re`gles d'analyse des
      e'quivalences entre variables.

\item eval.c: fonctions C re'alisant un e'valuateur d'expressions constantes.
      Cet e'valuateur est utilise' principalement pour calculer les bornes des
      tableaux et leur adresse en cas d'e'quivalence.

\item expression.c: fonctions C appele'es par les re`gles d'analyse des
      expressions contenues dans les de'clarations et le code d'un
      module Fortran.

\item hashtable.c: fonctions C permettant de ge'rer la table des symboles de
      l'analyseur syntaxique.

\item intrinsic.c: fonctions C de'crivant les fonctions intrinse`ques de
      Fortran.

\item parser.c: le programme principal du parser. Ce programme est
      responsable des initialisations, ouvertures de fichiers, et de
      l'enchainement de l'analyseur lexical et de l'analyseur syntaxique.

\item parser.h: fichier contenant quelques constantes et macros partage'es.

\item procedure.c:  fonctions C appele'es par les re`gles d'analyse des
      appels de modules externes.

\item statement.c: fonctions C appele'es par les re`gles d'analyse des
      instructions d'un module Fortran.

\item util.c: diverses fonctions C partage'es.
\end{itemize}

\PAR{Conclusion}
\PAR{}
Le programme parser est entie`rement re'alise'. Son code ne devrait
maintenant subir des transformations que pour effectuer des corrections. 

\PAR{}
La repre'sentation interme'diaire va au contraire e'voluer au fur et a`
mesure que de nouvelles passes de PIPS vont e^tre de'veloppe'es. En
effet, la plupart des informations qui seront calcule'es par la suite
(pre'dicats, effets des proce'dures, etc.) doivent e^tre directement
raccroche'es soit aux instructions d'un module, soit aux entite's, ou
bien encore aux expressions. Dans tous les cas, cela signifie qu'il
faudra ajouter de nouveaux champs aux domaines de'ja` existants.

\newpage
\SEC{ANNEXE}
\PAR{}
Cette annexe contient le listing des programmes sources du parser.

\end{document}
\end
