\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

% pour importer des structures de donne'es Newgen
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}

\newcommand{\titre}{PROJET PIPS \\
	RESULTAT DE LA PARALLELISATION \\
		INTERPROCEDURALE
}

\newcommand{\auteur}{
        	Franc,ois IRIGOIN
}
\newcommand{\docdate}{Mars 1991}
\newcommand{\numero}{E151}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

\tableofcontents

\newpage

\section{Introduction}

Quatre programmes de calculs nume'riques, repre'sentant diverses
me'thodes de re'solution, ont e'te' fournis par l'ONERA pour le projet
PIPS afin d'en e'valuer les re'sultats. Ces quatre programmes ont pour
nom {\tt tmines}, {\tt aile}, {\tt oa118} et {\tt cr2cnf}.

Nous nous inte'ressons uniquement ici aux re'sultats obtenus en matie`re
de paralle'lisation interproce'durale, qui e'tait un des points
novateurs du projet PIPS.

\section{Programme {\tt tmines}}

Le programme {\tt tmines} a e'te' analyse' manuellement en de'tail. Il ne
contient pas de paralle'lisme interproce'dural.

\section{Programme {\tt aile}}

Le programme {\tt aile} comporte environ 3000 lignes de Fortran. Trois
proce'dures comportent des appels dans des corps de boucle susceptibles
d'e^tre paralle'lise's: {\tt norm} qui appelle {\tt pvn} (calcul de
produit vectoriel tridimensionnel), {\tt extr} qui appelle la
fonction {\tt d} (calcul de distance tridimensionnelle) et le programme
principal {\tt aile} qui fait appel a` {\tt clcoupk}.

Aucune de ces deux routines ne contient de boucle DO. Elles ne peuvent
donc pas repre'senter une partie importante du temps d'exe'cution globale.
Mais il faut ne'anmoins e^tre capable de paralle'liser les boucles
qui les contiennent.

\subsection{Traitement de la proce'dure {\tt norm}}

Pour faciliter l'e'tude de ce cas, les instructions de branchement ont
e'te' e'limine'es manuellement et syste'matiquement remplace'es par des
blocs IF. Ceci a e'te' facile car le code initial est parfaitement
structure'. Un utilitaire de structuration automatique comme {\em
struct} aurait pu effectuer cette conversion.

La proce'dure {\tt norm} contient trois appels a` {\tt pvn}. Deux
d'entre eux se trouvent dans une boucle 200 de niveau 1 assez complexe 
qui a peu de chance d'e^tre paralle`le, inde'pendamment de ces
deux appels. 

Le troisie`me appel se trouve place' au sein d'une paire de boucles 300.
Il devrait e^tre paralle'lise' mais trois tableaux temporaires {\tt TI},
{\tt TJ} and {\tt TK} cre'ent une {\em output dependence}. L'algorithme
de privatisation utilise' ne fonctionne que pour des scalaires.

\begin{verbatim}
         ...
         DO 300 K = K1,K2,1                                          
            DO 300 J = J1,JA,1                                       
               DO 310 L = 1,3,1                                      
                  TJ(L) = (T((J+1),K,((NI+L)-1))-T((J-1),K,((NI+L)-1)))
                  TK(L) = (T(J,(K+1),((NI+L)-1))-T(J,(K-1),((NI+L)-1)))
310            CONTINUE                                 
               CALL PVN(TJ, TK, TI)                     
               T(J,K,NN) = (S*TI(1))                    
               T(J,K,(NN+1)) = (S*TI(2))                
               T(J,K,(NN+2)) = (S*TI(3))                
300      CONTINUE
         ...
\end{verbatim}

La boucle 200 mentionne'e auparavant ne'cessite aussi l'expansion ou la
privatisation de ces trois me^mes tableaux.

\subsection{Traitement de la proce'dure {\tt extr}}

La proce'dure {\tt extr} est assez courte pour e^tre reproduite
inte'gralement ici apre`s privatisation:

\begin{verbatim}
      SUBROUTINE EXTR(NI,NC)
C********************************************************
C     CALCULE LES COEFFICIENTS D EXTRAPOLATION
C     SUR LA SURFACE DE L AILE  (K=K1)
C********************************************************
      DIMENSION T(52,21,60)
      COMMON/CT/T
      COMMON/CI/I1,I2,IMAX,I1P1,I1P2,I2M1,I2M2,IBF
      COMMON/CJ/J1,J2,JMAX,J1P1,J1P2,J2M1,J2M2,JA,JB,JAM1,JBP1
      COMMON/CK/K1,K2,KMAX,K1P1,K1P2,K2M1,K2M2
      COMMON/CNI/L
      L = NI                                             
      K = K1                                             
      DO 300 J = J1,JA,1                                 
         PRIVATE J,JH,S3,S2,S1
         S1 = D(J, K, J, (K+1))                          
         S2 = (D(J, (K+1), J, (K+2))+S1)                 
         S3 = (D(J, (K+2), J, (K+3))+S2)                 
         T(J,1,(NC+3)) = ((S2*S3)/((S1-S2)*(S1-S3)))     
         T(J,1,(NC+4)) = ((S3*S1)/((S2-S3)*(S2-S1)))     
         T(J,1,(NC+5)) = ((S1*S2)/((S3-S1)*(S3-S2)))     
         JH = ((J1+J2)-J)                                
         T(JH,1,(NC+3)) = T(J,1,(NC+3))                  
         T(JH,1,(NC+4)) = T(J,1,(NC+4))                  
         T(JH,1,(NC+5)) = T(J,1,(NC+5))                  
300      CONTINUE                                        
      RETURN
      END
\end{verbatim}
La paralle'lisation de la boucle 300 ne'cessite la preuve que les intervalles
des valeurs prises par les variables {\tt J} et {\tt JH} ont une
intersection vide.


L'initialisation des variables cle's, {\tt J1}, {\tt J2} et {\tt JA},
est effectue'e par une instruction READ dans le programme principal,
probablement afin d'effectuer une allocation dynamique:

\begin{verbatim}
      ...
      READ(NXYZ) TITXYZ
      READ(NXYZ) I1,I2,J1,JA,K1,K2
      REWIND NXYZ
C
      N4=4
      J1=J1+1
      J2=2*JA+1
      JA=JA+1
      ...
\end{verbatim}

A supposer qu'une analyse se'mantique interproce'durale pousse'e soit
effectue'e, on obtient les e'quations suivantes (attention a`
l'incre'mentation de {\tt JA} qui suit l'affectation de {\tt J2}):
\[
J1 \leq J \leq JA
\]
\[
JH = J1 + J2 - J
\]
\[
J2 = 2 JA - 1
\]
En remplac,ant $J2$ par sa valeur:
\[
JH = J1 + 2 JA - 1 -J
\]
puis en utilisant la borne supe'rieure sur $J$, on obtient une ine'galite'
entre $JH$ et $J$:
\[
JH \geq J1 + J - 1
\]
Malheureusement, cette ine'galite' ne permet pas de conclure. Il faudrait
aussi avoir l'information:
\[
J1 >= 2
\]
qui est tre`s vraisemblable puisque {\tt J1} est incre'mente' de un
initialement et que l'utilisateur donne probablement des dimensions
strictement positives.

L'analyse se'mantique se re've`le ici impuissante. Il aurait fallu avoir
connaissance des contraintes implicites respecte'es par l'utilisateur
quand il cre'e son fichier de donne'es.

La valeur de {\tt JH} par rapport a` {\tt J1} et {\tt JA} est critique
dans l'ensemble du programme {\tt aile}. On retrouve le me^me test pour
les boucles 700 et 710 de {\tt extr} et pour {\tt clcoupk}. Les listings
FPP de Cray montrent que la paralle'lisation de ces boucles est
envisage'es mais abandonne'es en attence de directives de
paralle'lisation explicite. C'est donc l'ensemble du processus de
paralle'lisation et non seulement la paralle'lisation interproce'durale
qui profiterait de l'analyse se'mantique.

\section{Programme {\tt oa118}}

Le programme {\tt oa118} contient trois routines susceptibles
de contenir une boucle paralle`le avec appel de proce'dure: {\tt pmat},
{\tt grad1} et le programme principal lui-me^me, {\tt oa118}.

\subsection{Analyse du module {\tt pmat}}

La proce'dure {\tt pmat} est tre`s simple puisqu'elle effectue un
produit matrice x vecteur a` l'aide d'une proce'dure calculant
un produit scalaire, {\tt sdot}.

Voici le code paralle'lise' de {\tt pmat}:
\begin{verbatim}
      SUBROUTINE PMAT(V,W)
C
      PARAMETER(NFAC=49)
      COMMON/OACOF/AA(NFAC,NFAC)
      DIMENSION V(1),W(1),C(NFAC)
C
      DO 10 I = 1,NFAC,1
         PRIVATE I
         DOALL 20 J = 1,NFAC,1
            PRIVATE J
20          C(J) = AA(I,J)
         W(I) = SDOT(NFAC, C, 1, V, 1)
1O    CONTINUE
      RETURN
      END
\end{verbatim}
ainsi que le code se'quentiel de {\tt sdot}:
\begin{verbatim}
      FUNCTION SDOT(N,X,INCX,Y,INCY)
      REAL*4 X(1),Y(1),SDOT
      SDOT = 0.0           
      IX = 1               
      IY = 1               
      DO 10 I = 1,N,1      
         SDOT = (SDOT+(X(IX)*Y(IY)))
         IX = (IX+INCX)             
         IY = (IY+INCY)             
10       CONTINUE                   
      ENDDO
      RETURN
      END
\end{verbatim}

L'appel a` {\tt sdot} ne pose pas de proble`me de paralle'lisation puisqu'il
s'agit d'une fonction pure comme le trouve PIPS. Voici les effets
cumule's trouve's automatiquement:
\begin{verbatim}
C		< MAY BE READ   >: Y X INCX INCY
C		<MUST BE READ   >: N
       FUNCTION SDOT(N,X,INCX,Y,INCY)
\end{verbatim}

Il s'agit donc encore une fois d'un proble`me de paralle'lisation
intraproce'dural dans {\tt pmat}. Le vecteur {\tt C} est utilise' pour
stocker une par une les lignes de la matrice {\tt AA}. Pour
paralle'liser la boucle 10 sur I, il faudrait e^tre capable d'expanser
ou de privatiser {\tt C} ce que ne sait pas faire PIPS.

Une autre approche consisterait a` profiter de l'incre'ment {\tt INCX} passe'
en argument a` {\tt sdot}. En lui donnant la valeur {\tt NFAC} et en
passant {\tt AA} directement, on peut faire l'e'conomie de la transposition
implicitement effectue'e par le biais de {\tt C}. Le passage d'argument
{\tt AA}/{\tt X} de'clenche un message d'avertissement {\em bad reshaping}
mais le code ge'ne're' est maintenant paralle`le:
\begin{verbatim}
C     MODIFIED EXCERPT OF OA118
C     
      SUBROUTINE PMAT(V,W)
C     
      PARAMETER(NFAC=49)
      COMMON/OACOF/AA(NFAC,NFAC)
      DIMENSION V(1),W(1)
C     
      DOALL 10 I = 1,NFAC,1
         PRIVATE I
         W(I) = SDOT(NFAC, AA(I,1), NFAC, V, 1) 
      ENDDO
      RETURN
      END
\end{verbatim}

\subsection{Analyse du module {\tt grad1}}

Le module {\tt grad1} est forme' de 60 lignes de Fortran. Le coeur de
l'algorithme est une boucle while, re'alise'e par l'instruction {\tt DO 2}
et par le test {\tt IF(RR.LT.RRM)GO TO 11}. Ce {\tt DO} avec {\tt exit}
est transforme' en un {\tt while} implicite par la phase de construction
du graphe de contro^le hie'rarchique.

A l'inte'rieur du corps de cette boucle, la zone inte'ressante pour
le paralle'lisme interproce'dural est la suivante:
\begin{verbatim}
      DO 3 II = 1,IPQ,1                        
         DO 4 I = 1,NFAC,1                     
4           Y(I) = S(I,II)                     
         DO 5 JJ = II,IPQ,1                    
            DO 6 I = 1,NFAC,1                  
               PRIVATE I
6              Z(I) = S(I,JJ)                  
            A(II,JJ) = SDOT(NFAC, Y, 1, Z, 1)  
5           A(JJ,II) = A(II,JJ)                
         DO 7 I = 1,NFAC,1                     
7           Z(I) = R(I,IPP0)                   
3        RS(II) = SDOT(NFAC, Y, 1, Z, 1)       
\end{verbatim}

La version paralle`le produite par PIPS ne contient pas de paralle'lisme
interproce'dural:
\begin{verbatim}
      DO 3 II = 1,IPQ,1
         DOALL 4 I = 1,NFAC,1
            PRIVATE I
4           Y(I) = S(I,II)                                             
         ENDDO
         DO 5 JJ = II,IPQ,1
            DOALL 6 I = 1,NFAC,1
               PRIVATE I
6              Z(I) = S(I,JJ)                                          
            ENDDO
            A(II,JJ) = SDOT(NFAC, Y, 1, Z, 1)                          
         ENDDO
         DO 5 JJ = II,IPQ,1
5           A(JJ,II) = A(II,JJ)                                        
         ENDDO
         DOALL 7 I = 1,NFAC,1
            PRIVATE I
7           Z(I) = R(I,IPP0)                                           
3        RS(II) = SDOT(NFAC, Y, 1, Z, 1)                               
\end{verbatim}
Seules les boucles triviales qui servent a` effectuer des copies
sont paralle'lise'es. La recopie dans la sous-colonne {\tt A(II:IPQ,II)}
de la sous-ligne {\tt A(II,II:IPQ)} est distribue'e. Elle n'est pas
paralle`le parce que l'e'le'ment diagonal est inutilement recopie'
et que cette copie provoque une {\em output dependence}.

Vu les spe'cifications du module {\tt sdot}, il est possible d'e'liminer
les multiples recopies que contient cette partie de code et de faire
les appels a` {\tt sdot} directement sur les tableaux {\tt S} et {\tt R}.
Le code se'quentiel devient:
\begin{verbatim}
      DO 3 II = 1,IPQ,1                        
         DO 5 JJ = II,IPQ,1                    
            A(II,JJ) = SDOT(NFAC, S(1,II), 1, S(1,JJ), 1)  
5           A(JJ,II) = A(II,JJ)                
3        RS(II) = SDOT(NFAC, S(1,II), 1, R(I,IPP0), 1)       
\end{verbatim}
et l'e'diteur de liens de'tecte un {\em bad reshaping} entre {\tt S} et
{\tt R} d'une part, et {\tt X} et {\tt Y} d'autre part, puisque les
tableaux n'ont pas le me^me nombre de dimensions.

La distribution de boucles produit l'effet attendu:
\begin{verbatim}
      DO 3 II = 1,IPQ,1
         DO 5 JJ = II,IPQ,1
            A(II,JJ) = SDOT(NFAC, S(1,II), 1, S(1,JJ), 1)               0028
         ENDDO
      ENDDO
      DO 3 II = 1,IPQ,1
         DO 5 JJ = II,IPQ,1
5           A(JJ,II) = A(II,JJ)                                         0029
         ENDDO
      ENDDO
      DO 3 II = 1,IPQ,1
3        RS(II) = SDOT(NFAC, S(1,II), 1, R(1,IPP0), 1)                  0030
      ENDDO
\end{verbatim}

Le calcul des effets des appels a` {\tt sdot} ne pose pas de proble`me
malgre' le {\em bad reshaping} parce qu'il s'agit d'une fonction pure:
\begin{verbatim}
C		< MAY BE READ   >: II
C		<MUST BE READ   >: IPQ
C		<MUST BE WRITTEN>: II
      DO 3 II = 1,IPQ,1
C		< MAY BE READ   >: JJ
C		<MUST BE READ   >: II IPQ
C		<MUST BE WRITTEN>: JJ
         DO 5 JJ = II,IPQ,1
C		< MAY BE READ   >: S
C		<MUST BE READ   >: II JJ
C		<MUST BE WRITTEN>: A(II,JJ)
            A(II,JJ) = SDOT(NFAC, S(1,II), 1, S(1,JJ), 1)
         ENDDO
      ENDDO
C		< MAY BE READ   >: II
C		<MUST BE READ   >: IPQ
C		<MUST BE WRITTEN>: II
      DO 3 II = 1,IPQ,1
C		< MAY BE READ   >: JJ
C		<MUST BE READ   >: II IPQ
C		<MUST BE WRITTEN>: JJ
         DO 5 JJ = II,IPQ,1
C		<MUST BE READ   >: JJ II A(II,JJ)
C		<MUST BE WRITTEN>: A(JJ,II)
5           A(JJ,II) = A(II,JJ)                      
         ENDDO
      ENDDO
C		< MAY BE READ   >: II
C		<MUST BE READ   >: IPQ
C		<MUST BE WRITTEN>: II
      DO 3 II = 1,IPQ,1
C		< MAY BE READ   >: S R
C		<MUST BE READ   >: II
C		<MUST BE WRITTEN>: RS(II)
3        RS(II) = SDOT(NFAC, S(1,II), 1, R(1,IPP0), 1) 
      ENDDO
\end{verbatim}

Par contre, la paralle'lisation n'est pas possible parce que les
variables {\tt II} et {\tt JJ} ne sont pas privatise'es:
\begin{verbatim}
      DO 3 II = 1,IPQ,1
         DO 5 JJ = II,IPQ,1
            A(II,JJ) = SDOT(NFAC, S(1,II), 1, S(1,JJ), 1)  
         ENDDO
      ENDDO
      DO 3 II = 1,IPQ,1
         DO 5 JJ = II,IPQ,1
5           A(JJ,II) = A(II,JJ)                            
         ENDDO
      ENDDO
      DO 3 II = 1,IPQ,1
3        RS(II) = SDOT(NFAC, S(1,II), 1, R(1,IPP0), 1)     
      ENDDO
\end{verbatim}
L'examen des effets de cette version de {\tt grad1} n'a pas permis de
trouver l'origine de ce proble`me.

Si on isole cette partie, c'est la distribution de boucle qui ne marche plus:
\begin{verbatim}
      DO 3 II = 1,IPQ,1
         PRIVATE II
         DOALL 5 JJ = II,IPQ,1
            PRIVATE JJ
            A(II,JJ) = SDOT(NFAC, S(1,II), 1, S(1,JJ), 1) 
         ENDDO
         DOALL 5 JJ = II,IPQ,1
            PRIVATE JJ
5           A(JJ,II) = A(II,JJ)                           
         ENDDO
      ENDDO
      DOALL 3 II = 1,IPQ,1
         PRIVATE II
3        RS(II) = SDOT(NFAC, S(1,II), 1, R(1,IPP0), 1)     
      ENDDO
\end{verbatim}
L'origine de ce comportement n'a pas encore e'te' e'lucide' non plus.

La complexite' de {\tt solv3}, qui effectue la re'solution d'un syste`me
line'aire, est du me^me ordre de grandeur que l'initialisation de la
matrice syme'trique {\tt A}: $O(n^3 )$. Il est donc important de de'tecter
le paralle'lisme interproce'dural.

\subsection{Qualite' du code de {\tt oa118}}

Le programmeur ne semble pas mai^triser pleinement le langage FORTRAN.
Ou bien il a essaye' d'appliquer des optimisations manuelles qu'il n'a
pas documente'es.  De nombreuses recopies de tableaux, inutiles a
priori, limitent la paralle'lisation parce que l'expansion et/ou la
privatisation de tableaux ne sont pas effectue'es.

\subsection{Analyse du module {\tt oa118}}

Le programme principal, 392 lignes de FORTRAN, contient les appels suivants:
\begin{verbatim}
OA118
        OAMET           (94 lignes)
        OAMAT1          (120 lignes)
        GRAD1           (62 lignes)
        do
                PHWAK   (86 lignes)
                GRAD1   (62 lignes)
        enddo
        SOLV            (25 lignes)
        PHWPAN          (85 lignes)
        GRAD1           (62 lignes)
        do
                OAVITEL (487 lignes)
        enddo
\end{verbatim}

Il est trop complexe pour pouvoir e^tre analyse' sans connaissance
de ses fonctionnalite's.

\subsection{Re'sultats obtenus avec {\tt oa118}}

Ce programme contient potentiellement du parallelisme de trop haut
niveau pour pouvoir e^tre analyse' syntaxiquement. Le paralle'lisme
interproce'dural de niveau moyen est bloque' par des {\em output
dependence} qui sont dues a` la manie`re inhabituelle, voir maladroite,
dont le codage a e'te' effectue'.

\section{Programme {\tt cr2cnf}}

Le programme {\tt cr2cnf} est le plus riche de tous en boucles contenant
des appels de proce'dures. Pas moins de cinq proce'dures, {\tt front},
{\tt invfro}, {\tt zproax}, {\tt matelt} et {\tt mbtelt}, appellent neuf
autres proce'dures ou fonctions, {\tt vmov}, {\tt descen}, {\tt nbdiag},
{\tt choles}, {\tt invopt}, {\tt mxvadd}, {\tt mxv}, {\tt phi} et
{\tt dphi}.

\subsection{Analyse du module {\tt front}}

Le module {\tt front} est si court qu'il est possible d'en donner le
code complet:
\begin{verbatim}
      SUBROUTINE FRONT(A,B,N,NC,AF,C,Z) 
      IMPLICIT REAL*8(A-H,O-Z)
C  ROUTINE DE CALCUL DE LA DECOMPOSITION FRONTALE DE LA MATRICE
C  TRIDIAGONALE PAR BLOCS DEFINIE PAR A(N,N,2) POUR LA SECTION COURANTE
C  ET B(N,N) POUR LE DERNIER BLOC DIAGONAL .
      DIMENSION A(N,N,3),B(N,N),AF(N,N,NC),C(N,N),Z(N,N)
C  INVERSION DU PREMIER BLOC DIAGONAL . 
      CALL CHOLES(A(1,1,1), N, AF(1,1,1), Z)                        
C  COPIE DES BLOCS DIAGONAUX DE LA MATRICE AVANT DECOMPOSITION .
      LA = (N*N)                                                    
      DO 1 NNS = 2,(NC-1),1                                         
1        CALL VMOV(LA, A(1,1,1), AF(1,1,NNS))                       
      CALL VMOV(LA, B(1,1), AF(1,1,NC))                             
C  CONTRACTION PUIS INVERSION DES BLOCS DIAGONAUX DE LA LA MATRICE
C  SECTION PAR SECTION .
      DO 2 NNS = 2,NC,1                                             
         DO 3 J = 1,N,1                                             
3           CALL DESCEN(AF(1,1,(NNS-1)), A(1,J,2), N, C(1,J))       
         CALL NBDIAG(AF(1,1,NNS), C, AF(1,1,(NNS-1)), N)            
         CALL CHOLES(AF(1,1,NNS), N, AF(1,1,NNS), Z)                
2        CONTINUE                                                   
      RETURN
      END
\end{verbatim}

On remarque que le programmeur a profite' de sa connaissance du stockage
des matrices pour effectuer leurs copies a` l'aide d'une routine de
copie de vecteur, {\tt vmov}. Les matrices {\tt A} et {\tt AF} sont
line'arise'es et leur dimension re'sultante est {\tt LA = N * N}. Cette
technique va provoquer un {\em bad reshaping} et PIPS va conclure que
{\tt A} est sans doute lue et que {\tt AF} est sans doute e'crite comme
on le voit ci-dessous (les effets sur la me'moire des instructions sont
indique's en commentaire). La boucle 1 ne peut donc e^tre trouve'e
paralle`le.

On peut se demander pourquoi il n'a pas e'limine' cette boucle 1 en
passant comme longueur {\tt LA*(NC-2)}.

\begin{verbatim}
      SUBROUTINE FRONT(A,B,N,NC,AF,C,Z) 
      IMPLICIT REAL*8(A-H,O-Z)
C  ROUTINE DE CALCUL DE LA DECOMPOSITION FRONTALE DE LA MATRICE
C  TRIDIAGONALE PAR BLOCS DEFINIE PAR A(N,N,2) POUR LA SECTION COURANTE
C  ET B(N,N) POUR LE DERNIER BLOC DIAGONAL .
      DIMENSION A(N,N,3),B(N,N),AF(N,N,NC),C(N,N),Z(N,N)
C  INVERSION DU PREMIER BLOC DIAGONAL . 
C		< MAY BE READ   >: AF CHOLES:Z2 CHOLES:D
C		< MAY BE WRITTEN>: AF CHOLES:Z2
C		<MUST BE READ   >: A N CHOLES:Z1
C		<MUST BE WRITTEN>: CHOLES:D CHOLES:Z1
      CALL CHOLES(A(1,1,1), N, AF(1,1,1), Z)                    
C		<MUST BE READ   >: N
C		<MUST BE WRITTEN>: LA
C  COPIE DES BLOCS DIAGONAUX DE LA MATRICE AVANT DECOMPOSITION .
      LA = (N*N)                                                
C		< MAY BE READ   >: NNS
C		<MUST BE READ   >: NC
C		<MUST BE WRITTEN>: NNS
      DO 1 NNS = 2,(NC-1),1                                     
C		< MAY BE READ   >: A
C		< MAY BE WRITTEN>: AF
C		<MUST BE READ   >: LA
1        CALL VMOV(LA, A(1,1,1), AF(1,1,NNS))                   
C		< MAY BE READ   >: B
C		< MAY BE WRITTEN>: AF
C		<MUST BE READ   >: LA
      CALL VMOV(LA, B(1,1), AF(1,1,NC))                         
C		< MAY BE READ   >: NNS
C		<MUST BE READ   >: NC
C		<MUST BE WRITTEN>: NNS
C  CONTRACTION PUIS INVERSION DES BLOCS DIAGONAUX DE LA LA MATRICE
C  SECTION PAR SECTION .
      DO 2 NNS = 2,NC,1                                         
C		< MAY BE READ   >: J
C		<MUST BE READ   >: N
C		<MUST BE WRITTEN>: J
         DO 3 J = 1,N,1                                         
C		< MAY BE READ   >: AF A((/I,I=1,N,1/),J,2) DESCEN:Y
C		                   DESCEN:C
C		< MAY BE WRITTEN>: C((/I,I=1,N,1/),J) DESCEN:C DESCEN:Y
C		<MUST BE READ   >: N
3           CALL DESCEN(AF(1,1,(NNS-1)), A(1,J,2), N, C(1,J))   
C		< MAY BE READ   >: AF C NBDIAG:Z1 NBDIAG:Z2
C		< MAY BE WRITTEN>: AF NBDIAG:Z2 NBDIAG:Z1
C		<MUST BE READ   >: N
         CALL NBDIAG(AF(1,1,NNS), C, AF(1,1,(NNS-1)), N)        
C		< MAY BE READ   >: CHOLES:Z2 CHOLES:D
C		< MAY BE WRITTEN>: AF CHOLES:Z2
C		<MUST BE READ   >: AF N CHOLES:Z1
C		<MUST BE WRITTEN>: CHOLES:D CHOLES:Z1
         CALL CHOLES(AF(1,1,NNS), N, AF(1,1,NNS), Z)            
2        CONTINUE                                               
      RETURN
      END
\end{verbatim}

Il est a` noter que les tableaux arguments formels de {\tt vmov} sont
de'clare's:
\begin{verbatim}
DIMENSION X(*), Y(*)
\end{verbatim}
alors que l'information ne'cessaire e'tait disponible pour raffiner
ces de'clarations sans ne'cessiter le calcul de re'gions:
\begin{verbatim}
DIMENSION X(LX), Y(LX)
\end{verbatim}

Le cas de la boucle 3 est aussi inte'ressant. On y remarque que les effets
sur les tableaux {\tt A} et {\tt C} sont de'crits avec suffisamment de
finesse pour permettre la paralle'lisation de cette boucle. Cependant, la
proce'dure {\tt descen} manipule localement deux tableaux statiques,
{\tt C} et {\tt Y}, qui ont e'te' alloue's dans le common {\tt TOTO} (sic),
avec des dimensions n'ayant rien a voir avec leur usage courant. Si on
modifie manuellement {\tt descen} en de'clarant {\tt C} et {\tt Y} comme
locaux a` la proce'dure, on obtient bien une boucle 3 paralle`le:
\begin{verbatim}
C     EXCERPT FROM CR2CNF
C
C     SUBROUTINE DESCEN IS MODIFIED SO AS NOT TO USE THE /TOTO/ COMMON
C     AND ITS VARIABLE C AND Y
C
C***********************************************************************
      SUBROUTINE FRONT(A,B,N,NC,AF,C,Z) 
      IMPLICIT REAL*8(A-H,O-Z)
C  ROUTINE DE CALCUL DE LA DECOMPOSITION FRONTALE DE LA MATRICE
C  TRIDIAGONALE PAR BLOCS DEFINIE PAR A(N,N,2) POUR LA SECTION COURANTE
C  ET B(N,N) POUR LE DERNIER BLOC DIAGONAL .
      DIMENSION A(N,N,3),B(N,N),AF(N,N,NC),C(N,N),Z(N,N)
C  INVERSION DU PREMIER BLOC DIAGONAL . 
      CALL CHOLES(A(1,1,1), N, AF(1,1,1), Z)                       
C  COPIE DES BLOCS DIAGONAUX DE LA MATRICE AVANT DECOMPOSITION .
      LA = (N*N)                                                   
      DO 1 NNS = 2,(NC-1),1
1        CALL VMOV(LA, A(1,1,1), AF(1,1,NNS))                      
      CALL VMOV(LA, B(1,1), AF(1,1,NC))                            
C  CONTRACTION PUIS INVERSION DES BLOCS DIAGONAUX DE LA LA MATRICE
C  SECTION PAR SECTION .
      DO 2 NNS = 2,NC,1
         DOALL 3 J = 1,N,1
3           CALL DESCEN(AF(1,1,(NNS-1)), A(1,J,2), N, C(1,J))      
         CALL NBDIAG(AF(1,1,NNS), C, AF(1,1,(NNS-1)), N)           
         CALL CHOLES(AF(1,1,NNS), N, AF(1,1,NNS), Z)               
      RETURN
      END
\end{verbatim}

La paralle'lisation de la boucle 2 est bloque'e par plusieurs facteurs.
Tout d'abord le tableau {\tt C} de {\tt front} n'est alloue' qu'une fois
et il va cre'er des {\em output dependendence}. Ensuite, l'analyse
des effets de {\tt nbdiag} et de {\em choles} sur le tableau {\tt AF} n'est
pas assez fine. Contrairement a` ce qui s'e'tait passe' pour {\tt
descen} et {\tt C}, l'association parame`tre formel/parame`tre re'el
n'est pas accepte'e par PIPS.

\subsection{Analyse des modules {\tt matelt} et {\tt mbtelt}}

Ces deux modules initialisent la matrice {\tt DAE} en appelant une fonction,
{\tt DPHI}, qui appelle elle-me^me une autre fonction, {\tt PHI}. Cette
initialisation semble comple'tement paralle`le dans {\tt mbtelt} mais
PIPS ne trouve qu'une partie du paralle'lisme suite a` la non privatisation
de certains indices de boucles, {\tt I} et {\tt J}:
\begin{verbatim}
C  CALCUL DE LA MATRICE DAE .
      DOALL 6 K = 1,3,1
         PRIVATE K
         DOALL 6 L = 1,3,1
            PRIVATE L
            DO 6 I = 1,6,1
               DO 6 J = 1,6,1
                  DAE(K,I,L,J) = ((DPHI(K, I, Y)*DPHI(L, J, Y))/2.)     0013
               ENDDO
            ENDDO
         ENDDO
      ENDDO
\end{verbatim}
Cette anomalie provient d'une interfe'rence avec les ordres
d'entre'e-sortie qui se trouvent a` la fin du module. Ils contiennent
des boucles implicites utilisant les me^mes indices {\tt I} et {\tt J}
et les effets ne sont pas calcule's assez pre'cise'ment:
\begin{verbatim}
C		<MUST BE READ   >: L K DAE J I
C		<MUST BE WRITTEN>: J I
            WRITE (UNIT=6,FMT=2000) ((DAE(K,I,L,J), J = 1,6,1), I = 1   0028
     &      ,6,1)                                                       0028
\end{verbatim}
On remarque que {\tt I} et {\tt J} sont indique's comme devant e^tre lus
alors que leur e'criture pre'ce`de toujours cette lecture. Les {\em
use-def chains} re'sultantes empe^chent la privatisation et donc la
paralle'lisation des boucles 6 {\tt I} et 6 {\tt J} ci-dessus.

Cette explication semble e^tre la bonne puisque leur renommage en {\tt I1}
et {\tt J1} permet d'obtenir les quatre boucles paralle`les qu'on attendait.

\subsection{Analyse du module {\tt zproax}}

Le module {\tt zproax} est simple:
\begin{verbatim}
      SUBROUTINE ZPROAX(A,B,NOE,NC,X,Y)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(NOE,NOE,3),B(NOE,NOE),X(NOE,NC),Y(NOE,NC)
C  PRODUIT PAR LA MATRICE BLOC TRIDIAGONALE SYMETRIQUE A
C  A(*,*,1) EST LE BLOC DIAGONAL COURANT, A(*,*,2) LE BLOC SUR-DIAGONAL ,
C  A(*,*,3) LE BLOC SOUS-DIAGONAL  .
C  B(*,*) EST LE DERNIER BLOC DIAGONAL
      LYN = (NOE*NC)                                              
      CALL VCLR(LYN, Y)                                           
      NCI = (NC-1)                                                
      DO 1 NNS = 1,NCI,1                                          
         CALL MXVADD(A(1,1,1), NOE, X(1,NNS), NOE, Y(1,NNS))       
         CALL MXVADD(A(1,1,2), NOE, X(1,(NNS+1)), NOE, Y(1,NNS))    
         CALL MXVADD(A(1,1,3), NOE, X(1,NNS), NOE, Y(1,(NNS+1)))    
1        CONTINUE                                                   
      ENDDO
      CALL MXVADD(B, NOE, X(1,NC), NOE, Y(1,NC))                      
      RETURN
      END
\end{verbatim}

Les effets calcule's par PIPS sont les suivants:
\begin{verbatim}
      SUBROUTINE ZPROAX(A,B,NOE,NC,X,Y)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(NOE,NOE,3),B(NOE,NOE),X(NOE,NC),Y(NOE,NC)
C  PRODUIT PAR LA MATRICE BLOC TRIDIAGONALE SYMETRIQUE A
C  A(*,*,1) EST LE BLOC DIAGONAL COURANT, A(*,*,2) LE BLOC SUR-DIAGONAL ,
C  A(*,*,3) LE BLOC SOUS-DIAGONAL  .
C  B(*,*) EST LE DERNIER BLOC DIAGONAL
C		<MUST BE READ   >: NOE NC
C		<MUST BE WRITTEN>: LYN
      LYN = (NOE*NC)                                              
C		< MAY BE WRITTEN>: Y
C		<MUST BE READ   >: LYN
      CALL VCLR(LYN, Y)                                           
C		<MUST BE READ   >: NC
C		<MUST BE WRITTEN>: NCI
      NCI = (NC-1)                                                  
C		< MAY BE READ   >: NNS
C		<MUST BE READ   >: NCI
C		<MUST BE WRITTEN>: NNS
      DO 1 NNS = 1,NCI,1                                               
C		< MAY BE READ   >: A X((/I,I=1,NOE,1/),NNS) Y MXVADD:Z1
C		< MAY BE WRITTEN>: Y MXVADD:Z1
C		<MUST BE READ   >: NOE
         CALL MXVADD(A(1,1,1), NOE, X(1,NNS), NOE, Y(1,NNS))          
C		< MAY BE READ   >: A X((/I,I=1,NOE,1/),(NNS+1)) Y
C		                   MXVADD:Z1
C		< MAY BE WRITTEN>: Y MXVADD:Z1
C		<MUST BE READ   >: NOE
         CALL MXVADD(A(1,1,2), NOE, X(1,(NNS+1)), NOE, Y(1,NNS))     
C		< MAY BE READ   >: A X((/I,I=1,NOE,1/),NNS) Y MXVADD:Z1
C		< MAY BE WRITTEN>: Y MXVADD:Z1
C		<MUST BE READ   >: NOE
         CALL MXVADD(A(1,1,3), NOE, X(1,NNS), NOE, Y(1,(NNS+1)))     
1        CONTINUE                                                    
      ENDDO
C		< MAY BE READ   >: B X((/I,I=1,NOE,1/),NC) Y MXVADD:Z1
C		< MAY BE WRITTEN>: Y MXVADD:Z1
C		<MUST BE READ   >: NOE
      CALL MXVADD(B, NOE, X(1,NC), NOE, Y(1,NC))                        0011
      RETURN
      END
\end{verbatim}
On remarque que {\tt mxvadd} utilise aussi le common {\tt TOTO} pour disposer
d'espace temporaire et que ceci serait suffisant pour empe^cher la
paralle'lisation des appels a` {\tt mxvadd}. 

La rede'claration de {\tt Z1} comme tableau local ne suffirait dependant pas
parce que les effets de {\tt mxvadd} sur le parame`tre {\tt Y} ne sont
pas assez pre'cis. Pour une raison encore inconnue, PIPS ne se rend pas
compte que seule une colonne de {\tt Y} est mise a` jour a` chaque appel.

\subsection{Analyse du module {\tt invfro}}

Le module principal qui est appele' par {\tt invfro} est {\tt invopt}. Ils
communiquent entre eux en utilisant le common {\tt TOTO}, ce qui paralyse
imme'diatement toute tentative de paralle'lisation.

Les appels a` {\tt mxv} se trouvent tous accompagne's d'un ou plusieurs
appels a` {\tt invopt}.

\section{Conclusion}

Les re`gles de programmation suivantes se de'gagent de ces essais:
\begin{enumerate}

  \item le {\tt IF} structure' devrait e^tre utilise' partout ou` c'est
possible pour rendre le code plus clair (les conditions des tests
deviennent plus simples a` interpre'ter) et pour e'liminer une bonne
partie des {\tt GO TO}; l'ajout de la structure de contro^le {\tt
WHILE} permettrait d'e'liminer la plupart des {\tt GO TO} restants,
et me^me peut-e^tre tous (nous ne disposons pas du restructureur
{\em struct} sous SUNOS pour le ve'rifier);

  \item les arguments formels devraient e^tre, autant que possible,
dimensionne's pre'cise'ment. Les de'clarations {\tt A(*)} et surtout
{\tt A(1)} devraient e^tre evite'es, quitte a` passer des arguments
supple'mentaires (ce qui est rarement ne'cessaire parce que
l'information est de toute fac,on disponible pour les bornes de boucles);

  \item e'viter l'utilisation de tableaux temporaires qui vont provoquer
des {\em output dependence}; leur de'tection est techniquement possible
mais n'a pas encore e'te' imple'mente'e, dans aucun syste`me dont nous
avons connaissance;

  \item ve'rifier explicitement les conditions que doivent ve'rifier les
parame`tres de dimensionnement; les tests correspondants permettront a`
l'analyse se'mantique de propager ces conditions sans que l'utilisateur
ait a` ajouter manuellement des pre'dicats (cas de {\tt aile});

  \item de'clarer les tableaux locaux aux proce'dures comme {\em dynamiques}
au lieu de re'utiliser des tableaux en COMMON pour e'conomiser de la
me'moire; il faut que les programmeurs scientifiques s'habituent a`
l'utilisation de la pile; il faudrait que des tableaux de dimension calcule'e
puissent y e^tre alloue's (ce n'est pas dans la norme);

  \item passer les arguments explicitement pluto^t que de les passer par
common;

\end{enumerate}

Les directions de recherche qui se trouvent infirme'es par l'expe'rience
sont:
\begin{itemize}

  \item l'utilisation des re'gions pour repre'senter les effets des
modules; les effets sont assez simples pour e^tre
repre'sente's atomiquement au niveau du module appele'; le vrai
proble`me est celui de la traduction des effets sur les parame`tres
formels en effets sur les parame`tres re'els;

  \item la prise en compte des EQUIVALENCE s'ave`re avoir e'te'
inutile; trois statements EQUIVALENCE en tout et pour tout apparaissent
dans l'ensemble des quatre benchmarks; deux d'entre eux ont e'te'
ajoute's par l'e'quipe PIPS pour e'liminer des de'finitions multiples de
commons; le troisie`me a e'te' mis en commentaire par le programmeur de
l'ONERA; il semble donc raisonnable de mettre parmi les re`gles de
programmation l'interdiction de l'usage de l'ordre EQUIVALENCE;

\end{itemize}

Les directions de recherche du projet PIPS qui se trouvent confirme'es par
l'expe'rience sont:
\begin{itemize}

  \item l'utilite' d'une analyse se'mantique interproce'durale pousse'e,
au-dela` de la progration de constantes qui avait e'te' initialement
pre'vue dans le contrat PIPS;

  \item l'utilite' d'un test de de'pendance puissant pouvant exploiter
les conditions apporte'es par les bornes de boucles et l'analyse se'mantique;

\end{itemize}

Les directions de recherche que nous pouvons de'duire de ces essais
sont les suivantes:
\begin{enumerate}

  \item expansion et/ou privatisation de tableaux; l'utilisation d'effets
de type {\em re'gion} permettrait d'obtenir l'information {\em MUST} au lieu
de l'information {\em MAY} sur les tableaux; il faudrait aussi e^tre capable
de calculer des {\em use/def chains} hie'rarchiques, puisque le {\em kill}
d'un tableau ne peut e^tre obtenu que par une boucle {\tt DO};

  \item meilleure technique de mise en correspondance entre tableau
parame`tre formel et tableau parame`tre re'el; le nombre de messages {\em
bad reshaping} devrait e^tre re'duit; ceci suppose la prise en compte
des re'sultats de l'analyse se'mantique et l'utilisation d'un algorithme
de {\em pattern-matching};

  \item meilleure de'tection des tableaux statiques {\em morts} dans les
proce'dures parce qu'on commence par les affecter; ils devraient e^tre
retire's des effets cumule's des proce'dures (voir {\tt front} et {\tt
descen}); ce proble`me est proche du premier;

\end{enumerate}

L'utilisation des programmes re'els fournis par l'ONERA pour le projet
PIPS a permis tout d'abord de trouver de nombreuses erreurs de
programmation du paralle'liseur. Elle nous permet maintenant de
ve'rifier et de corriger nos directions de recherches. Nous souhaitons
que ceci reste possible pour nos projets futurs, avec des programmes
plus re'cents si possible.

Une e'troite collaboration avec des analystes-nume'riciens connaissant
bien les programmes utilise's comme benchmarks s'ave`rent indispensable.
Elle nous permettrait de de'terminer rapidement ou` les points
inte'ressants des programmes se trouvent et si le paralle'lisme
de'couvert a ou non un inte're^t.

\end{document}
\end
