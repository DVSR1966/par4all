\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS:
		DETECTEUR DE PARALLELISME ET GENERATEUR DE PROGRAMME \\
		RAPPORT DE SYNTHESE }
\newcommand{\auteur}{
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT \\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}
\newcommand{\docdate}{De'cembre 1990}
\newcommand{\numero}{E138}
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\vspace{2cm}

\tableofcontents

\newpage

\section*{Introduction}

La de'tection du paralle'lisme et la production de programmes
paralle`les s'appuient sur les re'sultats obtenus lors de l'analyse
se'mantique (cf. rapport EMP-CAI-I~E137). Ces re'sultats comprennent une
premie`re version du graphe de de'pendance correspondant aux {\em
use-def chains}, des informations sur les effets interproce'duraux des
proce'dures ({\em SDFI}) et des pre'dicats sur les variables scalaires
entie`res du programme.

Modifiant le'ge`rement l'ordre de pre'sentation pre'vu dans le contrat,
nous de'crivons successivement les transformations scalaires qui sont
effectue'es pour supprimer un maximum de de'pendances dues a` cette
classe de variables, le test de de'pendance, propre au CAI, qui fait
intervenir des calculs en nombres entiers et qui supprime un maximum de
de'pendances porte'es par les tableaux, les transformations de
boucles qui sont effectue'es en prenant en compte le graphe de
de'pendance raffine' par la phase pre'ce'dente et enfin la ge'ne'ration
de programmes paralle`les.

Rappelons que les transformations de programmes sont pre'sente'es
globalement dans le rapport EMP-CAI-I~E/141.

\section{Transformations scalaires}

Comme nous l'expliquons dans le rapport consacre' aux transformations de
programme (EMP-CAI-I~E/141), les transformations pre'vues peuvent e^tre
ge'ne'ralise'es en une transformation unique plus ge'ne'rale, la {\em
privatisation}. La privatisation consiste a` de'tecter les variables
dont la dure'e de vie est e'gale a` une ite'ration de corps de boucle et
dont on peut donc ignorer les {\em output} et {\em anti} de'pendances.

Une variable est locale (i.e. prive'e) a` un corps de boucle (on pourra
ulte'rieurement ge'ne'raliser cette notion a` toutes les instructions,
en particulier les blocs) si sa valeur en entre'e de boucle et sa valeur
en sortie ne sont pas utilise'es; c'est typiquement le cas d'une
variable temporaire. Les de'pendances inter-ite'rations dues a` cette
variable peuvent e^tre omises durant la phase de paralle'lisation;
chaque ite'ration de boucle aura sa propre version de cette variable.

Pour effectuer automatiquement ce type de transformation (dont la
fre'quence est tre`s e'leve'e en pratique), les chaines {\em use-def}
sont ne'cessaires pour ve'rifier les conditions de privatisation.  Les
paralle'liseurs qui n'utilisent pas de chaines {\em use-def} ont
ge'ne'ralement recours a` des directives fournies par l'utilisateur
(certifiant le caracte`re non-vivant de ces variables en entre'e et
sortie de boucle) pour effectuer cette ope'ration.

L'algorithme de privatisation est base' sur un calcul d'e'limination.
Toutes les variables sont suppose'es locales aux boucles qui les
englobent. On parcourt alors le graphe de de'pendance (en fait, les
{\em use-def chains}) de telle manie`re que chaque conflit de'termine
le sous-ensemble des boucles englobantes communes qui pre'servent le
conflit. Une fois le graphe de de'pendance parcouru, seules les
de'clarations se'mantiquement correctes de variables locales subsistent.
Ces de'clarations sont stocke'es dans le membre {\tt locals}
de'finissant les boucles (le prettyprinter ge'ne'rant des de'clarations
de type {\tt PRIVATE} quand des variables locales sont pre'sentes).

D'autres transformations scalaires ont e'te' expe'rimente'es dans le
cadre de la de'tection des re'ductions. Voir ci-dessous les
transformations de boucles.

\section{Test de de'pendance}

Le calcul du graphe de de'pendances (voir la structure de donne'es dans
l'annexe 1) est effectue' selon les techniques de calcul line'aire
de'veloppe'es au CAI et publie'es dans les proceedings de SIGPLAN'86. Il
consiste a` raffiner le graphe de de'pendances correspondant aux
{\em use-def chains}. Le calcul pre'cis du graphe des de'pendances est fait en
e'tudiant chaque conflit sugge're' par les {\em use-def chains}. Il est
ne'cessaire de ve'rifier chaque conflit car les {\em use-def chains} ne
tiennent pas compte des indices de tableaux. Cela signifie que certains
conflits existant au niveau des {\em use-def} chaines vont disparai^tre
apre`s le calcul pre'cis des de'pendances. Dans le cas d'une de'pendance
entre deux e'le'ments de tableaux {\tt T(E)} et {\tt T(F)}, il convient
de tester si, en fonction des variables apparaissant dans les
expressions {\tt E} et {\tt F}, ces deux expressions peuvent e^tre
e'gales. Ces variables sont soit des indices de boucles englobantes,
soit des parame`tres de structure, soit des expressions complexes.
Ainsi, la boucle suivante comporte deux conflits sur le tableau {\tt T}
(producteur-con\-som\-ma\-teur et con\-som\-ma\-teur-producteur) dont un
seul subsiste (producteur-con\-som\-ma\-teur) apre`s l'analyse plus
fine.
\begin{verbatim}
        DO I = 1, 10
           T(I) = ...
           ...  = T(I) ...
        ENDDO
\end{verbatim}
On se limite, pour des raisons a` la fois pratique (pre'sence dans les
programmes re'e'ls) et the'orique (de'cidablite' du proble`me), au cas
ou` les expressions d'indice sont des expressions line'aires; si ce
n'est pas le cas, on prend l'attitude conservative consistant a`
supposer l'existence d'un conflit.

Le coeur du calcul des de'pendances est donc forme' de la construction,
puis du test de la faisabilite', d'un syste`me line'aire en nombres
entiers. Ce test de faisabilite' est base' sur une version le'ge`rement
ame'liore'e de l'algorithme d'e'limination de Fourier-Motzkin. Le
premier changement consiste a` traiter les e'galite's, de manie`re
exacte, avant de combiner deux-a`-deux les ine'galite's. 

Le second aspect re'side dans une re'solution incre'mentale du syste`me
de contraintes, en le projetant successivement, niveau par niveau, sur
les sous-espaces de de'pendance et en testant la satisfiabilite' du
syste`me re'sultant, apre`s rajout de contraintes additionnelles de la
forme $di=0$ ou $di>0$ ($i$ est un index de boucle et $di$ correspond a`
la direction de de'pendance a` tester).  

Les programmes de test de de'pendances font massivement appel a` la
bibliothe`que line'aire de'veloppe'e au CAI dans le cadre d'un contrat
avec le PRC $C^3$. Une version objet de cette bibliothe`que est livre'e
avec les sources de PIPS et se trouve dans le re'pertoire
\verb+Utilities+.

Il est aussi ne'cessaire d'e'tudier chaque conflit pour rechercher quelle
boucle le cre'e ve'ritablement. Cette e'tude a pour but de mettre a`
jour le niveau de chaque de'pendance, c'est a` dire d'indiquer quelle
boucle ferait disparai^tre ce conflit si on l'exe'cutait
se'quentiellement. Dans l'exemple pre'ce'dent, le niveau de l'unique
de'pendance sur {\tt T} vaut 2, ce qui signifie que ce conflit ne peut
pas disparai^tre en se'quentialisant une boucle. La boucle unique est
ne'anmoins paralle`le et le conflit est re'solu au sein de chaque ite'ration.

Un point essentiel de Pips concerne la prise en compte des appels de
proce'dures. Les effets de celles-ci, obtenus de manie`re
interproce'durale, sont repercute's au niveau du site d'appel. Les
e'le'ments de tableaux concerne's en lecture ou e'criture sont
pre'cise's par l'interme'diaire des re'gions et des re'sulats de
l'analyse se'mantique (cf. rapport EMP-CAI-I~E137). Ces pre'dicats sont
rajoute's au contexte d'appel (i.e., indices des boucles englobantes)
dans la construction du syste`me de contraintes.

Il est important de remarquer que les de'pendances dues aux variables
locales ne sont pas ignore'es. Les conflits demeurent me^me si les
variables sont locales. Nous allons voir dans la section suivante
comment les variables prive'es sont prises en compte au niveau de la
paralle'lisation. 

Les structures de donne'es utilise'es sont de'crites dans le rapport
EMP-CAI-I E/137 au chapitre consacre' aux {\em use-def chains} pour {\em
graph} et {\em dg} et au chapitre consacre' a` la de'tection des
relations line'aires entre variables pour les syste`mes line'aires.

\section{Transformations de boucles}

Deux transformations de boucles peuvent e^tre effectue'es par PIPS. La
premie`re est la distribution de boucle. C'est la seule qui soit
inte'ressante pour de'tecter du paralle'lisme et pour ge'ne'rer des
instructions vectorielles. Elle est faite en utilisant l'algorithme
d'Allen \& Kennedy cite' ci-dessous, soit isole'ment, soit couple'e avec
la de'tection du paralle'lisme. A noter que cette tranformation n'est
inte'ressante que dans le cas ou` l'architecture-cible est munie d'une
unite' vectorielle. PIPS e'tant un paralle'liseur ge'ne'rique, le choix
de la mise en place de cette transformation est laisse' a`
l'utilisateur. Cette transformation est couple'e avec le prettyprinter;
celui-ci utilise, sur demande de l'utilisateur, la syntaxe ``vecteur''
de Fortran 90 pour imprimer les boucles vectorielles.

La seconde transformation est l'e'change de boucle. Elle est implante'e
comme un cas particulier de transformation unimodulaire en utilisant les
algorithmes de'crits par Franc,ois Irigoin dans {\em Dependence
Approximation and Global Parallel Code Generation for Nested Loops},
International Workshop on Parallel and Distributed Algorithms, Bonas,
1988, dans {\em Code Generation for the Hyperplane Method and Loop
Interchange}, rapport EMP-CAI-I~E/102, et dans {\em Scanning Polyhedra
with DO Loops}, PPoPP'91. Cette transformation n'a pas pu e^tre
inte'gre' dans le paralle'liseur, faute de machine cible permettant de
de'river une fonction de choix. Elle ne produit pas de paralle'lisme et
elle peut e^tre applique'e de beaucoup de manie`res diffe'rentes: le
choix en est donc laisse' a` l'utilisateur et n'est pas fait
automatiquement. Si plus tard une machine cible est de'fini, il sera
possible de l'utiliser pour faire varier la granularite' du
paralle'lisme et/ou pour ame'liorer la localite'.

Une dernie`re transformation, encore au stade expe'rimental, a e'te'
imple'mente'e en CommonLISP, mais n'a pas e'te' inte'gre'e. Elle
effectue la de'tection des re'ductions ge'ne'ralise'es, i.e. des
invariants de boucle, des variables d'induction et des re'ductions. Cet
algorithme est base' sur la communication de Pierre Jouvelot et Babak Dehbonei
intitule'e {\em A Unified Semantic Approach for the Vectorization and
Parallelization of Generalized Reductions} qui a e'te' publie'e dans les
proceedings de la confe'rence internationale ACM SIGARCH ICS'89. La
de'tection des re'ductions, tels les produits scalaires, permet la mise
en e'vidence d'ope'rations ge'ne'ralement efficacement imple'mente'es
sur les superordinateurs actuels. PIPS e'tant un outil ge'ne'rique, il
n'est cependant pas possible de conside'rer que ces tranformations
augmentent a` tout coup le paralle'lisme.

\section{Ge'ne'ration de programmes paralle`les}

L'algorithme de paralle'lisation utilise' est une variante de celui
d'Allen \& Kennedy.  Il est de'taille' dans la revue {\em ACM TOPLAS}
volume 9, nume'ro 4 d'octobre 1987. Il travaille sur les boucles
imbrique'es qui ne comportent pas de branchements. A noter que la
pre'sence du graphe de contro^le structure' dans PIPS permet de masquer
l'existence de banchements locaux, autorisant ainsi un accroissement du
nombre de boucles susceptibles d'e^tre traite'es par le paralle'liseur.
Contrairement a` l'algorithme d'Allen \& Kennedy classique, la technique
de paralle'lisation utilise'e est donc de'finie de manie`re re'cursive;
si une boucle contient un branchement, les instructions de son corps
sont re'cursivement analyse'es tandis que si elle est bien structure'e,
la paralle'lisation est effectue'e.

Le calcul des composantes fortement connexes du graphe des de'pendances
et le tri topologique de ces composantes sont faits en utilisant des
algorithmes classiques, pre'sente's dans l'ouvrage {\em TYPES DE DONNEES
ET ALGORITHMES --- Recherche, Tri, Algorithmes sur les Graphes} par
Marie-Claude Gaudel, Miche`le Soria et Christine Froidevaux dans la
collection Didactique de l'INRIA. 

Il nous a fallu adapter l'algorithme de Allen et Kennedy pour pouvoir
paralle'liser les boucles comportant des conflits dues aux variables
locales. En effet, la version standard
de cet algorithme ne sait pas traiter par
exemple la boucle suivante:
\begin{verbatim}
        DO I = 1, 10
           PRIVATE S
           S = T(I) ...         (1)
           U(I) = S ...         (2)
        ENDDO
\end{verbatim}
En effet, si le conflit sur {\tt S} con\-som\-ma\-teur-producteur de 2 vers 1
est conserve', la boucle reste se'quentielle; et si le conflit est
de'truit par la phase de calcul des de'pendances la boucle est
distribue'e et on obtient:
\begin{verbatim}
        DOALL I = 1, 10
           PRIVATE S
           S = T(I) ...         (1)
        ENNDO
        DOALL I = 1, 10
           PRIVATE S
           U(I) = S ...         (2)
        ENDDO
\end{verbatim}
ce qui n'est pas correct.

La solution que nous avons adopte'e consiste a` conserver tous les
conflits, de fac,on a` empe^cher les mauvaises distributions de boucle,
et a` analyser a posteriori chaque boucle de'clare'e se'quentielle par
Kennedy et Allen pour ve'rifier si les cycles sont brise's lorsque les
conflits dus aux variables prive'es sont ignore's. Dans ce dernier cas,
la boucle est de'clare'e paralle`le.

Dans l'annexe technique du contrat PIPS, il e'tait pre'vu de ge'ne'rer
des boucles DOACROSS. Cette construction, propose'e en 1984 par Ron
Cytron dans son PhD, constitue une extension inte'ressante des boucles
se'quentielles et paralle`les. Elle permet d'exprimer un pourcentage
de paralle'lisme fonction du recouvrement possible des ite'rations
de corps de boucle. Les boucles paralle`les correspondent a` un
recouvrement complet (100~\%) et les boucles se'quentielles a` un
recouvrement nul (0~\%).

La ge'ne'ration de boucle DOACROSS a e'te' abandonne'e parce qu'aucun
re'sultat expe'rimental n'est venu en montrer l'inte're^t pour des
programmes re'els tournant sur des machines du commerce.

\section{Conclusion}

Outil de paralle'lisation ge'ne'rique, PIPS permet la mise en e'vidence
du paralle'lisme de type vectoriel ou MIMD. La phase de de'tection du
paralle'lisme utilise une version ame'liore'e de l'algorithme d'Allen \&
Kennedy pour prendre en compte la pre'sence des variables locales au
corps des boucles et la structure du graphe de contro^le de PIPS.

\section{Annexe: Description du graphe de de'pendances}

\input{dg.datastructure}

\end{document}
