\documentstyle[12pt]{farticle}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS-CRAY \\
		ETAT D'AVANCEMENT DES TRAVAUX No 1
}

\newcommand{\auteur}{
		Bruno BARON \\
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT \\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01.018 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}

% pour importer des structures de donne'es Newgen
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\docdate}{7 Janvier 1992}
\newcommand{\numero}{E161}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01.018 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\vspace{2cm}

\tableofcontents

\newpage

\section*{Introduction}
Commence' depuis trois mois, le contrat Pips-Cray avance simultane'ment
sur plusieurs fronts que nous pre'sentons dans ce rapport d'avancement:
la de'tection des re'ductions ge'ne'ralise'es, le remplacement des
constantes, la se'lection du paralle'lisme utile et enfin le de'roulage
de boucle.

Il faut noter que nous n'avons pu commencer les tests sur machine Cray
a` cause d'un retard dans l'ouverture d'un compte sur l'une des machines
du CEA (proble`mes de proce'dure lie's a` l'e'puisement de certains
cre'dits cote's CEA).  Compte tenu de l'ampleur du travail a re'aliser,
cela ne nous a pas empe^che' de progresser.


\section{Re'ductions ge'ne'ralise'es}
Un des volets du contrat PIPS-Cray concerne l'imple'mentation des
ope'rations de re'ductions, comme la somme de vecteurs ou le produit
interne.  Une me'thode puissante, appelle'e {\em re'ductions
ge'ne'ralise'es}, a e'te' envisage'e pour e^tre inte'gre'e dans PIPS.
Elle est de'crite dans la publication scientifique {\em A Unified
Semantic Approach for the Vectorization and Parallelization of
Generalized Reductions} par Pierre Jouvelot et Babak Dehbonei et
pre'sente' a` la {\em 1989 ACM SIGARCH International Conference on
Supercomputing} en Crete. 

Etant donne' le caracte`re avance' de cet algorithme, il a e'te' convenu
de l'imple'menter en CommonLISP, utilisant pour cela les facilite's de
compatibilite' qu'offre l'outil NewGen qui sert de base aux
de'veloppements de PIPS.  D'un point de vue pratique, l'essentiel a
consiste' jusqu'a` pre'sent a` remettre a` jour l'environnement
PIPS/CommonLISP qui n'avait pas e'te' utilise' depuis plusieurs
semestres.  Des routines de lecture des bases de donne'es {\tt
pipsdbm/pipsmake} ont e'galement e'te' e'crites et sont en cours de
validation.  Dans les prochains mois, l'imple'mentation du coeur de
l'algorithme, de'ja` imple'mente' une premie`re fois au Centre de
Recherche BULL, devrait e^tre poursuivie et teste'e.


\section{Remplacement de constantes}
Les analyses se'mantiques interproce'durales re'alise'es dans Pips
permettent de connai^tre les valeurs de variables scalaires entie`res en
certains points du programme.  Ces variables peuvent donc e^tre
remplace'es par leur valeur.  C'est l'objectif de la passe de
remplacement de constantes, pre'vue par ce contrat.

Un prototype de cette passe remplace les constantes dans les expressions
suivantes:
\begin{itemize}
  \item la condition de l'instruction \verb+IF+, 
  \item les bornes et l'incre'ment des boucles \verb+DO+
\end{itemize}
Les valeurs des variables scalaires entie`res de ces expressions sont
e'value'es a` partir des pre'conditions associe'es a` l'instruction dont
fait partie l'expression. Pour cela, la fonction
sc\_minmax\_of\_variable() projette les e'quations du syste`me de
pre'conditions sur la dimension associe'e a` la variable pour obtenir un
intervalle de variation re'duit a` un e'le'ment pour les constantes et
e'gal a` $Z\!\!\!\!Z$ pour les variables dont on ne sait rien.

Ce prototype devrait permettre de concevoir une passe plus ge'ne'rale
qui inte`gre le remplacement des constantes, l'e'valuation partielle de
l'expression et la simplification des sous-expressions line'aires.


\section{Se'lection du paralle'lisme}
L'une des difficulte's majeures de ce projet consiste a` se'lectionner
le paralle'lisme utile parmi celui que le projet pre'ce'dent, PIPS, a
mis en e'vidence. En effet parmi les boucles paralle'lisables certaines
devraient e^tre retenues comme boucles vectorielles, d'autres pour
partager l'exe'cution de leurs ite'rations par diverses taches
paralle`les (micro-tasking), alors que d'autres encore doivent rester
se'quentielles. La complexite' de cette se'lection est spe'cialement
accrue par la diversite' des transformations disponibles afin
d'optimiser le temps d'exe'cution d'un nid de boucles.

Afin d'obtenir dans un de'lai raisonnable une version simple du
ge'ne'rateur de code paralle`le pour Cray, une me'thode rudimentaire
consiste a` choisir dans un nid de boucle (qui a e'te' paralle'lise'
avec l'algorithme de Kennedy et Allen) la boucle la plus interne pour la
vectorisation si elle est paralle'lisable, et une boucle externe
paralle'lisable pour la paralle'lisation; les autres boucles restent
se'quentielles. Cela a e'te' imple'mente' dans la librairie ``{rice}''
sans prendre en compte le paralle'lisme imbrique' entre proce'dures et
fonctions. En fait, il a suffi d'inhiber la paralle'lisation des
boucles autres que celles retenues ci-dessus. Il faudra par la suite
tenir compte de l'interproce'duralite' pour la se'lection du
paralle'lisme.

La proprie'te' boole'enne \verb+GENERATE_NESTED_PARALLEL_LOOPS+ doit
e^tre \verb+FALSE+ pour activer cette se'lection. Ensuite il suffit de 
paralle'liser le code comme d'habitude: ``Display para''. Voir l'exemple
en annexe.


\section{De'roulage de boucle}
Dite ``loop unrolling'', cette transformation consiste a` diminuer le
nombre d'ite'ration de la boucle de'roule'e en regroupant plusieurs
ite'rations du corps de boucle en une seule. Utilise'e a` bon escient,
cela permet d'utiliser tous les registres vectoriels d'un processeur.
De plus, l'overhead de boucle est re'duit gra^ce a` la diminution du
nombre d'ite'rations.

Une premie`re e'tape a consiste' a` imple'menter la transformation en
elle me^me, afin de pouvoir ensuite e'valuer par des tests le gain
obtenu. Cela deviendra possible de`s que l'acce`s au Cray
deviendra effectif et que le pretty-printer Pips ge'ne'rera du Fortran
paralle`le adapte' au Cray (utilisant les directives spe'cifiques
CFT77). 

\subsection{De'finition du de'roulage de boucle}
Les conventions pour de'crire les transformations sont les suivantes:
\begin{itemize}
  \item les nom en lettres minuscules apparaissent tel quel dans le
texte du programme re'el.
  \item les nom en majuscules de'signent dans le programme re'el:
     \subitem une expression s'il ont le suffixe \_EXP
     \subitem un entier s'ils ont le suffixe \_INT
     \subitem une fonction de la variable IND qui ge'ne`re le code du
corps de boucle pour BODY(IND). La valeur retourne'e pour IND valant
EFF\_EXP s'e'crit BODY(IND \ EFF\_EXP)
     \subitem une variable a` de'faut.
\end{itemize}

Soit la boucle initiale:
\begin{verbatim}
      do IND = LB_EXP, UB_EXP, INC_EXP
         BODY(IND)
      enddo
\end{verbatim}
La boucle de'roule'e \verb+RATE_INT+ fois est alors de la forme:
\begin{verbatim}
      lu_nub = (UB_EXP - LB_EXP + INC_EXP) / INC_EXP
      lu_ib = mod(lu_nub, RATE_INT)
      do lu_ind = 0, lu_ib-1, 1
         BODY(IND \ (lu_ind*INC_EXP + LB_EXP))
      enddo
      do lu_ind = lu_ib, lu_nub-1, RATE_INT
         BODY(IND \ (lu_ind*INC_EXP + LB_EXP))
         BODY(IND \ ((lu_ind+1)*INC_EXP + LB_EXP))
         ...
         BODY(IND \ ((lu_ind+(RATE_INT-1))*INC_EXP + LB_EXP))
      enddo
      IND = LB_EXP + max(lu_nub, 0)*INC_EXP
\end{verbatim}

\subsection{Conditions de validite'}
Les conditions suivantes doivent e^tre ve'rifie'es dans la fonction
\verb+loop_unroll_consistent_p()+ appele'e avant d'appliquer la
transformation:
\begin{itemize}
  \item le taux de de'roulage doit e^tre un entier supe'rieur ou e'gal
a` 1. 
  \item les trois expressions que comporte le \verb+range+ de la boucle
doivent e^tre entie`res, ainsi que l'indice de boucle.
  \item les expressions du {\tt range} doivent n'avoir aucun effet de
bord. Il faudrait donc ve'rifier que les {\em effets propres} de la boucle
initiale ne comportent aucun {\tt write}.
  \item le corps de la boucle initiale ne doit pas comporter de point
d'entre'e (GOTO un label a` l'inte'rieur de la boucle), ni de
rede'finition de l'indice de boucle; cela est garanti par la norme
Fortran 77, paragraphes 11.10.8 et 11.10.5 respectivement.
  \item le entite's cre'e'es pour la transformation ne doivent pas
pre'exister dans le code (lu\_nub, lu\_ib et lu\_ind). Il faudra par la
suite palier cette restriction.
\end{itemize}

\subsection{Preuve de validite'}
Une transformation de programme est valide si elle ne modifie pas
la se'mantique de ce programme. Dans le cas d'une boucle, cela revient
a` montrer que le corps de boucle est exe'cute' le me^me nombre de fois
dans le me^me ordre avec des indices tels que l'on retombe sur
l'exe'cution initiale. De plus, l'indice de la boucle initiale doit
avoir la me^me valeur en fin d'exe'cution dans les deux cas.

Nous conside'rons dans la preuve des e'tapes interme'diaires: la boucle
est d'abord normalise'e (dans le cas \verb+INC_EXP+ positif puis dans le
cas \verb+INC_EXP+ ne'gatif). Cette normalisation permet en particulier
d'unifier les deux cas pre'ce'dents, tout en restant conforme a` la
norme Fortran 77. La boucle normalise'e pre'sente la forme suivante,
pour tout \verb+INC_EXP+:
\begin{verbatim}
      lu_nub = (UB_EXP - LB_EXP + INC_EXP) / INC_EXP
      do lu_ind = 0, lu_nub-1, 1
         BODY(IND \ (lu_ind*INC_EXP + LB_EXP))
      enddo
      IND = LB_EXP + max(lu_nub, 0)*INC_EXP
\end{verbatim}
Le de'roulement de boucle est ensuite applique' a` cette boucle
normalise'e.

\subsection{Opportunite'}
La fonction de de'cision devra juger de l'opportunite' de la
transformation, et choisir le taux de de'roulage. Elle devra tenir
compte:
\begin{itemize}
  \item du nombre d'ite'rations,
  \item du nombre de vecteurs en registre dans cette boucle,
  \item du nombre d'ope'rations dans la boucle.
\end{itemize}


\section*{Conclusion}
Les travaux pour le projet PIPS-Cray progressent normalement.  De`s que
l'acce`s a` un Cray nous sera possible et que les tests vont pouvoir
commencer, nous allons imple'menter le ge'ne'rateur de code paralle`le
spe'cifique CFT77.

\newpage

\section*{Annexe A}
\subsection*{Exemple de se'lection du paralle'lisme}
Soit la fonction de calcul du produit de matrice:
\begin{verbatim}
      SUBROUTINE MATMUL(N, A, B, C)
      REAL*8 A(N,N), B(N,N), C(N,N)
      DO I = 1,N
         DO J = 1,N
            C(I,J) = 0.0
            DO K = 1,N
               C(I,J) = C(I,J) + A(I,K)*B(K,J)
            ENDDO
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

Apre`s paralle'lisation sans la se'lection, on obtient le maximum de
boucles paralle`les:
\begin{verbatim}
      SUBROUTINE MATMUL(N, A, B, C)
      REAL*8 A(N,N), B(N,N), C(N,N)
      DOALL I = 1, N
         DOALL J = 1, N
            C(I,J) = 0.0
         ENDDO
      ENDDO
      DOALL I = 1, N
         DOALL J = 1, N
            DO K = 1, N
               C(I,J) = C(I,J)+A(I,K)*B(K,J)
            ENDDO
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

Apre`s paralle'lisation avec la se'lection (en ajoutant dans un fichier
./properties.rc la ligne 
``\verb+GENERATE_NESTED_PARALLEL_LOOPS FALSE+''), la seconde boucle J
n'est pas paralle`le. En effet, la boucle externe I est paralle`le, et
la boucle K plus interne empe`che la vectorisation:
\begin{verbatim}
      SUBROUTINE MATMUL(N, A, B, C)
      REAL*8 A(N,N), B(N,N), C(N,N)
      DOALL I = 1, N
         DOALL J = 1, N
            C(I,J) = 0.0
         ENDDO
      ENDDO
      DOALL I = 1, N
         DO J = 1, N
            DO K = 1, N
               C(I,J) = C(I,J)+A(I,K)*B(K,J)
            ENDDO
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}
Remarquer que sur machine Cray, la premie`re boucle J sera vectorielle,
alors que les deux boucles I seront exe'cute'es avec le micro-tasking.

\end{document}
