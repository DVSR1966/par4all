\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\titre}{RAPPORT D'AVANCEMENT No 5 (LOT 6)\\
                    ANALYSEUR S\'EMANTIQUE ET D\'ETECTEUR DE PARALL\'ELISME}
\newcommand{\auteur}{
        Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{De'cembre 1989}
\newcommand{\numero}{E124}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\SEC{Introduction}
\PAR{}
Ce rapport interme'diaire donne l'e'tat d'avancement de nos travaux sur
l'analyse se'mantique et la de'tection du paralle'lisme.

\PAR{}
Dans le cadre de l'analyse se'mantique, nous de'taillons dans la section
\ref{AS} les modifications apporte'es a` la repre'sentation interme'diaire pour
stocker:
\begin{itemize}
  \item les informations relatives au calcul des pre'dicats par la me'thode
	de Cousot et Halbwachs (transformeur de pre'dicats),
  \item les pre'dicats calcule's eux-me^mes,
  \item et les informations interproce'durales affe'rentes a` chaque module
	(effets en lecture et e'criture et transformateur de pre'dicat).
\end{itemize}
Transformeurs de pre'dicats et pre'dicats sont stocke's au niveau
{\tt statement}.

\PAR{}
Dans la cadre de la de'tection du paralle'lisme, nous pre'sentons dans
la section \ref{DP} les applications faites du graphe de contro^le
structure' (cf.  pre'ce'dent rapport) dans le domaine de la construction
des chaines {\em use-def}, de leur utilisation pour la privatisation de
variables et la construction du graphe de'pendance et, enfin, de
l'adaptation de l'algorithme de Allen et Kennedy.

\PAR{}
La repre'sentation interme'diaire du projet PIPS ayant e'te' largement
augmente'e au cours des derniers mois, nous donnons en annexe le listing
complet de cette repre'sentation interme'diaire en utilisant la notation
Newgen, abondamment commente'e.

\SEC{Analyseur se'mantique}
\label{AS}

\subsection{Structures de donne'es utilise'es}

Deux nouvelles structures de donne'es ont e'te' ajoute'es dans la
repre'sentation interme'diaire d'un programme: le {\tt transformer} et le
{\tt predicat}. Ces deux structures sont utilise'es pour enrichir
les informations porte'es par les {\tt statement}s. Les explications qui
suivent ont e'te' directement extraites de la description de la ri
fournies en annexe.

Le domaine {\tt transformer} de'finit une relation entre les pre'conditions
d'un {\tt statement} et les postconditions correspondantes. Cette relation
porte sur les valeurs des variables scalaires entie`res du module.

Les variables qui apparaissent dans la liste des arguments sont celles
qui sont modifie'es par le {\tt statement} correspondant. Deux valeurs
sont donc associe'es a` chacune d'entre elles: la pre- et la
post-valeur.  Les post-valeurs sont porte'es par les entite's
elles-me^mes. Les pre'-valeurs sont porte'es par des entite's
spe'ciales. Les variables scalaires entie`res qui ne sont pas modifie'es
et qui n'apparaissent donc pas dans la liste des arguments n'ont qu'une
seule valeur, porte'e par l'entite' correspondant a` la variable.

La relation est de'finie par des e'galite's et des ine'galite's
line'aires entre valeurs.

Un transformer n'est de'fini qu'apre`s une phase d'analyse se'mantique.

Le domaine {\tt predicate} de'finit une relation entre valeurs de
variables scalaires entie`res. Son interpre'tation est fonction de
son utilisation. Il peut s'agir soit d'un pre'dicat valable en
un point du programme (i.e. un invariant), soit d'un pre'dicat
valable entre deux points du programme. Il s'agit alors d'une
abstraction d'une commande, c'est-a`-dire d'un {\tt transformer}.

\subsection{Propagation de constante intra-proce'durale}

Une premie`re e'tape de l'analyse se'mantique a e'te' re'alise'e,
la propagation de constantes intra-proce'durale. Elle est base'e
sur le calcul des effets et sur les affectations affines a`
des variables scalaires entie`res.

L'algorithme utilise' consiste a` faire une interpre'tation
abstraite du programme en terme de polye`dres, sans calcul de point fixe.
Les boucles, les tests et les zones non structure'es des modules
ne cre'ent pas d'information mais en de'truisent seulement.

L'algorithme de propagation d'un invariant initial sur tout le corps
d'un module n'est pas encore e'crit.

Les appels a` des fonctions ou routines externes ne sont pas
encore traite's correctement parce que cette information interproce'durale
n'e'tait pas encore disponible dans la repre'sentation interme'diaire. Elle
devrait e^tre ajoute'e rapidement.

La ge'ne'ralisation a` une propagation de constante interproce'durale
ne'cessite, en plus du stockage de {\tt transformer}s globaux pour
chaque module du programme, une nouvelle routine de traduction et
de filtrage des {\tt effects} et des {\tt transformer}s.

Le travail sur l'analyse se'mantique intra-proce'durale va se poursuivre
en ajoutant un calcul d'enveloppe convexe pour pouvoir traiter le cas
des tests et un calcul de point fixe base' sur l'e'largissement de
Cousot et Halbwachs pour pouvoir traiter les boucles plus finement.

\subsection{Informations interproce'durales}

Pour e'viter d'avoir a` utiliser un espace de travail trop grand, Pips
peut fonctionner en ne conservant en me'moire que la table interproce'durale
des entite's et le code d'un ou deux modules. Il n'est donc pas pratique
de conserver les effets et les transformers uniquement au niveau
{\tt statement}.

D'autre part, certains effets locaux sont masque's vis-a`-vis du module
appelant et certains re'sultats de l'analyse se'mantique intra-proce'durale
sont sans signification pour les modules exte'rieurs. Il faut donc
filtrer et e'ventuellement amalgamer les informations conserve'es
au niveau {\tt statement}.

C'est pourquoi deux nouveaux champs ont e'te' ajoute's au niveau {\tt code},
{\tt effects} et {\tt transformer}. Ces deux champs sont commente's dans
l'annexe ou` est de'crite la repre'sentation interme'diaire.

\SEC{De'tecteur de paralle'lisme}
\label{DP}
\SSE{Meilleure de'tection des de'pendances}
Le rapport pre'ce'dent pre'sentait une nouvelle structure de donne'es
permettant de repre'senter le graphe de contro^le d'un programme de
manie`re plus adapte'e a` la paralle'lisation. En particulier, ce {\em
graphe de contro^le structure' (GCS)} permettait de pre'server la
structuration inhe'rente a` la grande majorite' des programmes (i.e., de
localiser de manie`re fine les zones d'influence des {\tt goto}),
permettant ainsi d'en profiter plus largement qu'avec les techniques
classiques. 

\PAR{}
Nous de'crivons comment ce GCS a e'te' utilise' pour construire les
chaines {\em use-def} et pour privatiser les variables locales a` des nids de
boucles, ces deux nouvelles phases ayant pour but d'affiner le calcul du
graphe de de'pendance. En effet, la version pre'se'dente du
paralle'liseur comportait une phase de calcul de de'pendances tre`s
rudimentaire qui:
\BIT
\item analysait pour chaque paire possible d'instructions tous les
conflits potentiels,
\item ne savait pas de'terminer si les effets d'un corps de boucle sur
une variable scalaire e'taient ou non locaux.
\EIT
L'exemple suivant montre que cette analyse simpliste n'e'tait pas
satisfaisante dans de tre`s nombreux cas. Sans les phases que nous
allons pre'senter dans la suite, le paralle'liseur ne peut pas se rendre
compte que la boucle sur {\tt I} peut d'une part e^tre coupe'e en deux
(ce qui donne une meilleure localite' des acce`s aux tableaux {\tt T} et
{\tt U}), et que d'autre part chaque boucle re'sultante peut e^tre
paralle'lise'e car les modifications du scalaire {\tt S} sont locales a`
chaque boucle: la valeur de {\tt S} est tue'e en entre'e et non
utilise'e par la suite (ce qui est e'galement de'tecte' automatiquement).
\begin{verbatim}
      DO I = 1, 10
         S = T(I)+1
         T(I) = S + S**2 + S**3
         S = U(I)+1
         U(I) = S + S**2 + S**3
      ENDDO
\end{verbatim}
Gra^ce a` notre analyse plus fine des de'pendances, cette boucle
pourrait e^tre transforme'e en:
\begin{verbatim}
      DOALL I = 1, 10
         PRIVATE S
         S = T(I)+1
         T(I) = S + S**2 + S**3
      ENDDO     
      DOALL I = 1, 10
         PRIVATE S
         S = U(I)+1
         U(I) = S + S**2 + S**3
      ENDDO
\end{verbatim}

\PAR{}

\SSE{Organisation du calcul des de'pendances}
\PAR{}
L'organisation actuelle du calcul des de'pendances est la suivante:

\BIT
\item le graphe de contro^le structure' est calcule' sur la totalite' du
module soumis au paralle'liseur;

\item les effets des instructions sont calcule's sur la totalite' du
module soumis au paralle'liseur; la version actuelle de cette phase ne
sait pas traiter les appels a` d'autres modules mais des travaux sont en
cours pour ame'liorer ce point;

\item les {\em use-def} chaines sont calcule'es elles aussi sur la totalite' du
module; cette analyse n'a pas de sens sur une portion de module
puisqu'il faut connai^tre les variables vivantes en entre'e et en sortie
de la portion analyse'e;

\item une fois ce point atteint, le paralle'liseur pourrait tenter une
premie`re e'tape de paralle'lisation en utilisant les {\em use-def} chaines
comme premie`re approximation du graphe de de'pendances; ceci est
d'autant plus possible que {\em use-def} chaines et graphe de de'pendances sont
en fait la me^me chose pour PIPS; cette e'tape n'est pas effectue'e
actuellement vu le peu de paralle'lisme qui serait obtenu;

\item les variables prive'es a` un corps de boucle sont recherche'es
pour toutes les boucles du module;

\item les {\em use-def} chaines sont raffine'es pour tous les conflits dus a`
des re'fe'rences a` des e'le'ments de tableaux; cette ope'ration est
applique'e aux boucles en cours de paralle'lisation (et non pas a` la
totalite' du module) pour des raisons d'efficacite' car les algorithmes
de calcul en nombres entiers sont complexes et couteux en temps cpu.
\EIT

\PAR{}
Nous de'taillons ces diffe'rentes phases dans la suite de cette section.

\SSE{Effets des instructions}
\PAR{}
Les de'pendances utilisent la notion de conflit entre instructions.
Celle-ci est de'termine'e par les effets des instructions: quelles
variables ou e'le'ments de tableaux sont-ils lus et/ou modifie's par chaque
instruction du module?

\PAR{}
En vue de traiter le proble`me dans son cas le plus ge'ne'ral (et, {donc},
interproce'dural), les effets des instructions sont cumule's selon la
structure syntaxique du programme a` paralle'liser. Comme la
de'termination exacte des effets d'une instruction est un proble`me non
de'cidable (penser aux tests, par exemple), nous avons e'tendu la
de'finition d'un effet pour prendre en compte le type d'{\em
approximation} connu (cf. la de'finition de la repre'sentation
interme'diaire de PIPS en annexe). Ainsi, un effet est caracte'rise'
par:
\BIT
\item la variable ou l'e'le'ment de tableau re'fe'rence': une {\tt
reference};

\item l'attribut permettant de savoir si cet effet est une lecture ou
une e'criture: une {\tt action}; 

\item l'attribut permettant de savoir si cet effet est certain ou
seulement possible: une {\tt approximation};
\EIT

\PAR{}
L'effet de l'exemple suivant sur {\tt T} est {\tt <T(I), WRITE, MUST>}
car la premie`re instruction est effectue'e a` coup su^r alors que
l'effet sur {\tt M} est {\tt <M(I,J), READ, MAY>} a` cause du test.
\begin{verbatim}
        T(I) = 0.0
        IF (I .EQ. J) PRINT *, M(I,J)
\end{verbatim}

\PAR{}
L'information {\tt approximation} est de plus ne'cessaire pour calculer
les chaines {\em use-def} de manie`re pre'cise car elle permet de
savoir si une affectation a` une variable ``{tue}'' ou non toutes les
de'finitions pre'ce'dentes de cette variable.

\SSE{Chaines {\em use-def}}
\PAR{}
Les chaines {\em use-def}, telles que de'finies dans les ouvrages
classiques de compilation, permettent de relier toute utilisation d'une
variable a` la liste des de'finitions qui sont susceptibles de lui
correspondre. Nous avons e'tendu de manie`re naturelle cet algorithme
classique a` notre GCS; ceci implique une nouvelle strate'gie de calcul
de point-fixe pour de'terminer la solution des e'quations {\em
data-flow} dans le cas de programmes non-structure's. Des travaux sont
en cours pour de'montrer la correction de notre me'thode dans le cas
ge'ne'ral (les cas pratiques e'tant pour leur part presque toujours
trivialement corrects e'tant donne' la simplicite' des graphes de
contro^le rencontre's).

\PAR{}
Si les chaines {\em use-def} sont bien adapte'es aux me'thodes
d'optimisation rencontre'es dans les compilateurs, elles ne sont pas
suffisantes pour traiter tous les cas de de'pendance qu'il est
ne'cessaire de prendre en compte pour pre'server la se'mantique
se'quentielle d'un programme au cours de leur paralle'lisation (le
graphe de de'pendance est calcule' a` partir des chaines {\em use-def},
cf. ci-dessous). Ainsi, outre les de'finitions de variables, il nous
faut propager e'galement leur utilisation en vue de pouvoir
ulte'rieurement calculer les de'pendances de type {\em anti}. Cette
adaptation a e'galement e'te' imple'mente'e.

\PAR{}
Le re'sultat du calcul des chaines {\em use-def} est une premie`re
version, extre^mement fruste, du graphe de de'pendances, base'e
uniquement sur les conflits entre variables, inde'pendement des indices
de tableaux e'ventuels; a` noter que les notions d'e'quivalence sont
traite'es dans cette phase. Ce premier graphe de de'pendance est
ulte'rieurement affine' en prenant en compte la notion de niveau 
ne'cessaire pour l'algorithme d'Allen et Kennedy et en utilisant les
tests de de'pendance de type Banerjee et Fourier-Motzkin.

\SSE{Privatisation}
\PAR{}
Une variable est locale (i.e. prive'e) a` un corps de boucle (on pourra
ulte'rieurement ge'ne'raliser cette notion a` toutes les instructions,
en particulier les blocs) si sa valeur en entre'e de boucle et sa valeur
en sortie ne sont pas utilise'es; c'est typiquement le cas d'une
variable temporaire. Les de'pendances inter-ite'rations dues a` cette
variable peuvent e^tre omises durant la phase de paralle'lisation;
chaque ite'ration de boucle aura sa propre version de cette variable.

\PAR{}
Pour effectuer automatiquement ce type de transformation (dont la
fre'quence est tre`s e'leve'e en pratique), les chaines {\em use-def}
sont ne'cessaires pour ve'rifier les conditions de privatisation.  Les
paralle'liseurs qui n'utilisent pas de chaines {\em use-def} ont
ge'ne'ralement recours a` des directives fournies par l'utilisateur
(certifiant le caracte`re non-vivant de ces variables en entre'e et
sortie de boucle) pour effectuer cette ope'ration.

\PAR{}
L'algorithme de privatisation est base' sur un calcul d'e'limination.
Toutes les variables sont suppose'es locales aux boucles qui les
englobent. On parcourt alors le graphe de de'pendance (en fait, les
chaines {\em use-def}) de telle manie`re que
chaque conflit de'termine le sous-ensemble des boucles englobantes
communes qui pre'servent le conflict. Une fois, le graphe de de'pendance
parcouru, seules les de'clarations se'mantiquement correctes de
variables locales subsistent. Ces de'clarations sont stocke'es dans le
membre {\tt locals} de'finissant les boucles (le prettyprinter
ge'ne'rant des de'clarations de type {\tt PRIVATE} quand des variables
locales sont pre'sentes).

\SSE{Calcul pre'cis du graphe de de'pendance}
\PAR{}
Le calcul pre'cis du graphe des de'pendances est fait en e'tudiant
chaque conflit sugge're' par les {\em use-def} chaines. Le coeur du calcul des
de'pendances est inchange' par rapport a` la version pre'ce'dente:
construction puis test de la faisabilite' d'un syste`me line'aire en
nombres entiers.

\PAR{}
Il est ne'cessaire de ve'rifier chaque conflit car les {\em use-def} chaines ne
tiennent pas compte des indices de tableaux. Cela signifie que certains
conflits existant au niveau des {\em use-def} chaines vont disparai^tre apre`s
le calcul pre'cis des de'pendances.

\PAR{}
Ainsi, la boucle suivante comporte deux conflits sur le tableau {\tt T}
(producteur-con\-som\-ma\-teur et con\-som\-ma\-teur-producteur) dont un seul
subsiste (producteur-con\-som\-ma\-teur) apre`s l'analyse plus fine.

\begin{verbatim}
        DO I = 1, 10
           T(I) = ...
           ...  = T(I) ...
        ENDDO
\end{verbatim}

\PAR{}
Il est aussi ne'cessaire d'e'tudier chaque conflit pour rechercher quelle
boucle le cre'e ve'ritablement. Cette e'tude a pour but de mettre a`
jour le niveau de chaque de'pendance, c'est a` dire d'indiquer quelle
boucle ferait disparai^tre ce conflit si on l'exe'cutait
se'quentiellement. Dans l'exemple pre'ce'dent, le niveau de l'unique
de'pendance sur {\tt T} vaut 2, ce qui signifie que ce conflit ne peut
pas disparai^tre en se'quentialisant une boucle. La boucle unique est
ne'anmoins paralle`le et le conflit est re'solu au sein de chaque ite'ration.

\PAR{}
Il est important de remarquer que les de'pendances dues aux variables
locales ne sont pas ignore'es. Les conflits demeurent me^me si les
variables sont locales. Nous allons voir dans la section suivante
comment les variables prive'es sont prises en compte au niveau de la
paralle'lisation. 

\SSE{Adaptation de l'algorithme de Allen et Kennedy}
\PAR{}
Il nous a fallu adapter l'algorithme de Allen et Kennedy pour pouvoir
paralle'liser les boucles comportant des conflits dues aux variables
locales. En effet, la version standard ({\em ACM TOPLAS} volume 9,
nume'ro 4 de Octobre 1987) de cet algorithme ne sait pas traiter par
exemple la boucle suivante:
\begin{verbatim}
        DO I = 1, 10
           PRIVATE S
           S = T(I) ...         (1)
           U(I) = S ...         (2)
        ENDDO
\end{verbatim}
En effet, si le conflit sur {\tt S} con\-som\-ma\-teur-producteur de 2 vers 1
est conserve', la boucle reste se'quentielle; et si le conflit est
de'truit par la phase de calcul des de'pendances la boucle est
distribue'e et on obtient:
\begin{verbatim}
        DOALL I = 1, 10
           PRIVATE S
           S = T(I) ...         (1)
        ENNDO
        DOALL I = 1, 10
           PRIVATE S
           U(I) = S ...         (2)
        ENDDO
\end{verbatim}
ce qui n'est pas correct.

\PAR{}
La solution que nous avons adopte'e consiste a` conserver tous les
conflits, de fac,on a` empe^cher les mauvaises distributions de boucle,
et a` analyser a` posteriori chaque boucle de'clare'e se'quentielle par
Kennedy et Allen pour ve'rifier si les cycles sont brise's lorsque les
conflits dus aux variables prive'es sont ignore's. Dans ce dernier cas,
la boucle est de'clare'e paralle`le.

\section{Conclusion}

Le travail sur Pips s'est poursuivi normalement durant les trois derniers
mois. La phase d'analyse se'mantique apporte une premie`re contribution
visible a` Pips avec la propagation de constante intra-proce'durale.
La phase de paralle'lisation s'est enrichie d'une premie`re transformation,
la privatisation, qui nous a oblige' a` modifier l'algorithme de
paralle'lisation d'Allen et Kennedy. Le calcul des de'pendances a
par ailleurs e'te' ame'liore' pour prendre en compte le graphe de contro^le
et la disponibilite' des effets des instructions, qui sont aussi utilise's
pour calculer les {\em use-def} chaines et, indirectement, pour effectuer
la privatisation.

\newpage
\section*{ANNEXE 1}
\PAR{}
Cette annexe contient la version actuelle de la repre'sentation
interme'diaire annote'e, dans le formalismede NewGen.

\newpage
\section*{ANNEXE 2}
\PAR{}
Cette annexe contient les me^me structures de donne'es que l'annexe
pre'ce'dente, mais de'pouille'e de leurs commentaires et trie'es par
ordre alphabe'tique, a` l'exception du domaine {\tt entity} qui apparai^t
sous la lettre t comme {\tt tabulated entity}.

\end{document}
\end
