\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\titre}{RAPPORT D'AVANCEMENT No 3 \\
                    ANALYSE SYNTAXIQUE AU NIVEAU PROGRAMME \\
                    ANALYSE S\'EMANTIQUE}
\newcommand{\auteur}{Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{Mars 1989}
\newcommand{\numero}{E109}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\PAR{Introduction}
\PAR{}Ce rapport interme'diaire donne l'e'tat d'avancement de nos travaux sur
l'analyse syntaxique au niveau programme et sur l'analyse se'mantique.

\SEC{Analyse syntaxique au niveau programme}

\SSE{Objectifs}

\PAR{Acce`s direct aux informations inter-proce'durales}
\PAR{}
Un programme Fortran se compose de un ou plusieurs fichiers, chaque
fichier contenant un ou plusieurs modules (function, main ou subroutine).

\PAR{}
Dans le cadre de la paralle'lisation automatique, nous sommes amene's a`
effectuer des traitements inter-proce'duraux, c'est a` dire sur la
totalite' du programme, et des traitements intra-proce'duraux, c'est a`
dire sur un module uniquement.

\PAR{}
Notre premier objectif est d'avoir une repre'sentation interne ou`
chaque entite' n'a qu'une seule de'finition. Par exemple, si le module P
contient un appel au module Q, nous voulons que l'entite' re'fe'rence'e
dans l'instruction CALL de P soit la me^me entite' que celle cre'e'e
lors de l'analyse de Q. Ceci permet un acce`s direct, depuis par exemple
une instruction CALL, aux diverses informations associe'es a` Q, et
notamment le code de Q.

\PAR{}
Ceci n'est possible qu'apre`s une phase d'e'dition de liens, puisque P
et Q peuvent parfaitement e^tre de'finis dans deux fichiers diffe'rents,
et que nous n'imposons aucun ordre pour soumettre les diffe'rents
fichiers d'un programme Fortran au parser. 

\PAR{Optimisation de l'espace de travail de PIPS}
\PAR{}
Notre second objectif est un peu contradictoire: il s'agit de ne pas
avoir a` charger en me'moire de fac,on permanente la repre'sentation
interne de tous les modules du programme.  Ceci risquerait de conduire
a` des programmes exe'cutables tre`s gros, ce qui pourrait avoir des
conse'quences dramatiques sur les performances, me^me avec une gestion
de me'moire virtuelle efficace.

\PAR{}
Comme beaucoup d'algorithmes sont bottom-up ou top-down, il arrive
souvent que seuls deux modules au plus doivent e^tre actifs en me^me
temps en me'moire: le module appelant et le module appele'.

\PAR{}
Il nous faut alors avoir la possibilite' d'activer ou de de'sactiver un
module. L'activation correspond au chargement en me'moire des donne'es
repre'sentant ce module a` partir de fichiers. La de'sactivation
correspond a` l'ope'ration inverse: sauvegarde sur fichiers de ces
donne'es, et re'cupe'ration de la place me'moire occupe'e par le
module. Ceci peut sembler incompatible avec notre repre'sentation
interne ge're'e par Newgen, ou` les pointeurs jouent un ro^le important,
bien que leur utilisation soit cache'e derrie`re les fonctions d'acce`s
ge'ne're'es automatiquement.

\SSE{Activation et de'sactivation d'un module}

\PAR{}
Nous expliquons dans ce paragraphe en quoi consiste l'activation et la
de'sactivation d'un module.

\PAR{}
Un module de nom Q est repre'sente' par une entite' de nom
\verb/TOP-LEVEL:Q/ qui de'crit le type, les de'clarations et le corps du
module Q. 

\PAR{}
Nous remarquons que la repre'sentation interne a e'te' conc,ue de telle
sorte que les instructions contenues dans le code d'un module Q
contiennent des re'fe'rences vers les entite's qui composent Q, mais que le
contraire ne soit pas vrai. 

\PAR{}
Ceci signifie qu'il est possible de libe'rer l'espace alloue' pour le
code d'une fonction sans risque d'avoir des pointeurs re'fe'renc,ant des
zones de me'moire libe're'es. Comme ce code repre'sente ge'ne'ralement
la majeure partie des donne'es d'un module, nous en de'duisons ce que
sera l'activation et la de'sactivation d'un module:

\begin{itemize}
\item la de'sactivation correspondra a` la sauvegarde sur fichier du domaine
\verb/statement/ contenu dans la valeur initiale du module, qui est de
type \verb/code/, puis a` la libe'ration de la me'moire occupe'e par ce
statement.
\item l'activation correspondra au chargement de ce me^me domaine
\verb/statement/ depuis un fichier.
\end{itemize}

\SSE{Implications sur l'analyse syntaxique}

\PAR{}
Nous expliquons dans la suite quels traitements sont effectue's par les
phases d'analyse syntaxique pour rendre l'activation et la
de'sactivation possible.

\SSS{Analyse syntaxique au niveau module}

La phase d'analyse syntaxique au niveau module (parser) a pour but de
construire la repre'sentation interne d'un module a` partir de son texte
source Fortran. Parser ne fait aucun traitement interproce'dural, ce qui
signifie qu'il se remet dans son e'tat initial apre`s avoir parse'
chaque module.

\PAR{}
Pour chaque fichier \verb/file.f/ analyse', le parser effectue la
traduction en format interne de tous les modules \verb/M1/, \verb/M2/,
..., \verb/Mn/ contenus dans ce fichier.  Le re'sultat du parser est
forme' d'un couple de fichiers pour chaque module M analyse'.

\begin{enumerate}

\item Un fichier de nom \verb/TOP-LEVEL:M.entities/ qui contient toutes les
entite's cre'e'es lors de l'analyse de M. Toutes les entite's y sont
comple`tement de'finies, sauf l'entite' \verb/TOP-LEVEL:M/ dont le
sous-domaine \verb/statement/ de la valeur initiale vaut
\verb/statement_undefined/.

\item Un fichier de nom \verb/TOP-LEVEL:M.code/ qui contient la valeur
du statement mentionne' ci dessus, c'est a` dire le code de M.

\end{enumerate}

\SSS{Analyse syntaxique au niveau programme}

\PAR{Principe}
\PAR{}
L'analyse syntaxique au niveau programme (linker) effectue un travail
e'quivalent a` celui de l'e'diteur de liens dans une chaine de
compilation classique. Cette phase est en cours de re'alisation.

\PAR{}
Cette phase devra faire en sorte que les entite's qui doivent e^tre
partage'es par diffe'rents modules le soient effectivement. Ceci est
vrai pour les constantes, pour les fonctions intrinse`ques de Fortran
(\verb/PRINT/, \verb/FORMAT/, \verb/.EQ./, \verb/+/, ...), pour les
entite's repre'sentant des commons, et pour toutes les fonctions
externes.

\PAR{}
Ce dernier point est important. Dans notre exemple, l'exe'cution de
parser sur le module P contenant un appel a Q aura eu pour effet de
cre'er une entite' locale a` P de nom P:Q, de type functional, de
storage rom, et de value unknown. C'est cette entite' qui est
re'fe'rence'e dans l'instruction d'appel a` Q. 

\PAR{}
Apre`s exe'cution de linker, cette entite' devra avoir disparue, et
l'instruction \verb/CALL Q/ devra re'fe'rencer directement l'entite'
TOP-LEVEL:Q dont la valeur initiale est le code de Q. Cette entite'
devra donc avoir e'te' cre'e'e.

\PAR{Me'thode}
\PAR{}
Pour cela, la phase linker devra donc combiner entre eux tous les fichiers
\verb/TOP-LEVEL:Mi.entities/ qui ont e'te' cre'e's lors de l'analyse des
modules \verb/Mi/ formant le programme a` analyser.  Le re'sultat de
cette combinaison sera un fichier \verb/prog.entities/ ou` \verb/prog/
est le nom du programme, donne' par l'utilisateur.

\PAR{}
Ensuite, tous les fichiers \verb/TOP-LEVEL:Mi.code/ devront e^tre mis a
jour pour respecter la cohe'rence avec le fichier \verb/prog.entities/.
Ainsi, la re'fe'rence a` l'entite' P:Q dans un call a` Q contenu dans P
devra e^tre remplace' par une re'fe'rence a` l'entite' TOP-LEVEL:Q.

\SSS{Conclusion}
\PAR{}
La phase Linker est en cours de re'alisation, et son fonctionnement
exact sera de'crit dans le prochain rapport d'avancement de nos travaux.

\section{Analyse se'mantique intra-proce'durale}

\PAR{}
Un prototype d'analyseur se'mantique, utilisant la me'thode de Cousot et
Halbwachs mais n'effectuant que l'analyse en avant, est en cours de
re'alisation. Les premiers invariants ont de'ja` e'te' calcule's sur de
petits programmes de test, car la programmation a e'te' facilite' par
l'utilisation d'une bibliothe`que d'alge`bre line'aire en nombres
entiers et d'un analyseur syntaxique, pre'alablement de'veloppe'e au CAI.

\subsection{Premiers re'sultats}

\PAR{}
Ces premiers essais ont montre' que nous e'tions capables d'obtenir les
ine'galite's entre indices et bornes de boucles et les e'galite's
line'aires entre variables. Ces e'galite's de'finissent, entres autres,
les variables inductives et nous disposons donc de l'information
minimale ne'cessaire a` la parallelisation. Il reste a` voir si ce type
d'analyse procure, sur les programmes du jeu d'essai de l'ONERA,
d'autres invariants utiles a` la paralle'lisation automatique des
programmes. Rappelons que ceci e'tait un des objectifs du projet PIPS:
une analyse se'mantique sophistique'e est-elle utile a` la
paralle'lisation interproce'durale de programmes scientifiques?

\paragraph{Vitesse de convergence}

\PAR{}
Ces premiers essais ont aussi montre' que le temps d'exe'cution de
l'algorithme de re'solution du syte`me au polye`dres tel qu'il est
pre'sente' dans la the`se d'Halbwachs croissait exponentiellement
avec la profondeur d'imbrication des boucles et conduisait a` des
temps prohibitifs. Nous nous proposons donc d'e'tudier de nouvelles
strate'gies de re'solution, base'es sur la connaissance des variables
vivantes, permettant de factoriser le syste`me aux polye`dres en
sous-syte`mes de dimensions infe'rieurs et de ne re'soudre les
sous-syste`mes qu'un nombre minimum de fois.

\paragraph{Qualite' du point fixe}

\PAR{}
De plus, la recherche de points fixes est essentiellement {\em approximative}.
Aucun syste`me de re'solution n'est capable de de'cider s'il est utile
de poursuivre les ite'rations croissantes qui permettent d'ame'liorer
la connaissance qu'on a d'un programme ou s'il faut passer a` une phase
d'ite'rations de'croissantes pour assurer la convergence vers un re'sultat
correct.

\PAR{}
Les deux informations de base, les contraintes portant sur les indices de
boucles qui doivent se trouver entre les bornes infe'rieures et supe'rieures
correspondantes et la de'tection des variables inductives, semblent
expe'rimentalement obtenues apre`s deux ite'rations croissantes
seulement. Il serait utile de {\em prouver} que c'est toujours le
cas.

\PAR{}
Il est aussi possible de construire des exemples pour lesquels il faut
au moins trois ite'rations croissantes avant l'e'largissement pour
obtenir l'invariant line'aire qui est la meilleure solution possible.
En voici un exemple:

\begin{verbatim}
        C = 0
        DO 100 I = 1, N
                C = 1 - C
100     CONTINUE
\end{verbatim}

\PAR{}
Ici \verb+C+ n'est pas une variable inductive mais sa valeur est ne'anmoins
contrainte par les ine'galite's line'aires $0 \leq C \leq 1$. L'algorithme
d'e'largissement de'crit dans la the`se de Halbwachs ne peut trouver
ces contraintes qu'apre`s 3 ite'rations croissantes sur le corps de boucle.
Apres seulement deux ite'rations, toute information sur \verb+C+ est
perdue.

\PAR{}
Il est peut-e^tre possible de modifier l'algorithme d'e'largissement pour
essayer de {\em deviner} plus vite quelles contraintes peuvent e^tre
garde'es. Une telle ame'lioration a de'ja` e'te' apporte'e par Halbwachs
dans sa the`se par rapport a` l'e'largissement mentionne' par
Patrick Cousot dans sa the`se d'e'tat: un 2e`me ensemble de contraintes,
M2, y est conserve' en sus de l'ensemble initial, M1. Une telle modification
devrait e^tre prouve'e parce que l'e'largissement assure la convergence et
que la conservation de contraintes supple'mentaires risquent d'augmenter
la dure'e des ite'rations de'croissantes. Ceci constitue une deuxie`me
direction de recherche.

\paragraph{Point fixe non-line'aire}

\PAR{}
Il est aussi possible de construire une boucle test dont l'invariant
n'est pas line'aire et qui va e^tre approxime' par une suite inifinie
de polye`dres. La boucle suivante est caracte'rise'e par l'invariant
quadratique:
\[
J = \frac{I(I-1)}{2}
\]
qui ne peut qu'e^tre approxime' par des polye`dres convexes. Les
ite'rations croissantes construisent une suite de polye`dres dont la
limite n'est pas un polye`dre. Elle contient un nombre infini de
contraintes (resp. d'e'le'ments dans le syste`me ge'nerateur). Chaque
ite'ration supple'mentaire apporte un peu d'information, qui permettrait
e'ventuellement, sur un cas particulier construit expre`s, de
paralle'liser la boucle. 

\begin{verbatim}
        J = 0
        DO 100 I = 1, N
                J = J + I
100     CONTINUE
\end{verbatim}

\PAR{}
Il n'y a donc pas de moyen algorithmique d'interrompre les ite'rations
croissantes pour la simple raison qu'elles n'apportent plus d'informations.
Il faut donc ici aussi trouver un compromis expe'rimental en fonction
des jeux de tests qui nous ont e'te' procure's par l'ONERA. Nous
envisageons pour le moment de nous arre^ter soit par convergence
soit sur un nombre maximum d'ite'rations croissantes. Dans ce contexte,
convergence signifie que l'on obtient la me^me solution apre`s
e'largissement qu'on effectue $n$ ou $n+1$ ite'rations croissantes.
C'est une solution cou^teuse en temps CPU dont l'inte're^t reste
a` prouver expe'rimentalement.

\paragraph{Invariants inter-ite'ration}

\PAR{}
Un autre proble`me que pose l'application de la me'thode d'analyse se'mantique
de P. Cousot a` la paralle'lisation vient de l'absence de pre'dicats
construits sur les valeurs des variables en diffe'rents points du
programme. Les invariants standards sont construits sur les valeurs
des variables en {\em un} point de contro^le du programme. La de'tection
du paralle'lisme s'effectue en comparant les valeurs des variables en
{\em deux} points de contro^le diffe'rents. Les invariants en un point
sont donc utilisables mais on pourrait obtenir davantage de paralle'lisme
avec des invariants linea'ires construits sur deux points. 

\PAR{}
Par exemple, la boucle suivante, ou` \verb+f+ est une fonction sans
effet de bord, est paralle`le:

\begin{verbatim}
        J = 0
        DO 100 I = 1, N
                T(J) = f(J)
                J = J + I
100     CONTINUE
\end{verbatim}

\PAR{}
En effet, \verb+J+ est calculable directement en fonction de \verb+I+
(\verb+J=I*(I-1)/2+) et si deux valeurs de \verb+I+, $i_1$ et $i_2$, sont
diffe'rentes les deux valeurs correspondantes de \verb+J+, $j_1$ et $j_2$
sont aussi diffe'rentes. Plus pre'cisemment, il est possible de prouver
qu'il n'y a pas d'{output dependence} parce que:
\[
j_1 - j_2 \geq i_1 - i_2
\]
et qu'on testera ce syste`me sous les conditions:
\[
i_1 > i_2
\]
et
\[
j_1 = j_2
\]
L'information cle' est donc de nature line'aire et pourrait donc e^tre
calcule'e par la me'thode de Cousot moyennant l'adjonction de variables
supple'mentaires pour repre'senter les ite'rations 1 et 2. 

\PAR{}
Une solution serait peut-e^tre de mettre le programme pre'ce'dent sous
une forme faisant apparai^tre explicitement la proble'matique de la
paralle'lisation, c'est-a`-dire en transformant le conflit entre deux
ite'rations de la me^me instruction auxquelles est attache' le me^me
invariant, en un conflit entre deux ite'rations de deux instructions
e'quivalentes mais pour lesquelles deux invariants peuvent e^tre
calcule's.

\begin{verbatim}
C       premieres iterations
        J = 0
        DO 100 I = 1, I1-1
                T(J) = f(J)
                J = J + I
100     CONTINUE

C       iteration I1
        I1 = I
        J1 = J
        T(J1) = f(J1)
        J = J1 + I1

C       iterations suivantes
        DO 200 I = I1+1, I2-1
                T(J) = f(J)
                J = J + I
200     CONTINUE

C       iteration I2
        I2 = I
        J2 = J
        T(J2) = f(J2)
        J = J2 + I2

C       iterations finales
        DO 300 I = I2+1, N
                T(J) = f(J)
                J = J + I
300     CONTINUE
\end{verbatim}

\PAR{}
Cette transformation revient a` distinguer deux ite'rations
particulie`res du corps de boucle est a` les traiter avec des variables
spe'ciales, utilise'es sous la contrainte d'affectation unique.
L'analyse se'mantique a` la Cousot va donc permettre d'e'tablir des
relations entre des pseudo-variables, qui ne sont que les valeurs des
vraies variables en deux ite'rations distinctes.

\PAR{}
Cette transformation de programmes, si elle s'ave'rait utile, ne serait
pas effectue'e explicitement sur le programme mais uniquement lors de la
construction du syste`me aux polye`dres.

\paragraph{Directions de recherche}

\PAR{}
Ces premiers re'sultats expe'rimentaux nous ont donc conduit a` de'finir
quatre directions de recherches:
\begin{itemize}
  \item trouver un algorithme de re'solution efficace en pre'sence des
        boucles imbrique'es qui caracte'risent tant de programmes
        scientifiques
  \item trouver un e'largissement {\em devinant} mieux les contraintes
        potentiellement invariantes
  \item trouver un moyen de n'effectuer un grand nombre d'ite'rations
        croissantes que si cela est potentiellement utile
  \item trouver un moyen de calculer des pre'dicats inter-ite'rations
\end{itemize}

\subsection{Evolution logicielle}

\PAR{}
Pour passer du prototype au syste`me PIPS tel qu'il est pre'vu, il reste
a` e'crire une interface entre la repre'sentation interne de PIPS
(repre'sentation intra-proce'durale et graphe de contro^le - en cours de
de'finition) et l'algorithme de re'solution du syste`me aux polye`dres,
qui doit encore e^tre teste' pour savoir si la factorisation du syste`me
selon les composantes fortement connexes du graphe de contro^le est possible.

\PAR{}
Il faudra aussi effectuer des mesures sur notre bibliothe`que d'alge`bre
line'aire en nombres entiers pour acce'le'rer les routines cle's. Mais le
gain a attendre de cet effort n'est pas un gain de complexite', tout
au plus un coefficient.

\subsection{Point sur l'analyse se'mantique}

\PAR{}
Le de'veloppement de l'analyseur se'mantique se poursuit normalement.
Le caracte`re quelque peu spe'culatif de ce rapport d'avancement ne
refle`te pas le fait que le travail effectue' ces deux derniers mois
a consiste' essentiellement en de la programmation e'le'mentaire, dont il
n'y a pas grand-chose a` dire dans un rapport d'avancement.

\PAR{}
Seule une re'alisation de type prototype pouvait nous permettre
d'obtenir des re'sultats montrables aussi rapidement et de voir
rapidement dans quelles directions il allait falloir faire porter nos
efforts de re'flexion avant la re'alisation finale. 
\end{document}
\end
