\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}
\newcommand{\domain}[2]{\paragraph{{#1}}\paragraph{}{\em #2}}
\newcommand{\titre}{RAPPORT D'AVANCEMENT \\
                    ANALYSE SEMANTIQUE ET DETECTION DU PARALLELISME}
\newcommand{\auteur}{Franc,ois IRIGOIN \\
        Pierre JOUVELOT \\
        Re'mi TRIOLET}
\newcommand{\docdate}{Septembre 1989}
\newcommand{\numero}{E116}

\newcommand{\SEC}[1]{\section{#1}}
\newcommand{\SSE}[1]{\subsection{#1}}
\newcommand{\SSS}[1]{\subsubsection{#1}}
\newcommand{\PAR}[1]{\paragraph{#1}}
\newcommand{\SPA}[1]{\subparagraph{#1}}
\newcommand{\BQU}{\begin{quote}}
\newcommand{\EQU}{\end{quote}}
\newcommand{\BIT}{\begin{itemize}}
\newcommand{\EIT}{\end{itemize}}
\newcommand{\BDE}{\begin{description}}
\newcommand{\EDE}{\end{description}}
\newcommand{\BEQ}{\begin{equation}}
\newcommand{\EEQ}{\end{equation}}
\newcommand{\BAR}{\begin{array}}
\newcommand{\EAR}{\end{array}}
\newcommand{\BDO}{\begin{document}}
\newcommand{\EDO}{\end{document}}
\newcommand{\BCE}{\begin{center}}
\newcommand{\ECE}{\end{center}}
\newcommand{\BTG}{\begin{tabbing}}
\newcommand{\ETG}{\end{tabbing}}
\newcommand{\BTR}{\begin{tabular}}
\newcommand{\ETR}{\end{tabular}}
\newcommand{\BAB}{\begin{abstract}}
\newcommand{\EAB}{\end{abstract}}
\newcommand{\BEN}{\begin{enumerate}}
\newcommand{\EEN}{\end{enumerate}}
\newcommand{\BFI}{\begin{figure}}
\newcommand{\EFI}{\end{figure}}
\newcommand{\VSP}{\vspace*{\baselineskip}}

\setlength{\parindent}{0cm}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}
\sloppy

\SEC{Introduction}
\PAR{}
Ce rapport interme'diaire donne l'e'tat d'avancement de nos travaux sur
l'analyse se'mantique et la de'tection du paralle'lisme. Une part
importante de ces travaux est repre'sente' par le calcul du graphe de
contro^le d'un module que nous pre'sentons en de'tail dans la
section~\ref{controle}. Ce graphe de contro^le est ou sera utilise' par
plusieurs phases de PIPS, et notamment:
\BIT
\item la phase d'analyse se'mantique pour construire les e'quations
se'mantiques associe'es a` un programme,

\item par la phase de de'tection de paralle'lisme pour de'terminer
si une boucle peut e^tre paralle'lise'e, me^me dans le cas ou` elle
contient des instructions de branchements non structure'es, 

\item par la phase de calcul des use-def chains, 

\item etc...
\EIT

Nous pre'sentons dans la suite l'e'tat d'avancement de la phase de
de'tection du paralle'lisme (section~\ref{kennedy}), les structures de
donne'es et l'algorithme mis en oeuvre pour le calcul du graphe de
contro^le (section~\ref{controle}), et l'e'tat d'avancement de la phase
d'analyse se'mantique (section~\ref{semantique}).

\SEC{De'tection du paralle'lisme}
\label{kennedy}
\PAR{}
Une phase de de'tection du paralle'lisme est en cours de de'veloppement
dans le projet PIPS. Dans un premier temps, nous nous sommes restreints
a` l'algorithme de Kennedy et Allen applique' aux boucles ne contenant
que des instructions d'affectation.

\PAR{}
Le calcul du graphe de de'pendances (voir la structure de donne'es dans
l'annexe 1) est effectue'e selon les techniques de calcul line'aire
de'veloppe'es au CAI et qui seront pre'sente'es dans les prochains
rapports. Les programmes de calcul du graphe de de'pendances font
massivement appel a` la bibliothe`que line'aire de'veloppe'e au CAI dans
le cadre d'un contrat avec le PRC $C^3$.

\PAR{}
Le calcul des composantes fortement connexes du graphe des de'pendances
et le tri topologique de ces composantes sont faits en utilisant des
algorithmes classiques, pre'sente's dans l'ouvrage {\em TYPES DE DONNEES
ET ALGORITHMES --- Recherche, Tri, Algorithmes sur les Graphes} par
Marie-Claude GAUDEL, Miche`le Soria et Christine Froidevaux dans la
collection Didactique de l'INRIA.

\PAR{}
L'algorithme de Kennedy proprement dit est celui pre'sente' dans la
revue {\em ACM TOPLAS} volume 9, nume'ro 4 de Octobre 1987. Nous donnons
dans l'annexe 3 quelques re'sultats obtenus avec la premie`re version de
cette phase; la boucle est affiche'e avant et apre`s transformation par
le pretty-printer de PIPS. Les temps d'execution indique's sont ceux de
la phase de paralle'lisation uniquement, les temps du parser et du
linker ne sont pas compte's.

\SEC{Construction du graphe de contro^le}
\label{controle}
\PAR{}
Si l'arbre de syntaxe abstraite repre'sente la structure statique d'un
programme, le graphe de contro^le en est le pendant dynamique; il
associe a` chaque instruction la liste de ses pre'decesseurs et
successeurs possibles dans toute exe'cution du programme. Cette
structure de donne'e est importante pour effectuer toute analyse
se'mantique {\em flow-sensitive} tels les chaines {\em use-def} ou le
calcul de pre'dicats. De plus, elle intervient dans la de'tection du
paralle'lisme avec la notion de {\em masquage de contro^le} qui permet
de paralle'liser des boucles contenant des instructions de branchement
locaux.

\PAR{}
Nous de'crivons dans la section 1 les structures de donne'es implique'es
dans le graphe de contro^le et pre'sentons l'ide'e ge'ne'rale de
l'algorithme dans la section 2. Le listing commente' du programme est
donne' en annexe 2.

\SSE{Le graphe de contro^le}
\PAR{}
La majorite' des programmes utilisateurs sont (ou devraient) e^tre
structure's. Prenant ce fait en conside'ration, nous avons concu le
graphe de contro^le comme une extension de l'arbre de syntaxe abstrait.
Les structures de donne'es structure'es (i.e., boucle, conditionnelle,
se'quence et instruction e'le'mentaire) sont pre'serve'es telles quelles
dans le graphe de contro^le tandis que seuls les branchements
``cassent'' cette structure hie'rarchique pour cre'er un graphe
oriente'. Ceci permettra de traiter de manie`re simple les parties
paralle'lisables d'un programme, puisque les ruptures de contro^le
empe^chent ge'ne'ralement toute paralle'lisation (mais voir ci-dessous).
Un tel graphe de contro^le est appelle' {\em Structured Control Graph}.

\PAR{}
Cette inte'gration du graphe de contro^le avec les instructions du
programme se refle`te dans sa description re'cursive dans le fichier de
description NewGen:

\begin{verbatim}
control = statement x predecessors:control* x successors:control* ;
instruction = block:statement* + test + loop + ploop + goto:statement + 
              call + unstructured:control ;
statement = label:entity x number:int x instruction x effects:effect* ;
\end{verbatim}

\PAR{}
Dans un noeud du graphe de contro^le, le champ {\tt statement} sera toujours
structure'; cet invariant est introduit par l'algorithme de cre'ation du
graphe de contro^le. Dans la majorite' des cas, les champs {\tt
predecessors} et {\tt successors} auront des listes re'duites a` un
e'le'ment. Seule une instruction de branchement conditionnelle (dont le
{\tt statement} est un {\tt test}) cre'era une liste {\tt successors}
ayant plus d'un e'le'ment, le premier correspondant au branchement dans
le cas ou` la condition est ve'rifie'e. Des noeuds de jointure pourront
avoir plus d'un pre'de'cesseur.

\PAR{}
La liste des type d'instructions possibles d'un programme a e'te'
augmente'e d'un champ {\tt unstructured} qui apparaitra apre`s
construction du graphe de contro^le; il n'est jamais introduit par les
phases pre'ce'dentes de PIPS.

\PAR{}
Ce graphe de contro^le imple'mente la notion importante de {\em
masquage de contro^le}. Par exemple, si une boucle utilise un corps qui
comporte des branchements locaux (ceci est ve'rifie' au cours de la
construction du graphe), alors, vue de l'exte'rieur, cette boucle sera
conside're'e comme structure'e. Dans le cas d'une imple'mentation
paralle`le, la rupture de se'quence dans une ite'ration est en effet
inde'pendante des autres ite'rations et n'empe^che en rien l'exe'cution
paralle`le du programme. 

\SSE{Un exemple simple}
Dans le programme:
\begin{verbatim}
       do 10 i=1,n
       t(i) = i
       if ( i .le. m ) goto 20
           t(i) = i
20     continue
10     continue
\end{verbatim}
le corps de la boucle sera conside're' comme un graphe compose', entre
autres, d'un noeud d'affectation et d'un noeud de contro^le qui
correspond au saut conditionnel. Ceci est visible dans le pretty-print
du graphe de contro^le donne' ci-dessous:
\begin{verbatim}
Graph 60a48
           --> Node 60a48
           statement 61508
           Preds: 
           Succs: 
           Code of 60a48:
           DO @10 I = 1,N,1
               Graph 60c40
                   --> Node 60c40
                   statement 5d718
                   Preds: 
                   Succs: 60ca8 
                   Code of 60c40:
                   =(T(I),I)
                   End of code of 60c40
                   --> Node 60ca8
                   statement 5ff98
                   Preds: 60c40 
                   Succs: 60d38 60d50 
                   Code of 60ca8:
                   IF (.LE.(I,M)) THEN
                       GOTO @20
                   ELSE
                       CONTINUE()
                   ENDIF
                   End of code of 60ca8
                   --> Node 60d38
                   statement 60e70
                   Preds: 60ca8 
                   Succs: 608e0 
                   Code of 60d38:
                   End of code of 60d38
                   --> Node 608e0
                   statement 61300
                   Preds: 61180 60d38 
                   Succs: 
                   Code of 608e0:
20                 CONTINUE()
10                 CONTINUE()
                   End of code of 608e0
                   --> Node 61180
                   statement 61160
                   Preds: 60da0 
                   Succs: 608e0 
                   Code of 61180:
                   =(T(I),I)
                   End of code of 61180
                   --> Node 60da0
                   statement 60d80
                   Preds: 60d50 60e40 
                   Succs: 61180 
                   Code of 60da0:
                   End of code of 60da0
                   --> Node 60d50
                   statement 61098
                   Preds: 60ca8 
                   Succs: 60da0 
                   Code of 60d50:
                   CONTINUE()
                   End of code of 60d50
                   --> Node 60e40
                   statement 60e20
                   Preds: 
                   Succs: 60da0 
                   Code of 60e40:
                   End of code of 60e40
               End of graph 60c40
           ENDDO
00000      CONTINUE()
           End of code of 60a48
End of graph 60a48
\end{verbatim}
Ce graphe de de contro^le est construit (parsing et pretty-printing
compris) en 0.98s.

\SSE{Construction du graphe}
La routine principale de construction du graphe de contro^le prend en
entre'e un {\tt statement} et retourne le graphe de contro^le
correspondant. Comme pre'cise' pre'ce'demment, si le statement en
question est comple`tement structure', le graphe de contro^le sera
limite' a` un noeud; cela sera le cas, par exemple, de la routine de
multiplication matrices.

\PAR{}
L'algorithme utilise' est de'fini par induction sur la structure d'arbre
abstrait du programme. La routine re'cursive principale est {\tt
controlize} qui, pour un statement {\tt st} ayant {\tt pred} pour noeud
pre'decesseur et {\tt succ} pour noeud successeur, retourne dans {\tt
c\_res} le noeud de contro^le correspondant et met a` jour l'argument
{\tt used\_labels} qui contient la liste des occurences des e'tiquettes
utilise'es dans une instruction (ceci est utilise' dans
l'imple'mentation du masquage de contro^le).

\PAR{}
Le but essentiel de {\tt controlize} est d'e'liminer les {\tt goto} et
de les remplacer par des arcs dans le graphe de contro^le. Ceci est fait
via deux structures de donne'es (imple'mente'es par des tables de
hachage); {\tt label\_statements} associe a` tout nom d'e'tiquette la
liste de instructions qui la re'fe'rence, tandis que {\tt
label\_control} associe a` tout nom d'e'tiquette le noeud de contro^le
correspondant (qui est utilise' dans le cas de branchement en avant).
Ces deux structures de donne'es sont construites lors d'un premier
parcours de {\tt st} par la routine {\tt create\_statements\_of\_labels}.

\PAR{}
Le masquage de contro^le ne'cessite de compactifier les graphes de
contro^le des composantes d'une instruction en vue de les remplacer par
un seul noeud. La routine de test principale est {\tt covers\_labels\_p}
qui ve'rifie si les occurrences des e'tiquettes utilise'es dans
l'instruction repre'sentent toutes les apparences possibles de ces
e'tiquettes, auquel cas les branchements correspondants sont locaux et
pourront e^tre ne'glige's dans les instructions englobantes. Une e'tape
de compaction importante est {\tt compact\_list} correspondant aux
se'quences; elle permet de regrouper dans des sous-se'quences (i.e.,
{\em basic blocs}) les instructions qui ne comportent pas de
branchement.

\PAR{}
Une conse'quence de la construction du graphe de contro^le est la
possibilite' de de'tecter les instructions du pogramme qui correspondent
a` du ``code mort''. Si cette information est inutile a` la
paralle'lisation proprement-dite, elle peut indiquer une erreur de
conception du programme d'applications et est donc reporte'e a`
l'utilisateur.

\section{Analyse se'mantique}
\label{semantique}

\paragraph{}
Le travail concernant l'analyse se'mantique est pre'sente' en deux volets,
d'une part la programmation, d'autre part, une re'flexion algorithmique.

\subsection{Avancement de l'imple'mentation}

\paragraph{}
Le travail d'imple'mentation a consiste' a` re'cupe'rer le maximum
de code du prototype d'analyseur se'mantique pour e'crire l'analyseur PIPS.
Les modules existants ont e'te' de'coupe's en morceaux plus petits pouvant
e^tre installe's dans une de nos bibliothe`ques d'alge`bre line'aire,
compatibles avec l'environnement PIPS.

\paragraph{}
En sus du de'coupage, les diffe'rentes transformations effectue'es ont e'te':
\begin{itemize}
  \item le renommage des fonctions de base pour respecter des normes
        d'uniformisation de'pendant du nom de la structure de donne'es
        produites et de la fonctionnalite';
  \item l'ajou^t de commentaires et la mise en forme de commentaires
        pre'-existants;
  \item la rationalisation des fichiers {\em include}, avec une automatisation
        partielle de l'extraction des commentaires permettant d'assurer
        une meilleure cohe'rence entre le code C et les fichiers {\em headers};
  \item la mise au point de fichiers {\em Makefile} assurant la cohe'rence
        entre bibliothe`ques de'pendant les unes des autres;
  \item la modification de codes pre'sentant des de'pendances par rapport
        a` des modules ne faisant pas partie de PIPS;
  \item la mise en place de re'pertoires de tests permettant de ve'rifier
        les proce'dures de base dans un contexte minimum (non termine');
\end{itemize}
Il reste encore a` en ame'liorer les performances a` l'aide des outils
UNIX {\em prof} et {\em gprof} et a` de'velopper des versions
{\em instrumente'es} permettant de mieux comprendre le comportement
des algorithmes.

\paragraph{}
Ces bibliothe`ques sont au nombre de 7, comme les structures de donne'es
de'crites dans le rapport d'avancement de mars 1989 (rapport No~2):
\begin{itemize}
  \item vecteur,
  \item contrainte line'aire (e'galite' et ine'galite'),
  \item systeme de contraintes line'aires,
  \item rayon et droite,
  \item sommet,
  \item syste`me ge'ne'rateur,
  \item polye`dre (double repre'sentation par syste`me de contraintes et
        syste`me ge'ne'rateur).
\end{itemize}

\paragraph{}
Les routines essentielles pour l'analyse se'mantique par polye`dre sont:
\begin{itemize}
  \item {\em affectation}, qui calcule l'effet d'une affectation affine
         sur un polye`dre
        (i.e. sur son syste`me de contraintes et sur son syste`me ge'nerateur);
  \item {\em projection}, qui calcule l'effet d'une affectation non line'aire;
  \item {\em intersection\_demi}, qui calcule le nouveau pre'dicat d'une
        branche de test de la forme {\tt I.GE.J} 
        ({\em demi} signifie demi-espace);
  \item {\em intersection\_hyperplan}, qui calcule le nouveau pre'dicat
        d'une branche de test varie de la forme {\tt I.EQ.J};
  \item {\em enveloppe}, qui calcule l'enveloppe convexe de deux pre'dicats
        sur les points de jonction du graphe de contro^le (fin d'un test,
        boucle);
  \item {\em e'largissement}, qui permet de calculer un polye`dre point fixe
        pour les boucles (ope'rateur $\nabla$ de la the`se de Halbwachs);
  \item {\em sc\_to\_sg}, qui permet de passer d'un syste`me de contraintes
        a` un syste`me ge'ne'rateur;
  \item {\em normalisation}, qui permet d'e'liminer les contraintes 
        et les e'le'ments du syste`me ge'ne'rateur qui sont redondants;
\end{itemize}
Ces fonctions sont construites a` partir de fonctions similaires sur les
syste`mes de contraintes et sur les syste`mes ge'ne'rateurs.

\paragraph{}
Contrairement aux routines utilise'es pour le calcul de de'pendance qui
ope`rent sur des entiers, ces routines utilisent et produisent des
polye`dres rationnels.

\subsection{Modification de l'algorithme d'Halbwachs}

\paragraph{Notion de variable}

\paragraph{}
L'algorithme pre'sente' dans la the`se de N. Halbwachs ne prend pas en
compte ni l'aliasing implicite entre parame`tres formels ou entre
parame`tres formels et variables globales, ni l'aliasing explicite (i.e.
intra-proce'dural) cre'e' par la de'claration {\tt EQUIVALENCE}. Nous
proposons de suivre la norme Fortran~77 qui e'limine l'aliasing
implicite pour conside'rer que le premier proble`me ne se pose pas. Pour
traiter l'aliasing explicite nous prendrons ale'atoirement une des
variables scalaires en alias, si plusieurs scalaires sont concerne's. En
cas d'alias entre tableaux et scalaires, les instructions d'affectation
au tableau seront conside're'es comme des {\em kill}'s de la variable.
Cette re`gle pourrait e^tre ame'liore'e ulte'rieurement par un test de
de'pendance si le besoin s'en fait sentir.

\paragraph{Re'duction de la complexite'}

Le comportement exponentiel de l'algorithme de re'solution de'crit
dans la the`se de Halbwachs et imple'mente' dans le prototype d'analyseur
se'mantique est inacceptable pour des programmes scientifiques.

\paragraph{}
Nous proposons donc de de'couper la re'solution globale du syste`me aux
polye`dres en des re'solutions partielles, dont la combinaison risque
bien su^r de donner des re'sultats moins pre'cis mais dont le temps
d'exe'cution devrait e^tre a` peu pre`s line'aire par rapport a`
la taille du programme.

\paragraph{}
L'ide'e consiste a` calculer pour chaque composante du graphe de
contro^le structure' (cf. section~3) une relation, appele'e {\em
relation de transfert} dans la suite, entre le pre'dicat d'entre'e
(pre'condition) et le pre'dicat de sortie (post-condition). Les
relations de transfert seront propage'es de base en haut en fonction des
ope'rateurs de structuration du graphe de contro^le: se'quence (composition),
test (enveloppe convexe), boucle (e'largissement) et control (pour les
parties non structure'es du programme analyse'). Chaque
boucle aura une profondeur d'imbrication de 1, car les boucles internes
auront e'te' pre'ce'demment transforme'es en relation de transfert.
Le placement des ope'rations d'e'largissement ne'cessaires a` la
convergence est trivial, ainsi que celui des ope'rations de fermeture
convexe.

\paragraph{}
Les instructions e'le'mentaires (call assign, call read, call min,...)
fourniront les relations de transfert de base. L'analyse sera limite'e
a` l'assignation (call assign) dans un premier temps.

\paragraph{}
Pour les parties non structure'es (unstructured:control), nous proposons
dans un premier temps de n'effectuer qu'une projection des variables
{\em tue'es} par les statements correspondants. Si ces zones s'ave`rent
trop fre'quentes et paralle'lisables malgre' un contro^le non re'gulier,
il serait possible d'imple'menter l'algorithme d'Halbwachs pour elles.
L'analyse des parties structure'es e'ventuellement pre'sentes sous cette
zone control sera reprise normalement.

\paragraph{}
Une fois la relation de transfert calcule'e de bas en haut\footnote{Cette
approche pourrait aussi s'appliquer d'une manie`re interproce'durale
en ajoutant une traduction de la relation de transfert globale d'une
proce'dure a` chacun de ses sites d'appel.}, il ne reste plus qu'a` propager
les invariants de haut en bas du graphe de contro^le du module analyse'.

\paragraph{}
Cette approche nous permettra e'ventuellement d'ajouter un peu
d'information lors de la constitution du syste`me de de'pendance entre
deux re'fe'rences, en profitant de la pre'sence de la relation de
transfert entre les deux statements contenant ces re'fe'rences.

\paragraph{}
L'inconve'nient essentiel de cet algorithme est qu'il de'pend de la nature
des relations de transfert choisies. Pour obtenir les me^mes re'sultats
qu'avec l'algorithme d'Halbwachs, il faudrait au moins avoir des relations
de transfert {\em conditionnelles} ou` les conditions d'application
partielles et les relations de transfert partielles seraient de'finies
par des polye`dres\footnote{Ceci est plus ge'ne'ral que les formules
conditionelles utilise'es en e'valuation symbolique dans le projet
VELOURS et que la ge'ne'ralisation de la propagation de constantes
propose'e par Jean Goubault.}. Pour acce'le'rer l'exe'cution,
nous proposons de re'duire cette union de relations de transfert
partielles en une unique relation de transfert inconditionnelle par
fermeture convexe. Voici un exemple de programme ou` cette me'thode
va perdre de l'information:

\begin{verbatim}
I = 4
IF(I.EQ.4) THEN
        J = 5
ENDIF
\end{verbatim}

Soit $i_{old}$ et $j_{old}$ les valeurs de \verb+I+ et \verb+J+ avant
l'exe'cution d'une instruction, et $i_{new}$ et $j_{new}$ leurs valeurs
apre`s. La relation de transfert du bloc \verb+IF+ est $i_{new} = i_{old}$
et toute information sur \verb+J+ est perdue en faisant l'enveloppe
convexe de $j_{new} = 5$ et de $j_{new} = j_{old}$ (ce sont deux droites
non paralle`les; elles ge'ne`rent donc tout l'espace). La composition
de l'affectation \verb+I = 4+ avec ce test va donc fournir la relation
de transfert $i_{new} = 4$ et toute information sur \verb+J+ sera encore
perdue. La relation de transfert calcule'e normalement pour cette
se'quence serait $i_{new} = 4, j_{new} = 5$.

\paragraph{Fragilite' des pre'dicats polye`driques}

L'utilisation de l'enveloppe convexe fournit des re'sultats non intuitifs
car il est difficile aux programmeurs d'e^tre aussi stricts qu'un
programme et de faire abstraction d'informations implicites.

\paragraph{}
Supposons par exemple que nous ayons le corps de programme:
\begin{verbatim}
T(2) = ...
DO I = 1, N
  T(I) = ...
ENDDO
\end{verbatim}
Quel est la partie de \verb+T+ qui est touche'e par cette se'quence
d'instructions? On aimerait pouvoir dire \verb!T(1..N+1)! mais l'enveloppe
convexe des deux re'gions touche'es par \verb+T(2)+ et \verb+T(I)+ est 
le tableau \verb+T+ tout entier. Aucune information sur \verb+N+ n'est
disponible; cette variable peut avoir une valeur ne'gative et ne peut pas
e^tre utilise'e pour de'finir la partie de \verb+T+ modifie'e. Il faudrait
disposer d'une pre'dicat $n \ge 1$ pour pouvoir faire la de'duction
souhaite'e, \verb!T(1..N+1)!. Cette information est implicite pour tout
programmeur humain.

\paragraph{}
Supposons maintenant que nous recherchions des variables inductives dans le
code:
\begin{verbatim}
K = 0
DO I = 1, N
  K = K + 2
ENDDO
\end{verbatim}
et que nous soyons inte'resse' par la valeur de \verb+K+ en sortie de
boucle. Ici encore, nous n'aurons aucune information si nous ne savons pas
que la variable \verb+N+ a une valeur positive en entre'e de boucle.

\paragraph{Augmentation des sources d'information}

Pour pallier le proble`me pre'ce'dent, il faudrait pouvoir utiliser
des sources d'information secondaires comme les de'clarations
de tableaux\footnote{Mais attention aux de'clarations du genre
\verb+REAL T(1)+ que font les programmeurs Fortran dans les
sous-programmes quand ils ne voulent pas passer
la dimension en argument.}, et admettre que les boucles \verb+DO+ sont
programme'es pour e^tre exe'cute'es au moins une fois.

\subsection{Plan de travail}

La programmation de ce nouvel algorithme d'analyse se'mantique, qui
devrait re'soudre les points 1 et 4 de la section 2.1 du pre'ce'dent
rapport d'avancement, devrait e^tre effectue'e en priorite'. Il restera
ensuite a` ame'liorer la technique d'e'largissement en fonction des
re'sultats obtenus sur les programmes dont nous disposons (points~2~et~3)
et, tre`s vraisemblablement, l'efficacite' des proce'dures utilise'es.

\section{Conclusion}

La re'alisation du paralle'liseur PIPS progresse comme pre'vu. Il nous
faut maintenant aborder les proble`mes interproce'duraux et les
transformations de programme.

\newpage
\SEC{ANNEXE 1 --- DETECTION DU PARALLELISME}
\PAR{}
Cette annexe contient la description des structures de donne'es prive'es
du paralle'liseur.

\PAR{}
La structure de donne'es suivante imple'mente un graphe oriente'. Cette
structure est ge'ne'rique, mais elle peut e^tre adapte'e aux besoins de
chacun gra^ce aux deux domaines externes {\tt vertex\_label} et {\tt
arc\_label} qui sont attache's respectivement aux noeuds et aux arcs du
graphe.

Cette structure est utilise'e pour le graphe des de'pendances et pour le
graphe de contro^le d'un module.

\domain{External vertex\_label}
{}
\domain{External arc\_label}
{}

\domain{Graph = vertices:vertex*}
{Un graphe se compose tout simplement d'un ensemble de noeuds,
repre'sente's par le domaine {\tt vertex}.}

\domain{Vertex = vertex\_label x succs:succ*}
{Chaque noeud d'un graphe est repre'sente' par un {\tt vertex}. Le
sous-domaine {\tt succs} donne la liste des successeurs du noeud. Le
sous-domaine {\tt vertex\_label} doit etre utilise' pour les informations
attache'es a` chaque noeud et dont la nature de'pend de l'application
utilisant le graphe; voir par exemple le domaine {\tt dg\_vertex\_label}
dans le fichier {\tt kennedy.f.tex}.}

\domain{Succ = arc\_label x vertex}
{Chaque arc d'un graphe est repre'sente' par un {\tt succ}. Le
sous-domaine {\tt vertex} contient le noeud vers lequel l'arc pointe. Le
sous-domaine {\tt arc\_label} doit e^tre utilise' pour contenir les
informations attache'es a` chaque arc{,} et dont la nature de'pend de
l'application utilisant le graphe; voir par exemple le domaine {\tt
dg\_arc\_label} dans le fichier {\tt kennedy.f.tex}.}

\newpage{}
\PAR{}
Les structures de donne'es suivantes sont utilise'es par la phase {\tt
kennedy} de PIPS.

\domain{Import statement from "ri.newgen"}
{}
\domain{Import vertex from "graph.newgen"}
{}

\domain{dg\_vertex\_label = statement x enclosing\_loops:statement* x sccflags}
{Ce domaine est utilise' pour contenir les informations qui sont
attache'es a` chaque noeud du graphe de de'pendances (voir le domaine
{\tt graph} dans le fichier {\tt graph.f.tex}). Le sous-domaine {\tt
statement} repre'sente l'instruction qui porte la de'pendance. Le
sous-domaine {\tt enclosing\_loops} represente les boucles qui englobent
cette instruction; c'est une liste de {\tt statement} et non pas une
liste de {\tt loop} pour avoir acce`s aux effets de ces boucles. Le
sous-domaine {\tt sccflags} contient diverses informations utiles pour
le calcul des composantes fortement connexes.}

\domain{dg\_arc\_label = all\_levels:unit + levels:int*}
{Ce domaine est utilise' pour contenir les informations qui sont
attache'es a` chaque arc du graphe de de'pendances (voir le domaine {\tt
graph} dans le fichier {\tt graph.f.tex}). Il s'agit des niveaux des
de'pendances repre'sente'es par cet arc. Les de'pendances de niveau {\tt
all\_levels} sont cre'e'es par les scalaires affecte's dans les boucles.}

\domain{Sccflags = enclosing\_scc:scc x mark:int x dfnumber:int x lowlink:int}
{Ce domaine est utilise' par l'algorithme de calcul des composantes
fortement connexes d'un graphe.}

\domain{Sccs = sccs:scc*}
{Ce domaine permet de contenir le re'sultat de l'algorithme de calcul
des composantes fortement connexes d'un graphe. Il s'agit d'une liste de
{\tt scc}, c'est a` dire de composantes fortement connexes.}
\domain{Scc = vertices:vertex* x indegree:int}
{Ce domaine permet de repre'senter une composante fortement connexe d'un
graphe. Une {\tt scc} se compose d'un ensemble de noeuds, et d'un
sous-domaine {\tt indegree} utilise' par l'algorithme de tri topologique.
}

\newpage
\SEC{ANNEXE 2 --- RESULTATS DU PARALLELISEUR}
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           T(I) = 0.0
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
002           T(I) = 0.0
000       ENDDO
\end{verbatim}

en 0.8 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           T(I) = 0.0
003           V(I) = T(I) ** 2.
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
002           T(I) = 0.0
000       ENDDO
000       DOALL I = 1,10,1
003           V(I) = T(I) ** 2.
000       ENDDO
\end{verbatim}

en 1.2 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           DO J = 1,10,1
003               V1(I,J) = 0.0
004               V2(I,J) = V2(I,J) + V1(I + 1,J)
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
004               V2(I,J) = V2(I,J) + V1(I + 1,J)
000           ENDDO
000       ENDDO
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
003               V1(I,J) = 0.0
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.5 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           MAT(I,I) = 0.0
003           DO J = 1,I - 1,1
004               MAT(I,J) = 1.0
005               MAT(J,I) = --1.0
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DOALL J = 1,I - 1,1
005               MAT(J,I) = --1.0
000           ENDDO
000       ENDDO
000       DOALL I = 1,10,1
000           DOALL J = 1,I - 1,1
004               MAT(I,J) = 1.0
000           ENDDO
000       ENDDO
000       DOALL I = 1,10,1
002           MAT(I,I) = 0.0
000       ENDDO
\end{verbatim}

en 2.0 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           DO J = 1,10,1
003               MAT(I,J) = 0.0
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
003               MAT(I,J) = 0.0
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.0 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO L = 1,N - 1,1
002           DO J = L + 1,N,1
003               A(L,J) = A(L,J) / A(L,L)
000           ENDDO
004           DO I = L + 1,N,1
005               DO K = L + 1,N,1
006                   B(I,K) = A(I,L) * A(L,K)
007                   A(I,K) = A(I,K) - B(I,K)
000               ENDDO
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DO L = 1,N - 1,1
000           DOALL J = L + 1,N,1
003               A(L,J) = A(L,J) / A(L,L)
000           ENDDO
000           DOALL I = L + 1,N,1
000               DOALL K = L + 1,N,1
006                   B(I,K) = A(I,L) * A(L,K)
000               ENDDO
000           ENDDO
000           DOALL I = L + 1,N,1
000               DOALL K = L + 1,N,1
007                   A(I,K) = A(I,K) - B(I,K)
000               ENDDO
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.5 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,L,1
002           DO J = 1,N,1
003               C(I,J) = 0.0
004               DO K = 1,M,1
005                   C(I,J) = C(I,J) + A(I,K) * B(K,J)
000               ENDDO
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,L,1
000           DOALL J = 1,N,1
003               C(I,J) = 0.0
000           ENDDO
000       ENDDO
000       DOALL I = 1,L,1
000           DOALL J = 1,N,1
000               DO K = 1,M,1
005                   C(I,J) = C(I,J) + A(I,K) * B(K,J)
000               ENDDO
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.1 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           V1(I) = 0.0
003           V2(I) = V2(I) + V1(I + 1)
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
003           V2(I) = V2(I) + V1(I + 1)
000       ENDDO
000       DOALL I = 1,10,1
002           V1(I) = 0.0
000       ENDDO
\end{verbatim}

en 1.2 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           DO J = 1,10,1
003               V1(I,J) = 0.0
004               V2(I,J) = V2(I,J) + V1(I + 1,J)
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
004               V2(I,J) = V2(I,J) + V1(I + 1,J)
000           ENDDO
000       ENDDO
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
003               V1(I,J) = 0.0
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.7 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           DO J = 1,10,1
003               V1(I,J) = 0.0
004               V2(I,J) = V1(I,J) + V1(I,J + 1)
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DO J = 1,10,1
003               V1(I,J) = 0.0
004               V2(I,J) = V1(I,J) + V1(I,J + 1)
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.5 secondes.

\newpage
\paragraph{}
La boucle suivante:
\begin{verbatim}
001       DO I = 1,10,1
002           DO J = 1,10,1
003               V1(I,J) = 0.0
004               V2(I,J) = V1(I,J) + V1(I,J)
000           ENDDO
000       ENDDO
\end{verbatim}

est transforme'e en:

\begin{verbatim}
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
003               V1(I,J) = 0.0
000           ENDDO
000       ENDDO
000       DOALL I = 1,10,1
000           DOALL J = 1,10,1
004               V2(I,J) = V1(I,J) + V1(I,J)
000           ENDDO
000       ENDDO
\end{verbatim}

en 1.5 secondes.


\newpage
\SEC{ANNEXE 3 --- GRAPHE DE CONTROLE}
\PAR{}
Cette annexe contient le listing des programmes sources du graphe de
contro^le. 

\end{document}
\end
