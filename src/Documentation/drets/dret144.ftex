%	Rapport dret144
%	Manuel Utilisateur du Paralle'liseur
%	Version 1.0
%	rendue le 07.01.91
%	Version 1.1
%	preparee a partir du 15.03.91 (apres la recette)
%
% Il faudra faire evoluer ce manuel en tenant compte des remarques des
% utilisateurs et au fur et a mesure de l'evolution de PIPS.
% Les corrections les plus urgentes sont specifiees en commentaire
% commencant par %%


\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS \\
		Manuel Utilisateur du Paralle'liseur Batch (Version 2.1)}
\newcommand{\auteur}{
		Bruno BARON \\
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT\\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}
\renewcommand{\docdate}{13 Juillet 1992}
\newcommand{\numero}{E144}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\section*{Introduction}

Le Paralle'liseur Interproce'dural de Programmes Scientifiques PIPS est
un compilateur-restructureur {\em source a` source} qui transforme du
code Fortran se'quentiel en du code Fortran paralle`le. La version
actuelle de PIPS ne vise pas une machine particulie`re. L'objectif est
simplement de de'tecter autant de paralle'lisme que possible.

Cette notice s'adresse a` l'utilisateur averti qui a de bonnes
connaissances en programmation et en paralle'lisation automatique. Il
convient de porter son attention directement sur les exemples, en
re'servant la compre'hension de toutes les explications a` une lecture
poste'rieure. Elle est restreinte a` la version {\em batch} de PIPS.
La version multifene^tre de PIPS, {\tt wpips}, n'est pas pre'sente'e.
 
Nous pre'sentons tout d'abord les principes et le vocabulaire de base.
Nous montrons ensuite comment initialiser l'espace de travail qui va
permettre de conserver les nouvelles versions du programme et les
informations qui y sont attache'es. 

Nous de'taillons ensuite la commande {\em Display} qui permet d'afficher
directement des re'sultats a` l'e'cran. Une utilisation plus comple`te
des fonctionalite's de PIPS ne'cessite l'utilisation d'autres commandes
comme {\em Select} qui permet de choisir des options de compilation ou
d'analyse, {\em Build} qui permet de calculer des informations ou de
transformer le programme sans afficher les re'sultats et {\em Perform}
qui permet d'effectuer des transformations de programme explicitement.

Nous donnons ensuite la liste des analyses et des transformations de programme
qui peuvent e^tre effectue'es avec PIPS.

\section{Principes du fonctionnement}

%est de'crite par le schema 1.

Pour pre'server les
fichiers sources, pour permettre le de'veloppement de plusieurs versions
et pour regrouper en un unique endroit l'ensemble des fichiers qui sont
cre'e's au cours de la compilation d'un programme, l'analyse et les
transformations de programme sont re'alise'es dans le cadre d'un {\bf
workspace} (espace de travail) qui n'est qu'un sous-re'pertoire du
re'pertoire courant.

A cet espace de travail est associe'e une base de donne'es qui indique
a` chaque instant quelles sont les informations disponibles et quelles
sont les options choisies.  Chaque {\bf phase} du compilateur va ajouter
dans le {\em workspace} de nouveaux fichiers, appele's {\bf ressources}
dans la terminologie PIPS.  Plusieurs {\em phases} sont ge'ne'ralement
enchai^ne'es pour satisfaire une seule reque^te de l'utilisateur.

Afin d'assurer la cohe'rence de cet enchai^nement, toutes les reque^tes
de l'utilisateur sont effectue'es par {\bf Display}, {\bf Build} ou {\bf
Perform} ainsi que {\bf Interchange}. Ces commandes calculent
l'enchai^nement ne'cessaire a` la construction cohe'rente de la
ressource demande'e ou a` l'application correcte d'une re`gle.

A un programme source donne' peuvent naturellement correspondre plusieurs
espaces de travail, contenant chacun des versions paralle'lise'es diffe'rentes,
obtenues par la se'lection d'options de compilation diffe'rentes ou
par l'application explicite de diverses transformations de programmes.

\subsection{Notion de workspace}

% programme ressource

Pour travailler sur un code source, il faut donc commencer par cre'er un {\bf
workspace}, compose' de {\bf modules}. Plusieurs {\em workspaces}
peuvent e^tre cre'e's a` partir des me^mes fichiers sources, afin d'obtenir
plusieurs versions d'analyses et de transformations d'un programme. Un
{\bf module} correspond a` une proce'dure du programme associe' au workspace.

\subsection{Notion de ressource et de reque^te}

% pipsdbm, ressources, actions (ex cre'ation d'une ressource)

Les {\bf ressources} sont des objets type's, qui correspondent a` des
structures de donne'es. Chacune d'entre elles est stocke'e d'une
manie`re permanente dans un fichier portant le me^me nom. Elles sont
entie`rement ge're'es par le {\em contro^leur de ressources}, qui permet
de disposer des ressources sur disque comme en me'moire. Les ressources
de chaque type sont produites lors de l'exe'cution d'une {\bf phase}
particulie`re de PIPS, et sont relatives soit au programme tout entier,
soit a` un module particulier, qu'il s'agisse du programme principal,
d'une proce'dure ou d'une fonction.

% a une entite' du {\em workspace} (dite {\em
% owner}): PROGRAM pour le {\em programme}, MODULE pour le {\em module},
% CALLERS pour les modules {\em appelants} le module courant ou CALLEES
% pour les modules {\em appele's} par le module courant.

% Gestion de la base (ne rien faire en dehors de pips)

Les ressources sont cre'e'es directement par une reque^te explicite de
l'utilisateur, ou indirectement parce qu'elles s'ave`rent ne'cessaires
au calcul d'une autre ressource demande'e, elle, explicitement.

On peut conside'rer les reque^tes essentielles comme une action sur la
base de ressources. Afin de pre'server la cohe'rence de cette base de
ressources, il ne faut manipuler ces ressources qu'avec les utilitaires
PIPS de'crits dans cette notice: {\tt Display}, {\tt Build}, {\tt
Perform}, {\tt Interchange} ainsi que {\tt Delete}.

\subsection{Manipulations du workspace. Contro^leur de ressources}

%% Etre explicite sur le controleur de ressources
%% Donner dans Build et Perform l'explication de:
%% Request: Build RESOURCE for module MODULE...
%% Request: Perform RULE for module MODULE...

Afin de minimiser le temps de calcul et de rendre PIPS interactif
malgre' son caracte`re interproce'dural, les ressources ne sont
construites qu'a` la demande. A l'inte'rieur de {\tt Display}, {\tt
Build}, {\tt Perform} et {\tt Interchange}, des me'canismes de type {\em
make} enchai^nent re'cursivement l'exe'cution de chaque re`gle (ie.
chaque phase) requise au moment ou` les ressources dont elle a besoin
ont e'te' produites. Ces me'canismes s'appellent dans PIPS les
contro^leurs de ressources (pipsmake). Cela assure aussi la
re'utilisation des ressources, dans la mesure ou` pour chaque re`gle les
ressources produites sont poste'rieures aux ressources requises.

\subsection{Analyses et Transformations}
De nombreuses phases d'analyse et de transformation du programme peuvent
e^tre applique'es successivement, sans souci de la cohe'rence des
enchai^nements, qui est prise en charge par le contro^leur de
ressources. Ainsi l'utilisateur peut-il se concentrer sur le travail ou`
sa connaissance du programme est re'ellement utile.


\section{Cre'ation d'un workspace: Init}

\subsection{Environnement de PIPS}

% repertoire, source lu seulement

Pour utiliser PIPS, il faut pouvoir exe'cuter {\tt Init}, {\tt Build},
{\tt Perform} et {\tt Select}. Il convient d'ajouter a` son path la
directory ou` se trouvent ces shell-scripts et de de'finir quelques
variables d'environnement. Pour cela, il suffit d'exe'cuter l'un des
shell-scripts (selon votre shell usuel) fourni avec PIPS: 

{\tt . Pips/pipsrc.sh} (shell sh ou ksh) ou 

{\tt source Pips/pipsrc.csh} (shell csh ou tcsh). 

Si vous utilisez PIPS plusieurs fois, cette commande devrait e^tre
place'e dans votre fichier d'initialisation du shell.

Toutes ces commandes seront appele'es depuis le re'pertoire ou` sont
situe's les fichiers sources du programme que vous voulez paralle'liser.

PIPS ne'cessite beaucoup de place a` la fois en me'moire et sur disque.
Assurez-vous que vous disposez d'une capacite' suffisante avant de
commencer une nouvelle session... 

\subsection{Init}

% Utilisation, resultats

Usage: {\bf Init workspace [file.f] ...}

Pour cre'er un workspace de nom {\tt wspace} pour paralle'liser les
fichiers sources Fortran {\tt src1.f} et {\tt src2.f}, faire:
{\tt \$ Init wspace src1.f src2.f}

Les structures cre'e'es sont les suivantes: {\em wspace.schema} qui
de'crit la base de ressources, {\em wspace.database}, re'pertoire qui
comprendra toute la base de ressources, chaque ressource e'tant un
fichier; elle est initialise'e avec les SOURCE\_FILE, correspondant au
source de chacunes des proce'dures du programme (ou {\em modules}). Ces
SOURCE\_FILEs sont de'rive's, a` l'aide de l'utilitaire {\em fsplit}, a`
partir de vos propres fichiers sources, qui sont aussi vus comme des
ressources, dites USER\_FILE mais qui sont exceptionnellement en dehors du
re'pertoire {\em wspace.database} et qui ne seront jamais modifie's.
Chaque fichier SOURCE\_FILE ne contient donc qu'un unique module et
prend comme nom le nom de ce module.

Pour revenir a` un workspace de'ja` existant, utiliser:
{\tt \$ Init wspace}

Si vous n'e^tes pas seul a` travailler dans un me^me re'pertoire, il vous
faut spe'cifier votre workspace a` chaque commande (option {\tt -w}).

\subsection{Exemple}
Soit le fichier matmul.f qui comprend les proce'dures mm et saxpy. Pour
cre'er le programme mm1 a` partir de ce fichier, placez-vous sous un
re'pertoire qui contient matmul.f et tapez la commande:

{\tt \$ Init mm1 matmul.f}

Les messages qui notifient l'activite' de PIPS sont nombreux afin de
suivre les calculs re'alise's. Remarquer simplement parmi ceux de la
commande Init:
\begin{verbatim}
Spliting file    matmul.f
  Module         MM
  Module         SAXPY
\end{verbatim}
Nous savons donc que les modules de mm1 sont MM et SAXPY (qui peuvent
e^tre spe'cifie's en lettres minuscules dans les commandes suivantes).

Les fichiers cre'e's sont {\tt mm1.schema}, {\tt mm1.database/mm.f} et
{\tt mm1.database/saxpy.f}

\subsection{Destruction d'un workspace: Delete}

Afin de supprimer un workspace de nom wspace, il suffit de faire:
{\tt Delete wspace}

Noter que les sources re'els du programme (ressources USER\_FILE) ne sont pas
efface's par {\tt Delete}.


\section{Affichage des re'sultats: Display}

\subsection{Principe}

La plupart des analyses et des transformations de programme produisent
des re'sultats lisibles dans l'une des ressources PRINTED\_FILE ou
PARALLELPRINTED\_FILE, construites avec les re`gles ade'quates. Les
transformations de code sont alors effectue'es, et les analyses du code
sont visibles en commentaire de ces fichiers Fortran. La fabrication des
ressources et leur affichage est automatiquement re'alise' par la
commande {\tt Display}, qui exe'cute un appel a` {\tt Build}.

\subsection{Display}
Usage: {\bf Display [-w wspace] [-m module] pretty-print}

ou` les valeurs possibles de pretty-print sont: {\tt para code tran
prec comp prop cumu cg cgl cgc para90 }, et la valeur par de'faut est
{\tt para}. 

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

{\bf pretty-print} est une cle' a` laquelle sont associe's des
traitements PIPS qui aboutissent a` la fabrication d'une ressource
PRINTED\_FILE ou CALLGRAPH\_FILE ou encore PARALLELPRINTED\_FILE; ces
ressources sont des fichiers de texte qui permettent d'afficher les
analyses et transformations de programme.

\paragraph{PRINTED\_FILE} construit avec:
\begin{itemize}
\item{\tt code} donne le pretty-print de la repre'sentation interme'diaire
du module qu'utilise PIPS;
\item{\tt tran} donne en plus l'analyse se'mantique des transformers en
commentaire;
\item{\tt prec} fait de me^me avec les pre'conditions;
\item{\tt comp} fait de me^me avec les complexite's;
\item{\tt prop} fait de me^me avec les effets propres;
\item{\tt cumu} fait de me^me avec les effets cumules.
\end{itemize}

\paragraph{CALLGRAPH\_FILE} construit avec:
\begin{itemize}
\item{\tt cg} affiche le graphe des appels
\item{\tt cgl} donne en plus les boucles qui comprennent des appels
\item{\tt cgc} fait de me^me avec les structures de contro^le.
\end{itemize}

\paragraph{PARALLELPRINTED\_FILE} construit avec:
\begin{itemize}
\item{\tt para} donne le pretty-print du code paralle`le;
\item{\tt para90} donne aussi le pretty-print du code paralle`le, mais avec
la notation Fortran 90.
\end{itemize}

La ressource construite est affiche'e sur le fichier de sortie standard
stdout, alors que les messages informatifs sortent sur le fichier
d'erreur standard stderr.

\subsection{Exemple}
Pour visualiser la version paralle`le du module MM de mm1, taper:

{\tt \$ Display -m mm}

Toutes les phases doivent s'enchai^ner pour construire la ressource
\newline PARALLELPRINTED\_FILE du module MM. Finalement, on obtient:

\begin{verbatim}
Display of file mm1.database/MM.parf
C
C     MATRIX MULTIPLICATION - VERSION WITH CALL TO SAXPY
C
C     PARALLELIZATION OF LOOPS INCLUDING CALLS TO PROCEDURE
C
      SUBROUTINE MM(N, A, B, C)
C
      REAL*8 A(N,N), B(N,N), C(N,N), XAUX(0:127)
C
      DOALL I = 1,N,1
         PRIVATE I
         DOALL J = 1,N,1
            PRIVATE J
            C(I,J) = 0.0                                          0006
         ENDDO
      ENDDO
C
      DOALL J = 1,N,1
         PRIVATE J
         DO K = 1,N,1
            PRIVATE K
            CALL SAXPY(N, C(1,J), A(1,K), B(K,J))                 0011
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

Pour conserver dans le fichier mm1.mm.prec les pre'conditions de ce module,
faire: 

{\tt \$ Display prec > mm1.mm.prec}

Il faut noter que malgre' sa grande utilite', la commande {\tt Display}
ne permet pas de be'ne'ficier de toute la puissance de PIPS. Aussi
faut-il savoir recourir a` {\tt Select} , {\tt Perform}, {\tt
Build} et {\tt Interchange}.


\section{Choix des options: Select}

% Makefile reconfigurable

Pour initialiser un {\em workspace}, il faut spe'cifier quelles sont les
re`gles de construction des ressources. Une phase est une exe'cution
d'une re`gle, et a` chaque ressource est associe'e au moins une re`gle de
production. Un exemple de re`gle par de'faut est fourni dans le fichier
{\tt \$LIBDIR/pipsmake.rc}

\subsection{Fichier pipsmake.rc}

Au premier appel de {\tt Build}, {\tt Perform} ou {\tt
Select}, un fichier {\tt pipsmake.rc} est lu pour apprendre a`
PIPS les re`gles de production des ressources: celui du re'pertoire
courant s'il existe, celui de {\tt \$LIBDIR} a` de'faut. Aussi
pouvez-vous cre'er votre propre fichier d'initialisation de PIPS en
copiant  {\tt pipsmake.rc} et en le modifiant (voir la syntaxe de ce
fichier en annexe {\em pipsmake}).

Lorsque plusieurs re`gles sont disponibles dans {\tt pipsmake.rc} pour
cre'er une me^me ressource, la premie`re d'entre elles est
se'lectionne'e. Une autre re`gle pourra e^tre se'lectionne'e a` la place
de la premie`re au moyen de la commande {\tt Select}.

Une re`gle se'lectionne'e sera au besoin utilise'e pour une phase afin
de calculer une ressource requise. C'est la` le principe du {\em make}.

Une fois que {\tt pipsmake.rc} a e'te' lu, il ne sera plus jamais
utilise' pour ce workspace, puisqu'une repre'sentation interne du
pipsmake est conserve'e et tenue a` jour pour chaque workspace. Elle est
stocke'e dans le fichier {\tt wspace.pipsmake}.

\subsection{Select}
Usage: {\bf Select [-w wspace] rule [rule] ...}

Le workspace courant est utilise' a` moins qu'un nom ne soit spe'cifie'
par l'option {\tt -w}.

Les re`gles a` se'lectionner sont spe'cifiables soit par un nom
interne a` PIPS \newline (ex. {\tt rice\_full\_dependence\_graph}), soit
par un alias ge're' par le shell-script {\tt Build} (ex. {\tt rfulldg}).
Voir l'annexe {\em alias}.

\subsection{Exemple}
Soit le programme {\tt choles.f}. Montrons qu'il est ne'cessaire de
se'lectionner la re`gle \newline {\tt rice\_full\_dependence\_graph}
pour le paralle'liser:

{\tt \$ Init c2 choles.f}

Un seul module: CHOLES.

{\tt \$ Perform -m choles privatizer}

Ainsi sont privatise'es les variables pour lesquelles cette
transformation est licite.

{\tt \$ Display para >c2.para}
%%on pourrait faire 2>/dev/null (...) mais ne marche pas sous csh ni tcsh

Mais ce pretty-print n'est pas paralle`le:
\begin{verbatim} 
$ cat c2.para
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1,N,1
         PRIVATE I,KK,J,K,X
         X = A(I,I)                                              0004
         DO K = 1,(I-1),1
            PRIVATE K
            X = (X-(A(I,K)*A(I,K)))                              0007
         ENDDO
         P(I) = (1.0/SQRT(X))                                    0008
         DO J = (I+1),N,1
            PRIVATE J,KK,X
            X = A(I,J)                                           0011
            DO KK = 1,(I-1),1
               PRIVATE KK
               X = (X-(A(I,J)*A(I,KK)))                          0014
            ENDDO
            A(J,I) = (X*P(I))                                    0015
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}
Donc il convient de choisir une re`gle qui imple'mente un algorithme qui
tienne compte des pre'conditions:

{\tt \$ Select rfulldg}

Ainsi la re`gle RICE\_FULL\_DEPENDENCE\_GRAPH est se'lectionne'e.

{\tt \$ Display para >c2.para}

Qui calcule une version effectivement paralle`le:
\begin{verbatim} 
$ cat c2.para
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1,N,1
         PRIVATE I,KK,J,K,X
         X = A(I,I)                                                    0004
         DO K = 1,(I-1),1
            PRIVATE K
            X = (X-(A(I,K)*A(I,K)))                                    0007
         ENDDO
         P(I) = (1.0/SQRT(X))                                          0008
         DOALL J = (I+1),N,1
            PRIVATE J,KK,X
            X = A(I,J)                                                 0011
            DO KK = 1,(I-1),1
               PRIVATE KK
               X = (X-(A(I,J)*A(I,KK)))                                0014
            ENDDO
            A(J,I) = (X*P(I))                                          0015
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

\subsection{Avertissement}

Comme nous le constatons sur l'exemple pre'ce'dent, certaines re`gles ne
doivent pas e^tre se'lectionne'es, mais applique'es. L'application
consiste a` demander l'exe'cution {\em imme'diate} d'une re`gle
spe'cifique; elle est toujours licite. Par contre, la se'lection
consiste a` choisir la re`gle qui sera utilise'e {\em ulte'rieurement}
par de'faut pour produire une ressource d'un certain type.

Toutes les re`gles ne peuvent pas e^tre se'lectionne'es, afin de ne pas
introduire de cycle dans l'enchai^nement des re`gles. Par exemple,
la re`gle de nom {\tt distributer}, qui effectue la distribution de
boucles, et la re`gle {\tt privatizer}, qui privatise les variables
scalaires dans 
les boucles, produisent toutes deux la ressource {\tt CODE} a` partir
d'une ressource {\tt CODE} qui doit e^tre de'ja` disponible pour le
me^me module. Il faut donc que reste se'lectionne'e une autre re`gle qui
produise initialement {\tt CODE} ({\tt link} par de'faut). Cela ne
serait plus vrai si l'on se'lectionnait {\tt distributer} ou {\tt
privatizer} (cf. section {\em Application d'une re`gle: Perform}).


\section{Demande d'une ressource: Build}

\subsection{Build}
Usage: {\bf Build [-w wspace] [-m module] [-s
selected\_rule[,selected\_rule]...] [-p performed\_rule] resource}

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

La re`gles et la ressource peuvent e^tre spe'cifie'es par leur vrai nom
ou par un alias. Les alias sont ge'ne'ralement plus explicites mais
aussi plus longs.

Les re`gles {\tt selected\_rule} e'ventuellement spe'cifie'es avec
l'option -s sont se'lectionne'es (cf. {\em Select}).

Ensuite la re`gle {\tt perform\_rule} e'ventuellement spe'cifie'e avec
l'option -p est applique'e (cf. {\em Perform}).

Pour finir, la ressource {\tt resource} est calcule'e (build), a` moins
que ce ne soit une chai^ne vide, auquel cas seuls le Select et le Perform
sont effectue's.

Il faut remarquer qu'un effet e'quivalent a` celui d'un Select ou d'un
Perform peut e^tre
obtenu en utilisant des options de Build\footnote{En fait, Select et Perform font un appel
a` Build qui effectue les conversions et ve'rifications requises puis
appelle les binaires ne'cessaires. De cette fac,on, les alias peuvent
e^tre modifie's dans Build et valoir pour les autres shell-scripts (cf.
annexe {\em Alias}).}.

\subsection{Application}

Vous souhaitez une ressource qui ne soit pas visualisable a` l'e'cran
comme les effets d'une proce'dure ou un graphe de de'pendance (cf. annexe
{\em Base de ressources}). Pour l'obtenir, vous devez alors utiliser
Build. Cela est utile a` des fins de debug ou bien pour re'cupe'rer des
re'sultats partiels a` l'intention d'un autre logiciel. Le graphe de
de'pendance pourrait ainsi e^tre re'utilise' pour faire de l'ordonnancement
d'instructions.


\section{Application d'une re`gle: Perform}

\subsection{Perform}
Usage: {\bf Perform [-w wspace] [-m module] rule}

Le workspace (resp. le module) courant est utilise' a` moins qu'un nom
ne soit spe'cifie' par l'option {\tt -w} (resp. {\tt -m}).

La re`gle rule peut e^tre spe'cifie'e par son nom vrai ou par son nom
d'alias.

Il est ne'cessaire d'appliquer explicitement les re`gles qui ne
produisent pas directement une ressource mais qui la modifie.  C'est
notamment le cas de {\tt distributer} et {\tt privatizer} pour la
production de CODE.

\subsection{Exemple}

Voir la section Select.


\section{Analyses}
% chains et dg lost
Les phases de'crites ci-dessous sont celles pour lesquelles il est
possible de choisir un algoritme en utilisant {\em Select}. Il s'agit du
calcul des pre'dicats (les transformers et les pre'conditions) pour
l'analyse se'mantique, ainsi que du calcul du graphe de de'pendance. Cf.
rapport EMP-CAI-I E/137 pour plus de de'tails.

\subsection{Transformers}
Quatre algorithmes sont disponibles et leur distinction se fait sur deux
crite`res: Ils sont plus ou moins pre'cis et intra ou inter-proce'duraux.

Les re`gles associe'es a` ces algorithmes sont: TransFormers\_intra\_fast
(alias tf), TransFormers\_intra\_FULL (alias tffull),
TransFormers\_INTER\_fast (alias tfinter) TransFormers\_INTER\_FULL
(alias tfinterfull). 

\subsection{Pre'conditions}
De manie`re similaire, les re`gles sont: PreConditions\_intra (alias
pc),\newline PreConditions\_INTER\_fast (alias pcinter),
PreConditions\_INTER\_FULL (alias pcinterfull).

\subsection{Graphe de de'pendance}
Deux algorithmes sont disponibles: Rice\_fast\_Dependence\_Graph (alias
rdg) et \newline Rice\_FULL\_Dependence\_Graph (alias rfulldg), qui
prend en compte les pre'dicats.


\section{Transformations du programme}

\subsection{Privatisation de variables}
Celle-ci est toujours re'alise'e pour les indices de boucle sans qu'elle
soit demande'e. Par contre il faut appliquer la re`gle {\tt PRIVatizer}
(alias {\tt priv}) pour privatiser toutes les variables qui peuvent
l'e^tre, avant de demander la paralle'lisation, naturellement.

\subsection{Distribution de boucles}
Elle est re'alise'e en appliquant la re`gle {\tt DISTributer} 
(alias {\tt dist}). 

\subsection{Echange de boucles: Interchange}

Cette transformation fait exception quant a` son utilisation. 
Elle n'est pas applique'e avec Perform parce qu'il faut
pre'ciser le label de la boucle a` e'changer avec la boucle la plus
interne du nid de boucle.

Elle est accessible de cette interface par la commande {\bf Interchange}
dont la syntaxe est:

{\tt \$ Interchange [-w wspace] [-m module] label}

Cette commande effectue l'e'quivalent de Perform d'une re`gle qui
produirait la ressource CODE et enchai^ne imme'diatement un Display du
pretty-print code.

\subsubsection{Exemple}
Soit le code initial de loop4.f:

\begin{verbatim}
      program loop4

      real t(10,10)
      real v(10,10)

      do 100 i = 1, 5
         do 100 j = 1, i          
            t(j+1,i)=t(j,i) + v(j,i)
 100     continue
         end
\end{verbatim}

Pour obtenir l'inversion des deux  boucles:

\begin{verbatim}
$ Init l4 loop4.f
$ Interchange -m loop4 100 >l4.inv
$ cat l4.inv
      PROGRAM LOOP4

      REAL T(10,10)
      REAL V(10,10)

      DO 100 Ip = 1,5,1                                                0004
         DO 100 Jp = Ip,5,1                                            0006
            T((1+Ip),Jp) = (T(Ip,Jp)+V(Ip,Jp))                         0007
100         CONTINUE                                                   0008
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

% \subsubsection{Avertissement}

% Il n'est pas ve'rifie' que cette transformation est licite. Il convient
% donc de l'appliquer en connaissance des effets. Pour plus de de'tails,
% se re'fe'rer au rapport EMP-CAI-I E/143.

\subsection{Paralle'lisation de nid de boucles}

C'est la transformation de programme par de'faut; elle est obtenue en
demandant {\tt Display [para]}, qui construit la ressource 
PARALLELPRINTED\_FILE.
A la diffe'rence des transformations pre'ce'dentes, celle-ci est
e'labore'e a` partir de la ressource PARALLELIZED\_CODE distincte de la
ressource CODE a` partir de laquelle elle a e'te' construite. Elle peut
donc e^tre demande'e implicitement.

Ainsi, la paralle'lisation interproce'durale d'un module \verb+foo+ d'un
programme Fortran \verb+bar+ contenu dans le fichier \verb+source.f+ se
re'sume a`:
\begin{verbatim}
$ Init bar-v1 source.f
$ Display -m foo
\end{verbatim}
ou` \verb+bar-v1+ est la zone contenant la premie`re version
paralle'lise'e du programme \verb+bar+. Une deuxie`me proce'dure,
\verb+foofoo+, peut e^tre ensuite traite'e par une unique commande dans
le me^me espace de travail \verb+bar-v1+:
\begin{verbatim}
$ Display -m foofoo 
\end{verbatim}
a` condition, bien su^r, que son code se soit trouve' dans votre
fichier Fortran \verb+source.f+.

\newpage

\section*{Conclusion}

PIPS est un paralle'liseur interproce'dural expe'rimental. La version
de'crite dans ce rapport est la premie`re qui soit mise entre les mains
d'utilisateurs exte'rieurs a` l'Ecole des Mines. Il est vraisemblable que
de nombreuses erreurs subsistent et nous vous sommes d'avance reconnaissant
de nous les signaler (e-mail: \verb+<pipsgroup@ensmp.fr>+). Ne'anmoins nous
espe'rons que PIPS vous permettra d'obtenir des re'sultats inte'ressants
en paralle'lisation interproce'durale.

%\section{Re'cupe'ration d'erreurs}


%\section{Debug}

\newpage

\section*{Annexe 1: Installation de PIPS}

La version initiale de PIPS est fournie pour stations et serveurs SUN4,
exploite's sous SUNOS~4.0.3. PIPS fonctionne avec 8~Mo de me'moire physique
et 14~Mo d'espace {\em swap} pour de petits programmes, mais il faut disposer
de plus d'espace de swap pour des programmes de plusieurs milliers de lignes,
et si possible de plus de me'moire. La configuration utilise'e a` l'Ecole
des Mines consiste en un SUN~4/260, 32~Mo de me'moire et 50~Mo d'espace
de swap.

Il faut:
\begin{enumerate}

  \item choisir un re'pertoire, un proprie'taire et un groupe pour la
sous-arborescence PIPS; nous avons choisi de de'finir au CRI un compte
{\em pips} qui se trouve dans le groupe {\em staff} comme les chercheurs;

  \item effectuer un \verb+tar x Pips+ dans le re'pertoire ou` Pips doit e^tre
installe'; ce re'pertoire est au CRI {\em /home/users/pips}

  \item mettre a` jour le proprie'taire, le groupe et les droits pour
cette sous-arborescence; ge'ne'ralement {\tt chmod} a une option re'cursive;
sinon, il faut utiliser find;

  \item mettre a` jour les variables shell PIPSDIR, LINEARDIR, NEWGENDIR,
TMPDIR et e'ventuellement OPENWINHOME dans le fichier {\tt
Pips/pipsrc.sh} en fonction du re'pertoire qui a e'te' 
choisi pour l'installation; il est pre'fe'rable de donner des noms
absolus a` ces variables; au CRI, {\tt PIPSDIR=/home/users/pips/Pips}.
Le fichier {\tt Pips/pipsrc.csh} doit alors e^tre mis a` jour en
executant la commande {\tt Pips/make-pipsrc.csh}.

  \item exe'cuter directement celui de ces deux fichiers qui correspond
a` l'analyseur de commande retenu (cf. section {\em Environnement de
PIPS}); avec le Bourne Shell ou le Korn Shell:
\begin{quote}
{\tt . pipsrc.sh}
\end{quote}
avec le C Shell ou le TC Shell:
\begin{quote}
{\tt source pipsrc.csh}
\end{quote}

  \item pour continuer l'installation suivre les instructions du fichier
\verb+$UTILDIR/install-pips-src+.

  \item Pour installer le {\tt man} (dans {\tt /usr/man/manl}:\\
\verb+ cd $DOCDIR
make man+

\end{enumerate}

%%Preciser la structure de la cassette

\newpage

\section*{Annexe 2: Fortran PIPS}

Le compilateur PIPS n'accepte pas l'ensemble du langage Fortran tel
qu'il est de'fini dans la norme Fortran-77. Les restrictions et
extensions qui lui ont e'te' apporte'es sont de'finies et justifie'es en
de'tail dans le rapport EMP-CAI-I~E/103.

Les restrictions essentielles au langage sont les suivantes:
\begin{enumerate}

  \item ENTRY 

  \item BLOCKDATA

  \item ASSIGN et GOTO assigne'

  \item RETURN multiple

  \item GOTO calcule'

  \item ope'rateur substring ``:''

  \item initialisation de chai^nes de caracte`res de type Hollerith \\
(par exemple \verb+DATA A /8HOPERATIN,8HG POINT /+ doit e^tre
transforme' en \verb+DATA A /'OPERATIN','G POINT '/+)

  \item le caracte`re {\em double quote} est prohibe' comme dans la
norme bien que de nombreux compilateurs acceptent un jeu de caracte`res
plus grand que celui qui est spe'cifie' dans la norme;

  \item les fonctions formules ne sont pas traite'es;

  \item les constantes complexes doivent e^tre remplace'es par un appel
a` \verb+CMPLX+;

  \item les de'clarations de COMMONs doivent apparai^tre apre`s
	toutes les de'clarations de type.

\end{enumerate}

Ces restrictions peuvent e^tre contourne'es en modifiant {\em
syntaxiquement} le programme (voir le rapport EMP-CAI-I~E/103).
Les BLOCKDATAs devraient e^tre inclus dans le programme principal. Les
me'canismes fondamentaux de Fortran sont bien tous traite's par PIPS.

Il est aussi a` noter que les restrictions 1 (M.V.13), 2 (M.III.4,
M.V.17), 3 (M.III.6), 4 (M.V.12, M.V.16) et 7 (M.VI.15) )font partie des
constructions qu'il est conseille' d'e'viter dans:
\begin{quote}
FORTRAN 77 - Guide pour l'e'criture de programmes portables \\
Franc,oise Ficheux-Vapne'\\
(annexe B)
\end{quote}
D'autres conseils donne's dans cet ouvrage permettront d'ame'liorer
les re'sultats donne's par PIPS:
\begin{itemize}
  \item utilisation de \verb+END+ sans \verb+STOP+ ni \verb+RETURN+
	pour terminer les unite's de programme (M.IV.3, M.V.1, M.V.8, M.V.14);
  \item de'finition uniforme des \verb+COMMONs+ dans tout un programme
	(M.V.21)
\end{itemize}

% Il n'est pas non plus possible d'utiliser la me^me chai^ne de
% caracte`res pour un symbole global comme un nom de module ou de common
% et pour un symbole local comme un nom de variable ou de parame`tre formel.
% Cette dernie`re restriction est une source d'erreurs quelques fois difficiles
% a` comprendre.

Il faut s'assurer que tous les modules sont explicitement nomme's par
une instruction \verb+PROGRAM+, \verb+SUBROUTINE+ ou \verb+FUNCTION+.
Cela veut dire qu'il faut ajouter l'instruction:
\begin{center}
\begin{verbatim}
PROGRAM MAIN
\end{verbatim}
\end{center}
aux programmes principaux qui ne comprennent pas d'instructions \verb+PROGRAM+.
Un nom plus e'vocateur que \verb+MAIN+ peut bien su^r e^tre choisi.

L'objectif n'e'tant pas d'e'crire un compilateur commercial, les
messages d'erreurs ne sont pas force'ment tre`s explicites. Il faut donc
s'assurer au pre'alable que le programme soumis a` PIPS est accepte' par
un compilateur conventionnel. Les options de compilation choisie devraient
e^tre aussi se've`res que possible de manie`re a` e'liminer au maximum
les extensions par rapport a` la norme Fortran-77.

Un des proble`mes rencontre's est la restriction des instructions aux colonnes
7 a 72. Avec les editeurs pleine page, il est parfois difficile de se rendre
compte qu'on a depasser cette limite. Les messages fournis par PIPS sont
alors impre'visibles et incompre'hensibles par celui qui regarde le source.

Pour minimiser les proble`mes, les de'clarations devraient avoir la structure
suivante:
\begin{enumerate}

  \item de'claration des arguments;

  \item ordre \verb+IMPLICIT+ optionnel;

  \item de'claration des types et dimensions des variables;

  \item de'claration des externes, l'ordre EXTERNAL pre'ce'dant la
	de'claration de type;

  \item de'claration des \verb+COMMON+s.

\end{enumerate}

Les boucles DO ne devraient pas porter d'e'tiquettes. Pour en assurer la
paralle'lisation, il faut les re'e'crire comme un CONTINUE portant
l'e'tiquette suivi d'un DO sans e'tiquette:
\begin{verbatim}
 100 DO 200 I = 1, N
\end{verbatim}
doit e^tre mis sous la forme:
\begin{verbatim}
 100 CONTINUE
     DO 200 I = 1, N
\end{verbatim}

Enfin, les ordres DATA portant sur des variables statiques ne sont
correctement traite's qui s'ils se trouvent dans le programme principal
ou, tout au moins, dans le module le plus haut dans l'arbre des appels.
Cela est du^ a` des hypothe`ses approximatives sur la maine`re dont les
ordres DATA sont imple'mente's pour les variables dynamiques...

\newpage

\section*{Annexe 3: Messages d'erreur}

De nombreux messages d'erreurs ou d'avertissement peuvent e^tre e'mis par PIPS
(fichier non existant, erreur de syntaxe, option inconnue, etc...).
Les erreurs propres au compilateur provoquent volontairement
un message {\em core dumped} de manie`re a` pouvoir analyser ce qui s'est
passe'.

Le non-fonctionnement de \verb+pips_make+, qui se traduit par des recalculs
inutiles ou par des absences de calculs utiles, est ge'ne'ralement du^
au fonctionnement de NFS. Il faut ve'rifier que la machine sur laquelle
tourne PIPS a exactement la me^me heure que la machine qui ge`re les
fichiers. Le test peut se faire avec une commande du genre:

\begin{verbatim}
date; echo bonjour >foo; ls -l foo;rm foo
\end{verbatim}

Les stations peuvent e^tre resynchronise'es sur le serveur NFS en
utilisant la commande \verb+rdate+.

\section*{Annexe 4: Erreurs connues}

% L'algorithme de paralle'lisation ne prend pas en compte les de'pendances
% portant sur les {\em bornes} de boucles. Une distribution de boucle
% malencontreuse est parfois applique'e a` des affectations de variables
% scalaires locales. Il faut essayer d'e'liminer ces variables scalaires
% en remplac,ant leurs occurences par leur expression d'initialisation.
% Le programme re'sultant est faux.

L'algorithme de calcul des {\em use-def chains} cre'e de fausses
de'pendances sur des indices de boucle. Elles sont dues a` l'utilisation
d'un indice identique dans un DO implicite ou dans une expression de bornes
d'autres boucles. Ce proble`me est facilement identifiable parce que
l'indice de la boucle non paralle'lise'e n'est pas de'clare' {\tt
PRIVATE.} Le programme re'sultant n'est pas optimal mais est correct.

% Ces deux comportements aberrants sont dus au calcul des effets des
% instructions. Nous n'avons pas encore trouve' une solution qui soit a`
% la fois correcte et efficace.

Les commentaires portant sur les instructions {\tt GOTO} et {\tt RETURN}
sont perdus. Ceci est du^ au traitement des {\tt RETURN} comme des {\tt
GOTO} vers la fin de la proce'dure courante et a` la conversion des {\tt
GOTO} en arcs du graphe de contro^le. Il n'a pas e'te' pre'vu de faire
porter des commentaires par ces arcs. 

L'impression des formats longs de plus d'une ligne se fait en un seul
enregistrement. Les lignes suites qui devraient e^tre cre'es ne le sont pas.
Le fichier re'sultant n'est pas compilable.

Les fonctions formelles sont reconnues par le parser mais elles ne sont
pas traite'es correctement par les phases d'analyse. Le parser
emet un message de type \verb+user_error+.

Dans les de'clarations, les informations de type et de dimension doivent
e^tre donne'es avant les de'clarations de commons. En cas d'inversion,
les adresses des variables dans les commons peuvent e^tre fausses ainsi que
les calculs de de'pendance qui porteront sur elles.

% L'ordre {\tt EXTERNAL} n'est pas reconnu par le parser.

Les STOPs apparaissant dans des sous-programmes et les exceptions en
ge'ne'ral ne sont pas correctement traite's.

Le caracte`re {\em double quote} est pas accepte' dans les chai^nes de
caracte`res (N.B. il ne fait pas partie du jeu de caracte`res standard
de Fortran). Mais il ne peut pas servir comme de'limiteur de constante
chai^ne de caracte`res.
% Il faudrait quand me^me le filtrer automatiquement. Le proble`me
% vient de NewGen et non de PIPS.

Si un ordre ENTRY est utilise', PIPS de'clare qu'il manque le source
du module de nom sorrespondant si un CALL est rencontre' avant la
de'finition de l'ENTRY. La de'finition de l'ENTRY provoque une
erreur normale quand elle est rencontre'e.

Les PARAMETERs entient doivent e^tre initialise's par des expressions
inte'gralement entie`res. Aucun casting n'est effectue'.

\newpage

\section*{Annexe 5: Base de ressources}

Les calculs effectue's, la ressource sera disponible dans le fichier 
\newline {\tt wspace.database/MODULE.extension}. extension est en
lettres majuscules s'il s'agit d'une ressource structure'e pour PIPS (et
correspond au nom de la ressource), et en lettres minuscules s'il s'agit
d'une ressource construite par un pretty-printer (qui ge'ne`re du code
plus des commentaires).

Les ressources structure'es pour PIPS ne sont pas lisibles, et ne
peuvent servir qu'a` de futurs calculs dans la base.

Parmi les pretty-prints, on aura les extensions {\tt f} pour le Fortran
du SOURCE\_FILE, {\tt pref} pour le pretty-print du Fortran se'quentiel,
{\tt parf} pour le pretty-print du Fortran paralle`le, {\tt pred} pour
le pretty-print des pre'dicats. Pourtant, il est pre'fe'rable d'utiliser
la commande Display qui fournit une version toujours mise a` jour du
pretty-print requis.

Les manipulation directes du workshpace sont a` prohiber parce qu'elles
risquent d'engendrer des incohe'rences entre la base et son sche'ma.

\newpage

\section*{Annexe 6: Contro^leur de ressources pipsmake}

La syntaxe d'une re`gle du fichier pipsmake.rc est la suivante:
\begin{verbatim}
rule		> OWNER.resource
		[> OWNER.resource]...
	[< OWNER.resource]...
\end{verbatim}

Ces re`gles ne doivent pas e^tre modifie'es, mais il est possible d'en
changer l'ordre. Cf. rapport EMP-CAI-I~E/133 pour plus de de'tails.

La manipulation directe du fichier \verb+pipsmake.rc+ est a` e'viter.
Il faut commencer par en faire une copie dans la directory courante.
Cette copie n'est prise en compte que pour les nouveaux workspaces.

Tous les re'sultats souhaitables doivent pouvoir e^tre obtenus a` l'aide
de la commande {\em Select}, sauf la modification des 
options par de'faut. Par exemple, le test de de'pendance rapide peut e^tre
remplace' par le test de de'pendance pre'cis en e'changeant les re`gles
\verb+rice_fast_dependence_graph+ et \verb+rice_full_dependence_graph+.

\newpage

\section*{Annexe 7: Alias}

Les alias sont utilisables pour les re`gles et les ressources,
dans chacun des arguments correspondants de Build, Perform et Select.
Pourtant leur usage n'est jamais ne'cessaire (les noms de re`gles ou les
ressources sont aussi valides).

Les alias sont imple'mente's dans le shell-script de Pips (pre'sent
dans {\tt \$UTILDIR/Pips}), au moyen de la commande {\tt sed} de la
fonction {\tt rename()}. Une ligne correspond a` un alias, et la syntaxe
est la suivante:

{\tt s/alias\_name/true\_name/;}

Lorsque l'alias\_name est une sous-chai^ne d'un autre alias, il faut
qu'il soit positionne' apre`s lui.

%% Autres regles a preciser

Chaque utilisateur peut donc rede'finir les alias, qui sont initialise's
ainsi:

% A chaque modification de la zone verbatim suivante, refaire M-x untabify
% sur la region.
\begin{verbatim}
# resources
        s/PPF/ParallelPrinted_File/; \
        s/CGF/CallGraph_File/; \
        s/PF/Printed_File/; \
# rules for
    #dg
        s/rfulldg/Rice_FULL_Dependence_Graph/; \
        s/rsdg/Rice_Semantics_Dependence_Graph/; \
        s/rdg/Rice_fast_Dependence_Graph/; \
        s/prsdg/Print_Rice_Semantics_Dependence_Graph/; \
    #transformers
        s/tffull/TransFormers_intra_FULL/; \
        s/tfinterfull/TransFormers_INTER_FULL/; \
        s/tfinter/TransFormers_INTER_fast/; \
        s/tf/TransFormers_intra_fast/; \
    #preconditions
        s/pcinterfull/PreConditions_INTER_FULL/; \
        s/pcinter/PreConditions_INTER_fast/; \
        s/pc/PreConditions_intra/; \
    #callgraph_file
        s/prcgl/PRint_Call_Graph_with_Loops/; \
        s/prcgc/PRint_Call_Graph_with_Control/; \
        s/prcg/PRint_Call_Graph/; \
    #printed_file
        s/prct/PRint_Code_Transformers/; \
        s/prcpe/PRint_Code_Proper_Effects/; \
        s/prcce/PRint_Code_Cumulated_Effects/; \
        s/prcp/PRint_Code_Preconditions/; \
        s/prcc/PRint_Code_Complexities/; \
        s/prc/PRint_Code/; \
#Transformations to perform:
        s/dist/DISTributer/; \
        s/priv/PRIVatizer/; \
\end{verbatim}

\end{document}
