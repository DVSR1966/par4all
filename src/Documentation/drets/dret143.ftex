\documentstyle[12pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions.tex}

\newcommand{\titre}{PROJET PIPS \\
		RESULTATS SUR LES PROGRAMMES TESTS
}

\newcommand{\auteur}{
        	Franc,ois IRIGOIN \\
        	Pierre JOUVELOT \\
\vspace{0.5cm}
{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}
}
\newcommand{\docdate}{De'cembre 1990}
\newcommand{\numero}{E143}

\begin{document}
\input{/usr/share/local/lib/tex/macroslocales/PageTitre.tex}

{\it Le pre'sent document a e'te' e'tabli en exe'cution du contrat
No.~88.017.01 passe' par la Direction des Recherches, Etudes et
Techniques (De'le'gation Ge'ne'rale pour l'Armement)}

\vspace{2cm}

\tableofcontents

\newpage

\section*{Introduction}

Nous pre'sentons d'abord les re'sultats obtenus sur les cas d'e'cole par
les phases d'analyse de programmes et par les phases de transformations
de programmes. Nous analysons ensuite les re'sultats obtenus sur les
programmes re'els de test fournis par l'ONERA.

\section{Tests des phases d'analyse}

Seule parmi les phases d'analyse, la recherche de relations line'aires
entre variables scalaires se pre^te a` la constitution de programmes
de de'monstration. En effet, les calculs des effets des instructions et
ceux des {\em SDFI} ne produisent pas des re'sultats lisibles. Le calcul
des {\em use-def chains} produit un graphe, encore plus difficile a` e'tudier.

La validite' de ces analyses doit donc e^tre estime'e par l'utilisateur en
fonction des re'sultats de paralle'lisation.

\subsection{Analyse intraproce'durale}

\paragraph{Effet de l'enveloppe convexe}

~\newline
Programme initial:
\begin{verbatim}
      program intrar
      i = 3
      if(j.eq.6) then
         k = 0
      else
         k = 1
      endif
      end
\end{verbatim}

Programme de'core' avec les pre'conditions:
\begin{verbatim}
      PROGRAM INTRAR
C                       P() {}
      I = 3
C                       P(I) {I==3}
      IF ((J.EQ.6)) THEN
C                       P(I) {J==6, I==3}
         K = 0
      ELSE
C                       P(I) {I==3}
         K = 1
      ENDIF
C                       P(K, I) {0<=K, K<=1, I==3}
      RETURN
      END
\end{verbatim}

\subsection{Analyse interproce'durale}

Mise en e'vidence de l'effet de la se'lection de l'option
interproce'durale pour le calcul des {\em transformers}.

Programme initial:
\begin{verbatim}
      program interr
      i = 3
      j = 4
      call swap(i,j)
      end
      subroutine swap(n,m)
      integer t
      t = n
      n = m
      m = t
      return
      end
\end{verbatim}

Pre'conditions obtenues intraproce'duralement\footnote{En fait, il
s'agit d'une analyse interproce'durale ou` seuls les {\em SDFI} de la
routine \verb+SWAP+ sont pris en compte.}:
\begin{verbatim}
      PROGRAM INTERR
C                       P() {}
      I = 3
C                       P(I) {I==3}
      J = 4
C                       P(J, I) {J==4, I==3}
      CALL SWAP(I, J)
C                       P(J, I) {}
      RETURN
      END
\end{verbatim}

Re'sultat de l'analyse interproce'durale:
\begin{verbatim}
      PROGRAM INTERR
C                       P() {}
      I = 3
C                       P(I) {I==3}
      J = 4
C                       P(J, I) {J==4, I==3}
      CALL SWAP(I, J)
C                       P(J, I) {J==3, I==4}
      RETURN
      END
\end{verbatim}

\newpage

\section{Tests des transformations}

Nous pre'sentons successivement la privatisation, la paralle'lisation en
pre'sence de tests, la paralle'lisation avec distribution de boucles, la
paralle'lisation avec e'change des instructions et enfin la
paralle'lisation avec utilisation des pre'conditions. Nous ve'rifions que
nous de'tectons bien plusieurs niveaux de paralle'lisme, nous montrons que
nous pouvons proce'der a` des e'changes de boucles dans des cas ge'ne'raux,
puis nous finissons en comparant les sorties purement paralle`les,
utilisant Fortran~77 e'tendu, et les sorties vectorielles, utilisant
Fortran~90.

\subsection{Privatisation (expansion et substitution en avant)}

L'algorithme de Cholesky ne peut e^tre paralle'lise' que si les deux
utilisations de la variable X sont reconnues comme inde'pendantes et que
si X est privatise'e dans les boucles portant sur I et sur J.

Programme original:
\begin{verbatim}
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1, N
         X = A(I,I)
         DO K = 1, I-1
            X = X - A(I,K)*A(I,K)
         ENDDO
         P(I) = 1.0 / SQRT(X)
         DO J = I+1, N
            X = A(I,J)
            DO KK = 1, I-1
               X = X -A(I,J) * A(I,KK)
            ENDDO
            A(J,I) = X * P(I)
         ENDDO
      ENDDO
C
      RETURN
      END
\end{verbatim}

Programme transforme' apre`s privatisation:
\begin{verbatim}
C
C     CHOLESKI METHOD - VERSION 1
C
C     PRIVATIZATION
C     DEPENDENCE COMPUTATION WITH AND WITHOUT EXECUTION CONTEXT
C
      SUBROUTINE CHOLES(A, P, N)
      REAL X, A(N,N), P(N)
C
      DO I = 1,N,1                                                     0003
         PRIVATE KK,J,K,X
         X = A(I,I)                                                    0004
         DO K = 1,(I-1),1                                              0006
            X = (X-(A(I,K)*A(I,K)))                                    0007
         ENDDO
         P(I) = (1.0/SQRT(X))                                          0008
         DO J = (I+1),N,1                                              0010
            PRIVATE KK,X
            X = A(I,J)                                                 0011
            DO KK = 1,(I-1),1                                          0013
               X = (X-(A(I,J)*A(I,KK)))                                0014
            ENDDO
            A(J,I) = (X*P(I))                                          0015
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

\subsection{Paralle'lisation en pre'sence de tests}

La pre'sence de tests ne perturbe pas la reconnaissance des boucles
paralle`les.

Version initiale:
\begin{verbatim}
      program goto
      real t(200)
      
      do 10 i=1,100
         if( i.lt.50 ) goto 20
         do 30 j=1,200
            t(j) = 3.14159
 30      continue
 20      continue
 10   continue
      
      end
\end{verbatim}

Version paralle'lise'e:
\begin{verbatim}
      PROGRAM GOTO
      REAL T(200)
      
      DO 10 I = 1,100,1                                                0003
         PRIVATE I
         IF ((I.LT.50)) THEN                                           0009
         ELSE
            GOTO 99996
         ENDIF
99994    CONTINUE                                                      0004
10       CONTINUE                                                      0014
         GOTO 99992
99996    CONTINUE                                                      0006
         DOALL 30 J = 1,200,1
            PRIVATE J
            T(J) = 3.14159                                             0012
         ENDDO
         GOTO 99994
99992    CONTINUE
      ENDDO
      RETURN
      END
\end{verbatim}

La re'ge'ne'ration du graphe de contro^le n'est pas particulie`rement
adroite, mais le code ge'ne're' ne devrait pas perturber un compilateur.
Il faudrait bien su^r ame'liorer ce point si PIPS devait e^tre utilise'
interactivement.

\subsection {Paralle'lisation et distribution de boucles}

La distribution de boucles permet de  paralle'liser certaines
boucles. Elle est souvent associe'e a`  une autre transformation de
programme. Dans l'exemple suivant, elle permet de paralle'liser une
partie de la boucle.

Programme initial:

\begin{verbatim}
      program ditrb
      real t(10)
      real v(10)
      n=10
      do 100 i = 1, 10
         t(i) = t(i-1)+2
         v(i)=t(i)+v(i)
 100  continue
      end
\end{verbatim}

Programme obtenu apre`s paralle'lisation:

\begin{verbatim}
      PROGRAM DITRB
      REAL T(10)
      REAL V(10)
      N = 10
      DO 100 I = 1,10,1
         T(I) = (T((I-1))+2)
      DOALL 100 I = 1,10,1
         V(I) = (T(I)+V(I))
      ENDDO
      RETURN
      END
\end{verbatim}


\newpage
\subsection{Paralle'lisation et e'change des instructions }

Intervertir l'ordre d'exe'cution des instructions dans un corps de
boucles permet de vectoriser ou de paralle'liser certaines
boucles supple'mentaires.
Le programme suivant en est un exemple: 

Programme initial:

\begin{verbatim}

      program dists
      real t1(11,10)
      real t2(10,10)
      
      do 100 i = 1, 10,1
         do 100 j = 1,10,1
            t1(i,j) = 0
            t2(i,j)=t2(i,j) + t1(i+1,j)
 100     continue
         end

\end{verbatim}

L'interversion  des deux  instructions permet  de  vectoriser les boucles, 
ou  de les distribuer et de les paralle'liser.
La  boucle d'indice I  n'aurait pas e'te' paralle'lise'e dans la version
initiale du programme.

Le programme obtenu apre`s la phase de paralle'lisation est le suivant:

\begin{verbatim}

      PROGRAM DISTS
      REAL T1(11,10)
      REAL T2(10,10)

      DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 100 J = 1,10,1
            PRIVATE J
            T2(I,J) = (T2(I,J)+T1((I+1),J))                            0007
         ENDDO
      ENDDO
      DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 100 J = 1,10,1
            PRIVATE J
            T1(I,J) = 0                                                0006
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}




\subsection{Paralle'lisation  utilisant les pr\'econditions}


L'utilisation  des pre'conditions  permet de paralle'liser certaines
boucles qui ne l'auraient pas e'te' ne'cessairement.
Dans l'exemple suivant, elles vont permettre de paralle'liser la boucle 
d'incide I.

Programme initial:

\begin{verbatim}

      program prec
      real MAT(10,10)
      
      do 100 I = 1,10,1
         MAT(I,I) = 0.0
         do 100 J = 1,I - 1,1
            MAT(I,J) = 1.0
            MAT(J,I) = -1.0
 100     continue
         end
\end{verbatim}

 
La phase de calcul des pre'conditions donne les informations suivantes:

\begin{verbatim}

      PROGRAM PREC
      REAL MAT(10,10)

C                       P() {}
C                       P() {}
C                       P() {}
      DO 100 I = 1,10,1      
C                       P(J, I) {I<=10, 1<=I}
C                       P(J, I) {1<=I, I<=10}
         MAT(I,I) = 0.0      
C                       P(J, I) {I<=10, 1<=I}
         DO 100 J = 1,(I-1),1
C                       P(J, I) {J+1<=I, 1<=J, I<=10, 1<=I}
C                       P(J, I) {1<=I, I<=10, 1<=J, 1+J<=I}
            MAT(I,J) = 1.0   
C                       P(J, I) {J+1<=I, 1<=J, I<=10, 1<=I}
            MAT(J,I) = (-1.0)
C                       P(J, I) {1<=I, I<=10, 1<=J, 1+J<=I}
100         CONTINUE         
         ENDDO
      ENDDO
C                       P(J, I) {}
      RETURN
      END

\end{verbatim}

Ces informations utilise'es lors de  la phase de paralle'lisation
permettent de paralle'liser la boucle d'indice I:

\begin{verbatim}

      PROGRAM PREC
      REAL MAT(10,10)

     DOALL 100 I = 1,10,1
         PRIVATE I
         MAT(I,I) = 0.0                                                0004
      ENDDO
      DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 100 J = 1,(I-1),1
            PRIVATE J
            MAT(I,J) = 1.0                                             0007
         ENDDO
      ENDDO
      DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 100 J = 1,(I-1),1
            PRIVATE J
            MAT(J,I) = (-1.0)                                       
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

~\newpage
\subsection{Paralle'lisation et boucles imbriqu\'ees}

\begin{verbatim}
      program iloop
      real mat(10,10)

      do 100 i = 1, 10,1
         do 100 j = 1,10,1
            mat(i,j) = 0
 100     continue
         end
\end{verbatim}

Programme obtenu apre`s paralle'lisation:

\begin{verbatim}
   PROGRAM ILOOP
      REAL MAT(10,10)

       DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 100 J = 1,10,1
            PRIVATE J
            MAT(I,J) = 0                                               0006
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}

\subsection {Paralle'lisation du produit de matrices}

Programme initial:

\begin{verbatim}
      program matmul
      real a(10,10)
      real b(10,10)
      real c(10,10)
      
      l =10
      n=10
      m=10
      do 100 i = 1, l,1
         do 100 j = 1,n,1
            c(i,j) = 0
            do 100 k=1,m,1
               c(i,j)=c(i,j) + a(i,k) * b(k,j)
 100        continue
            end
\end{verbatim}

Programme obtenu apre`s paralle'lisation:

\begin{verbatim}

     PROGRAM MATMUL
      REAL A(10,10)
      REAL B(10,10)
      REAL C(10,10)

      L = 10                                                           0002
      N = 10                                                           0003
      M = 10                                                           0004
      DOALL 100 I = 1,L,1
         PRIVATE I
         DOALL 100 J = 1,N,1
            PRIVATE J
            C(I,J) = 0                                                 0009
         ENDDO
      ENDDO
      DOALL 100 I = 1,L,1
         PRIVATE I
         DOALL 100 J = 1,N,1
            PRIVATE J
            DO 100 K = 1,M,1
               PRIVATE K
               C(I,J) = (C(I,J)+(A(I,K)*B(K,J)))                       0012
            ENDDO
         ENDDO
      ENDDO
      RETURN
      END
\end{verbatim}


\subsection {Inversion de boucles}


 De manie`re ge'ne'rale, l'inversion de boucles  est utilise'e pour
augmenter la localite' des donne'es utilise'es et permettre la
vectorisation de la boucle la plus interne dans le corps de boucles.

~\newpage
\subsubsection{Inversion de boucles sur un domaine triangulaire}

Dans l'exemple suivant, l'inversion des deux boucles d'indices i et j
permet de vectoriser la boucle la plus interne.

Programme initial:

\begin{verbatim}
      program loop4

      real t(10,10)
      real v(10,10)

      do 100 i = 1, 5
         do 100 j = 1, i          
            t(j+1,i)=t(j,i) + v(j,i)
 100     continue
         end

\end{verbatim}

Programme obtenu apre`s l'inversion  des deux  boucles:

\begin{verbatim}
      PROGRAM LOOP4

      REAL T(10,10)
      REAL V(10,10)

      DO 100 Ip = 1,5,1                                                0004
         DO 100 Jp = Ip,5,1                                            0006
            T((1+Ip),Jp) = (T(Ip,Jp)+V(Ip,Jp))                         0007
100         CONTINUE                                                   0008
         ENDDO
      ENDDO
      RETURN
      END


\end{verbatim}

\subsubsection{Inversion de boucles sur un domaine plus complexe}

Dans l'exemple suivant, la boucle la plus interne est e'chang\'ee avec 
la plus externe. Cette ope'ration permet d'augmenter la localite' des
donne'es acce'de'es. Tous les e'le'ments des tableaux m et t seront
acce'de's de manie`re contig\"ue. 

~\newpage
Programme initial:

\begin{verbatim}
      program loop3

      real t(10,10,10)
      real m(10,10)

      N = 10
      do 100 i = 1, 10
         do 100 j = i+1, 10-i
            do 100 k = j, N
               m(i,j)  = m(i,j) + 2 * t(i,j,k) 
 100        continue
            end

\end{verbatim}

Programme obtenu apre`s l'inversion  des boucles:

\begin{verbatim}
      PROGRAM LOOP3
      REAL T(10,10,10)
      REAL M(10,10)

      N = 10                                                           0002
      DO 100 Ip = 2,N,1                                                0004
         DO 100 Jp = 2,Ip,1                                            0006
            DO 100 Kp = 1,MIN((10-Jp), (-1+Jp)),1                      0008
               M(Kp,Jp) = (M(Kp,Jp)+(2*T(Kp,Jp,Ip)))                   0009
100            CONTINUE                                                0010
            ENDDO
         ENDDO
      ENDDO
      RETURN
      END

\end{verbatim}

\subsection{Ge'neration de code vectoriel}

Pour obtenir une sortie en style Fortran~90, il faut mettre la
proprie'te' \verb+PRETTYPRINT_FORTRAN90+ a` vrai dans le fichier
\verb+properties.rc+ local.

\begin{verbatim}
      program vector
      real a(10,10), b(100)
      
      do 100 i = 1, 10
         do 200 j = 1, 10
            a(i,j) = 0.
 200     continue
 100  continue
      
      do 300 i = 1, 100
         b(i) = 1.
 300  continue
      
      end
\end{verbatim}
\begin{verbatim}
      PROGRAM VECTOR
      REAL A(10,10), B(100)
      
      DOALL 100 I = 1,10,1
         PRIVATE I
         A(I,(/I,I=1,10,1/)) = 0.
      ENDDO
      B((/I,I=1,100,1/)) = 1.
      RETURN
      END
\end{verbatim}

A noter que la re'utilisation de la variable {\tt I} dans le format
vectoriel n'entre pas en conflit avec l'indice {\tt I} de la boucle la
plus englobante, les scopes e'tant diffe'rents.

\subsection{Ge'ne'ration de code paralle`le}

Vu le manque de lisibilite' du code vectoriel utilisant les DO implicites dans
les expressions d'indices, l'option par de'faut consiste a` ne
ge'ne'rer que du code paralle`le. Il n'est donc pas ne'cessaire de
s'inquie'ter du fichier \verb+properties.rc+ local, a` moins qu'il ne
modifie justement la variable \verb+PRETTYPRINT_FORTRAN90+.

\begin{verbatim}
      program vector
      real a(10,10), b(100)
      
      do 100 i = 1, 10
         do 200 j = 1, 10
            a(i,j) = 0.
 200     continue
 100  continue
      
      do 300 i = 1, 100
         b(i) = 1.
 300  continue
      
      end
\end{verbatim}

\begin{verbatim}
      PROGRAM VECTOR
      REAL A(10,10), B(100)
      
      DOALL 100 I = 1,10,1
         PRIVATE I
         DOALL 200 J = 1,10,1
            PRIVATE J
            A(I,J) = 0.                                                0006
         ENDDO
      ENDDO
      DOALL 300 I = 1,100,1
         PRIVATE I
         B(I) = 1.                                                     0011
      ENDDO
      RETURN
      END
\end{verbatim}

\newpage

\section{Tests en vraie grandeur}

Les quatre programmes fournis par l'ONERA en tant qu'e'chantillons
repre'sentatifs des me'thodes nume'riques couramment utilise'es pour des
travaux lie's a` la de'fense nationale ont e'te' e'tudie's de quatre
manie`res diffe'rentes.

Ils ont tout d'abord permis de de'finir et de valider les restrictions
a` Fortran qui ont e'te' admises pour re'duire le volume de travail lie'
a` l'analyse se'mantique et la prise en compte de constructions ne
pouvant en aucun cas conduire a` des exe'cutions paralle`les. Les
re'sultats ont e'te' de'crits dans un pre'ce'dent rapport
(EMP-CAI-I~E/103, octobre 1988).

Depuis cette date, ces choix ont e'te' largement valide's sur des
programmes plus nombreux. La premie`re limitation qu'il faudrait retirer
concerne la notion de \verb+BLOCKDATA+ qui intervient trop souvent
pourqu'il soit possible de demander aux usagers de les remplacer par des
assignations dans le programme principal. Un deuxie`me proble`me s'est
re've'le' au moment du link: il n'est pas possible d'avoir une variable
ayant le me^me nom qu'un symbole global comme un COMMON ou une SUBROUTINE.

Ensuite une analyse manuelle des codes a e'te' effectue'e par un
analyste-nume'ricien pour de'finir le maximum de paralle'lisme que PIPS
pouvait trouver.
Cette e'tude tre`s fastidieuse n'a pu e^tre mene'e comple`tement
que pour le programme TMINES qui ne contient pas de paralle'lisme
interproce'dural, alors que sa de'tection est l'objectif premier du
projet PIPS.

Puis les quatre programmes ont e'te' soumis au paralle'liseur de
Cray Research, {\em FPP}, de manie`re a` pouvoir disposer d'une
re'fe'rence commerciale.

Enfin, les quatre programmes ont e'te' soumis a` PIPS en utilisant
diverses options pour le test de de'pendance. L'analyse manuelle des
re'sultats et la comparaison des divers re'sultats sont extre^mement
fastidieuses et elles ne font pas directement l'objet du contrat PIPS.
Il s'agit pluto^t de son e'valuation.

Il a donc fallu re'duire le champ des essais et l'essentiel des efforts
s'est porte' sur le programme {\em TMINES}.

\subsection{Programme TMINES}

Comme il a de'ja` e'te' indique' auparavant, le programme TMINES ne
contient pas de paralle'lisme interproce'dural dans des boucles DO.
PIPS et FPP de'tectent comme paralle`les les me^mes boucles.

L'algorithme de distribution de boucles de PIPS s'ave`re contenir une
erreur qui se manifeste lorsqu'une variable inductive d'une boucle
externe est utilise'e dans une expression de borne de boucle. Ce
proble`me peut e^tre re'solu (temporairement) en effectuant un
remplacement de la variable inductive par une expression faisant
intervenir les indices de boucles.

Le programme TMINES contient plusieurs variables inductives
multidimensionnelles que les me'thodes actuelles ne peuvent pas
convertir. La transformation devrait donc e^tre effectue'e a` la main.
La plupart des endroits ou` il peut e^tre utile de la faire peuvent e^tre
rapidement de'tecte's en recherchant les boucles dont la paralle'lisation
n'est empe^che'e que par une unique de'pendance.

Le programme TMINES est inte'gralement analyse' et paralle'lise'
interproce'duralement par PIPS. Il n'est bien su^r pas possible d'en
donner le listing complet.  A titre d'exemple, voici la version
paralle'lise'e de CALMAT, une des subroutines les plus importantes de TMINES:

\begin{verbatim}
      SUBROUTINE CALMAT(IM,JM,KM,R,CX,CY,CZ,BEL,BELK)
C
      DIMENSION CX(IM,JM,KM),CY(IM,JM,KM),CZ(IM,JM,KM),R(IM,JM,KM)
      DIMENSION BEL(37,IM-1,JM-1)
      DIMENSION BELK(37,IM-1,JM-1,KM-1)
C
      COMMON/POLXYZ/PXX(8,8,9),PYY(8,8,9),PZZ(8,8,9),PXY(8,8,9)
     $             ,PXZ(8,8,9),PYZ(8,8,9),P(8,9,3),W(9)
      COMMON/MACH/XMACH,XMIN,XMAX,XNEWT,IDEC
      COMMON/VECT/X(8,3,81),A(3,3,81),SURF(81),TEMP(81),RES(81,8)
     $,S11(81),S12(81),S13(81),S22(81),S23(81),S33(81)
      COMMON/SECM/SECM1(25,25),SECM2(25,25)
C
C
C
      IMM = (IM-1)                                                     0002
      JMM = (JM-1)                                                     0003
C
      KMM = (KM-1)                                                     0004
      DOALL 101 K = 1,KM,1
         PRIVATE K
         DOALL 101 J = 1,JM,1
            PRIVATE J
            R((/I,I=1,IM,1/),J,K) = 0.
         ENDDO
      ENDDO
C
      DO 1 K = 1,KMM,1
         PRIVATE K
         DOALL 11 LB = 1,37,1
            PRIVATE LB
            DOALL 11 J = 1,JMM,1
               PRIVATE J
               BEL(LB,(/I,I=1,IMM,1/),J) = 0.
            ENDDO
         ENDDO
         DO 10 J = 1,JMM,1
            PRIVATE J
            X(1,1,(/I,I=1,IMM,1/)) = CX((/I,I=1,IMM,1/),J,K)
            X(1,2,(/I,I=1,IMM,1/)) = CY((/I,I=1,IMM,1/),J,K)
            X(1,3,(/I,I=1,IMM,1/)) = CZ((/I,I=1,IMM,1/),J,K)
            X(2,1,(/I,I=1,IMM,1/)) = CX((/I,I=(1+1),(1+IMM),1/),J,K)
            X(2,2,(/I,I=1,IMM,1/)) = CY((/I,I=(1+1),(1+IMM),1/),J,K)
            X(2,3,(/I,I=1,IMM,1/)) = CZ((/I,I=(1+1),(1+IMM),1/),J,K)
            X(3,1,(/I,I=1,IMM,1/)) = CX((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,K)
            X(3,2,(/I,I=1,IMM,1/)) = CY((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,K)
            X(3,3,(/I,I=1,IMM,1/)) = CZ((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,K)
            X(4,1,(/I,I=1,IMM,1/)) = CX((/I,I=1,IMM,1/),(J+1),K)
            X(4,2,(/I,I=1,IMM,1/)) = CY((/I,I=1,IMM,1/),(J+1),K)
            X(4,3,(/I,I=1,IMM,1/)) = CZ((/I,I=1,IMM,1/),(J+1),K)
            X(5,1,(/I,I=1,IMM,1/)) = CX((/I,I=1,IMM,1/),J,(K+1))
            X(5,2,(/I,I=1,IMM,1/)) = CY((/I,I=1,IMM,1/),J,(K+1))
            X(5,3,(/I,I=1,IMM,1/)) = CZ((/I,I=1,IMM,1/),J,(K+1))
            X(6,1,(/I,I=1,IMM,1/)) = CX((/I,I=(1+1),(1+IMM),1/),J,(K+        -1
     &      1))
            X(6,2,(/I,I=1,IMM,1/)) = CY((/I,I=(1+1),(1+IMM),1/),J,(K+        -1
     &      1))
            X(6,3,(/I,I=1,IMM,1/)) = CZ((/I,I=(1+1),(1+IMM),1/),J,(K+        -1
     &      1))
            X(7,1,(/I,I=1,IMM,1/)) = CX((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,(K+1))
            X(7,2,(/I,I=1,IMM,1/)) = CY((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,(K+1))
            X(7,3,(/I,I=1,IMM,1/)) = CZ((/I,I=(1+1),(1+IMM),1/),(J+1)        -1
     &      ,(K+1))
            X(8,1,(/I,I=1,IMM,1/)) = CX((/I,I=1,IMM,1/),(J+1),(K+1))
            X(8,2,(/I,I=1,IMM,1/)) = CY((/I,I=1,IMM,1/),(J+1),(K+1))
            X(8,3,(/I,I=1,IMM,1/)) = CZ((/I,I=1,IMM,1/),(J+1),(K+1))
            DO 30 L = 1,8,1
               PRIVATE L
               SURF((/I,I=1,IMM,1/)) = W(L)
               DOALL 2 LJ = 1,3,1
                  PRIVATE LJ
                  DOALL 2 LK = 1,3,1
                     PRIVATE LK
                     A(LK,LJ,(/I,I=1,IMM,1/)) = 0.
                  ENDDO
               ENDDO
               DOALL 2 LJ = 1,3,1
                  PRIVATE LJ
                  DOALL 2 LK = 1,3,1
                     PRIVATE LK
                     DO 2 LL = 1,8,1
                        PRIVATE LL
                        A(LK,LJ,(/I,I=1,IMM,1/)) = (A(LK,LJ,(/I,I=1,         -1
     &                  IMM,1/))+(X(LL,LK,(/I,I=1,IMM,1/))*P(LL,L,LJ)        -1
     &                  ))
                     ENDDO
                  ENDDO
               ENDDO
               DO 3 LL = 1,3,1
                  PRIVATE LL
                  TEMP((/I,I=1,IMM,1/)) = A(LL,LL,(/I,I=1,IMM,1/))
                  SURF((/I,I=1,IMM,1/)) = (SURF((/I,I=1,IMM,1/))*TEMP        -1
     &            ((/I,I=1,IMM,1/)))
                  A(LL,LL,(/I,I=1,IMM,1/)) = 1.
                  DOALL 4 LJ = 1,3,1
                     PRIVATE LJ
                     A(LL,LJ,(/I,I=1,IMM,1/)) = (A(LL,LJ,I)/TEMP(I))
                  ENDDO
                  DO 5 KK = 1,2,1
                     PRIVATE KK
                     KKK = (1+MOD(((KK-1)+LL), 3))                     0084
                     TEMP((/I,I=1,IMM,1/)) = A(KKK,LL,(/I,I=1,IMM,1/)        -1
     &               )
                     A(KKK,LL,(/I,I=1,IMM,1/)) = 0.
                     DOALL 6 LJ = 1,3,1
                        PRIVATE LJ
                        A(KKK,LJ,(/I,I=1,IMM,1/)) = (A(KKK,LJ,I)-(           -1
     &                  TEMP(I)*A(LL,LJ,I)))
                     ENDDO
                  ENDDO
               ENDDO
               S11((/I,I=1,IMM,1/)) = (((A(1,1,(/I,I=1,IMM,1/))*A(1,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(1,2,(/I,I=1,IMM,1/))*A(1,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(1,3,(/I,I=1,IMM,1/))*A(1,3,             -1
     &         (/I,I=1,IMM,1/))))
               S22((/I,I=1,IMM,1/)) = (((A(2,1,(/I,I=1,IMM,1/))*A(2,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(2,2,(/I,I=1,IMM,1/))*A(2,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(2,3,(/I,I=1,IMM,1/))*A(2,3,             -1
     &         (/I,I=1,IMM,1/))))
               S33((/I,I=1,IMM,1/)) = (((A(3,1,(/I,I=1,IMM,1/))*A(3,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(3,2,(/I,I=1,IMM,1/))*A(3,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(3,3,(/I,I=1,IMM,1/))*A(3,3,             -1
     &         (/I,I=1,IMM,1/))))
               S12((/I,I=1,IMM,1/)) = (((A(1,1,(/I,I=1,IMM,1/))*A(2,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(1,2,(/I,I=1,IMM,1/))*A(2,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(1,3,(/I,I=1,IMM,1/))*A(2,3,             -1
     &         (/I,I=1,IMM,1/))))
               S13((/I,I=1,IMM,1/)) = (((A(1,1,(/I,I=1,IMM,1/))*A(3,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(1,2,(/I,I=1,IMM,1/))*A(3,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(1,3,(/I,I=1,IMM,1/))*A(3,3,             -1
     &         (/I,I=1,IMM,1/))))
               S23((/I,I=1,IMM,1/)) = (((A(2,1,(/I,I=1,IMM,1/))*A(3,1        -1
     &         ,(/I,I=1,IMM,1/)))+(A(2,2,(/I,I=1,IMM,1/))*A(3,2,             -1
     &         (/I,I=1,IMM,1/))))+(A(2,3,(/I,I=1,IMM,1/))*A(3,3,             -1
     &         (/I,I=1,IMM,1/))))
               SURF((/I,I=1,IMM,1/)) = ABS(SURF(I))
               BEL(37,(/I,I=1,IMM,1/),J) = (BEL(37,(/I,I=1,IMM,1/),J)        -1
     &         +SURF((/I,I=1,IMM,1/)))
               IJL = 0                                                 0108
               DO 8 IL = 1,8,1
                  PRIVATE IL
                  DO 8 JL = IL,8,1
                     IJL = (IJL+1)                                     0113
                     BEL(IJL,(/I,I=1,IMM,1/),J) = (BEL(IJL,(/I,I=1,          -1
     &               IMM,1/),J)+(SURF((/I,I=1,IMM,1/))*((((((S11(            -1
     &               (/I,I=1,IMM,1/))*PXX(IL,JL,L))+(S22((/I,I=1,IMM,        -1
     &               1/))*PYY(IL,JL,L)))+(S33((/I,I=1,IMM,1/))*PZZ(IL        -1
     &               ,JL,L)))+(S12((/I,I=1,IMM,1/))*PXY(IL,JL,L)))+(         -1
     &               S13((/I,I=1,IMM,1/))*PXZ(IL,JL,L)))+(S23((/I,I=1        -1
     &               ,IMM,1/))*PYZ(IL,JL,L)))))
                  ENDDO
               ENDDO
            ENDDO
            DOALL 39 L = 1,8,1
               PRIVATE L
               RES((/I,I=1,IMM,1/),L) = 0.
            ENDDO
            IND = 0                                                    0124
            DO 40 IL = 1,7,1
               PRIVATE IL
               IND = (IND+1)                                           0127
               RES((/I,I=1,IMM,1/),IL) = (RES((/I,I=1,IMM,1/),IL)+(          -1
     &         BEL(IND,(/I,I=1,IMM,1/),J)*X(IL,1,(/I,I=1,IMM,1/))))
               DO 40 JL = JJ,8,1
                  IND = (IND+1)                                        0134
                  RES((/I,I=1,IMM,1/),IL) = (RES((/I,I=1,IMM,1/),IL)+        -1
     &            (BEL(IND,(/I,I=1,IMM,1/),J)*X(JL,1,(/I,I=1,IMM,1/))        -1
     &            ))
                  RES((/I,I=1,IMM,1/),JL) = (RES((/I,I=1,IMM,1/),JL)+        -1
     &            (BEL(IND,(/I,I=1,IMM,1/),J)*X(IL,1,(/I,I=1,IMM,1/))        -1
     &            ))
               ENDDO
            ENDDO
            RES((/I,I=1,IMM,1/),8) = (RES((/I,I=1,IMM,1/),8)+(BEL(36,        -1
     &      (/I,I=1,IMM,1/),J)*X(8,1,(/I,I=1,IMM,1/))))
            R((/I,I=(1+1),(1+IMM),1/),J,K) = (R((I+1),J,K)-RES(I,2))
            R((/I,I=1,IMM,1/),J,K) = (R(I,J,K)-RES(I,1))
            R((/I,I=(1+1),(1+IMM),1/),J,(K+1)) = (R((I+1),J,(K+1))-          -1
     &      RES(I,6))
            R((/I,I=1,IMM,1/),J,(K+1)) = (R(I,J,(K+1))-RES(I,5))
            R((/I,I=(1+1),(1+IMM),1/),(J+1),K) = (R((I+1),(J+1),K)-          -1
     &      RES(I,3))
            R((/I,I=1,IMM,1/),(J+1),K) = (R(I,(J+1),K)-RES(I,4))
            R((/I,I=(1+1),(1+IMM),1/),(J+1),(K+1)) = (R((I+1),(J+1),(        -1
     &      K+1))-RES(I,7))
            R((/I,I=1,IMM,1/),(J+1),(K+1)) = (R(I,(J+1),(K+1))-RES(I,        -1
     &      8))
         ENDDO
         DOALL 66 LB = 1,37,1
            PRIVATE LB
            DOALL 66 I = 1,IMM,1
               PRIVATE I
               BELK(LB,I,(/I,I=1,JMM,1/),K) = BEL(LB,I,(/I,I=1,JMM,1         -1
     &         /))
            ENDDO
         ENDDO
      ENDDO
      DO 1 K = 1,KMM,1
         PRIVATE K
         DO 10 J = 1,JMM,1
            PRIVATE J
            DO 40 IL = 1,7,1
               PRIVATE IL
               JJ = (IL+1)                                             0128
            ENDDO
         ENDDO
      ENDDO
      DOALL 7 J = 1,JM,1
         PRIVATE J
         SECM1(J,(/I,I=1,KM,1/)) = (-R(1,J,K))
      ENDDO
      DOALL 7 J = 1,JM,1
         PRIVATE J
         SECM2(J,(/I,I=1,KM,1/)) = R(IM,J,(/I,I=1,KM,1/))
      ENDDO
      RETURN
      END

\end{verbatim}

A noter les de'clarations de type PRIVATE pour les variables locales a`
un corps de boucle.

\subsection{Programme OA118}

La version paralle'lise'e du module GRAD1 dans OA118.f est donne'e
ci-dessous. Aucun paralle'lisme interproce'dural n'est de'tecte' mais
il a quand me^me e'te' ne'cessaire d'analyser les sous-programmes
appele's, \verb+PMAT+, \verb+SDOT+ et \verb+SOLV3+.

\begin{verbatim}
       SUBROUTINE GRAD1(B,X)
C MULTI GRADIENT  SANS FENETRAGE
C 
       PARAMETER(NFAC=49,IRMAX=50)
      COMMON/OASET/PIO2
      COMMON/OACOF/AA(NFAC,NFAC)
       DIMENSION A(IRMAX,IRMAX),B(NFAC),X(NFAC)
       DIMENSION ALFA(IRMAX),R(NFAC,IRMAX),S(NFAC,IRMAX)
       DIMENSION Y(NFAC),Z(NFAC),RS(IRMAX),D(IRMAX)
      RRM = 1.E-20                                                     0002
C 111 X(I)=B(I)/AA(I,I)
      Y((/I,I=1,NFAC,1/)) = 0.
      X((/I,I=1,NFAC,1/)) = 0.
      R((/I,I=1,NFAC,1/),1) = (B(I)-Y(I))
      IPM = 50                                                         0010
      IPP = 1                                                          0011
      IP = 1
99997 IF ((IP.LE.IPM)) THEN
      ELSE
         GOTO 99996
      ENDIF
      IPP0 = IPP                                                       0014
      IPP = (IPP+1)                                                    0015
      IPQ = IP                                                         0016
      Y((/I,I=1,NFAC,1/)) = R((/I,I=1,NFAC,1/),IPP0)
      CALL PMAT(Y, Z)                                                  0020
      S((/I,I=1,NFAC,1/),IPP0) = Z((/I,I=1,NFAC,1/))
      DO 3 II = 1,IPQ,1
         Y((/I,I=1,NFAC,1/)) = S((/I,I=1,NFAC,1/),II)
         DO 5 JJ = II,IPQ,1
            Z((/I,I=1,NFAC,1/)) = S((/I,I=1,NFAC,1/),JJ)
            A(II,JJ) = SDOT(NFAC, Y, 1, Z, 1)                          0034
         ENDDO
         DO 5 JJ = II,IPQ,1
5           A(JJ,II) = A(II,JJ)                                        0035
         ENDDO
         Z((/I,I=1,NFAC,1/)) = R((/I,I=1,NFAC,1/),IPP0)
3        RS(II) = SDOT(NFAC, Y, 1, Z, 1)                               0039
      ENDDO
      CALL SOLV3(IPQ, A, RS, D)                                        0040
      R((/I,I=1,NFAC,1/),IPP) = R((/I,I=1,NFAC,1/),IPP0)
      DO 42 II = 1,IPQ,1
         X((/I,I=1,NFAC,1/)) = (X((/I,I=1,NFAC,1/))+(RS(II)*R((/I,I=1        -1
     &   ,NFAC,1/),II)))
      ENDDO
      DO 43 II = 1,IPQ,1
         R((/I,I=1,NFAC,1/),IPP) = (R(I,IPP)-(RS(II)*S(I,II)))
      ENDDO
      Y((/I,I=1,NFAC,1/)) = R((/I,I=1,NFAC,1/),IPP)
      RR = SDOT(NFAC, Y, 1, Y, 1)                                      0057
      WRITE (FMT=*,UNIT=6) IP,RR                                       0058
      WRITE (FMT=*,UNIT=100) IP,RR                                     0059
      IF ((RR.LT.RRM)) THEN                                            0065
      ELSE
         GOTO 99993
      ENDIF
99996 CONTINUE                                                         0060
99991 RETURN
      GOTO 99990
99993 CONTINUE                                                         0062
2     CONTINUE                                                         0066
      IP = (IP+1)
      GOTO 99997
99990 CONTINUE
      END
\end{verbatim}

A noter la pre'sence des instructions de branchement aux e'tiquettes de
la forme 9999x qui correspondent a` la rege'ne'ration sous forme de
programme Fortran du graphe de contro^le structure'.

\subsection{Programme CR2CNF}

Le programme CR2CNF est inte'gralement traite' par PIPS.

La version paralle'lise'e de MATELT, subroutine de CR2CNF, est donne'e
ci-dessous. Il faut remarquer le degre' d'imbrication e'leve' des boucles
DO. Il ne permet pas l'utilisation directe des techniques d'analyse
se'mantique de'veloppe'es par Halbwachs et Cousot.

\begin{verbatim}
C*********************************************************************
      SUBROUTINE MATELT(DAE,IMPRE)
      IMPLICIT REAL*8(A-H,O-Z)
C  ROUTINE DE CALCUL DE LA MATRICE DES INTEGRALES SUR LE PRISME DE
C  REFERENCE DES PRODUITS DES DERIVEES PARTIELLES DES FONCTIONS DE
C  BASE . DAE(K1,J1,K2,J2) = INTEGRALE DE DPHI(K1,J1)*DPHI(K2,J2)
      DIMENSION DAE(3,6,3,6),Y(3,6)
C  INITIALISATION DU TABLEAU DES COORDONNEES DES POINTS DE QUADRATURE .
      Z = (1./(2.*SQRT(3.)))                                           0002
      DO 1 I = 1,3,1
         Y(I,(/I,I=1,6,1/)) = 0.
      ENDDO
      Y(3,(/I,I=1,3,1/)) = (0.5-Z)
      Y(3,(/I,I=4,6,1/)) = (0.5+Z)
      DO 4 J = 1,4,3
         Y(1,J) = 0.5                                                  0016
      ENDDO
      DO 4 J = 1,4,3
         Y(1,(J+1)) = 0.5                                              0017
      ENDDO
      DO 4 J = 1,4,3
         Y(2,(J+1)) = 0.5                                              0018
      ENDDO
      DO 4 J = 1,4,3
         Y(2,(J+2)) = 0.5                                              0019
      ENDDO
      DOALL 5 K = 1,3,1
         DOALL 5 L = 1,3,1
            DO 5 I = 1,6,1
               DO 5 J = 1,6,1
C  CALCUL DE LA MATRICE DAE .
5                 DAE(K,I,L,J) = 0.                                    0029
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      DOALL 6 K = 1,3,1
         DOALL 6 L = 1,3,1
            DO 6 I = 1,6,1
               DO 6 J = 1,6,1
                  DO 6 NQ = 1,6,1
                     DAE(K,I,L,J) = (DAE(K,I,L,J)+((DPHI(K, I, Y(1,NQ        40
     &               ))*DPHI(L, J, Y(1,NQ)))/12.))                     0040
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      IF ((IMPRE.LE.0)) THEN                                           0047
      ELSE
         GOTO 99996
      ENDIF
99994 CONTINUE
      RETURN
      GOTO 99992
99996 CONTINUE                                                         0044
      WRITE (UNIT=6,FMT=*)                                                   48
     &'   MATRICES DES INTEGRALES DES DERIVEES DES FONCTIONS'          0048
      WRITE (UNIT=6,FMT=*) '   DE BASE SUR LE PRISME UNITAIRE'         0049
      DOALL 8 K = 1,3,1
         DOALL 8 L = 1,3,1
            WRITE (UNIT=6,FMT=1000) K,L                                0054
         ENDDO
      ENDDO
      DO 8 K = 1,3,1
         DO 8 L = 1,3,1
            WRITE (UNIT=6,FMT=2000) ((DAE(K,I,L,J)),J = 1,6,1)),I = 1        55
     &      ,6,1)                                                      0055
         ENDDO
      ENDDO
      GOTO 99994
99992 CONTINUE
      END
\end{verbatim}

\subsection{Programme AILE}

Le programme AILE est inte'gralement traite' par PIPS. L'exemple choisi est
celui de la routine \verb+GEOM+. Les boucles 89 et 33 sont correctement
paralle'lise'es mais les boucles 88, 111 et 222 restent se'quentielles.
Les causes de l'attitude prudente du paralle'liseur n'ont pas pu e^tre
de'couvertes.

\begin{verbatim}
      SUBROUTINE GEOM
C******************************************************
C      NXYZ    FICHIER DES COORDONNEES DES NOEUDS
C      NGEO    FICHIER DES COEF. ET DES NORMALES
C      NDIST   FICHIER DES RAYONS NUMERIQUES
C      MAILLAGE SYMETRIQUE / XOY
C******************************************************
      DIMENSION T(52,21,60)
      COMMON/CT/T
      COMMON/CTI/TITXYZ(8),TITRE0(8),IT0,TITRE(8),IT
      COMMON/IO/LEC,IMP,KIMP,NXYZ,NGEO,NDIST
      COMMON/CI/I1,I2,IMAX,I1P1,I1P2,I2M1,I2M2,IBF
      COMMON/CJ/J1,J2,JMAX,J1P1,J1P2,J2M1,J2M2,JA,JB,JAM1,JBP1
      COMMON/CK/K1,K2,KMAX,K1P1,K1P2,K2M1,K2M2
      COMMON/CKI1/KI1,LI1,MI1
      COMMON/CKI2/KI2,LI2,MI2
      DATA KPRE,KCOR/1,-1/
      DATA N1,N3,N4,N7,N10,N14,N17/1,3,4,7,10,14,17/
C
      READ (UNIT=NXYZ) TITXYZ                                           0002
      READ (UNIT=NXYZ) N,N,N,N,N,N                                      0003
      READ (UNIT=NXYZ) (((T(J,K,L), J = J1,JA,1), K = K1,K2,1), L = 7          4
     &,9,1)                                                             0004
      READ (UNIT=NXYZ) (((T(J,K,L), J = J1,JA,1), K = K1,K2,1), L = 4          5
     &,6,1)                                                             0005
      READ (UNIT=NXYZ) (((T(J,K,L), J = J1,JA,1), K = K1,K2,1), L = 1          6
     &,3,1)                                                             0006
      DO 88 K = K1,K2,1
         DO 88 J = J1,JA,1
            T(J,K,10) = (((KI2*T(J,K,7))+(LI2*T(J,K,4)))+(MI2*T(J,K,1         11
     &      )))                                                         0011
         ENDDO
      ENDDO
      DO 88 K = K1,K2,1
         DO 88 J = J1,JA,1
            T(J,K,11) = (((KI2*T(J,K,8))+(LI2*T(J,K,5)))+(MI2*T(J,K,2         12
     &      )))                                                         0012
         ENDDO
      ENDDO
      DO 88 K = K1,K2,1
         DO 88 J = J1,JA,1
            T(J,K,12) = (((KI2*T(J,K,9))+(LI2*T(J,K,6)))+(MI2*T(J,K,3         13
     &      )))                                                         0013
         ENDDO
      ENDDO
\end{verbatim}
\begin{verbatim}
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL COEF(N10, N7, N17, I2, KPRE, ID)                             0015
      IF ((UNIT(NGEO).LT.0)) THEN                                       0026
      ELSE
         GOTO 99995
      ENDIF
99993 CONTINUE                                                          0016
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL COEF(N7, N4, N17, I2M1, KPRE, ID)                            0027
      IF ((UNIT(NGEO).LT.0)) THEN                                       0037
      ELSE
         GOTO 99991
      ENDIF
99989 CONTINUE                                                          0028
      CALL COEF(N7, N4, N17, I2, KCOR, ID)                              0038
      CALL NORM(N10, N7, N4, N14, N17, I2)                              0039
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL EXTR(N7, N17)                                                0040
      IF ((UNIT(NGEO).LT.0)) THEN                                       0050
      ELSE
         GOTO 99987
      ENDIF
99985 CONTINUE
C     BUFFER OUT (NGEO,0) (T(1,1,14),T(JMAX,KMAX,16))
22    CONTINUE                                                          0041
      IF ((UNIT(NGEO).LT.0)) THEN                                       0060
      ELSE
         GOTO 99983
      ENDIF
99981 CONTINUE                                                          0051
      DO 111 K = K1,K2,1
         DO 111 J = J1,J2,1
            T(J,K,13) = SQRT(AMIN1(T(J,K,ID), T(J,K,(ID+2))))           0065
         ENDDO
      ENDDO
      IF ((UNIT(NDIST).LT.0)) THEN                                      0076
      ELSE
         GOTO 99979
      ENDIF
99977 CONTINUE                                                          0067
      II = I1P1
99976 IF ((II.LE.I2M1)) THEN
      ELSE
         GOTO 99975
      ENDIF
      I = ((I1+I2)-II)                                                  0079
      IM = (I-1)                                                        0080
      IF ((I.EQ.I2M1)) THEN                                             0086
      ELSE
         GOTO 99972
      ENDIF
\end{verbatim}
\begin{verbatim}
99970 CONTINUE                                                          0081
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL COEF(N4, N1, N17, IM, KPRE, ID)                              0090
      IF ((UNIT(NGEO).LT.0)) THEN                                       0100
      ELSE
         GOTO 99967
      ENDIF
99965 CONTINUE                                                          0091
      CALL COEF(N4, N1, N17, I, KCOR, ID)                               0101
      CALL NORM(N7, N4, N1, N14, N17, I)                                0102
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL EXTR(N4, N17)                                                0103
      IF ((UNIT(NGEO).LT.0)) THEN                                       0113
      ELSE
         GOTO 99963
      ENDIF
99961 CONTINUE                                                          0104
      DO 222 K = K1,K2,1
         DO 222 J = J1,J2,1
            T(J,K,13) = SQRT(AMIN1(T(J,K,ID), T(J,K,(ID+2))))           0118
         ENDDO
      ENDDO
      IF ((UNIT(NDIST).LT.0)) THEN                                      0129
      ELSE
         GOTO 99959
      ENDIF
99957 CONTINUE                                                          0120
100   CONTINUE                                                          0130
      II = (II+1)
      GOTO 99976
99959 IF ((UNIT(NDIST).EQ.0)) THEN                                      0126
      ELSE
         GOTO 99954
      ENDIF
99952 CONTINUE                                                          0018
      STOP                                                              0175
99951 RETURN
      GOTO 99949
99954 GOTO 99952
99963 IF ((UNIT(NGEO).EQ.0)) THEN                                       0110
      ELSE
         GOTO 99948
      ENDIF
      GOTO 99952
99948 GOTO 99952
99967 IF ((UNIT(NGEO).EQ.0)) THEN                                       0097
      ELSE
         GOTO 99946
      ENDIF
      GOTO 99952
99946 GOTO 99952
99972 CONTINUE                                                          0083
      CALL POUSSE(N4, N3, N7)                                           0087
      CALL POUSSE(N1, N3, N4)                                           0088
      READ (UNIT=NXYZ) (((T(J,K,L), J = J1,JA,1), K = K1,K2,1), L = 1         89
     &,3,1)                                                             0089
      GOTO 99970
\end{verbatim}
\begin{verbatim}
99975 DOALL 89 K = K1,K2,1
         T((/I,I=J1,JA,1/),K,10) = (((KI1*T((/I,I=J1,JA,1/),K,1))+(           -1
     &   LI1*T((/I,I=J1,JA,1/),K,4)))+(MI1*T((/I,I=J1,JA,1/),K,7)))
      ENDDO
      DOALL 89 K = K1,K2,1
         T((/I,I=J1,JA,1/),K,11) = (((KI1*T((/I,I=J1,JA,1/),K,2))+(           -1
     &   LI1*T((/I,I=J1,JA,1/),K,5)))+(MI1*T((/I,I=J1,JA,1/),K,8)))
      ENDDO
      DOALL 89 K = K1,K2,1
         T((/I,I=J1,JA,1/),K,12) = (((KI1*T((/I,I=J1,JA,1/),K,3))+(           -1
     &   LI1*T((/I,I=J1,JA,1/),K,6)))+(MI1*T((/I,I=J1,JA,1/),K,9)))
      ENDDO
      CALL COEF(N1, N10, N17, I1, KCOR, ID)                             0139
      CALL NORM(N4, N1, N10, N14, N17, I1)                              0140
C     BUFFER OUT (NGEO,0) (T(1,1,17),T(JMAX,KMAX,25))
      CALL EXTR(N1, N17)                                                0141
      IF ((UNIT(NGEO).LT.0)) THEN                                       0151
      ELSE
         GOTO 99941
      ENDIF
99939 CONTINUE                                                          0142
      DOALL 333 K = K1,K2,1
         T((/I,I=J1,J2,1/),K,13) = SQRT(AMIN1(T(J,K,ID), T(J,K,(ID+2)         -1
     &   )))
      ENDDO
      IF ((UNIT(NDIST).LT.0)) THEN                                      0167
      ELSE
         GOTO 99937
      ENDIF
99935 CONTINUE                                                          0158
      ENDFILE (UNIT=NDIST)                                              0168
      ENDFILE (UNIT=NGEO)                                               0169
      REWIND (UNIT=NDIST)                                               0170
      REWIND (UNIT=NGEO)                                                0171
      REWIND (UNIT=NXYZ)                                                0172
      GOTO 99951
99937 IF ((UNIT(NDIST).EQ.0)) THEN                                      0164
      ELSE
         GOTO 99934
      ENDIF
      GOTO 99952
99934 GOTO 99952
99941 IF ((UNIT(NGEO).EQ.0)) THEN                                       0148
      ELSE
         GOTO 99932
      ENDIF
      GOTO 99952
99932 GOTO 99952
99979 IF ((UNIT(NDIST).EQ.0)) THEN                                      0073
      ELSE
         GOTO 99930
      ENDIF
      GOTO 99952
99930 GOTO 99952
99983 IF ((UNIT(NGEO).EQ.0)) THEN                                       0057
      ELSE
         GOTO 99928
      ENDIF
      GOTO 99952
99928 GOTO 99952
99987 IF ((UNIT(NGEO).EQ.0)) THEN                                       0047
      ELSE
         GOTO 99926
      ENDIF
      GOTO 99952
99926 GOTO 99952
99991 IF ((UNIT(NGEO).EQ.0)) THEN                                       0034
      ELSE
         GOTO 99924
      ENDIF
      GOTO 99952
99924 GOTO 99952
99995 IF ((UNIT(NGEO).EQ.0)) THEN                                       0023
      ELSE
         GOTO 99922
      ENDIF
      GOTO 99952
99922 GOTO 99952
99949 CONTINUE
      END
\end{verbatim}

\section{Conclusion}

Cette premie`re version du paralle'liseur PIPS donne des re'sultats
satisfaisants sur les programmes de test. Les objectifs de'finis dans le
contrat sont atteints mais il reste encore beaucoup de travail a`
effectuer pour exploiter l'investissement re'alise' jusqu'ici. 

D'une part, il faudrait examiner en de'tail le code paralle`le produit
pour voir ce qui n'a pas e'te' trouve' et ta^cher d'y reme'dier. Il
faudrait que ce travail soit effectue' sur un nombre de programmes aussi
grand que possible ce qui ame'liorera aussi la fiabilite' de PIPS.
Ce travail est a` la fois ingrat, cou^teux en temps et difficilement
publiable.

D'autre part, il faudrait choisir une machine cible et ajouter les
transformations de programme ne'cessaires a` une bonne exploitation du
paralle'lisme en fonction de la hie'rarchie me'moire et des divers
overheads associe's a` cette machine cible. Cette machine cible et son
compilateur faciliteraient aussi la validation des re'sultats et
permettraient de quantifier les re'sultats des optimisations et analyses
effectue'es.

\end{document}
