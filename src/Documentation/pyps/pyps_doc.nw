\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{noweb}
\usepackage{listings}
\usepackage[margin=3cm]{geometry}
 
\title{A tutorial for Pyps}
\author{Grégoire Payen de La Garanderie}

\lstset{breaklines=true}

\begin{document}

\maketitle

\section{Introduction}
Pyps is the Python interface to Pips source to source compiler.
It is in fact a Python API to write your own pass manager and
quickly build a new compiler.
The focus of Pyps is to provide an interface for both high-level scripts for transformation automation
and for interactive use of Pips with auto-completion and inline documentation of Pips transformations.
Pyps provides iPyps interpreter based on ipython interpreter shell which have a reacher feature set than tpips.
Simple scripting with Pyps doesn't require a strong knowledge of Python language and allows to deal with Pips in a more structured and intuitive way than tpips.

This tutorial will show the functionnality of Pyps using the C code below:
<<gas.c>>=
#include <stdio.h>
#include <sys/time.h>

void copy (int w, int h, unsigned char bytes[h*w], unsigned char dest[h*w])
{
  int i,j;

  for (i = 0; i < w; i++)  
    for (j = 0; j < h; j++)
      {
	dest[j*w + i] = bytes[j*w + i];
      }
}

void light (int w, int h, unsigned char bytes[h*w], unsigned char val)
{
  int i,j;

  for (i = 0; i < w; i++)  
    for (j = 0; j < h; j++)
      {
	unsigned char current = bytes[j*w + i];
	bytes[j*w + i] = (((int)current + val)>255)?255:current+val;
      }
}

void curve (int w, int h, unsigned char bytes[h*w], unsigned char lut[h*w])
{
  int i,j;

  for (i = 0; i < w; i++)  
    for (j = 0; j < h; j++)
      {
	unsigned char current = bytes[j*w + i];
	bytes[j*w + i] = lut[current];
      }
}

void transfo (int w, int h, unsigned char bytes[h*w], unsigned char dest[h*w], unsigned char lut[h*w], unsigned char val)
{
  copy (w, h, bytes, dest);
  curve (w, h, dest, lut);
  light (w, h, dest, val);
}

int main (int ac, char *av[])
{
	FILE *in, *map, *out;
	int height, width;
	double t;
	long i, size;

	if (ac != 4) {
		printf ("Usage: light infile.pgm mapfile.amp outfile.pgm\n");
		exit (1);
	}

	in = fopen (av[1], "r");
	if (in == NULL)	{
		perror ("fopen");
		exit (1);
	}

	map = fopen (av[2], "r");
	if (map == NULL) {
		perror ("fopen");
		exit (1);
	}

	fscanf (in, "%c", &c1);
	fscanf (in, "%c", &c2);
	if (c1 != 'P' || c2 != '5') {
		fprintf (stderr, "Error, input file is not PGM\n");
		exit (1);
	}

	fscanf (in, "%d %d", &height, &width);
	fscanf (in, "%d", &maxval);

	printf ("w=%d, h=%d, max=%d\n", width, height, maxval);

	{
		unsigned char (*bytes)[height*width];
		unsigned char (*dest)[height*width];
		unsigned char (*lut)[height*width];
		size = width * height;

		bytes = (unsigned char (*) [height*width]) malloc (sizeof (unsigned char) * size);
		if (bytes == NULL) {
			perror ("malloc");
			exit (1);
		}

		dest = (unsigned char (*)[height*width]) malloc (sizeof (unsigned char) * size);
		if (dest == NULL){
			perror ("malloc");
			exit (1);
		}

		lut = (unsigned char (*)[height*width]) malloc (sizeof (unsigned char) * 256);
		if (lut == NULL) {
			perror ("malloc");
			exit (1);
		}

		{
			int n = 0;
			unsigned char val;
			while (fread (&val, 1, 1, map) != 0) {
				(*lut)[n] = val;
				n++;
			}
		}

		fseek (in, 1, SEEK_CUR);
		for (i = 0; i < size; i ++) {
			if (fread (*bytes + i, 1, 1, in) == 0) {
				perror ("fread");
				exit (1);
			}
		}
		fclose (in);

		transfo (width, height, *bytes, *dest, *lut, 5);


		out = fopen (av[3], "w");
		if (out == NULL) {
			perror ("fopen");
			exit (1);
		}
		fprintf (out, "P5\n");
		fprintf (out, "%d %d\n", height, width);
		fprintf (out, "%d\n", maxval);
		for (i = 0; i < size; i ++)	{
			if (fwrite (*dest + i, 1, 1, out) == EOF) {
				perror ("fwrite");
				exit (1);
			}
		}
		fclose (out);
	}
}
@

\section{First steps in Pyps}

There is two ways to work with Pyps, either importing pyps package in Python or using the interactive Pyps environnement based on iPython : iPyps (running command ipyps).
The last method should be preferred for interactive use of Pyps.

<<test.py>>=
from pyps import workspace, module #iPyps takes care of this for you
@

To begin, you should create a new Pips workspace. Pips workspace are represented by Python \emph{workspace} type.
To create a new workspace, you need the list of all source files that you want to handle.
Note that you can't add source file to the project after its creation.
In this example, we have only the [[gas.c]] source file.

<<test.py>>=
ws = workspace("gas.c")
# If you have more than one source file, you should use something like :
# ws = workspace("somesource.c","someothersource.c","lastsource.c")
@
Running this, Pips parses files, functions and procedures.
You can disable the verbose output using [[verbose=False]] as an extra parameter.
Each functions and source files are represented in Python by an object of type \emph{module} :

<<test.py>>=
t=ws.fun.transfo #Retrieve function transfo and bind it to variable t
m=ws.fun.main #Retrieve function main
g=ws.cu.gas #Retrieve compilation unit gas.c
@

For iPyps users, completion function and source name completion is available using TAB key after typing [[ws.fun.]] and [[ws.cu.]]

You can print function information and documentation extracted from \LaTeX\  source file [[properties\_rc.tex]] by using ‘?’ :
<<test.py>>=
ws.fun.inlining? #Print documentation
@

This should output something like :
\footnotesize
\begin{lstlisting}
Type:		instancemethod
Base Class:	<type 'instancemethod'>
String Form:	<bound method module.inlining of <pyps.module instance at 0x9e0718c>>
Namespace:	Interactive
File:		/usr/lib/python2.6/site-packages/pips/pyps.py
Definition:	ws.fun.foo.inlining(self, callers='', use_initialization_list=True, **props)
Docstring:
    Inlining is a well known technique.  Basically, it replaces a function call by the function body. The current implementation does not work if the function has static declarations, access global variables  can be set to define the list of functions where the call sites have to be inlined. By default, all call sites of the inlined function are inlined.
\end{lstlisting}
\normalsize

In this brouhaha, the more relevant informations are \emph{Definition} and \emph{Docstring}. Looking at the definition of the function, we know that it takes two arguments. Each argument have a default value, so you can skip a parameter if you are pleased with the default value. For instance :
<<test.py>>=
ws.fun.copy.inlining(self,callers="transfo")
#The call is threated as if USE_INITIALIZATION_LIST is set to True 
#because of the default value
@

Value of properties are automatically restored after transformation call to their orignal state to avoid side effects onto other transformation, whereas in tpips properties are set at global scope and can interact with transformations sometimes by mistake.

Sometimes, dependency between transformations and properties are not dectected because of missing or implicit relation in [[properties-rc.tex]]. It is still possible to pass a property as parameter even if Pyps don't know about the relation :
<<test.py>>=
ws.fun.light.inlining(self, callers="transfo", purge_labels=False);
@
As you can see, we add an extra property purge\_labels which is not listed in Python inlining function prototype. Furthermore, the real Pips name of the property is INLINING\_PURGE\_LABELS. Pyps automatically append transformation’s name at the begining of a property when needed and also automatically convert property name to upper case.

Sometimes, you need to specify which transformations should be used by Pips to get some ressources. This is accomplish by doing the following in Pyps :
<<test.py>>=
ws.activate(module.preconditions_inter_fast) #To activate transformation preconditions_inter_fast
#or alternatively
ws.activate("preconditions_inter_fast")
@
The advantage of the first form over the second is that you can use auto-completion over transformation name.

\section{Looping, filtering and transforming a bench of module}
It is possible to loop on every module. For instance :
<<test.py>>=
for i in ws.fun:
	i.display()
@
The former is equivalent to :
<<test.py>>=
ws.all.display()
@

[[ws.all]] returns an object of type \emph{modules}.
\emph{modules} objects have the same interface as \emph{module}:
when a function from a \emph{modules} object is called, it calls the same function of every listed module.

It is also possible to find modules using a filter :
<<test.py>>=
#Print all functions which call function “transfo”.
m = ws.filter(lambda x: ws.fun.transfo in x.callees())
m.display()
@
The former is equivalent to using the [[callers()]] method:
<<test.py>>=
m = ws.fun.transfo.callers()

\section{Loop transformations}

Transformations can also be made on loops.
In this example, we have a loop in \emph{curve} function.
You can access to a loop either by iterating over each loop with something like :
<<test.py>>=
for l in ws.fun.curve.loops():
	print "Loop labeld ",l.label , "from module", l.module #Do something in the loop
@
or by label, if you know it :
<<test.py>>=
l = ws.fun.curve.loops("l99999")
#Do something with loop l
@

When manipulating code for the first time, Pips has not yet assigned labels to loops because Pips delayed it until labels are required (eg. by a transformation). You can ask Pips to insert loop labels in code by using method \emph{flag\_loops} :
<<test.py>>=
m.display()
#There is no loop label
m.flag_loops()
m.display()
#You can see loop label and do something with them
l = m.loops("l99999")
l.unroll(rate=3) #Call Unroll transformation
@

\section{Global properties}

Pips properties can be accessed and modified at global scope using [[ws.props.]]. However, modifying a property at global scope in Pyps is a bad idea, because much of the global properties are overwriting by default value when used. Global properties can lead to unintentionnal side effects and there use is discouraged in Pyps.

For instance, you can get or set property INLINING\_PURGE\_LABELS using :

<<test.py>>=
print ws.props.INLINING_PURGE_LABELS #Print it
ws.props.INLINING_PURGE_LABELS = False
ws.props.INLINING_PURGE_LABELS = True
@

\section{Checkpoints}
Pyps provides a basic feature for checkpoints.
They can be used to save and then restore back Pyps state when trying to do a potentially wrong transformation. 
Checkpointing returns a handle that must be used to restore the previous workspace.
<<test.py>>=
a=ws.checkpoint()
l.unroll(rate=3) #Call Unroll transformation
ws.fun.main.display()
ws.restore(a)
ws.fun.main.display()
@

\section{Pyrops}
It is not possible to work on several workspaces in Pips at the same time in a script.
To bypass this limitation in Pyps, a Python module named Pyrops transparently encapsulate each workspace in a separate program.
It’s more an elegant workaround than a true solution however it works well despite it is complicated to debug Pips C libraries through this extension.
Pyrops provides a new workspace inherited of Pyps workspace :
<<test2.py>>=
from pyrops import pworkspace
ws = pworkspace("test.c")
@
Here, ws is a remote workspace. You can add a seconde workspace :
<<test2.py>>=
ws2 = pworkspace("test.c")
@

After creation, you can apply transformations to your remotes workspaces as if they were true Pyps workspace.
<<test2.py>>=
ws.all.display()
#...
@

To close a workspace, you can do :
<<test2.py>>=
ws.close()
@

And just before to terminate the program :
<<test2.py>>=
pyrops.Launcher.shutdown()
@

Sometimes, some errors occured in Python internals during Python exit. They are not harmeful nor important.

\section{pips-make}
When having a large project with many GCC options, it can be difficult to create a Pyps workspace. pips-make is a tool which try to create a workspace for you by instrumenting the compilation process.

For instance, if you have a project which use a classic compilation process. You can do :

\begin{lstlisting}
./configure
pips-make
make install
\end{lstlisting}

Here, the pips-make step do the same thing as make but records also useful informations about the project and put them in a new directory \emph{pips.ws}.
If your project doesn't use a Makefile, you can use commande \emph{pips-make --env} to open a new shell where GCC calls are recorded. To do the trick, pips-make change PATH variable in such way that calls to GCC are intercepted by pips-make version of them instead of the original. After processing, pips-make forward calls to GCC.

pips-make use the following environnement variables :
\begin{enumerate}
  \item PIPS\_WORKSPACE : where to put files (default: directory pips.ws) ;
  \item PIPS\_WORKINGDIR : base directory used to construct files relative path (default: .) ;
  \item PIPS\_BINPATH : path to pips-make binaries (default: installation dependant hard-coded in pips-make prefix/lib/pips-make) ;
  \item PIPS\_CC : compiler which should be called by pips-make (default: gcc) ;
  \item PIPS\_LD : linker which should be called by pips-make (default: \$PIPS\_CC) ;
  \item PIPS\_AR : archiver which should be called by pips-make (default: ar).
\end{enumerate}

Currently, pips-make registers calls to the compiler, the linker and ar.
After this preprocessing step, you can import your new workspace using the Python class \emph{CCWorkspace} which have the same behaviour as \emph{workspace}.
<<pmtest.py>>=
from pipsgcc import CCWorkspace
import pyps

w = workspace("pips.ws", parents = [CCWorkspace]) \footnote{+\nomgen{see section \ref{wpcomposition} for more information on this workspace instanciation syntax}+}

ws.all.display() #Display it
ws.compile() #Replay compilation
@

pips-make try to record the whole compilation process of the Makefile. Library makefiles often recompile source files more than once with differents flags, for instance to build static and shared library versions. pips-make store preprocessed versions of the files to avoid dependancy problems or so. When a file is compiled twice or more, pips-make stores the file preprocessed with the last set of flags and emits a warning if preprocessed files are differents. An other problem is that sometimes examples are compiled by the Makefile, this result in having more than once \emph{main} function which of course Pyps dislike. When using Pyps, be sure to deactivate example compilation in the build configuration, otherwise you may encountered problems.

\section{Workspace composition} \label{wpcomposition}
Pyps is a quite simple interface for Pips usage, furthermore, it is extensible and allow you to develop high level task onto Pips.

Of note is the worksapce `parents' attribute, which allows to define advices
before, around and after the initial functions.

In order to use this, create a workspace, for instance:

<<parents.py>>=
# File foo.py
class workspace:
	# No need to inherit
	def __init__(self, ws, sources, **kwargs):
		# Given the same arguments as pyps.workspace, plus the workspace
		# itself as the first argument
		pass # nothing to do, maybe `self.ws = ws' to save the `real'
			 # workspace if necessary.

	def pre_bar(self, arg...):
		# Same arguments as pyps.workspace.bar()
		print "foo.pre_bar: running just before pyps.workspace.bar()"
@

The users will need to `import foo', and create their workspace as `ws =
pyps.workspace(sources, parents = [foo.workspace])'.

With a `pre\_' suffix, the function will be called before the function of
the same name; with a `post\_', it will be run after. Without a prefix,
it will entirely replace the initial function. In other words, defining
pre\_bar is similar to saying in emacs:
\begin{lstlisting}
(defadvice foo-pre-bar (before bar (arg...) (progn ...)))
(ad-activate foo-pre-bar)
\end{lstlisting}

Defining \lstinline|foo.workspace.baz()| when \lstinline|pyps.workspace.baz()| already exists
will \emph{replace} \lstinline|pyps.workspace.baz()| (of course, foo's version of baz()
may call the initial one.

If the workspace is created as: \lstinline|ws = pyps.workspace(..., parents = [foo, bar])|, a call to ws.quux will call:

\begin{enumerate}
\item foo.pre\_quux
\item bar.pre\_quux
\item foo.quux
\item at foo.quux' discretion, bar.quux
\item at bar.quux's discretion, pyps.workspace.quux
\item bar.post\_quux
\item foo.post\_quux
\end{enumerate}

This is not an error if any (or even all) intermediate functions don't
exist.


\end{document}
