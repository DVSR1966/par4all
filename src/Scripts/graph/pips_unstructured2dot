#! /usr/bin/env python
"""
Take a graph prettyprint file (GRAPH_PRINTED_FILE ressource) from PIPS and
output a dot graph that can be displayed by a dot/graphviz-compatible
tool, such as ZGRViewer.
"""

import sys, re

#import pygraphviz

# Use libgv-python on Debian:
import gv

# The current node number
node_number = 0
# To keep track of nested unstructured instructions:
statement_number_stack = []

# The code to output in a node:
output_statement_buffer = []

newline_re = re.compile("\n")

def protect_newline(text):
    "Transform all the newline into texto \n"
    return newline_re.sub("\\n", text)

def keep_for_output(text):
    "Add the text to be prettyprinted later"
    global output_statement_buffer

    output_statement_buffer.append(text)

graph = gv.digraph("Source Control Graph")

attributes_to_add_to_next_node = []

def add_attribute_to_next_node(attribute, value):
    global attributes_to_add_to_next_node
    attributes_to_add_to_next_node.append([attribute, value])

def set_attribute(graphic_object, attribute, value):
    gv.setv(n, attribute, value)

this_is_the_unstructured_entry_p = False

def add_a_node(node, label, comment):
    n = gv.node(graph, str(node))
    gv.setv(n, 'label', label)
    gv.setv(n, 'comment', protect_newline(comment))
    return n

remove_leading_blank_lines_re = re.compile("^([ \\t]*\\\\n)+")

def add_a_statement(node, comment):
    global this_is_the_unstructured_entry_p, output_statement_buffer
    global attributes_to_add_to_next_node

    # Transforn the list of lines into text:
    text = '\\n'.join(output_statement_buffer)
    text = remove_leading_blank_lines_re.sub("", text)
    output_statement_buffer = []

    n = add_a_node(node, text, comment)

    for a in attributes_to_add_to_next_node:
        gv.setv(n, a[0], a[1])
    attributes_to_add_to_next_node = []

    if (this_is_the_unstructured_entry_p):
        gv.setv(n, 'shape', 'ellipse')
    else:
        gv.setv(n, 'shape', 'box')
    this_is_the_unstructured_entry_p = False
    return n

def add_a_successor(n, successor):
    return gv.edge(n, successor)

def add_an_eventual_unreachable_arrow(node, control):
    """If the node given to this procedure is an entry node of an
    unstructured that has an unreachable exit node, display a dashed arrow
    from the entry node to the exit"""
    if (control in unreachable_exit):
	exit_node = unreachable_exit[control]
	n = add_node(exit_node, "Unreachable from %s to %s" % (control, exit_node))
        edge = add_a_successor(n, exit_node)
 	set_attribute(edge, "style", "dotted")
 	set_attribute(edge, "color", "violet")


output_file_name = sys.argv[1] + '.dot'

# First build a map of unstructured with unreachable exit:
f = open(sys.argv[1])
unreachable_exit = {}
unreachable_re = re.compile("^\204Unstructured Unreachable (.*) -> (.*)$")
for line in f.readlines():
    m = unreachable_re.match(line)
    if m:
        entry_control = m.group(1);
	exit_control = m.group(2);
	unreachable_exit[entry_control] = exit_control;
f.close()

# Parse the PIPS output:
unstructured_re = re.compile("^\200Unstructured (.*) end: (.*)$")
unstructured_end_re = re.compile("^\201Unstructured End (.*) end: (.*)$")
unstructured_item_re = re.compile("^\202Unstructured Item (.*)$")
unstructured_successor_re = re.compile("^\203Unstructured Successor -> ?(.*)$")
f = open(sys.argv[1])
control = node_number
for line in f.readlines():
    line = line[:-1] # To skip the marker
    m = unstructured_re.match(line)
    if m:
        # \200Unstructured 0xa0aa20 end: 0x3cfa40
        unstructured_begin = m.group(1)
        unstructured_end = m.group(2)
        # Create the node before the unstructured entry:
        n = add_a_statement(control, "Statement not from an unstructured")
        # Add an edge from this node to the unstructured entry:
        add_a_successor(n, unstructured_begin)
        # This node will have this colour:
        add_attribute_to_next_node('color', 'lightgreen')
        # Since the first node could be an IF, delay the attributes for
        # the beginning:
	this_is_the_unstructured_entry_p = True
	node_number += 1
	# Keep track of the number of the statement that should follow
	# this unstructured at its exit:
	statement_number_stack.append(node_number)
        continue

    m = unstructured_end_re.match(line)
    if m:
        # \201Unstructured End 0xa0aa20 end: 0x3cfa40
        unstructured_begin = m.group(1)
        unstructured_end = m.group(2)
        control = statement_number_stack.pop()
        continue

    m = unstructured_item_re.match(line)
    if m:
        # \202Unstructured Item 0x3c79f0
	# Should use a stack here ?
	control = m.group(1)
        continue

    m = unstructured_successor_re.match(line)
    if m:
        # ^\203Unstructured Successor -> ?(.*)
        successors = m.group(1).split(' ')
        if (successors == []):
            n = add_a_statement(control, line[1:])
            set_attribute(n, 'shape', 'ellipse')
            set_attribute(n, "color", "lightgray")
            # Reconnect to the node outside of the unstructured:
            add_a_successor(n, statement_number_stack[-1])
        elif (len(successors) == 2):
	    # 2 successors, that is an "if then else":
	    add_attribute_to_next_node("shape", "diamond")
            if (not this_is_the_unstructured_entry_p):
		add_attribute_to_next_node("color", "cyan")
            else:
                # Display a lightgreen rhombus to mark the IF at the
                # unstructured entry:
                this_is_the_unstructured_entry_p = False
            n = add_a_statement(control, line[1:])
	    add_an_eventual_unreachable_arrow(n, control)
	    then_edge = add_a_successor(n, "then_%d" % node_number)
	    set_attribute(then_edge, "color", "red")
	    else_edge = add_a_successor(n, "else_%d" % node_number)
	    set_attribute(else_edge, "color", "blue")
	    then_st = add_a_node("then_%d" % node_number,
                                 "THEN", line[1:])
	    set_attribute(then_st, "color", "lightred")
	    set_attribute(then_st, "shape", "triangle")
	    set_attribute(then_st, "fontname", "helvetica")
	    then_edge2 = add_a_successor(then_st, successors[0])
	    set_attribute(then_edge, "color", "red")
	    else_st = add_a_node("else_%d" % node_number,
                                 "ELSE", line[1:])
	    set_attribute(else_st, "color", "lightblue")
	    set_attribute(else_st, "shape", "triangle");
	    set_attribute(else_st, "fontname", "helvetica");
	    else_edge2 = add_a_successor(else_st, successors[1])
	    set_attribute(else_edge2, "color", "blue")
	    node_number += 1
            continue

        else:
            # Just a sequence I guess:
            n = add_a_statement(control, line[1:])
            add_a_successor(n, successors[0])
            add_an_eventual_unreachable_arrow(n, control)
	    continue

    # Add the source line to the current node label to set later:
    keep_for_output(line)

gv.layout(graph, 'dot')
gv.write(graph, output_file_name)
#gv.render(graph, 'xlib')

#  G=pygraphviz.AGraph()
# G.add_node('a')#, label ="un gro machin"
# G.add_edge('b','c')
# G.write("file.dot")
# G.layout('dot')
# G.draw('xlib')
