#! /bin/sh
#
# $RCSfile: pips_at_night,v $ version $Revision$
# ($Date: 1996/08/10 10:03:56 $, )
# (c) Fabien COELHO July 1996
# 
# what to do at night...
#

#
# source environment if needed (as from cron)

test -r $HOME/.profile && . $HOME/.profile
test "$PIPS_DIR" || . /projects/Pips/pipsrc.sh

#
# initialization of variables

unset no_cleaning no_newgen no_linear no_pips no_validation

# use this mail (not /bin/mail...)
mail=/usr/ucb/mail
test -x $mail || mail=mail

arch=.
user=`whoami`
host=`hostname`
email=${REPLYTO:-$user}
script=`basename $0`
verbose=:
msg=

# for temporary files
report=/tmp/${script}.${user}.$$
rm -f ${report}*

#
# Functions

verb()
{
    echo "$script: $@ (`date`)" >&2
}

usage()
{
    ret=$1
    shift
    cat <<-EOF
	$script (version $Revision$): $@
	Description
	  This shell script checks pips sources and functionalities.
	  It is intended to be run from cron at night, hence its name.
	  It cleans pips directories, recompiles newgen, linear and pips
	  for various "architectures" and validates. Reports about 
	  successes or failures are sent. 
	Summary of options:
	  -h: this help
	  -v: verbose
	  -c arch: compile for arch (may be a list, default is .)
	  -a email: address to report (default: \$REPLYTO else \`whoami\`)
	  -C: skip cleaning
	  -N: skip newgen
	  -L: skip linear
	  -P: skip pips
	  -V: skip validation
	EOF
    exit $ret
}

# MAKE nlp(=what) name file(=report) 'targets' arch...
# make 'target' for all specified arch.
# the detailed report is sent only on failures.
MAKE()
{
    what=$1; name=$2; report=$3; targets="$4"; shift 4
    detailed=$report.detailed
    summary=$report.summary

    for a in "$@"; do
	make-pips -$what -o $summary -m $a ARCH=$a $targets
    done 2> $detailed > /dev/null

    cat $summary >> $report

    # send the detailed report if some failures occured
    grep 'failed$' $summary > /dev/null 2>&1 &&
	$mail -s "$script: $name report" $email \
	< $detailed > /dev/null 2>&1

    rm -f $detailed $summary
}

#
# Get command line options

while getopts hvCNLPVc:a: OPT
do
    case $OPT in
	h) usage 0 "some help" ;;
	v) verbose=verb ;;
	a) email=$OPTARG ;;
	c) arch="$OPTARG" ;;
    # skipping parts:
	C) no_cleaning=1 ;;
	N) no_newgen=1 ;;
	L) no_linear=1 ;;
	P) no_pips=1 ;;
	V) no_validation=1 ;;
	*) usage 2 "invalid option" ;;
    esac
done

shift `expr $OPTIND - 1`

[ $# -eq 0 ] || usage 3 "unexpected args: $@" 

#
# Do the job and send reports

{
    $verbose "Starting $email/$host"
    
    #
    # CLEANING

    test "$no_cleaning" && {
	$verbose Skipping Cleaning
    } || {
	$verbose "Cleaning pips"

	$verbose - Deleting old workspaces...
	find ${PIPS_HOME}/Pips -name '*.database' -type d -mtime +7 -print | 
	    xargs ${PIPS_UTILDIR}/Delete
	    
	$verbose - Removing core files older than one week
	find ${PIPS_HOME}/Pips -name core -mtime +7 -print | 
	    xargs rm -f

	$verbose - Deleting forgotten validation directories and files
	find ${PIPS_HOME}/Pips -name '.validate_*' -mtime +7 -print |
	    xargs rm -rf

	$verbose - Removing generated files in Production...
	msg="${msg}C"
        MAKE nlp cleaning $report clean .
    }

    #
    # COMPILE

    # 1: NEWGEN
    test "$no_newgen" && {
	$verbose Skipping Newgen compilation
    } || {
	$verbose "Compiling Newgen/Production"
	msg="${msg}N"
	MAKE n newgen $report "clean-compiled recompile" $arch
    }
    
    # 2: LINEAR
    test "$no_linear" && {
	$verbose Skipping Linear compilation
    } || {
	$verbose "Compiling Linear/Production"
	msg="${msg}L"
	MAKE l linear $report "clean-compiled recompile" $arch
    }

    # 3: PIPS
    test "$no_pips" && {
	$verbose Skipping Pips compilation
    } || {
	$verbose "Compiling Pips/Production"
	msg="${msg}P"
	MAKE p pips $report "clean-compiled recompile" $arch
    }

    # 4: SUMMARY
    test "$no_newgen$no_linear$no_pips" = '111' ||
    {
	$verbose "Generating summary"
	summary=SUCCEEDED
	grep 'failed$' $report > $report.failed && summary=FAILED
	$mail -s "$script: compile ${msg} ($arch): ${summary}" $email \
	    < $report.failed > /dev/null 2>&1
	rm -f $report*
    }

    #
    # VALIDATE Pips

    test "$no_validation" && {
	$verbose Skipping Pips validation
    } || {
	$verbose "Validating PIPS"
	Validate -vti 50 -a ${email}
    }

    $verbose "Ending $email/$host"
} 2>&1 | $mail -s "$script: report" ${email}

# That is all!
#
