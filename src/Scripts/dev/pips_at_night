#! /bin/sh
#
# $RCSfile: pips_at_night,v $ version $Revision$
# ($Date: 1996/08/07 09:08:59 $, )
# (c) Fabien COELHO July 1996
# 
# what to do at night...
#

#
# source environment if needed (as from cron)

test -r $HOME/.profile && . $HOME/.profile
test "$PIPS_DIR" || . /projects/Pips/pipsrc.sh

#
# initialization of variables

unset no_cleaning no_newgen no_linear no_pips no_validation

# use this mail (not /bin/mail...)
mail=/usr/openwin/bin/mail
test -x $mail || mail=mail

arch=.
user=`whoami`
email=${REPLYTO:-$user}
script=`basename $0`
verbose=:
msg=

# for temporary files
report=/tmp/${script}.${user}.$$
rm -f ${report}*

#
# Functions

verb()
{
    echo "$script: $@" >&2
}

usage()
{
    ret=$1
    shift
    cat <<-EOF
	$script (version $Revision$): $@
	Description
	  This shell script checks pips sources and functionalities.
	  It is intended to be run from cron at night, hence its name.
	  It cleans pips directories, recompiles newgen, linear and pips
	  for various "architectures" and validates. Reports about success
	  and failures are sent. 
	Summary of options:
	  -h: this help
	  -v: verbose
	  -c arch: compile for arch (may be a list, default is .)
	  -a email: address to report (default: \$REPLYTO else \`whoami\`)
	  -C: skip cleaning
	  -N: skip newgen
	  -L: skip linear
	  -P: skip pips
	  -V: skip validation
	EOF
    exit $ret
}

# compile n|l|p(=what) name file(=report) arch...
# compile "what" for all architectures.
# the detailed report is sent only on failures
compile()
{
    what=$1; name=$2; report=$3; shift 3

    detailed=$report.detailed
    summary=$report.summary

    {
      make-pips -$what -o $summary clean 
      for a in "$@"; do
	make-pips -$what -o $summary -m $a ARCH=$a clean-compiled recompile
      done 
    } 2> $detailed > /dev/null
    
    cat $summary >> $report

    # send the detailed report if some failures occured
    grep 'failed$' $summary > /dev/null 2>&1 &&
	$mail -s "$script: $name recompile report" $email \
	< $detailed > /dev/null 2>&1

    rm -f $detailed $summary
}

#
# Get command line options

while getopts hvCNLPVc:a: OPT
do
    case $OPT in
	h) usage 0 "some help" ;;
	v) verbose=verb ;;
	a) email=$OPTARG ;;
	c) arch="$OPTARG" ;;
    # skipping parts:
	C) no_cleaning=1 ;;
	N) no_newgen=1 ;;
	L) no_linear=1 ;;
	P) no_pips=1 ;;
	V) no_validation=1 ;;
	*) usage 2 "invalid option" ;;
    esac
done

shift `expr $OPTIND - 1`

[ $# -eq 0 ] || usage 3 "unexpected args: $@" 

#
# Do the job and send reports

{
    $verbose Starting $script for $email 
    $verbose date: `date`
    
    #
    # CLEANING

    test "$no_cleaning" && {
	$verbose Skipping Cleaning
    } || {
	$verbose Cleaning pips
	$verbose date: `date`

	$verbose - Deleting old workspaces...
	find ${PIPS_HOME}/Pips -name '*.database' -type d -mtime +7 -print | 
	    xargs ${PIPS_UTILDIR}/Delete
	    
	$verbose - Removing core files older than one week
	find ${PIPS_HOME}/Pips -name core -mtime +7 -print | 
	    xargs rm -f

	$verbose - Deleting forgotten validation directories and files
	find ${PIPS_HOME}/Pips -name '.validate_*' -mtime +7 -print |
	    xargs rm -rf
    }

    #
    # COMPILE

    # 1: NEWGEN
    test "$no_newgen" && {
	$verbose Skipping Newgen compilation
    } || {
	$verbose Compiling Newgen/Production
	$verbose date: `date`
	msg="${msg} N"
	compile n newgen $report $arch
    }
    
    # 2: LINEAR
    test "$no_linear" && {
	$verbose Skipping Linear compilation
    } || {
	$verbose Compiling Linear/Production
	$verbose date: `date`
	msg="${msg} L"
	compile l linear $report $arch
    }

    # 3: PIPS
    test "$no_pips" && {
	$verbose Skipping Pips compilation
    } || {
	$verbose Compiling Pips/Production
	$verbose date: `date`
	msg="${msg} P"
	compile p pips $report $arch
    }

    # 4: SUMMARY
    test "$no_newgen$no_linear$no_pips" = '111' ||
    {
	$verbose Generating recompile summary
	$verbose date: `date`
	summary=SUCCEEDED
	grep 'failed$' $report > $report.failed && summary=FAILED
	$mail -s "$script: compile${msg}: ${summary}" $email \
	    < $report.failed > /dev/null 2>&1
	rm -f $report*
    }

    #
    # VALIDATE Pips

    test "$no_validation" && {
	$verbose Skipping Pips validation
    } || {
	$verbose Validating PIPS
	$verbose date: `date` 
	Validate -vti 50 -a ${email}
    }

    $verbose Ending $script for $email 
    $verbose date: `date`
} 2>&1 | $mail -s "$script: report" ${email}

# That is all!
#
