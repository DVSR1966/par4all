#! /bin/sh
#
# creates a subtree for pips (see PIPS_DIRECTORY_FOR_BINARIES)
# in this subtree will be stored all binaries for a pips architecture.
# this allows to move them on some other disk...
# PIPS_ARCH and PIPS_DIRECTORY_FOR_BINARIES should be kept coherent...
#
# $Id$
#

script=`basename $0`

unset group

#
# some functions

verb()
{
    echo "[$script] $@"
}

error()
{
    echo "[$script] $@"
    exit ${1:-1}
}

usage()
{
	cat <<-EOF
	Usage: $script [-g group] [-h] [dir [arch]]
	  $@
	EOF
    exit ${1:-0}
}

md()
{
    for d in "$@"
    do 
       verb "[md] ${d}"
       test -d ${d} || mkdir ${d} || error 6 "[md] cannot on ${d}" ;
    done
}

#
# get options

while getopts g:h opt
do
    case $opt in
	h) usage ;;
	g) group=${OPTARG} ;;
        *) error 2 "invalid option";;
    esac
done

shift `expr $OPTIND - 1`

dir=${1:-`pwd`}
arch=${2:-${PIPS_ARCH}}

#
# check arch

test "${arch}" || 
	error 4 "some architecture expected"
expr ${arch} : '^[A-Z0-9]*$' > /dev/null || 
	error 5 "invalid ${arch} architecture"

#
# make directories

verb "Making directories"

md 	${dir} \
	${dir}/${arch} 

for x in Prod Deve ; do
    md ${dir}/${arch}/${x}
    for s in PIPS NEWGEN LINEAR EXTERN ; do
	md ${dir}/${arch}/${x}/${s}
        for d in Bin Lib ; do
            md ${dir}/${arch}/${x}/${s}/${d} \
		${dir}/${arch}/${x}/${s}/${d}/${arch}
        done
    done
    for d in Passes Libs Runtimes Scripts ; do
        md ${dir}/${arch}/${x}/PIPS/${d}
    done
done

md  ${dir}/${arch}/Prod/PIPS/Runtime \
    ${dir}/${arch}/Prod/PIPS/Runtime/hpfc \
    ${dir}/${arch}/Prod/PIPS/Runtime/wp65\
    ${dir}/${arch}/Prod/PIPS/Runtime/hpfc/${arch} \
    ${dir}/${arch}/Prod/PIPS/Runtime/wp65/${arch}

#
# owner and rights

test "${group}" && {

    verb "Group ${group}"
    find ${dir}/${arch} -type d -print | xargs chgrp ${group}

    verb "Rights rwxrwsr-x"
    find ${dir}/${arch} -type d -print | xargs chmod ug+rwx,g+s,o+rx-w 
}

#
# make links

verb "Making links"

# ml dir link
ml()
{
   d=${1}
   lnk=${2}
   test -d ${d} || error 3 "[ml] no ${d} directory"
   test -d ${lnk} && { mv ${lnk}/* ${d}; rmdir ${lnk}; }
   test -L ${lnk} && rm ${lnk}
   ln -s ${d} ${lnk}
}

# dir what
make_all_links()
{
    targ=${1}
    root=${2}
    ml ${targ}/Lib/${arch} ${root}/Lib/${arch}
    ml ${targ}/Bin/${arch} ${root}/Bin/${arch}
}

make_all_links ${dir}/${arch}/Prod/PIPS   ${PIPS_ROOT}
make_all_links ${dir}/${arch}/Prod/NEWGEN ${NEWGEN_ROOT}
make_all_links ${dir}/${arch}/Prod/LINEAR ${LINEAR_ROOT}
make_all_links ${dir}/${arch}/Prod/EXTERN ${EXTERN_ROOT}

ml ${dir}/${arch}/Prod/PIPS/Runtime/hpfc/${arch} \
	${PIPS_ROOT}/Runtime/hpfc/${arch}
ml ${dir}/${arch}/Prod/PIPS/Runtime/wp65/${arch} \
	${PIPS_ROOT}/Runtime/wp65/${arch}

#
# cleaning sources

verb "Cleaning sources from ${arch} direct"

find 	${PIPS_ROOT}/Src   ${PIPS_DEVEDIR} \
	${LINEAR_ROOT}/Src ${LINEAR_DEVEDIR} \
	${NEWGEN_ROOT}/Src ${NEWGEN_DEVEDIR} \
	\( -name "${arch}" -o -name "Makefile.depend.${arch}" \) -print |
xargs rm -rf 

#
# that is all
#
