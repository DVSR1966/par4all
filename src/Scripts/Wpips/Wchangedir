#! /bin/sh
#
# $RCSfile: Wchangedir,v $ (version $Revision$)
# $Date: 1996/09/12 12:37:50 $, 
#
# (c) FC September 1996
#
# this script allows to chose a directory interactively. 
# wish is started without assumption on its location.
sed '1,/^###/d' $0 | wish "$@" 
exit $?
#
###
#
# Wish script
#
# fills the list listbox with directories. links are followed...
#  - list: the listbox window to be dealt with
#  - dir: the considered directory
#
proc filldirlist { list dir } {
    $list delete 0 end
    set pwd [pwd]
    cd $dir
    foreach d [lsort [glob * .*]] {
	if {$d != "." && [file readable $d]} {
	    set name $d
	    # follows link...
	    while {[file type $d] == "link"} {
		set d [file readlink $d]
	    }
	    # then append if is a directory
	    if {[file isdirectory $d]} {
		$list insert end $name
	    }		
	}
    }
    cd $pwd
    $list selection clear 0 end
}

#
# appends newdir to dir with managing especially .., / and .
#  - dir: the current directory
#  - newdir: the incremental adjuntion to be appended
#
proc appenddir { dir newdir } {
    if {$newdir != ".."} {
	if {$dir != "/"} {
	    return $dir/$newdir
	} else {
	    return /$newdir
	}
    } else {
	set ldir [split $dir /]
	set len [llength $ldir]
	set last [lindex $ldir [expr $len-1]]
	if {($last != "..") && ($last != ".") } {
	    set ldir [lrange $ldir 0 [expr $len-2]]
    	    if {$len == 2 && [lindex $ldir 0] == {}} { return / }
	} else {
	    lappend ldir $newdir
	}
	return [join $ldir /]
    }
}

#
# scrolls the entry so that the end is displayed
#  - entry: the entry window to be dealt with
#
# ??? its quite approximative because the width is fixed but the
#     real # of characters depends on the (not) chosen font.
#     also it uses a feature of xview which does not add blanks
#     when trying to scrool to far on the right...
#
proc seeentryend { entry } {
    set i [$entry index end]
    $entry xview [expr $i<[$entry cget -width]? 0: $i]
}

#
# interactive directory choice.
#  - root: root of the window to create ("" for main window)
#  - currentdir: default startpoint (may be absolute or relative)
#
proc changedir { root currentdir } {
    #
    # the global local variables:-)
    #
    global changedir_result changedir_dir changedir_root changedir_home

    set changedir_dir  $currentdir
    set changedir_root $root
    set changedir_home $currentdir

    #
    # creates the window if needed
    #
    if {$root == ""} {
	wm title . "Change Directory"
    } else {
	toplevel $root
	wm title $root "Change Directory"
    }

    #
    # top buttons: "/" "Home" "Ok" "Quit"
    #
    frame $root.top 
    button $root.top.root -text "/" -command {
	set changedir_dir / 
	filldirlist $changedir_root.list.dirs $changedir_dir
        seeentryend $changedir_root.direct.entry
    }
    button $root.top.home -text "Home" -command {
	set changedir_dir $changedir_home; 
	filldirlist $changedir_root.list.dirs $changedir_dir
        seeentryend $changedir_root.direct.entry
    }
    button $root.top.okay -text "Ok" -command {
	set changedir_result $changedir_dir
        if {$changedir_root == ""} {
	    puts $changedir_result
	    exit
	} 
    }
    button $root.top.quit -text "Quit" -command {
	set changedir_dir $changedir_home
	$changedir_root.top.okay invoke
    }
    pack $root.top.root $root.top.home $root.top.okay $root.top.quit \
	-side left -expand true -fill x -padx 1m -pady 1m -ipadx 2 -ipady 2

    #
    # direct entry in the middle 
    #
    frame $root.direct
    label $root.direct.lab -text "Directory: "
    entry $root.direct.entry -width 30 -relief sunken \
	-textvariable changedir_dir 
    # <Return> is okay
    bind  $root.direct.entry <Return> {
	$changedir_root.top.okay invoke
    }
    # <Tab> updates the displayed list
    bind  $root.direct.entry <Tab> {
	filldirlist $changedir_root.list.dirs $changedir_dir
    }
    # <Configure> resize ???
    bind  $root.direct.entry <Configure> {
	set l [winfo width $changedir_root.direct.lab]
        set d [winfo width $changedir_root.direct]
	# ??? well, the next formula is not convincing...
	# it is not sure to be stable if sg is changed...
	set n [expr ($d-$l-24)/7]
	set w [%W cget -width]
	if {$n!=$w} {
	    %W configure -width $n
	    seeentryend %W
	}
    }

    pack  $root.direct.lab -side left -padx 1m -pady 1m -ipadx 2 -ipady 2 
    pack  $root.direct.entry -side left \
	-padx 1m -pady 1m -ipadx 2 -ipady 2 -fill y -expand true

    #
    # choice from the list
    #
    frame $root.list
    listbox $root.list.dirs -relief raised -bd 2 \
	-yscrollcommand "$root.list.scroll set"
    scrollbar $root.list.scroll -command "$root.list.dirs yview"
    bind $root.list.dirs <Double-1> { 
	# update dir according to the clicked item
	set newdir [%W get [%W curselection ]]
	set changedir_dir [appenddir $changedir_dir $newdir]
	# update display
	filldirlist %W $changedir_dir
        seeentryend $changedir_root.direct.entry
    }
    pack $root.list.dirs -side left -fill both -expand true \
	-padx 1m -pady 1m -ipadx 2 -ipady 2
    pack $root.list.scroll -side left -fill y -padx 1m -pady 1m 

    #
    # full window (if resized, .list is expanded on y)
    #
    pack $root.top $root.direct -fill both 
    pack $root.list -fill both -expand true

    # set initial display
    filldirlist $root.list.dirs $changedir_dir
    seeentryend $root.direct.entry

    if {$root != ""} {
	# focus and interaction...
	set old [focus]
	grab set $root
	focus $root
    }
  
    #
    # waits for changedir_result to be set, the returns...
    tkwait variable changedir_result
    destroy $root
    focus $old
    return $changedir_result
}

#
# default startpoint directory is .
# may be specifyed by invoking "$RCSfile: Wchangedir,v $ -- some/directory"
#

if {$argc == 0} {
    set dir .
} else {
    set dir [lindex $argv 0]
}

#
# print out the result
#
puts [changedir "" $dir ]

# end of $RCSfile: Wchangedir,v $
#
