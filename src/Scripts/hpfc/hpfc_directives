#! /bin/sh
#
# $RCSfile: hpfc_directives,v $ ($Date: 1996/02/26 10:52:28 $, )
# version $Revision$
#
# Filter to switch from hpf directives to subroutine calls to be parsed
# by a Fortran 77 parser. I guess some perl or awk might be much nicer
# and more efficient, but I'm not very good at it:-) Looks like an exercice
# of style, "yes I can do it with seds and trs";-)
# It may be thought as clever or stupid:-)
#
# F77 and HPF directives -> 
# calls to HPFC special subroutines and functions -> 
# HPFC subs and functs analyzed and removed -> 
# analyzes on the correct transformed code
#
# Notes:
#
# - Only one subroutine or function should be put in the pipe. 
# - I do not deal with "R E A L" like Fortran lexical problems.
# - There may be problems with if and do instructions...
#   that is IF () & DO with a directive comment would not work.
# - independent, new and reduction are orthogonal.
# - Ctrl-L, Ctrl-G and Ctrl-V are used as intermediate characters, 
#   thus should not appear in the program, otherwise troubles...
# - some default value is assigned to number of processors...
# - some specific directives for HPFC.
# - * for descriptive mappings at subroutine interface are not managed.
#
# (c) Fabien Coelho, February 95 and later.
# don't expect anything from this script.
#

#
# HPF directives:
#
# _a: align
# _b: realign
# _c: cyclic
# _d: distribute
# _e: redistribute
# _i: independent
# _k: block 
# _n: new
# _p: processors
# _r: reduction
# _s: *
# _t: template
# _u: pure
# _y: dynamic
# _#: number_of_processors()
#
# _X: special default processor arrangement
#
# missing: inherit
#
# static directives are moved AFTER declarations, 
# since I need to parse them as statements.
#
# HPFC directives: (FCD = Fabien Coelho Directives:-)
#
# local/endlocal (hack for localized computations, cannot be nested)
# _1: synchro
# _2: timeon
# _3: timeoff
# _4: setbool // to change the compiler global behavior...
# _5: setint  // dangerous and added for validation purposes...
#
# (_ is hpfc)
#

#
# commands:
#
# the sed version should be able to handle very large lines... 
# gnu sed is okay. idem tr. SUN sed is not ok.

SED=${HPFC_SED:-sed}
TR=${HPFC_TR:-tr}
RM=rm

# number of processors:
NOP=${1:-${HPFC_NUMBER_OF_PROCESSORS:-8}}

# temporary files prefix:
TMP=/tmp/hpfc_directives.$$
$RM -f $TMP.*

#
# directive normalization.
# FCD are simply translated into hpf-like prefixed directives
# ??? maybe should I add some option to avoid this translation?
#
$SED '#
      # HPF and FC directive origins to Ctrl-V
      #
      s,^[Cc!\*][Hh][Pp][Ff]\$\(.\)[ 	]*,\1,;
      s,^[Cc!\*][Ff][Cc][Dd]\$\(.\)[ 	]*,\1,;
      #
      # switch to lower case letters the directives *only*
      #
      //s,A,a,g;//s,B,b,g;//s,C,c,g;//s,D,d,g;//s,E,e,g;//s,F,f,g;
      //s,G,g,g;//s,H,h,g;//s,I,i,g;//s,J,j,g;//s,K,k,g;//s,L,l,g;
      //s,M,m,g;//s,N,n,g;//s,O,o,g;//s,P,p,g;//s,Q,q,g;//s,R,r,g;
      //s,S,s,g;//s,T,t,g;//s,U,u,g;//s,V,v,g;//s,W,w,g;//s,X,x,g;
      //s,Y,y,g;//s,Z,z,g;' |
#
# continuation handling:
# - put the whole file on one line:-)
# - then we can pattern-match on carriage returns!
# - remove not desired cr (& and 6 column styles)
# - and back to a normal file
#
$TR '\012' '' | 
$SED 's,&[ 	]*., ,g;s, *[^ ], ,g' | 
$TR '' '\012' | 
#
# massive pattern-matching transformations:
# directives are switched to hpfc specials calls.
#
$SED '#
      # space normalization (pattern-matching is easier afterwards)
      #
      //s,[ 	][ 	]*, ,g;
      //s,\([0-9a-z]\) \([^0-9a-z]\),\1\2,g;
      //s,\([^0-9a-z]\) \([0-9a-z]\),\1\2,g;
      //s,\([^0-9a-z]\) \([^0-9a-z]\),\1\2,g;
      //s,)with ,) with ,;
      //s,)onto ,) onto ,;
      #
      # indirect reserved words: block, cyclic, *, nop
      #
      //s,\([\,(]\)block\([\,()]\),\1k\2,g
      //s,\([\,(]\)block\([\,()]\),\1k\2,g
      //s,k\([\,)]\),k()\1,g
      //s,\([\,(]\)cyclic\([\,()]\),\1c\2,g
      //s,\([\,(]\)cyclic\([\,()]\),\1c\2,g
      //s,c\([\,)]\),c(1)\1,g
      //s,\*\([\,)]\),s()\1,g
      //s,number_of_processors(),#,g
      #
      # FC directives and hacks...
      #
      s, synchro,      1,
      s, timeon,      2,
      s, timeoff,      3,
      s, setbool,      4,
      s, setint,      5,
      s, local\(.*\),      i(I_LOCAL)\1      do I_LOCAL = 0\, 0,
      s, end[ ]*local,      enddo,
      #
      # HPF declaration directives (well, pure is not)
      #
      s, dynamic \(.*\),      y(\1),
      s, pure \(.*\),      u(\1),
      s, template \(.*\),      logical \1      t(\1),
      s, processors \(.*\),      logical \1      p(\1),
      #
      # HPF static and dynamic mapping directives
      #  - some simple free style is parsed.
      #
      s, align \(.*\) with \(.*\),      a(\1\,\2),
      s, align with \(.*\)::\(.*\),      a(\2\,\1),
      s, realign \(.*\) with \(.*\),      b(\1\,\2),
      s, realign with \(.*\)::\(.*\),      a(\2\,\1),
      s, distribute \(.*\) onto \(.*\),      d(\1\,\2),
      s, distribute onto \(.*\)::\(.*\),      d(\2\,\1),
      s, distribute \(.*\),      d(\1\,hpfcX),
      s, redistribute \(.*\) onto \(.*\),      e(\1\,\2),
      s, redistribute onto \(.*\)::\(.*\),      d(\2\,\1),
      s, redistribute \(.*\),      e(\1\,hpfcX),
      #
      # HPF parallelism directives
      #
      # list of directives are managed orthogonaly... (see A-284)
      # independent must be handles with and without arguments.
      //s,\,new(, new(,g
      //s,\,reduction(, reduction(,g
      //s,\,independent\([(\,]\), independent\1,g
      //s,\,independent *$, independent,
      # specific handling
      s, new,      n,g
      s, reduction,      r,g
      s, independent,      i,g
      #
      # on errors...
      #
      s,, syntax error:,
      #
      # switch to special hpfc functions...
      #
      s,\([12345abdeintpryu]\),call hpfc\1,g
      s,\([ck#s]\),hpfc\1,g' | 
#
# handles multi lines breaking (independent with new...)
#
$TR '' '\012' |
#
# number_of_processors substitution.
# separates static directives from others.
#
$SED "s,hpfc#,$NOP,g;
      /^      call hpfc[adptuy45]/w $TMP.1
      /^      call hpfc[adptuy45]/d" > $TMP.0

#
# line before which the static directives will be inserted
# i.e. last line of the declarations.
#
# first, find the last declaration line 
# (program and subroutine needed if none!)
# (functions added for implicitely typed functions...)
# (common also appear in the declaration part of the program...)
# (parameter??? I should check)

LINE=`
$SED -n '/^[^Cc\*!].... [ 	]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr][ 	\*]/=
         /^[^Cc\*!].... [ 	]*[Rr][Ee][Aa][Ll][ 	\*]/=
         /^[^Cc\*!].... [ 	]*[Ss][Tt][Rr][Ii][Nn][Gg][ 	\*]/=
         /^[^Cc\*!].... [ 	]*[Ss][Uu][Bb][Rr][Oo][Uu][Tt][Ii][Nn][Ee][ 	]/=
         /^[^Cc\*!].... [ 	]*[Pp][Rr][Oo][Gg][Rr][Aa][Mm][ 	]/=
         /^[^Cc\*!].... [ 	]*[Ll][Oo][Gg][Ii][Cc][Aa][Ll][ 	\*]/=
         /^[^Cc\*!].... [ 	]*[Cc][Oo][Mm][Pp][Ll][Ee][Xx][ 	\*]/=
	 /^[^Cc\*!].... [ 	]*[Cc][Oo][Mm][Mm][Oo][Nn][ 	\*]/=
	 /^[^Cc\*!].... [ 	]*[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn][ 	\*]/=
         /^[^Cc\*!].... [ 	]*[Bb][Yy][Tt][Ee][ 	\*]/=' $TMP.0 |
$SED -n '$p'`

[ "$LINE" ] || LINE=0

#
# then deal with continuations if any.
# comments and blank lines are also skipped, or why should I not ?

LAST_LINE=`
$SED -n "1,$LINE b
         s,^\([^Cc\*!]....[^ ]\),\1,
         s,^\([Cc\*!]\),\1,
         s,^\([ 	]*\)\$,\1,
         t cont
         q
         : cont
         =" $TMP.0 | 
$SED -n '$p'`

LINE=${LAST_LINE:-$LINE}

DEFAULT_USED=`$SED -n '/\,hpfcX)/p;/\,hpfcX)/q;' $TMP.0 $TMP.1`

#
# final output
{
  $SED -n "1,$LINE p" $TMP.0
  #
  # default processor arrangement is 1D
  #
  [ "$DEFAULT_USED" ] &&
  { 
    echo "      logical hpfcX($NOP)"
    echo "      call hpfcp(hpfcX($NOP))"
  }
  $SED -n p $TMP.1
  $SED "1,$LINE d" $TMP.0
} | 
#
# breaks generated lines which are too long
# first insert some marks, after comma or parenthesis
# there should be no identifiers larger than 15 characters (55+15=70)
#
$SED '/^[^Cc\*!].... call hpfc.[( ].\{50,\}$/s/\([^]\{55\}[^,()]*[,()]\)/\1     x /g' |
#
# later replaced by CR
#
$TR '' '\012'

#
# clean temporary files

$RM -f $TMP.*

# That is all
#
