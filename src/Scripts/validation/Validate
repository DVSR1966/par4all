#! /bin/sh
#
# (parallel) validation, Fabien Coelho, March 1994
#
# $Id$
#

#
# get the environment if necessary (ok at CRI)

[ "$PIPS_ROOT" ] || . /projects/Pips/pipsrc.sh

[ "$PIPS_VALIDDIR" ] || PIPS_VALIDDIR=$PIPS_ROOT/Validation
export PIPS_VALIDDIR

#
# should be in the environment

# why does pwd sometimes return /home/users/pips on chailly?
# sh and pwd are not very clever:-)
# this results in much troubles thru rsh...

if [ "$pips_home" ] 
then
  # this is for cri...
  REAL_PIPSHOME=`(cd $pips_home/../pips;pwd)`
else
  REAL_PIPSHOME=
fi

# echo "--$REAL_PIPSHOME--$pips_home--"

#
# to avoid nfs problems
#
absolute_name()
{
  echo $1 | sed "s,^${REAL_PIPSHOME},${pips_home},;
                 s,^${pips_home}/Pips/Production,${PIPS_ROOT},"
}

ping=${PIPS_PING:-ping}

#

script=`basename $0`

unset valid_option warning performance

vdir="$PIPS_VALIDDIR"
VALID="$PIPS_ROOT/Utils/validate-sequential"

# so as to find the right ping, mail and date...
PATH="/usr/ucb:/usr/etc:/usr/bin:/usr/games:.:$PATH"

MAIL=${PIPS_MAIL:-Mail}

# coulommiers.ensmp.fr -> coulommiers
hostname=`hostname | sed 's/\..*//'`
user=`whoami`
PWD=`absolute_name \`pwd\``

# defaults

deb1=":"
deb2=":"
verb=":"
parallel="1"
# time between sub-validation return checks.
update=10

#
# functions

debug()
{
  echo [Validate:${hostname}] "$@" >&2
}

verbose()
{ 
  echo [Validate:${hostname}] "$@" >&2
  echo "$@" >> $MSG
}

unstammer()
{
    unst_f1=""
    unst_f2=""
    unst_sep=${2:-:}
    unst_counter=1;

    for unst_f1 in `
    for unst_f2 in \`echo "$1" | tr "$unst_sep" ' '\`
    do
      echo "$unst_counter	$unst_f2"
      unst_counter=\`expr $unst_counter + 1\`
    done | sort +1d -2 +0n -1 | uniq -1 | sort +0n -1 | cut -f 2 `
    do
      echo "$unst_sep$unst_f1"
    done | tr -d '\012' 
}

remote()
{
    rhost=$1; shift;

    if [ $rhost = $hostname ]
    then
      ( "$@" & ) ;
    else
      rsh $rhost "$@" &
    fi
}

#
# keeps alive hosts from the list
#
alive()
{
  for v_host in `echo $1 | tr ':' ' '`
  do
    $deb2 " | $ping $v_host"
    $ping $v_host > /dev/null 2>&1 && echo ":$v_host"
  done | tr -d '\012'
}

#
# echos the pips to be run

which_executable()
{
  PATH="${PWD}/${PIPS_ARCH}:${PIPS_ROOT}/Bin/${PIPS_ARCH}:${PWD}:${PATH}" \
    type $1 | sed "s,.* is ,,"
}

#
# on errors
#
validate_usage()
{
  cat >&2 <<-EOF
	$script (version $Revision$): $@
	Description
	  This script executes pips non regressive tests (in \$PIPS_VALIDDIR).
	  The modules to test (script arguments) are executed in parallel on
	  available hosts from \$PIPS_HOSTS. Reports are sent to the user.
	Usage: $script [-dsvpnhtVD] [-a address] [-r dir] [-l dir]
	       [-x/y pips/tpips] [-i lines] [-f file] [modules]
	  -h: this help
	  -d: debug
	  -D: more debug
	  -s: silent (default)
	  -v: verbose
	  -V: more verbose
	  -p: parallel (default)
	  -n: sequential
	  -t: timing
	  -a adress: mail sent to (default "$user" for you:-)
	  -r dir: run directory (default .)
	  -i lines: max number of lines for sending a full message
	  -l dir: lock directory (default .)
	  -f file: what file in a module (use with -n)
	  -x pips: pips to be used
	  -y tpips: tpips to be used 
	    default {,t}pips: . ./\$PIPS_ARCH \$PIPS_ROOT/Bin/\$PIPS_ARCH type)
	  modules: if none, from file \$PIPS_VALIDDIR/defaults.\$PIPS_ARCH
	           else from file \$PIPS_VALIDDIR/defaults
EOF
  exit ${1:-1}
}

#
# I'm not so happy of that function...
# an allow null_glob_expansion would have been nicer
#
prefix_file_exists()
{
  $deb2 " | in prefix_file_exists for $1"
  for f in $1.* ; do test -f $f && return 0 ; done
  $deb2 " | not found"
  return 1
}

# returns one arg chosen randomly
randomize()
{
    # $deb2  `type random ; echo $?`
    if type random > /dev/null 2>&1 
    then
	random -e $#
	shift $?
    fi
    echo $1
}

#
# finds an availbale host
#   waits for the termination of one run
#   stores the result and
#   gives the available hostname back
#
available_host()
{
  prefix_file_exists $WAITING || return 1
  #
  # waiting
  #
  until prefix_file_exists $RESULT
  do
    $deb1 " | sleep" 
    sleep $update
  done
  $deb1 " | ok"
  #
  # get the result, hostname and remove the lock files
  #
  ah_file=`randomize $RESULT.*`
  $deb2 " | ah_file is $ah_file"
  # failed="$failed-"`cat $ah_file`
  #
  # failures append
  cat $ah_file >> $FAILED
  ah_host=`basename $ah_file | cut -d. -f 5`
  rm -f $WAITING.$ah_host $RESULT.$ah_host
  #
  # available host
  #
  $deb2 " | available host found: $ah_host"
  echo $ah_host
}

#
# date taken for timing
#
local_date() { date +"%h %d %y, %T";}

#
# validate
#
send_validate()
{
  validate_module=$1
  validate_host=$2

  $deb1 " | remote $validate_host \ "
  $deb1 " | $VALID \ "
  $deb1 " |   -r $RUNDIR \ "
  $deb1 " |   -l $RESULT \ "
  $deb1 " |   -x $pips_version \ "
  $deb1 " |   -y $tpips_version \ "
  $deb1 " |   -u $valid_option $validate_module"

  remote $validate_host \
  $VALID -r $RUNDIR -l $RESULT -x "$pips_version" -y "$tpips_version" \
         -u $valid_option $validate_module &

  echo "$validate_module" > $WAITING.$validate_host
}

#
# get options

while getopts DVdtsvpnhr:l:x:y:i:a: opt
do
  case $opt in
    d) deb1="debug" ;;
    D) deb1="debug"; deb2="debug";  valid_option="$valid_option -d" ;;
    t) performance="begin `local_date`"; valid_option="$valid_option -t";;
    v) verb='verbose' ;;
    V) verb='verbose' ; valid_option="$valid_option -v";;
    i) valid_option="$valid_option -i $OPTARG" ;;
    s) verb=':' ;;
    p) parallel="1" ;;
    n) parallel="" ;;
    r) RUNDIR="$OPTARG" ;;
    l) LOCKDIR="$OPTARG" ;;
    x) pips_version="$OPTARG" ;;
    y) tpips_version="$OPTARG" ;;
    h) validate_usage 0 ;;
    a) user="$OPTARG" ; valid_option="$valid_option -a $user" ;;
    *) echo  ; validate_usage 1
  esac
done

shift `expr $OPTIND - 1`

################################################################## Properties

if [ "$PIPS_PROPERTIESRC" ]
then
    valid_option="$valid_option -p $PIPS_PROPERTIESRC"
    warning="$PIPS_PROPERTIESRC used! $warning"
else
    test -f ./properties.rc && {
	valid_option="$valid_option -p `absolute_name $PWD/properties.rc`"
	warning="./properties.rc used! $warning"
    }
fi

#################################################################### PipsMake

if [ "$PIPS_PIPSMAKERC" ]
then
    valid_option="$valid_option -p $PIPS_PIPSMAKERC"
    warning="$PIPS_PIPSMAKERC used! $warning"
else
    test -f ./pipsmake.rc && {
	valid_option="$valid_option -m `absolute_name $PWD/pipsmake.rc`"
	warning="./pipsmake.rc used! $warning"
    }
fi


#
# some default cases

RUNDIR=`absolute_name ${RUNDIR:-$PWD}`
LOCKDIR=`absolute_name ${LOCKDIR:-$RUNDIR}`

#
# lock names

WAITING="$LOCKDIR/.validate_waiting.$hostname.$$"
RESULT="$LOCKDIR/.validate_result.$hostname.$$"
FAILED="$LOCKDIR/.validate_failed.$hostname.$$"
MSG="$LOCKDIR/.validate_msg.$hostname.$$"

#
# the working directory

cd $RUNDIR
 
#
# variables

if test -r $vdir/defaults.$PIPS_ARCH
then
    default_file="$vdir/defaults.$PIPS_ARCH"
else
    default_file="$vdir/defaults"
fi

default_test="default_test"
subject="PIPS Validation"

pips_version=`absolute_name ${pips_version:-\`which_executable pips\`}`
tpips_version=`absolute_name ${tpips_version:-\`which_executable tpips\`}`

export pips_version
export tpips_version

$deb1 " | $user on $hostname"
$deb2 " | real PIPSHOME: $REAL_PIPSHOME"

#
# modules to be checked by the validation

case $# in
  0) $verb "Taking default validation from $default_file" ;
     MODULES=`sed /#/d < $default_file | tr -s '\012' ' '` ;;
  *) MODULES="$*"
esac

$deb2 " | MODULES 1: $MODULES"
MODULES=`unstammer "$MODULES" ' '`

$verb "Modules: $MODULES"

#
# hosts to be used by the validation

VALHOSTS=$hostname

if [ "$parallel" -a "$PIPS_HOSTS" ]
then
  VALHOSTS="$VALHOSTS:${PIPS_HOSTS}"
fi

$deb2 " | hosts before unstammering: $VALHOSTS"
VALHOSTS=`unstammer $VALHOSTS`

$deb2 " | hosts before checking ups: $VALHOSTS"
VALHOSTS=`alive $VALHOSTS`

$verb "Hosts: $VALHOSTS"

#
# Sequential case

[ ! "$parallel" ] && \
{
  $verb "sequential validation"

  $deb1 "exec $VALID \ "
  $deb1 "   -r $RUNDIR \ "
  $deb1 "   -x $pips_version \ "
  $deb1 "   -u $valid_option $MODULES"

  exec $VALID -r $RUNDIR -x "$pips_version" -u $valid_option $MODULES
}

#
# Parallel case

$verb "parallel validation"
$verb " - with $pips_version"
$verb " - and  $tpips_version"
$verb " - in $RUNDIR"

$verb "creating initial locks"

touch $FAILED

for h in `echo $VALHOSTS | tr ':' ' '`
do
  $deb1 " | initial lock for $h"
  touch $WAITING.$h $RESULT.$h
done

#

$verb "validating modules"

for m in $MODULES
do
  h=`available_host`
  $verb " - validate $m on $h at `date`"
  send_validate $m $h
done

#

$verb "waiting for reports"

while available_host ; do : ; done > /dev/null

#
#

$verb "generating final report at `date`"

failed=`tr '\012' '-' < $FAILED`

$deb2 " | failed 0: /$failed/"
failed=`unstammer "$failed" '-'`
$deb1 " | failed : /$failed/"

if [ "$failed" ]
then
  final="failed: [$failed]"
  finalsubject="$subject: failed"
else
  final="succeeded"
  finalsubject="$subject: succeeded"
fi

[ "$performance" ] && performance="$performance, end `local_date`"

cat >> $MSG <<%

Your Validation Suite Test for

$MODULES

$final
pips:  $pips_version
tpips: $tpips_version

$warning

$performance

In case of problems, contact coelho@cri.ensmp.fr
%

${MAIL} -s "$finalsubject" $user < $MSG

rm -f $FAILED $MSG

#
# that is all
#
