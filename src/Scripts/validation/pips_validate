#! /bin/bash
# $Id$

# defaults
# where is the validation
vdir=${PIPS_VALIDDIR:-$PIPS_ROOT/Validation}

# temporary directory
tdir=${PIPS_TEMPDIR:-/tmp}

# running directory
rdir=.

tpips=$(type -p tpips)
pips=$(type -p pips)

# display help
function usage()
{
  local status=$1 msg=$2
  [[ $msg ]] && echo "message: $msg" >&2
  echo -e \
    "$0 [options] directories or files...\n" \
    "options:\n" \
    "  -h: show some help\n" \
    "  -v: be verbose (repeat for more verbosity)\n" \
    "  -p pips: use this 'pips' executable, default $pips\n" \
    "  -t tpips: use this 'tpips' executable, default $tpips\n" \
    "  -T dir: temporary directory, default '/tmp'\n" \
    "  -V dir: validation directory, default '$vdir'\n" \
    "  -R dir: running directory, default '.'\n" \
    "  -O dir: output directory, default '.'\n" \
    "arguments:\n" \
    "  validation directories (e.g. Semantics Regions ...)\n" \
    "  or files (e.g. Semantics/w14.f ...)\n"
  exit ${status:-1}
}

# verb level 'message to be shown...'
verb=0
function verb()
{
  local level=$1 msg=$2
  [[ $verb -ge $level ]] && echo "# $msg" >&2
}

# checks
[[ $PIPS_ROOT ]] || usage 1 'PIPS_ROOT must be defined'
[[ -d $PIPS_ROOT ]] || usage 2 "no root directory: $PIPS_ROOT"

mail=

# get options
while [ "$1" ]
do
  opt=$1
  case $opt in
      --) shift ; break ;;
      -*) shift ;;
      *) break ;;
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) let verb++ ;;
      -t|--tpips) tpips=$1 ; shift ;;
      -p|--pips) pips=$1 ; shift ;;
      -T|--tmp) tdir=$1 ; shift ;;
      -V|--valid) vdir=$1 ; shift ;;
      -R|--run) rdir=$1 ; shift ;;
      -O|--out|--output) odir=$1 ; shift ;;
      -m|--mail) mail="$mail $1" ; shift ;;
      *) usage 1 "unexpected option: $opt"
  esac
done

# where to put results
odir=$rdir

# option checks
[[ -d $vdir ]] || usage 3 "no validation directory: $vdir"
[[ -d $tdir ]] || usage 4 "no temporary directory: $tdir"
[[ -d $rdir ]] || usage 5 "no run directory: $rdir"
[[ -d $odir ]] || usage 5 "no output directory: $odir"

[[ -x $pips ]] || usage 7 "not executable: $pips"
[[ -x $tpips ]] || usage 8 "not executable: $tpips"

[[ -f properties.rc ]] && usage 17 "cannot run with local 'properties.rc'"
[[ -f pipsmake.rc ]] && usage 18 "cannot run with local 'pipsmake.rc'"

[[ $rdir != '.' ]] && pushd $rdir

# result directory
resdir=$odir/validation_results.$$
mkdir $resdir || usage 9 "error mkdir $resdir"

# start summary
summary=$resdir/summary

echo "validation for $@
with pips=$pips
and tpips=$tpips
running in $rdir
on $(date)
" >> $summary

# set default directories if necessary
if [[ ! $@ ]]
then
  [[ -r $vdir/defaults ]] || usage 10 "cannot read $vdir/defaults"
  set - $(cat $vdir/defaults | grep -v '#')
fi

# validate a file
# returns whether it is a success
# appends errors to $summary
function validate_file()
{
  # file='/some/path/to/directory/file.f'
  local file=$1
  [[ -f $file ]] || usage 12 "no such source file: $file"
  verb 2 "validating $file..."

  # full_name='/some/path/to/directory/file'
  # name='file'
  # upper='FILE'
  local full_name=${file%.[cfF]} 
  local name=${full_name/*\//}
  local upper=$(echo $name | tr '[a-z]' '[A-Z]')

  # dir='/some/path/to/directory'
  local dir=${full_name%/*} 
  [[ -d $dir ]] || usage 13 "no such 'dir' directory: $dir"

  # updir='/some/path/to'
  local updir=${dir%/*}
  [[ -d $updir ]] || usage 14 "no such 'updir' directory: $updir"

  # output='directory/file'
  local output=${full_name/$updir\//}
  # output='directory_file'
  output=${output/\//_}
  verb 4 "output suffix is: $output"

  # out="$resdir/directory_file"
  local out=$resdir/$output
  local status

  if [[ -r $full_name.test ]] ; then
      # *.test
      verb 3 "$full_name.test method"
      # ??? what about using default_test substitution?!
      $full_name.test > $out.out 2> $out.err
      status=$?

  elif [[ -r $full_name.tpips ]] ; then 
      # *.tpips
      verb 3 "$full_name.tpips method"
      $tpips $full_name.tpips > $out.out 2> $out.err
      status=$?

  elif [[ -r $dir/default_test ]] ; then
      # default_test
      verb 3 'default_test method'
      local test=$tdir/default_test_$$.sh
      # perform some substitutions...
      sed -e "s/tested_file/${file//\//\\/}/g" \
	  -e "s/tested_dir/${dir//\//\\/}/g" \
	  -e "s/tested_name/$name/g" \
	  -e "s/TESTED_NAME/$upper/g" \
	  < $dir/default_test > $test
      chmod +x $test
      $test > $out.out 2> $out.err
      status=$?
      rm -f $test
      
  elif [[ -r $dir/default_tpips ]] ; then
      # default_tpips
      verb 3 'default_tpips method'
      FILE=$file WSPACE=$name \
	  ${tpips} $dir/default_tpips > $out.out 2> $out.err
      status=$?

  else
      verb 3 'default method'
      usage 0 "default method not implemented yet ($file)"
      status=1
  fi
  # cleanup
  [[ -f core ]] && rm -f core

  if [[ $status -eq 0 ]]
  then
    # generate diff and clean if okay
    local file_resdir=$full_name.result
    [[ -d $file_resdir ]] || \
      usage 15 "no result directory: $file_resdir"
    
    local reference=$file_resdir/test.$PIPS_ARCH
    [[ -f $reference ]] || reference=$file_resdir/test
    # create empty reference if necessary
    [[ -f $reference ]] || touch $reference

    ${PIPS_DIFF:-diff -b -c} $reference $out.out > $out.diff

    if [[ -s $out.diff ]] ; then
      verb 2 "changed: $file"
      echo "changed: $file" >> $summary
    else
      # ok!
      verb 3 "succeeded: $file"
      rm -f $out.*
    fi
  else
      echo "failed: $file" >> $summary
  fi

  return $status
}

# process directories (or possibly files)
errors=0
for obj in "$@"
do
  if [ -d $vdir/$obj ]
  then
      verb 1 "considering $obj directory"
      for file in $vdir/$obj/*.[cfF]
      do
	validate_file $file || let errors++
      done
  elif [ -f $vdir/$obj ]
  then
      validate_file $vdir/$obj || let errors++
  else
      usage 11 "unexpected object: $obj"
  fi
done

echo "
$errors errors
on $(date)" >> $summary

# cleanup databases?
Delete -a

[[ $mail ]] && verb 0 "mail not implemented yet"
