#! /bin/bash
# $Id$

# DEFAULTS
# where is the validation
vdir=${PIPS_VALIDDIR:-$PIPS_ROOT/Validation}

# temporary directory
tdir=${PIPS_TEMPDIR:-/tmp}

# running directory
rdir=.

tpips=$(type -p tpips)
pips=$(type -p pips)

# display help
function usage()
{
  local status=$1 msg=$2
  [[ $msg ]] && echo "message: $msg" >&2
  echo -e \
    "$0 [options] directories or files...\n" \
    "options:\n" \
    "  -h: show some help\n" \
    "  -v: be verbose (repeat for more verbosity)\n" \
    "  -p pips: use this 'pips' executable, default $pips\n" \
    "  -t tpips: use this 'tpips' executable, default $tpips\n" \
    "  -m email: send mails?\n" \
    "  -T dir: temporary directory, default '/tmp'\n" \
    "  -V dir: validation directory, default '$vdir'\n" \
    "  -R dir: running directory, default '.'\n" \
    "  -O dir: output directory, default '.'\n" \
    "arguments:\n" \
    "  validation directories (e.g. Semantics Regions ...)\n" \
    "  or files (e.g. Semantics/w14.f ...)\n"
  exit ${status:-1}
}

# verb level 'message to be shown...'
verb=0
function verb()
{
  local level=$1 msg=$2
  [[ $verb -ge $level ]] && echo "# $msg" >&2
}

# checks
[[ $PIPS_ROOT ]] || usage 1 'PIPS_ROOT must be defined'
[[ -d $PIPS_ROOT ]] || usage 2 "no root directory: $PIPS_ROOT"

# get options
while [ "$1" ] ; do
  opt=$1
  case $opt in
      --) shift ; break ;; # end of option
      -*) shift ;; # one option, processed by next "case"
      *) break ;; # must be an argument, stop option processing...
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) let verb++ ;;
      -t|--tpips) tpips=$1 ; shift ;;
      -p|--pips) pips=$1 ; shift ;;
      -T|--tmp) tdir=$1 ; shift ;;
      -V|--valid) vdir=$1 ; shift ;;
      -R|--run) rdir=$1 ; shift ;;
      -O|--out|--output) odir=$1 ; shift ;;
      -m|--mail) mail="$mail $1" ; shift ;;
      *) usage 1 "unexpected option: $opt"
  esac
done

# option checks
[[ -d $vdir ]] || usage 3 "no validation directory: $vdir"
[[ -d $tdir ]] || usage 4 "no temporary directory: $tdir"
[[ -d $rdir ]] || usage 5 "no run directory: $rdir"

# result directory
[[ $odir ]] || odir=$rdir/validation_results.$$
[[ -d $odir ]] && usage 5 "output directory already created: $odir"
mkdir $odir || usage 9 "error mkdir $odir"

[[ -x $pips ]] || usage 7 "not executable: $pips"
[[ -x $tpips ]] || usage 8 "not executable: $tpips"

[[ -f properties.rc ]] && usage 17 "cannot run with local 'properties.rc'"
[[ -f pipsmake.rc ]] && usage 18 "cannot run with local 'pipsmake.rc'"

# go !
[[ $rdir != '.' ]] && pushd $rdir

# start summary
summary=$odir/SUMMARY

echo "validation for $@
in $vdir
for $PIPS_ARCH architecture
output in $odir
with pips=$pips
and tpips=$tpips
running in $rdir
on $(date)
" >> $summary

# set default directories if necessary
if [[ ! $@ ]] ; then
  [[ -r $vdir/defaults ]] || usage 10 "cannot read $vdir/defaults"
  set - $(cat $vdir/defaults | grep -v '#')
fi

# validate a file
# returns whether it is a success
# appends errors to $summary
function validate_file()
{
  # file='/some/path/to/directory/file.f'
  local file=$1
  [[ -f $file ]] || usage 12 "no such source file: $file"
  verb 2 "validating $file..."

  # full_name='/some/path/to/directory/file'
  # name='file'
  # upper='FILE'
  local full_name=${file%.[cfF]} 
  local name=${full_name/*\//}
  local upper=$(echo $name | tr '[a-z]' '[A-Z]')

  # dir='/some/path/to/directory'
  local dir=${full_name%/*} 
  [[ -d $dir ]] || usage 13 "no such 'dir' directory: $dir"
  export PIPS_SRCPATH=$dir # set path for tpips?

  # updir='/some/path/to'
  local updir=${dir%/*}
  [[ -d $updir ]] || usage 14 "no such 'updir' directory: $updir"

  # prefix='directory/file'
  local prefix=${full_name/$updir\//}
  # output='directory_file'
  output=${prefix/\//_}
  verb 4 "output suffix is: $output"

  # out="$odir/directory_file"
  local out=$odir/$output

  # rel_file='directory/file.f'
  local rel_file=${file/$updir\//}
  local status

  if [[ -r $full_name.test ]] ; then
    verb 3 "$prefix.test method"
    # ??? what about using default_test substitution?!
    $full_name.test > $out.out 2> $out.err || status=$?

  elif [[ -r $full_name.tpips ]] ; then 
    verb 3 "$prefix.tpips method"
    $tpips $full_name.tpips > $out.out 2> $out.err || status=$?

  elif [[ -r $full_name.tpips2 ]] ; then 
    verb 3 "$prefix.tpips2 method (with stderr... bad idea)"
    $tpips $full_name.tpips2 2>&1 | sed '/ing file /d' > $out.out 
    status=$?

  elif [[ -r $dir/default_test ]] ; then
    verb 3 'default_test method'
    local test=$tdir/default_test_$$.sh
    # perform some substitutions...
    sed -e "s/tested_file/${file//\//\\/}/g" \
	-e "s/tested_dir/${dir//\//\\/}/g" \
	-e "s/tested_name/$name/g" \
	-e "s/TESTED_NAME/$upper/g" \
	< $dir/default_test > $test
    chmod +x $test
    $test > $out.out 2> $out.err || status=$?
    rm -f $test
    
  elif [[ -r $dir/default_tpips ]] ; then
    verb 3 'default_tpips method'
    FILE=$file WSPACE=$name \
	${tpips} $dir/default_tpips > $out.out 2> $out.err || status=$?
    
  else
    verb 3 'default method: Init/Display/Delete'
    {
      Init -f $file -d $name || status=$?
      while read module ; do
	Display -m $module -w $name || status=$?
      done < $name.database/modules
      Delete $name # ignore delete failture... 
    } > $out.out 2> $out.err
  fi
  [[ -f core ]] && rm -f core # cleanup

  if [[ $status -eq 0 ]] ; then
    # generate diff and clean if okay
    local file_resdir=$full_name.result
    [[ -d $file_resdir ]] || usage 15 "no result directory: $file_resdir"
    
    local reference=$file_resdir/test.$PIPS_ARCH
    [[ -f $reference ]] || reference=$file_resdir/test

    ${PIPS_DIFF:-diff -b -u} $reference $out.out > $out.diff

    if [[ -s $out.diff ]] ; then
      verb 2 "changed: $rel_file"
      echo "changed: $rel_file" >> $summary
      cp $out.out $file_resdir/out
      status=1 # something was wrong...
    else
      verb 2 "succeeded: $rel_file" # ok!
      rm -f $out.*
    fi
  else
      echo "failed: $rel_file" >> $summary
  fi

  return $status
}

# process directories (or possibly files)
errors=0
elist=''
for obj ; do
  failed=
  if [ -d $vdir/$obj ] ; then
    verb 1 "considering $obj directory"
    for file in $vdir/$obj/*.[cfF] ; do
      validate_file $file || let errors++ failed=1
    done
  elif [ -f $vdir/$obj ] ; then
    validate_file $vdir/$obj || let errors++ failed=1
  else
    usage 11 "unexpected object: $obj"
  fi
  [[ $failed ]] && elist="$elist$obj "
done
echo -e "\n$errors error(s) on $(date)" >> $summary
rm -rf *.database # cleanup

# report on stdout and by mail
msg='SUCCEEDED'
[[ $errors -gt 0 ]] && msg="FAILED ($elist)"
echo -e "\nvalidation $msg\n" ; cat $summary
[[ $mail ]] && ${PIPS_MAIL:-Mail} -s "validation $msg" $mail < $summary
