#! /bin/bash
# $Id$

script=${0/*\//}

rev='$Rev$'
rev=${rev/*: /}
rev=${rev/ */}

# To be sure that extended globing is available:

shopt -s extglob

# DEFAULTS
# where is the validation?
vdir=${PIPS_VALIDDIR:-$PIPS_ROOT/../../validation}

# default running directory
rdir=.
recurse=

# get default architecture and tpips/pips
arch=${PIPS_ARCH:-$($PIPS_ROOT/makes/arch.sh)}
tpips=$(type -p tpips)
pips=$(type -p pips)

# by default, do not create a missing .result directory:
auto_result_create=""

# By default do not display the diff:
display_diff=

# By default, no archive:
keep_archive=

# Where is stored the validation archives:
archive_dir_basename=SUMMARY_Archive

# fix collation (sort) order to default ASCII for all validations
unset LANG LC_ALL LC_COLLATE
export LC_ALL=C

# display help
function usage()
{
  local status=$1 msg=$2
  if [[ $msg ]]
  then
    echo -e "message: $msg\n" >&2
  fi
  if [[ $status == 0 || $status == 1 ]]
  then
    echo -e \
      "$script [options] directories or files...\n" \
	"revision $rev\n" \
	"options:\n" \
	"  -h|--help: show some help\n" \
	"  -v|--verbose: be verbose (repeat for more, over 2 is debug)\n" \
	"  -p|--pips pips: use this 'pips' executable\n" \
	"     default '$pips'\n" \
	"  -t|--tpips tpips: use this 'tpips' executable\n" \
	"     default '$tpips'\n" \
	"  -m|--mail email: send mails (not a good idea?)\n" \
	"  -V|--valid dir: validation destination directory\n" \
	"     default '$vdir'\n" \
	"  -R|--run dir: running directory, default '.'\n" \
        "  -r|--recurse: look for subdirectories...\n" \
	"  -d|--diff: display also a diff against previous validation\n" \
	"     to show what changed. Imply the --archive option\n" \
	"  -k|--archive: keep a summary of the validation in directory\n" \
	"    '$archive_dir_basename'\n" \
	"  -O|--out|--output dir: output directory, default '.'\n" \
	"arguments:\n" \
	"  -a|--auto-result-create: create a .result directory if it does\n" \
	"     not exist yet. Useful to create a new validation test,\n" \
	"     followed by a manual accept\n" \
	"  validation directories (e.g. Semantics Regions ...)\n" \
	"  or files (e.g. Semantics/w14.f ...)\n"
  fi
  exit ${status:-1}
}

# verb level 'message to be shown...'
verb=0
function verb()
{
  local level=$1 msg=$2
  [[ $verb -ge $level ]] && {
      while let level-- ; do echo -n '#' ; done
      echo " $msg"
  } >&2
}

# checks
[[ $PIPS_ROOT ]] || usage 2 'PIPS_ROOT must be defined'
[[ -d $PIPS_ROOT ]] || usage 2 "no root directory: $PIPS_ROOT"

# get options
while [ "$1" ] ; do
  opt=$1
  case $opt in
      --) shift ; break ;; # end of option
      -*) shift ;; # one option, processed by next "case"
      *) break ;; # must be an argument, stop option processing...
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) let verb++ ;;
      --version) echo "$script revision $rev" ; exit 0 ;;
      # look for work
      -r|--recurse) recurse=1 ;;
      # binaries to use
      -t|--tpips) tpips=$1 ; shift ;;
      --tpips=*) tpips=${opt/*=/} ;;
      -p|--pips) pips=$1 ; shift ;;
      --pips=*) pips=${opt/*=/} ;;
      # directories to use
      -V|--valid) vdir=$1 ; shift ;;
      --valid=*) vdir=${opt/*=/} ;;
      -R|--run) rdir=$1 ; shift ;;
      --run=*) rdir=${opt/*=/} ;;
      # result
      -O|--out|--output) odir=$1 ; shift ;;
      --out=*|--output=*) odir=${opt/*=/} ;;
      -m|--mail) mail="$mail $1" ; shift ;;
      --mail=*) mail="$mail ${opt/*=/}" ;;
      -a|--auto-result-create) auto_result_create=1 ;;
      # archive to detect changes
      -d|--diff) display_diff=1; keep_archive=1 ;;
      -k|--archive) keep_archive=1 ;;
      # error
      *) usage 1 "unexpected option: $opt"
  esac
done

# option checks
[[ -d $vdir ]] || usage 3 "no validation directory: $vdir"
[[ -d $rdir ]] || usage 4 "no run directory: $rdir"

# result directory
[[ $odir ]] || odir=$rdir/validation_results.$$
[[ -d $odir ]] && usage 5 "output directory already exists: $odir"
mkdir $odir || usage 6 "error on mkdir $odir"

[[ -x $pips ]] || usage 7 "not executable: $pips"
[[ -x $tpips ]] || usage 8 "not executable: $tpips"

[[ -f properties.rc ]] && usage 17 "cannot run with local 'properties.rc'"
[[ -f pipsmake.rc ]] && usage 18 "cannot run with local 'pipsmake.rc'"

# go into running directory
[[ $rdir != '.' ]] && pushd $rdir

# start summary
summary=$odir/SUMMARY

# directory for validation archives
archive_dir=$vdir/$archive_dir_basename
# previous validation summary
previous_summary=$archive_dir/SUMMARY-previous
# last validation summary
last_summary=$archive_dir/SUMMARY-last

# create the archive directory only if necessary:
[[ $keep_archive && ! -d $archive_dir ]] && mkdir $archive_dir

# Save last summary for later diff or inspection:
if [[ $keep_archive && -f $last_summary ]]; then
    # deal with symbolic links:
    rm -f $previous_summary
    mv $last_summary $previous_summary
fi

echo "validation for $@
in directory ${vdir}/
  $($PIPS_ROOT/makes/version.sh $vdir)
for $arch architecture
output in directory ${odir}/
with pips=$pips
$(${pips} -v)
and tpips=$tpips
$(${tpips} -v)
running in directory ${rdir}/
on $(hostname)
by $(whoami)
at $(date)
" >> $summary

# set default directories if necessary
if [[ ! $@ ]] ; then
  [[ -r $vdir/defaults ]] || usage 10 "cannot read $vdir/defaults"
  set - $(cat $vdir/defaults | grep -v '#')
fi

# validate a file
# returns whether it is a success
# appends errors to $summary
function validate_file()
{
  # file='/some/path/to/directory/file.(f|c|F|tpips)'
  local file=$1
  [[ -f $file ]] || usage 12 "no such source file: $file"
  verb 4 "validating $file..."

  # full_name='/some/path/to/directory/file' without the extension
  # name='file'
  # upper='FILE'
  local full_name=${file%.@([cfF]|tpips)}
  if [[ ! -d $full_name.result ]]
  then
    if [[ -n $auto_result_create ]]
    then
      mkdir $full_name.result
      touch $full_name.result/test
      echo "Directory $full_name.result created."
      echo "Think to run a manual_accept to set the results of the validation"
      echo "  of this file as the reference."
    else
      verb 1 "skipping $file: no matching result directory"
      echo "skipped: $file" >> $summary
      return 0
    fi
  fi

  local name=${full_name/*\//}
  local upper=$(echo $name | tr '[a-z]' '[A-Z]')

  # dir='/some/path/to/directory'
  local dir=${full_name%/*}
  [[ -d $dir ]] || usage 13 "no such 'dir' directory: $dir"

  # fix path to help more or less relative validation?
  export PIPS_VALIDDIR=$vdir # re-export...
  export PIPS_SRCPATH=$dir # set path for tpips?
  export VDIR=$dir # set path for validation

  # updir='/some/path/to'
  local updir=${dir%/*}
  [[ -d $updir ]] || usage 14 "no such 'updir' directory: $updir"

  # prefix='directory/file'
  local prefix=${full_name/$updir\//}
  # output='directory_file'
  output=${prefix/\//_}
  verb 4 "output suffix is: $output"

  # out="$odir/directory_file"
  local out=$odir/$output

  # rel_file='directory/file.f'
  local rel_file=${file/$updir\//}
  # Just in case pips command are not found and all the following tests
  # fail, initialize the status:
  local status=-1

  if [[ -r $full_name.test ]] ; then
    verb 3 "$prefix.test method"
    verb 4 "$full_name.test"
    # ??? what about using default_test substitution?!
    $full_name.test 2> $out.err ; status=$?

  elif [[ -r $full_name.tpips ]] ; then
    verb 3 "$prefix.tpips method"
    verb 4 "$tpips $full_name.tpips"
    $tpips $full_name.tpips 2> $out.err ; status=$?

  elif [[ -r $full_name.tpips2 ]] ; then
    verb 3 "$prefix.tpips2 method (with stderr... bad idea)"
    verb 4 "$tpips $full_name.tpips"
    $tpips $full_name.tpips2 2>&1 ; status=$?

  elif [[ -r $dir/default_test ]] ; then
    verb 3 'default_test method'
    # perform some substitutions on the fly...
    sed -e "s/tested_file/${file//\//\\/}/g" \
	-e "s/tested_dir/${dir//\//\\/}/g" \
	-e "s/tested_name/$name/g" \
	-e "s/TESTED_NAME/$upper/g" \
	< $dir/default_test | /bin/sh 2> $out.err
    status=$?

  elif [[ -r $dir/default_tpips ]] ; then
    verb 3 'default_tpips method'
    verb 4 "FILE=$file WSPACE=$name ${tpips} $dir/default_tpips"
    FILE=$file WSPACE=$name \
	${tpips} $dir/default_tpips 2> $out.err ; status=$?

  else
    verb 3 'default method: Init/Display/Delete'
    {
      Delete $name 2> /dev/null 1>&2 # ignore delete failure...
      Init -f $file -d $name ; status=$?
      while read module ; do
	Display -m $module -w $name ; status=$?
      done < $name.database/modules
      Delete $name 2> /dev/null 1>&2 # ignore delete failure...
    } 2> $out.err
  fi > $out.tmp

  verb 4 "Status = $status"

  # filter out validation directory path for all output...
  # the if/fi output above cannot be piped directly because
  # it would hide the "status" variable setting in a subshell.
  sed -e "s/${VDIR//\//\\/}/\$VDIR/g" $out.tmp > $out.out && rm -f $out.tmp

  [[ -f core ]] && rm -f core # cleanup

  if [[ $status -eq 0 ]] ; then
    # generate diff and clean if okay
    local file_resdir=$full_name.result
    [[ -d $file_resdir ]] || usage 15 "no result directory: $file_resdir"

    local reference=$file_resdir/test.$arch
    [[ -f $reference ]] || reference=$file_resdir/test

    ${PIPS_DIFF:-diff -b -u} $reference $out.out > $out.diff

    if [[ -s $out.diff ]] ; then
      verb 2 "$rel_file: CHANGED"
      echo "changed: $rel_file" >> $summary
      cp $out.out $file_resdir/out
      status=1 # something was wrong...
    else
      verb 3 "$rel_file: SUCCEEDED" # ok!
      rm -f $out.*
    fi
  else
      verb 2 "$rel_file: FAILED"
      echo "failed: $rel_file" >> $summary
  fi

  return $status
}

# process directories (or possibly files)
dones=0
errors=0
elist=''

# what do we have to do?
if [[ $recurse ]] ;
then
  what=$(find "$@" -type d -print |
         egrep -v '(\.svn|OLD|\.result|\.src|\.include)')
else
  what="$@"
fi

# this is not good.
# what means to be validated is when *.result directories are available
# and then we should look for available tpips/test/sources to do so?
for obj in $what
do
  failed=
  if [ -d $vdir/$obj ] ; then
    verb 1 "considering '$obj' directory"
    # this list may be empty: e.g. with the "pipspriv" repository
    for file in $vdir/$obj/*.@([cfF]|tpips); do
      verb 3 " - considering '${file//$vdir\//}' file"
      base=${file%.@([cfF]|tpips)}
      ext=${file/*./}
      if [[ $ext != tpips && -f $base.tpips ]] ; then
	  # If there is a file and a .tpips associated, skip the
	  # validation done for this file since it is done for the .tpips
	  continue
      fi
      validate_file $file || let errors++ failed=1
      let dones++
    done
  elif [ -f $vdir/$obj ] ; then
    verb 1 "considering '$obj' file"
    validate_file $vdir/$obj || let errors++ failed=1
    let dones++
  else
    usage 11 "unexpected object: $obj"
  fi
  [[ $failed ]] && elist="$elist$obj "
done

echo -e "\n$errors failed out of $dones on $(date)" >> $summary
rm -rf *.database # cold cleanup

# report on stdout and possibly by mail
if [[ $errors -eq 0 ]] ; then
    msg='SUCCEEDED'
else
    msg="FAILED $errors/$dones ($elist)"
fi

if [[ $keep_archive ]]; then
    # keep a copy as archive with date of the last modification of the
    # file in its name, inside a year/month directory:
    sum_ts=$(stat --format %z $summary)
    sum_ts=${sum_ts//.*/}
    sum_date=${sum_ts// */}
    sum_year=${sum_ts/-*/}
    sum_month=${sum_ts#*-}
    sum_month=${sum_month/-*/}
    sub_dir=$sum_year/$sum_month
    sum_time=${sum_ts//* /}
    sum_file=SUMMARY.${sum_date}_${sum_time}

    archive_summary=$archive_dir/$sub_dir/$sum_file
    mkdir -p $archive_dir/$sub_dir
    cp -a $summary $archive_summary
    rm -f $last_summary
    # use relative symbolic link
    ln -s $sub_dir/$sum_file $last_summary
fi

# output difference to stdout if required
function do_diff()
{
  if [[ -f $previous_summary && -f $last_summary ]]
  then
    echo 'What changed since the previous validation:'
    diff $previous_summary $last_summary
    echo ''
  else
    echo 'Previous or last summary is missing, no diff...'
  fi
}

echo -e "\nvalidation $msg\n"
[[ $display_diff ]] && do_diff
cat $summary

if [[ $mail ]] ; then
  {
    [[ $display_diff ]] && do_diff
    cat $summary
  } | ${PIPS_MAIL:-Mail} -s "validation $msg" $mail
fi

# ensure okay to make
exit 0
