#! /bin/bash
# $Id$

script=${0/*\//}

rev='$Rev$'
rev=${rev/*: /}
rev=${rev/ */}

# DEFAULTS
# where is the validation?
vdir=${PIPS_VALIDDIR:-$PIPS_ROOT/../../valid}

# default running directory
rdir=.

# get default architecture and tpips/pips
arch=${PIPS_ARCH:-$($PIPS_ROOT/makes/arch.sh)}
tpips=$(type -p tpips)
pips=$(type -p pips)

# display help
function usage()
{
  local status=$1 msg=$2
  if [[ $msg ]] 
  then
    echo -e "message: $msg\n" >&2
  fi
  if [[ $status == 0 || $status == 1 ]]
  then
    echo -e \
      "$script [options] directories or files...\n" \
	"revision $rev\n" \
	"options:\n" \
	"  -h|--help: show some help\n" \
	"  -v|--verbose: be verbose (repeat for more, over 2 is debug)\n" \
	"  -p|--pips pips: use this 'pips' executable\n" \
	"     default '$pips'\n" \
	"  -t|--tpips tpips: use this 'tpips' executable\n" \
	"     default '$tpips'\n" \
	"  -m|--mail email: send mails (not a good idea?)\n" \
	"  -V|--valid dir: validation directory\n" \
	"     default '$vdir'\n" \
	"  -R|--run dir: running directory, default '.'\n" \
	"  -O|--out|--output dir: output directory, default '.'\n" \
	"arguments:\n" \
	"  validation directories (e.g. Semantics Regions ...)\n" \
	"  or files (e.g. Semantics/w14.f ...)\n"
  fi
  exit ${status:-1}
}

# verb level 'message to be shown...'
verb=0
function verb()
{
  local level=$1 msg=$2
  [[ $verb -ge $level ]] && {
      while let level-- ; do echo -n '#' ; done
      echo " $msg"
  } >&2
}

# checks
[[ $PIPS_ROOT ]] || usage 2 'PIPS_ROOT must be defined'
[[ -d $PIPS_ROOT ]] || usage 2 "no root directory: $PIPS_ROOT"

# get options
while [ "$1" ] ; do
  opt=$1
  case $opt in
      --) shift ; break ;; # end of option
      -*) shift ;; # one option, processed by next "case"
      *) break ;; # must be an argument, stop option processing...
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) let verb++ ;;
      -t|--tpips) tpips=$1 ; shift ;;
      -p|--pips) pips=$1 ; shift ;;
      -V|--valid) vdir=$1 ; shift ;;
      -R|--run) rdir=$1 ; shift ;;
      -O|--out|--output) odir=$1 ; shift ;;
      -m|--mail) mail="$mail $1" ; shift ;;
      --version) echo "$script revision $rev" ; exit 0 ;;
      *) usage 1 "unexpected option: $opt"
  esac
done

# option checks
[[ -d $vdir ]] || usage 3 "no validation directory: $vdir"
[[ -d $rdir ]] || usage 4 "no run directory: $rdir"

# result directory
[[ $odir ]] || odir=$rdir/validation_results.$$
[[ -d $odir ]] && usage 5 "output directory already exists: $odir"
mkdir $odir || usage 6 "error on mkdir $odir"

[[ -x $pips ]] || usage 7 "not executable: $pips"
[[ -x $tpips ]] || usage 8 "not executable: $tpips"

[[ -f properties.rc ]] && usage 17 "cannot run with local 'properties.rc'"
[[ -f pipsmake.rc ]] && usage 18 "cannot run with local 'pipsmake.rc'"

# go !
[[ $rdir != '.' ]] && pushd $rdir

# start summary
summary=$odir/SUMMARY

echo "validation for $@
in directory ${vdir}/
  $($PIPS_ROOT/makes/version.sh $vdir)
for $arch architecture
output in directory ${odir}/
with pips=$pips
$(${pips} -v)
and tpips=$tpips
$(${tpips} -v)
running in directory ${rdir}/
on $(hostname)
by $(whoami)
at $(date)
" >> $summary

# set default directories if necessary
if [[ ! $@ ]] ; then
  [[ -r $vdir/defaults ]] || usage 10 "cannot read $vdir/defaults"
  set - $(cat $vdir/defaults | grep -v '#')
fi

# validate a file
# returns whether it is a success
# appends errors to $summary
function validate_file()
{
  # file='/some/path/to/directory/file.f'
  local file=$1
  [[ -f $file ]] || usage 12 "no such source file: $file"
  verb 4 "validating $file..."

  # full_name='/some/path/to/directory/file'
  # name='file'
  # upper='FILE'
  local full_name=${file%.[cfF]}
  if [[ ! -d $full_name.result ]]
  then
    verb 1 "skipping $file: no matching result directory"
    return
  fi

  local name=${full_name/*\//}
  local upper=$(echo $name | tr '[a-z]' '[A-Z]')

  # dir='/some/path/to/directory'
  local dir=${full_name%/*}
  [[ -d $dir ]] || usage 13 "no such 'dir' directory: $dir"

  # fix path to help more or less relative validation?
  export PIPS_VALIDDIR=$vdir # re-export...
  export PIPS_SRCPATH=$dir # set path for tpips?
  export VDIR=$dir # set path for validation

  # updir='/some/path/to'
  local updir=${dir%/*}
  [[ -d $updir ]] || usage 14 "no such 'updir' directory: $updir"

  # prefix='directory/file'
  local prefix=${full_name/$updir\//}
  # output='directory_file'
  output=${prefix/\//_}
  verb 4 "output suffix is: $output"

  # out="$odir/directory_file"
  local out=$odir/$output

  # rel_file='directory/file.f'
  local rel_file=${file/$updir\//}
  # Just in case pips command are not found and all the following tests
  # fail, initialize the status:
  local status=-1

  if [[ -r $full_name.test ]] ; then
    verb 3 "$prefix.test method"
    verb 4 "$full_name.test"
    # ??? what about using default_test substitution?!
    $full_name.test 2> $out.err ; status=$?

  elif [[ -r $full_name.tpips ]] ; then
    verb 3 "$prefix.tpips method"
    verb 4 "$tpips $full_name.tpips"
    $tpips $full_name.tpips 2> $out.err ; status=$?

  elif [[ -r $full_name.tpips2 ]] ; then
    verb 3 "$prefix.tpips2 method (with stderr... bad idea)"
    verb 4 "$tpips $full_name.tpips"
    $tpips $full_name.tpips2 2>&1 ; status=$?

  elif [[ -r $dir/default_test ]] ; then
    verb 3 'default_test method'
    # perform some substitutions on the fly...
    sed -e "s/tested_file/${file//\//\\/}/g" \
	-e "s/tested_dir/${dir//\//\\/}/g" \
	-e "s/tested_name/$name/g" \
	-e "s/TESTED_NAME/$upper/g" \
	< $dir/default_test | /bin/sh 2> $out.err
    status=$?

  elif [[ -r $dir/default_tpips ]] ; then
    verb 3 'default_tpips method'
    verb 4 "FILE=$file WSPACE=$name ${tpips} $dir/default_tpips"
    FILE=$file WSPACE=$name \
	${tpips} $dir/default_tpips 2> $out.err ; status=$?

  else
    verb 3 'default method: Init/Display/Delete'
    {
      Delete $name 2> /dev/null 1>&2 # ignore delete failure...
      Init -f $file -d $name ; status=$?
      while read module ; do
	Display -m $module -w $name ; status=$?
      done < $name.database/modules
      Delete $name 2> /dev/null 1>&2 # ignore delete failure...
    } 2> $out.err
  fi > $out.tmp

  verb 4 "Status = $status"

  # filter out validation directory path for all output...
  # the if/fi output above cannot be piped directly because
  # it would hide the "status" variable setting in a subshell.
  sed -e "s/${VDIR//\//\\/}/\$VDIR/g" $out.tmp > $out.out && rm -f $out.tmp

  [[ -f core ]] && rm -f core # cleanup

  if [[ $status -eq 0 ]] ; then
    # generate diff and clean if okay
    local file_resdir=$full_name.result
    [[ -d $file_resdir ]] || usage 15 "no result directory: $file_resdir"

    local reference=$file_resdir/test.$arch
    [[ -f $reference ]] || reference=$file_resdir/test

    ${PIPS_DIFF:-diff -b -u} $reference $out.out > $out.diff

    if [[ -s $out.diff ]] ; then
      verb 2 "$rel_file: CHANGED"
      echo "changed: $rel_file" >> $summary
      cp $out.out $file_resdir/out
      status=1 # something was wrong...
    else
      verb 3 "$rel_file: SUCCEEDED" # ok!
      rm -f $out.*
    fi
  else
      verb 2 "$rel_file: FAILED"
      echo "failed: $rel_file" >> $summary
  fi

  return $status
}

# process directories (or possibly files)
dones=0
errors=0
elist=''

for obj ; do
  failed=
  if [ -d $vdir/$obj ] ; then
    verb 1 "considering '$obj' directory"
    for file in $vdir/$obj/*.[cfF] ; do
      verb 3 " - considering '${file//$vdir\//}' file"
      validate_file $file || let errors++ failed=1
      let dones++
    done
  elif [ -f $vdir/$obj ] ; then
    verb 1 "considering '$obj' file"
    validate_file $vdir/$obj || let errors++ failed=1
    let dones++
  else
    usage 11 "unexpected object: $obj"
  fi
  [[ $failed ]] && elist="$elist$obj "
done
echo -e "\n$errors failed out of $dones on $(date)" >> $summary
rm -rf *.database # cold cleanup

# report on stdout and possibly by mail
if [[ $errors -eq 0 ]] ; then
    msg='SUCCEEDED'
else
    msg="FAILED $errors/$dones ($elist)"
fi
echo -e "\nvalidation $msg\n" ; cat $summary
if [[ $mail ]]
then
    ${PIPS_MAIL:-Mail} -s "validation $msg" $mail < $summary
fi

# ensure okay to make
exit 0
