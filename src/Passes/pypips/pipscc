#!/usr/bin/env python
import pyps
import sys
import os
import shutil
import string
import tempfile
import pickle
import subprocess
from pyps import module

class object_code:
	"""preprocessed c source file descriptor"""
	def __init__(self,sourcefile,cppflags,cflags):
		self.cflags=cflags
		CPP=os.getenv("CPP","cpp")
		cmd=[CPP,"-U__GNUC__"]+cppflags+[sourcefile]
		print "# running",cmd
		sp=subprocess.Popen(cmd,stdout=subprocess.PIPE)
		sp.wait()
		self.code=sp.stdout.read()
		self.cname=sourcefile.replace(os.sep,"__")
	def set_cname(self,cname):
		self.cname=cname
		for op in self.cflags:
			if op == "-c":
				i=self.cflags.index(op)
				self.cflags[i+1]=self.cname
				break
	def dump_to_c(self,in_dir):
		self.set_cname(in_dir+os.sep+self.cname)
		cfile=file(self.cname,"w")
		cfile.write(self.code)
		cfile.close()

def ofile():
	for opt in sys.argv[1:]:
		if opt[0] == '-o':
			index=sys.argv.index(opt)
			return sys.argv[index+1]
	return ""

def cppflags():
	flags=[]
	for opt in sys.argv[1:]:
		if opt[0:2] == "-D" or opt[0:2] == "-I" :
			flags+=[opt]
			sys.argv.remove(opt)
	return flags

class pipscc:
	"""modular pips compiler front-end"""
	def __init__(self):
		"""create a pips compiler instance from sys.argv"""
		self.is_ld=True
		for opt in sys.argv[1:]:
			if opt == "-c":
				self.is_ld=False
				break

	def run(self):
		"""run the compilation"""
		if not self.is_ld:self.pipscpp() 
		else:self.pipsld() 

	def pipscpp(self):
		"""simulate the behavior of the c preprocessor"""
		# parse command line
		CPPFLAGS=cppflags()
		OUTFILE=ofile()
		print "# CPPFLAGS: ", CPPFLAGS
		# look for input file
		for opt in sys.argv[1:]:
			if opt[0] != '-':
				if not OUTFILE:
					OUTFILE=opt[0:-1]+"o"
				# generate internal representation of preprocessed code
				obj=object_code(opt,CPPFLAGS,sys.argv[1:])
				# serialize it
				newobj=file(OUTFILE,"w")
				pickle.dump(obj,newobj)
				newobj.close()
				print "# OBJ written: ", OUTFILE
		# that's all folks

	def gather_object_files(self):
		INPUT_FILES=[]
		for opt in sys.argv[1:]:
			if opt[0] != '-' and opt[-2:]==".o":
				INPUT_FILES+=[opt]
		return INPUT_FILES

	def gather_c_files(self):
		INPUT_FILES=[]
		for opt in sys.argv[1:]:
			if opt[0] != '-' and opt[-2:]==".c":
				INPUT_FILES+=[opt]
		return INPUT_FILES

	def unpickle(self,WDIR,files):
		"""generate a list of unpickled object files from files"""
		O_FILES=[]
		for ifile in files:
				obj=pickle.load(file(ifile,"r"))
				obj.dump_to_c(WDIR)
				obj.oname=ifile
				O_FILES+=[obj]
		return O_FILES

	def changes(self,ws):
		"""apply any change to the workspace, should be overloaded by the user"""
		map(module.display,ws)

	def get_wd(self):
		"""selects a working directory for pipscc"""
		WDIR=tempfile.mkdtemp("pipscc")
		print "# intermediate files generated in", WDIR
		return WDIR

	def get_workspace(self,c_files):
		return pyps.workspace(c_files)

	def compile(self,wdir,o_files):
		CC=os.getenv("CC","gcc")
		for obj in o_files:
			cmd=[CC]+obj.cflags+["-o",obj.oname]
			print "# running", cmd
			sp=subprocess.Popen(cmd)
			sp.wait()
		
		cmd=reduce(lambda x,y:x+" "+y,sys.argv[1:],CC)
		print "# running", cmd
		res=os.system(cmd)
		exitcode= (res >>8)& 0xFF
		if exitcode:
			shutil.rmtree(wdir)

	def pipsld(self):
		"""simulate c linker, all computation is done at link time"""
		WDIR=self.get_wd()
		
		# gather pickled input files
		INPUT_FILES=self.gather_object_files()
		# load pickled input files
		O_FILES=self.unpickle(WDIR,INPUT_FILES)
		C_FILES=map(lambda o:o.cname,O_FILES)
		print "# input files: ", reduce(lambda x,y:x+" "+y,C_FILES,"")
		
		# run pips with this informations
		print "# running pips"
		ws = self.get_workspace(C_FILES)
		# add extra operations 
		self.changes(ws)
		# commit changes
		ws.save(indir=WDIR)
		# the end for pips
		ws.quit()
		
		# now run the compiler
		self.compile(WDIR,O_FILES)

#
##
#

if __name__ == "__main__":
	thecompiler=pipscc()
	thecompiler.run()
