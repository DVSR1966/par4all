#!/usr/bin/env python
import pyps
import sys
import os
import shutil
import string
import tempfile
import pickle
import subprocess
from pyps import module

class object_code:
	"""preprocessed c source file descriptor"""
	def __init__(self,sourcefile,cppflags,cflags):
		self.cflags=cflags
		CPP=os.getenv("CPP","cpp")
		cmd=[CPP]+cppflags+[sourcefile]
		sp=subprocess.Popen(cmd,stdout=subprocess.PIPE)
		sp.wait()
		self.code=sp.stdout.read()
		self.cname=sourcefile.replace(os.sep,"__")
	def set_cname(self,cname):
		self.cname=cname
		for op in self.cflags:
			if op == "-c":
				i=self.cflags.index(op)
				self.cflags[i+1]=self.cname
				break
	def dump_to_c(self,in_dir):
		self.set_cname(in_dir+os.sep+self.cname)
		cfile=file(self.cname,"w")
		cfile.write(self.code)
		cfile.close()

def ofile():
	for opt in sys.argv[1:]:
		if opt[0] == '-o':
			index=sys.argv.index(opt)
			return sys.argv[index+1]
	return ""

def cppflags():
	flags=[]
	for opt in sys.argv[1:]:
		if opt[0:2] == "-D" or opt[0:2] == "-I" :
			flags+=[opt]
			sys.argv.remove(opt)
	return flags

def pipscpp():
	"""simulate the behavior of the c preprocessor"""
	# parse command line
	CPPFLAGS=cppflags()
	OUTFILE=ofile()
	print "# CPPFLAGS: ", CPPFLAGS
	# look for input file
	for opt in sys.argv[1:]:
		if opt[0] != '-':
			if not OUTFILE:
				OUTFILE=opt[0:-1]+"o"
			# generate internal representation of preprocessed code
			obj=object_code(opt,CPPFLAGS,sys.argv[1:])
			# serialize it
			newobj=file(OUTFILE,"w")
			pickle.dump(obj,newobj)
			newobj.close()
			print "# OBJ written: ", OUTFILE
	# that's all folks

def pipsld():
	# working repository
	WDIR=tempfile.mkdtemp("pipscc")
	print "# intermediate files generated in", WDIR
	
	# gather pickled input files
	INPUT_FILES=[]
	for opt in sys.argv[1:]:
		if opt[0] != '-' and opt[-2:]==".o":
			INPUT_FILES+=[opt]
	# load pickled input files
	C_FILES=[]
	O_FILES=[]
	for ifile in INPUT_FILES:
			obj=pickle.load(file(ifile,"r"))
			obj.dump_to_c(WDIR)
			obj.oname=ifile
			C_FILES+=[obj.cname]
			O_FILES+=[obj]

	print "# input files: ", reduce(lambda x,y:x+" "+y,C_FILES,"")
	
	# run pips with this informations
	print "# running pips"
	ws = pyps.workspace(C_FILES)
	# add extra operations there 
	#map(module.suppress_dead_code,ws)
	
	# commit changes
	ws.save(indir=WDIR)
	# the end for pips
	ws.quit()
	
	# now run the compiler
	CC=os.getenv("CC","gcc")
	for obj in O_FILES:
		cmd=[CC]+obj.cflags+["-o",obj.oname]
		print "# running", cmd
		sp=subprocess.Popen(cmd)
		sp.wait()
	
	cmd=reduce(lambda x,y:x+" "+y,sys.argv[1:],CC)
	print "# running", cmd
	res=os.system(cmd)
	exitcode= (res >>8)& 0xFF
	if exitcode:
		shutil.rmtree(WDIR)

def guess_mode():
	is_ld=True
	for opt in sys.argv[1:]:
		if opt == "-c" :
			is_ld=False
			break
	if is_ld:return pipsld
	else : return pipscpp




#
##
#

def pipscc():
	"""run pips as if it was cc: .c -> pips -> .c -> cc -> .o"""
	runner=guess_mode()
	runner()

#
##
#

if __name__ == "__main__":
	pipscc()
