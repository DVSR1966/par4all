#! /bin/bash

# Script to deal with Par4All repositories

PIPS_MODULES="linear newgen nlpmake pips validation"

script=${0/*\//}

function stop_on_error() {
    # Stop on error, since going on after errors may lead to havoc for
    # example by working on some incorrect branch and so on
    set -o errexit
}


# Display help
function usage()
{
  local status=$1 msg=$2
  if [[ $msg ]]
  then
    echo -e "message: $msg\n" >&2
  fi
  if [[ $status == 0 || $status == 1 ]]
  then
    echo -e \
      "$script [options] ...\n" \
	"options:\n" \
	"  -h|--help: display the usual help message\n" \
	"  -v|--verbose: be verbose (repeat for more, over 2 is debug)\n" \
	"  -u|--update-git-svn: update the PIPS git-svn gateways that are\n" \
	"     into \$P4A_TOP/CRI-git-svn\n" \
	"  -g|--recursive-git-svn ...: apply a git command to all the git\n" \
	"     working copies inside the current directory. If no argument is\n" \
	"     given, a git svn rebase is done\n" \
	"  -f|--fetch-remote-git: fetch the objects from the remote git\n" \
	"     repositories (the PIPS git-svn gateways and the polylib git)\n" \
	"  -p|--pull-remote-git: pull the objects from the remote git\n" \
	"     repositories into their respective branches\n"
  fi
  exit ${status:-1}
}

# verb level 'message to be shown...'
verb=0
function verb()
{
  local level=$1 msg=$2
  [[ $verb -ge $level ]] && {
      while let level-- ; do echo -n '#' ; done
      echo " $msg"
  } >&2
}


function enforce_P4A_TOP() {
    if [[ -z "$P4A_TOP" ]] ; then
	cat <<EOF
P4A_TOP variable is not set.
It should contain the directory name with the Par4All git repository
working copies in it:
- par4all
- par4all-priv
- CRI-git-svn/linear
- CRI-git-svn/newgen
- CRI-git-svn/nlpmake
- CRI-git-svn/pips
- CRI-git-svn/validation
EOF
	exit 1
    fi
    # Set variables pointing to various Par4All parts:
    P4A_CRI_GIT_SVN=$P4A_TOP/CRI-git-svn
    P4A_ROOT=$P4A_TOP/par4all
    P4A_PRIV_ROOT=$P4A_TOP/par4all-priv
}


# Get into $current_branch the current git branch we are in:
function get_current_git_branch() {
    branch=`git branch | grep '^*' | sed 's/* //'`
    if [[ "$branch" == "(no branch)" ]] ; then
	echo "We are not in a branch, exiting..."
	exit
    fi
    current_branch=$branch
}


function do_update_CRI_git_svn() {
  enforce_P4A_TOP
  cd $P4A_CRI_GIT_SVN
  # Execute again this script to do a recursive git svn rebase:
  $0 --recursive-git-svn
}


# Apply a git action on all the git copy found inside the current directory:
function do_recursive_git() {
    # If no argument is given, act as git svn rebase
    if [[ ! $@ ]] ; then
	actions="svn rebase"
    else
	actions=$@
    fi

    # Use -prune since for each .git encountered it is useless to dig into:
    git_dirs=`find . -name .git -prune`

    for g in $git_dirs; do
	d=`dirname $g`
	(
	    echo Entering directory $d:
	    cd $d
	    echo "    Action: git $actions"
	    git $actions
	)
	echo
    done
}


# Fetch into the par4all git all the parts from the remote git associated:
do_fetch_remote_git() {
    enforce_P4A_TOP
    stop_on_error
    cd $P4A_ROOT
    echo Assume the correct remotes are set in this par4all git copy:
    for i in $PIPS_MODULE; do
	echo Fetching CRI/$i...
	git fetch CRI/$i
    done
    echo Fetching polylib...
    git fetch polylib
}


# Pull into the par4all git all the parts from the remote git associated:
do_pull_remote_git() {
    enforce_P4A_TOP
    stop_on_error
    cd $P4A_ROOT
    # Get the current branch to come back into later:
    get_current_git_branch
    echo Assuming the correct remotes are set in this par4all git copy...
    for i in $PIPS_MODULE; do
	# First jump into the branch of this name that will receive the
	# pull.  The idea is to have the possibility for a central place
	# to be able to change things here against remote inputs.
	git checkout $i
	# Pull the master branch of the remote git. Use a subtree merge
	# strategy since the root directory of the remote git is relocated
	# in a subdirectory of the Par4All git:
	git pull --strategy=subtree CRI/$i master
    done
    # Same for the polylib:
    git checkout polylib
    git pull --strategy=subtree polylib master

    # Revert back into the branch we were at the beginning:
    git checkout $current_branch
}


# Get options:
while [ "$1" ] ; do
  opt=$1
  case $opt in
      --) shift ; break ;; # end of option
      -*) shift ;; # one option, processed by next "case"
      *) break ;; # must be an argument, stop option processing...
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) let verb++ ;;
      -u|--update-git-svn) update_git_svn=1 ;;
      -g|--recursive-git-svn) recursive_git_action=1 ;;
      -f|--fetch-remote-git) fetch_remote_git=1 ;;
      -p|--pull-remote-git) pull_remote_git=1 ;;
      # error
      *) usage 1 "unexpected option: $opt"
  esac
done

if (( $verb >= 2 )) ; then
    # Put shell tracing on:
    set -vx
fi

if [[ $update_git_svn ]]; then
    do_update_CRI_git_svn
fi

if [[ $recursive_git_action ]]; then
    recursive_git $@
fi

if [[ $fetch_remote_git ]]; then
    do_fetch_remote_git
fi

if [[ $pull_remote_git ]]; then
    do_pull_remote_git
fi

# Some Emacs stuff:
### Local Variables:
### mode: sh
### mode: flyspell
### ispell-local-dictionary: "american"
### End:
