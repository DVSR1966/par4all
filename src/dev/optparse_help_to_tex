#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# - Ronan Keryell <ronan.keryell@hpc-project.com>
#

'''
Transform the help generated by a Python program that uses optparse into TeX to be included in some Beamer presentations :-)
'''

import string, sys, os, re, optparse

import ply.lex as lex
import ply.yacc as yacc

verbose = True
verbose = False


def verbose_print(*list):
    if verbose:
        print list


# Declare the tokens:
tokens = (
    'Usage',
    'Options',
    'Option',
    'Group',
    'SubOption',
    'Text'
    )

# Capture from 'Usage:' up to just before 'Options:'
t_Usage = r'^Usage:(.|\n)*?(?=Options:)'

t_Options = r'(?<=\n)Options:\n'


# Match something beginning with '  -' up to 2 spaces:
def t_Option(t):
    r'(?<=\n)[ ][ ]-.*?(?=\s\s)'
    # Remove the leading and trailing spaces around
    t.value = str.strip(t.value)
    verbose_print(t)
    return t


# Match something beginning with '  ' without '-' up to the end of the line
def t_Group(t):
    r'(?<=\n)[ ][ ][^- ].*?:\n'
    # Remove the leading and trailing spaces around
    t.value = str.strip(t.value)
    verbose_print(t)
    return t


# A suboption begins with 4 spaces, a dash up to 2 spaces:
def t_SubOption(t):
    r'(?<=\n)[ ]{4}-.*?(?=\s\s)'
    # Remove the leading and trailing spaces around
    t.value = str.strip(t.value)
    verbose_print(t)
    return t


# Normal text is some thing else begining with 2 spaces
def t_Text(t):
    r'[ ]{2,}.*\n'
    # Remove the leading and trailing spaces around
    t.value = str.strip(t.value)
    verbose_print(t)
    return t


# For other characters, we store them as the current declaration:
def t_error(t):
    if verbose:
        print("Found character '%s'" % t.value[0])
    # Remove it from the input:
    t.lexer.skip(1)

# A string containing ignored characters (spaces and tabs)
t_ignore  = ''



"""The parser of the output optparse help"""

def p_optparse_help(p):
    'optparse_help : Usage options'
    p[0] = p[2]


def p_options(p):
    'options : Options option_list group_list'
    p[0] = slide_itemize("Options", p[2]) + p[3]


def p_option_list(p):
    '''option_list : option_list option
                   | empty'''
    if len(p) == 3:
        p[0] = p[1] + p[2]
    else:
        p[0] = ""


def p_option(p):
    'option : Option text_list'
    p[0] = beautified_item(p[1], p[2])


def p_group_list(p):
    '''group_list : group_list group
                  | empty'''
    if len(p) == 3:
        p[0] = p[1] + p[2]
    else:
        p[0] = ""


def p_group(p):
    'group : Group suboption_list'
    p[0] = slide_itemize(p[1], p[2])


def p_suboption_list(p):
    '''suboption_list : suboption_list suboption
                      | empty'''
    if len(p) == 3:
        p[0] = p[1] + p[2]
    else:
        p[0] = ""


def p_suboption(p):
    'suboption : SubOption text_list'
    p[0] = beautified_item(p[1], p[2])


def p_text_list(p):
    '''text_list : Text text_list
                 | Text'''
    if len(p) == 3:
        # Concatenate the texts
        p[0] = p[1] + " " + p[2]
    else:
        p[0] = p[1]


def p_empty(p):
    'empty :'
    pass


def LaTeX_protect(string):
    "Protect the LaTeX special characters"
    return re.sub(r'([\\&~#_%$])', r'\\\1', string)


def slide_itemize(title, content):
    """Make a trans environment with the content.
    Assume the content is already protected"""
    return '\\begin{trans}{' + LaTeX_protect(title) \
           + '}\n  \\begin{description}\n' \
           + content + '\n  \\end{description}\n\\end{trans}\n\n\n'


def beautified_item(item_title, content):
    "Make a '\item' of un itemize environment"
    return r'    \item[\texttt{' + LaTeX_protect(item_title) + r'}:] ' \
           + LaTeX_protect(content) + '\n'


def main():
    '''The function called when this program is executed by its own'''

    parser = optparse.OptionParser(description = __doc__,
                                   usage = "%prog [options] [<files>]")


    (options, args) = parser.parse_args()

    if len(args) == 0:
        # If no argument is given, use standard input:
        input = sys.stdin
    else:
        # else, the argument is the file name to use:
        input = open(args[0])

    # slurp all the file in a string:
    content = input.read()
    input.close()

    lexer = lex.lex()
    parser = yacc.yacc()
    print parser.parse(content)

if __name__ == "__main__":
    main()

# Some Emacs stuff:
### Local Variables:
### mode: python
### mode: flyspell
### ispell-local-dictionary: "american"
### tab-width: 4
### End:
