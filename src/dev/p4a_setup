#! /bin/bash
#
# Inspired from setup_pips.sh from Fabien Coelho and get-pips4u.sh from
# Sebastien Varrette <Sebastien.Varrette@uni.lu> and Serge Guelton
# <Serge.Guelton@telecom-bretagne.eu>
#
# Ronan.Keryell@hpc-project.com

# The P4A_MAKE_OPTS environment variable can be used to pass options to
# make, such as --jobs=8

# Stop on error, since going on after errors may lead to havoc
set -o errexit

# Display help
function usage()
{
  local status=$1 msg=$2
  if [[ $msg ]]
  then
    echo -e "message: $msg\n" >&2
  fi
  if [[ $status == 0 || $status == 1 ]]
  then
    echo -e \
      "$script [options] ...\n" \
	"options (displayed in a logical sequential order to apply):\n" \
	"  To speed up installation, you can skip already installed stuff:\n" \
	"  --skip-polylib: skip the PolyLib installation\n" \
	"  --skip-newgen: skip the NewGen installation\n" \
	"  --skip-linear: skip the Linear installation\n" \
	"  --skip-pips: skip the PIPS installation\n" \
	"  -v|--verbose: be verbose\n" \
	"  -h|--help: display this usage :-)"
  fi
  exit ${status:-1}
}

# Get options:
while [ "$1" ] ; do
  opt=$1
  case $opt in
      --) shift ; break ;; # end of option
      -*) shift ;; # one option, processed by next "case"
      #*) break ;; # must be an argument, stop option processing...
      *) usage 1 "Argument not understood..." ;;
  esac

  case $opt in
      -h|--help) usage 0 ;;
      -v|--verbose) verb=1 ;;
      # Could be clever, but KISS :-)
      # Not that this could be environment variable to skip these
      # compilations too:
      --skip-polylib) P4A_SKIP_POLYLIB=1 ;;
      --skip-newgen) P4A_SKIP_NEWGEN=1 ;;
      --skip-linear) P4A_SKIP_LINEAR=1 ;;
      --skip-pips) P4A_SKIP_PIPS=1 ;;
      # error
      *) usage 1 "unexpected option: $opt"
  esac
done

if [[ -n $verb ]]; then
    # Put shell tracing on:
    set -vx
fi

if [[ -z $P4A_ROOT ]]; then
    echo "You need to have \$P4A_ROOT defined to the Par4All top-level directory"
    exit
fi

# Where everything is built:
P4A_BUILD=$P4A_ROOT/build
# Where things are installed
P4A_INSTALL_PREFIX=$P4A_ROOT/run

P4A_ETC=$P4A_INSTALL_PREFIX/etc
mkdir -p $P4A_ETC

if test -z "$INSTALL_PREFIX" ; then
    # install prefix passed by --prefix to the configure script:
    INSTALL_PREFIX=$P4A_INSTALL_PREFIX
fi
mkdir -p $INSTALL_PREFIX

# Default flags for the configure script:
PIPS_CONFIGURE_COMMON_FLAGS=" --disable-static"

# Where to find PIPS/pips if not specified:
if [[ -z $P4A_PIPS_SRC ]]; then
    P4A_PIPS_SRC=$P4A_ROOT/packages/PIPS/pips
fi

# Where to find PIPS/nlpmake if not specified:
if [[ -z $P4A_NLPMAKE_SRC ]]; then
    P4A_NLPMAKE_SRC=$P4A_ROOT/packages/PIPS/nlpmake
fi


cd $P4A_ROOT

# Install Par4All scripts:
mkdir -p $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/dev/{p4a_git,p4a_setup,p4a_valgrind} $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/dev/p4a_git_lib.bash $P4A_ETC
cp $P4A_ROOT/src/postprocessor/p4a_recover_includes $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/validation/{p4a_validate,p4a_validation} $P4A_INSTALL_PREFIX/bin

# Stuff still lacking from PIPS install:
cp $P4A_PIPS_SRC/src/Scripts/validation/pips* $P4A_INSTALL_PREFIX/bin

# To have the validation running:
mkdir -p  $P4A_INSTALL_PREFIX/makes
cp $P4A_NLPMAKE_SRC/makes/{arch.sh,version.sh} $P4A_INSTALL_PREFIX/makes

PIPS_COMPONENTS="linear newgen pips"
#PIPS_DIR=$P4A_ROOT/packages/PIPS

# The config files to source later:
P4A_RC_SH=$P4A_ETC/par4all-rc.sh
P4A_RC_CSH=$P4A_ETC/par4all-rc.csh

echo
echo "### creating `basename $P4A_RC_SH` and `basename $P4A_RC_CSH`"
echo

mkdir -p  $P4A_ETC
cat <<EOF > $P4A_RC_SH
# Minimum Par4All rc file for sh-compatible shells

export P4A_ROOT=$P4A_ROOT

# default architecture
#export PIPS_ARCH=$PIPS_ARCH
# software roots
#export EXTERN_ROOT=$P4A_BUILD
#export NEWGEN_ROOT=$P4A_BUILD
#export NEWGEN_ROOT=$PIPS_DIR/newgen
unset NEWGEN_ROOT
#export LINEAR_ROOT=$P4A_BUILD
#export LINEAR_ROOT=$PIPS_DIR/linear
unset LINEAR_ROOT
#export PIPS_ROOT=$P4A_BUILD
#export PIPS_ROOT=$PIPS_DIR/pips
# Hack to have access to makefiles...
#export ROOT=$P4A_ROOT/packages/PIPS
# For pyps:
#export PIPS_NO_PYPS=1
#export PYTHONPATH=$P4A_BUILD/lib

#export INSTALL_DIR=$P4A_BUILD

# Mainly to avoid the non working libraries.make:
#unset WITH_DYNAMIC_LIBRARIES

# fix path
#PATH=$P4A_BUILD/bin:$P4A_BUILD/utils:\$PATH
PATH=\$PATH:\$P4A_ROOT/run/bin

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:\$P4A_ROOT/run/lib
export PKG_CONFIG_PATH=\$P4A_ROOT/run/lib/pkgconfig
# To fix...
export PYTHONPATH=\$P4A_ROOT/run/lib/python2.5/site-packages/pips


# Temporary place for P4A_accel
export P4A_ACCEL_DIR=\$P4A_ROOT/src/p4a_accel

# Some hack to have p4a_recover_includes working. Directory to move
# somewhere else later...
#export PIPS_CPP_FLAGS=" -I$P4A_ROOT/src/postprocessor/include "
#export PYTHONPATH=/usr/share/pyshared
EOF

# Find the Fortran compiler:
type -t gfortran > /dev/null && export PIPS_F77=gfortran
type -t g77 > /dev/null && export PIPS_F77=g77
if [ -n "$PIPS_F77" ]; then
    echo >> $P4A_RC_SH
    echo "# The Fortran compiler to use:" >> $P4A_RC_SH
    echo "export PIPS_F77=$PIPS_F77" >> $P4A_RC_SH
fi

# Generate also a config file for csh users:
$P4A_PIPS_SRC/src/Scripts/env/sh2csh.pl < $P4A_RC_SH > $P4A_RC_CSH


# Build the package of name $1 that is to be found into directory $2, with
# some $3 options to configure.

# If the P4A_<PACKAGE>_SRC environment variable is set, the its value
# represents the directory to be used to get the source package instead of
# $2.  Useful to compile PIPS components directly from the SVN for
# example.
function build_package() {
    local package=$1
    local dir=$2
    local options=$3
    (
	# Get the package name uppercased:
	local upper_package=${package^^}
	# If the P4A_SKIP_<PACKAGE> is defined, skip its installation:
	eval "local skip_package=\$P4A_SKIP_${upper_package}"
	if [[ -n $skip_package ]]; then
	    echo "Skipping the '$package' package..."
	    echo
	    return
	fi

	# Find the value of a P4A_<PACKAGE>_SRC variable:
	eval "local src_dir=\$P4A_${upper_package}_SRC"
	if [[ -n $src_dir ]]; then
	    # Overide the source origin from the given environment variable:
	    dir=$src_dir
	fi

	echo "Installing the '$package' package from '$dir':"
	echo
	cd $dir
	dir=`pwd`

	# There are lacking files in the PolyLib that autoreconf do not
	# want to create :-(
	if [[ $package == polylib ]]; then
	    touch NEWS README AUTHORS ChangeLog
	fi
	autoreconf --install

	mkdir -p $P4A_BUILD/$package
	cd $P4A_BUILD/$package
	$dir/configure ${PIPS_CONFIGURE_COMMON_FLAGS} $options
	make $P4A_MAKE_OPTS
	make $P4A_MAKE_OPTS install
    )
}


# Add a potentially missing link to the PIPS make infrastructure for a
# given component:
function add_link_to_make_infrastructure () {
    local package=$1
    ln -s -f ../nlpmake/makes $P4A_ROOT/packages/PIPS/$package/makes
}

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS}
--prefix=${INSTALL_PREFIX}"

build_package polylib packages/polylib

add_link_to_make_infrastructure newgen
build_package newgen packages/PIPS/newgen

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS} PKG_CONFIG_PATH=${INSTALL_PREFIX}/lib/pkgconfig:$PKG_CONFIG_PATH"

add_link_to_make_infrastructure linear
build_package linear packages/PIPS/linear

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS} ${PIPS_CONFIG} PATH=${INSTALL_PREFIX}/bin:$PATH "

add_link_to_make_infrastructure pips
#build_package pips packages/PIPS/pips "--enable-doc --enable-gpips --enable-tpips --enable-pyps --enable-hpfc"
#build_package pips packages/PIPS/pips "--enable-tpips --enable-pyps"
build_package pips packages/PIPS/pips "--enable-tpips --enable-pyps --enable-hpfc"

# that's all folks
cat << EOF
============================================
Par4All is ready
everything got installed in
$INSTALL_PREFIX

According to your shell religion, you should include
$P4A_RC_SH
(for bash, dash, sh...) or
$P4A_RC_CSH
(tcsh, csh...).
============================================
EOF

exit 0
