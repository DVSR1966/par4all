#! /bin/bash -vx
#
# Inspired from setup_pips.sh from Fabien Coelho and get-pips4u.sh from
# Sebastien Varrette <Sebastien.Varrette@uni.lu> and Serge Guelton
# <Serge.Guelton@telecom-bretagne.eu>
#
# Ronan.Keryell@hpc-project.com

# Stop on error, since going on after errors may lead to havoc
set -o errexit

if [[ -z $P4A_ROOT ]]; then
    echo "You need to have \$P4A_ROOT defined to the Par4All top-level directory"
    exit
fi

# Where everything is built:
P4A_BUILD=$P4A_ROOT/build
# Where things are installed
P4A_INSTALL_PREFIX=$P4A_ROOT/run

P4A_ETC=$P4A_INSTALL_PREFIX/etc
mkdir -p $P4A_ETC

if test -z "$INSTALL_PREFIX" ; then
    # install prefix passed by --prefix to the configure script
    INSTALL_PREFIX=$P4A_INSTALL_PREFIX
fi
mkdir -p $INSTALL_PREFIX

# default flags for the configure script
PIPS_CONFIGURE_COMMON_FLAGS=" --disable-static"

cd $P4A_ROOT

# Install Par4All scripts:
mkdir -p $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/dev/{p4a_git,p4a_setup,p4a_valgrind} $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/dev/p4a_git_lib.bash $P4A_ETC
cp $P4A_ROOT/src/postprocessor/p4a_recover_includes $P4A_INSTALL_PREFIX/bin
cp $P4A_ROOT/src/validation/p4a_validate $P4A_INSTALL_PREFIX/bin

# Stuff still lacking from PIPS install:
cp $P4A_ROOT/packages/PIPS/pips/src/Scripts/validation/pips* $P4A_INSTALL_PREFIX/bin
# To have the validation running:
mkdir -p  $P4A_INSTALL_PREFIX/makes
cp $P4A_ROOT/packages/PIPS/nlpmake/makes/{arch.sh,version.sh} $P4A_INSTALL_PREFIX/makes

PIPS_COMPONENTS="linear newgen pips"
PIPS_DIR=$P4A_ROOT/packages/PIPS

# The config files to source later:
P4A_RC_SH=$P4A_ETC/par4all-rc.sh
P4A_RC_CSH=$P4A_ETC/par4all-rc.csh

echo
echo "### creating `basename $P4A_RC_SH`"
mkdir -p  $P4A_ETC
cat <<EOF > $P4A_RC_SH
# Minimum Par4All rc file for sh-compatible shells

export P4A_ROOT=$P4A_ROOT

# default architecture
#export PIPS_ARCH=$PIPS_ARCH
# software roots
#export EXTERN_ROOT=$P4A_BUILD
#export NEWGEN_ROOT=$P4A_BUILD
#export NEWGEN_ROOT=$PIPS_DIR/newgen
unset NEWGEN_ROOT
#export LINEAR_ROOT=$P4A_BUILD
#export LINEAR_ROOT=$PIPS_DIR/linear
unset LINEAR_ROOT
#export PIPS_ROOT=$P4A_BUILD
export PIPS_ROOT=$PIPS_DIR/pips
# Hack to have access to makefiles...
#export ROOT=$P4A_ROOT/packages/PIPS
# For pyps:
#export PIPS_NO_PYPS=1
#export PYTHONPATH=$P4A_BUILD/lib

#export INSTALL_DIR=$P4A_BUILD

# Mainly to avoid the non working libraries.make:
#unset WITH_DYNAMIC_LIBRARIES

# fix path
#PATH=$P4A_BUILD/bin:$P4A_BUILD/utils:\$PATH
PATH=\$PATH:\$P4A_ROOT/run/bin

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:\$P4A_ROOT/run/lib
export PKG_CONFIG_PATH=\$P4A_ROOT/run/lib/pkgconfig
# To fix...
export PYTHONPATH=\$P4A_ROOT/run/lib/python2.5/site-packages/pips


# Some hack to have p4a_recover_includes working. Directory to move
# somewhere else later...
#export PIPS_CPP_FLAGS=" -I$P4A_ROOT/src/postprocessor/include "
#export PYTHONPATH=/usr/share/pyshared
EOF

# Find the Fortran compiler:
type gfortran && export PIPS_F77=gfortran
type g77 && export PIPS_F77=g77
if [ -n "$PIPS_F77" ]; then
    echo >> $P4A_RC_SH
    echo "# The Fortran compiler to use:" >> $P4A_RC_SH
    echo "export PIPS_F77=$PIPS_F77" >> $P4A_RC_SH
fi

# Generate also a config file for csh users:
$PIPS_DIR/pips/src/Scripts/env/sh2csh.pl < $P4A_RC_SH > $P4A_RC_CSH


# Build the package of name $1 that is to be found into directory $2, with
# some $3 options to configure:
function build_package() {
    local package=$1
    local dir=$2
    local options=$3
    (
	cd $dir
	dir=`pwd`
	# There are lacking files in the Polylib that autoreconf do not
	# want to create :-(
	touch NEWS README AUTHORS ChangeLog
	autoreconf --install
	mkdir -p $P4A_BUILD/$package
	cd $P4A_BUILD/$package
	$dir/configure ${PIPS_CONFIGURE_COMMON_FLAGS} $options
	make
	make install
    )
}

# Add a potentially missing link to the PIPS make infrastructure for a
# given component:
function add_link_to_make_infrastructure () {
    local package=$1
    ln -s -f ../nlpmake/makes $P4A_ROOT/packages/PIPS/$package/makes
}

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS} --prefix=${INSTALL_PREFIX}"

build_package polylib packages/polylib

add_link_to_make_infrastructure newgen
build_package newgen packages/PIPS/newgen

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS} PKG_CONFIG_PATH=${INSTALL_PREFIX}/lib/pkgconfig:$PKG_CONFIG_PATH"

add_link_to_make_infrastructure linear
build_package linear packages/PIPS/linear

PIPS_CONFIGURE_COMMON_FLAGS="${PIPS_CONFIGURE_COMMON_FLAGS} ${PIPS_CONFIG} PATH=${INSTALL_PREFIX}/bin:$PATH "

add_link_to_make_infrastructure pips
#build_package pips packages/PIPS/pips "--enable-doc --enable-gpips --enable-tpips --enable-pyps --enable-hpfc"
build_package pips packages/PIPS/pips "--enable-tpips --enable-pyps"

# that's all folks
cat << EOF
============================================
Par4All is ready
everything got installed in $INSTALL_PREFIX

According to your shell religion, you should include $P4A_RC_SH (bash,
dash, sh...) or $P4A_RC_CSH (tcsh, csh...).
============================================
EOF

exit 0
