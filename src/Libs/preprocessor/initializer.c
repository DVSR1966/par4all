/* stdio is necessary for misc.h */
#include <stdio.h>
#include <string.h>

#include "genC.h"
#include "misc.h"

#include "properties.h"

#include "ri.h"
#include "ri-util.h"

#include "database.h"
#include "pipsdbm.h"

#include "resources.h"
#include "phases.h"

/* there is no real rule to produce source or user files; it was introduced
 * by Remi to deal with source and user files as with any other kind
 * of resources
 */
bool initializer(module_name)
string module_name;
{
    bool success_p = FALSE;

    if(!get_bool_property("GENERATE_MISSING_SOURCE_FILES")) {
	/* FI: strdup a cause de problemes lies aux varargs */
	user_error("initializer", "no source file for %s "
		   "(%s might be an ENTRY point)\n",
		   strdup(module_name), strdup(module_name), 0);
	success_p = FALSE;
    }
    else {
	entity m = local_name_to_top_level_entity(module_name);
	string file_name = string_undefined; /* in the workspace */
	string relative_file_name = string_undefined; /* relative to the current directory */
	FILE * f;
	functional t = functional_undefined;
	char nv = 'A';
	list pl = list_undefined;

	user_warning("initializer", "no source file for %s: synthetic code is generated\n",
		   strdup(module_name));
	if(entity_undefined_p(m)) {
	    pips_error("initializer", "No entity defined for module %s"
		       " although it must have been encountered at a call site\n");
	}

	/* pips' current directory is just above the workspace */
	file_name = strdup(concatenate(module_name, ".f", NULL));
	file_name = strlower(file_name, file_name);
	relative_file_name = strdup(concatenate(db_get_current_workspace_name(), ".database", "/",
				       file_name, NULL));
	f = safe_fopen(relative_file_name, "w");

	/* put a warning header */
	(void) fprintf(f, 
		       "!     This module was automatically generated by PIPS and should\n"
		       "!     be updated by the user with READ and WRITE effects on\n"
		       "!     formal parameters to be useful\n"
		       "!\n");

	/* Get the functional type */
	if(type_undefined_p(entity_type(m))
		    || !type_functional_p(entity_type(m))) {
	    user_warning("initializer", "Entity %s is neither a function nor a subroutine: "
		       "entity type is %s.\n"
		       "It should be called somewhere in your code and be of type functional.\n"
		       "Maybe there is a name conflict with a COMMON or an ENTRY point?\n",
		       entity_name(m), type_to_string(entity_type(m)));
	    safe_fclose(f, relative_file_name);
	    free(file_name);
	    free(relative_file_name);
	    success_p = FALSE;
	}

	else {
	    string ts = string_undefined; /* Fortran type for result */
	    string nature = string_undefined; /* Function or subroutine? */
	    string sep = string_undefined; /* Separator between result type and FUNCTION */
		
	    t = type_functional(entity_type(m));

	    /* is it a subroutine or a function? */
	    if(!type_void_p(functional_result(t))) {
		type tf = functional_result(t);

		pips_assert("initializer", type_variable_p(tf));
		ts = basic_to_string(variable_basic(type_variable(tf)));
		nature = "FUNCTION";
		sep = " ";
	    }
	    else {
		ts = "";
		sep = "";
		nature = "SUBROUTINE";
	    }
	    (void) fprintf(f, "      %s%s%s %s", ts, sep, nature, module_name);

	    /* generate the formal parameter list */
	    for(pl = functional_parameters(t); !ENDP(pl); POP(pl)) {
		(void) fprintf(f, "%s%c", pl==functional_parameters(t)? "(":", ", nv);
		nv ++;
	    }
	    (void) fprintf(f, "%s\n", ENDP(functional_parameters(t))? "":")");

	    /* Generate the formal parameter declarations */
	    nv = 'A';
	    MAP(PARAMETER, p, {
		type tp = parameter_type(p);

		pips_assert("initializer", type_variable_p(tp));

		if(basic_overloaded_p(variable_basic(type_variable(tp)))) {
		    (void) fprintf(f, "C     Unable to determine the type of parameter %c\n", nv);
		    (void) fprintf(f, "C     %s %c\n", 
				   basic_to_string(variable_basic(type_variable(tp))),
				   nv);
		}
		else {
		    (void) fprintf(f, "      %s %c\n", 
				   basic_to_string(variable_basic(type_variable(tp))),
				   nv);
		}
		nv++;
	    }, functional_parameters(t));

	    (void) fprintf(f, "      END\n");
	    safe_fclose(f, relative_file_name);

	    /* Update $ALL, the module list:
	     * In fact, ALL is evaluated dynamically using DBR_SOURCE_FILE.
	     * Do not do anything!
	     */

	    /* Add the new file as a file resource */
	    user_log("Registering synthesized file %s\n", file_name);
	    DB_PUT_FILE_RESOURCE(DBR_SOURCE_FILE, strdup(module_name), file_name);
	    success_p = TRUE;
	    free(relative_file_name);
	}
    }

    return success_p;
}
