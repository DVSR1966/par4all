/* $Id$
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "genC.h"
#include "linear.h"
#include "misc.h"
#include "ri.h"
#include "ri-util.h"
#include "transformations.h"

#include "c_syntax.h"
#include "cyacc.h"

#include "c_parser_private.h"

#include "resources.h"
#include "database.h"
#include "makefile.h"

#include "pipsdbm.h"
#include "pipsmake.h"

string compilation_unit_name; 

list CalledModules = NIL; 

statement ModuleStatement = statement_undefined;
  
stack ContextStack = stack_undefined;
stack FunctionStack = stack_undefined;
stack FormalStack = stack_undefined;
stack OffsetStack = stack_undefined;
stack StructNameStack = stack_undefined;

/* Global counter */
int loop_counter = 1; 
int derived_counter = 1; 
 
// to store the mapping between the entity and its type stack

static hash_table entity_to_type_stack_table = hash_table_undefined;

void init_entity_type_storage_table()
{
  entity_to_type_stack_table = hash_table_make(hash_pointer,0);
  //put_stack_storage_table("test","T");
}

void put_to_entity_type_stack_table(entity key, stack value)
{
  hash_put(entity_to_type_stack_table,(char *) key,(void *) value);
}

stack get_from_entity_type_stack_table(entity key)
{
  return ((stack) hash_get(entity_to_type_stack_table, key));
}

void reset_entity_type_stack_table()
{
  hash_table_free(entity_to_type_stack_table);
  entity_to_type_stack_table = hash_table_undefined;
}

hash_table keyword_typedef_table = hash_table_undefined;

void init_keyword_typedef_table()
{
  keyword_typedef_table = hash_table_make(hash_string,0);
  hash_put(keyword_typedef_table,"auto", (char *) TK_AUTO);
  hash_put(keyword_typedef_table,"break", (char *) TK_BREAK);
  hash_put(keyword_typedef_table,"case", (char *) TK_CASE);
  hash_put(keyword_typedef_table,"char", (char *) TK_CHAR);
  hash_put(keyword_typedef_table,"const", (char *) TK_CONST);
  hash_put(keyword_typedef_table,"continue", (char *) TK_CONTINUE);
  hash_put(keyword_typedef_table,"default", (char *) TK_DEFAULT);
  hash_put(keyword_typedef_table,"do", (char *) TK_DO);
  hash_put(keyword_typedef_table,"double", (char *) TK_DOUBLE);
  hash_put(keyword_typedef_table,"else", (char *) TK_ELSE);
  hash_put(keyword_typedef_table,"enum", (char *) TK_ENUM);
  hash_put(keyword_typedef_table,"extern", (char *) TK_EXTERN);
  hash_put(keyword_typedef_table,"float", (char *) TK_FLOAT);
  hash_put(keyword_typedef_table,"for", (char *) TK_FOR);
  hash_put(keyword_typedef_table,"goto", (char *) TK_GOTO);
  hash_put(keyword_typedef_table,"if", (char *) TK_IF);
  hash_put(keyword_typedef_table,"inline", (char *) TK_INLINE);
  hash_put(keyword_typedef_table,"int", (char *) TK_INT);
  hash_put(keyword_typedef_table,"long", (char *) TK_LONG);
  hash_put(keyword_typedef_table,"register", (char *) TK_REGISTER);
  hash_put(keyword_typedef_table,"restrict", (char *) TK_RESTRICT);
  hash_put(keyword_typedef_table,"return", (char *) TK_RETURN);
  hash_put(keyword_typedef_table,"short", (char *) TK_SHORT);
  hash_put(keyword_typedef_table,"signed", (char *) TK_SIGNED);
  hash_put(keyword_typedef_table,"sizeof", (char *) TK_SIZEOF);
  hash_put(keyword_typedef_table,"static", (char *) TK_STATIC);
  hash_put(keyword_typedef_table,"struct", (char *) TK_STRUCT);
  hash_put(keyword_typedef_table,"switch", (char *) TK_SWITCH);
  hash_put(keyword_typedef_table,"typedef", (char *) TK_TYPEDEF);
  hash_put(keyword_typedef_table,"union", (char *) TK_UNION);
  hash_put(keyword_typedef_table,"unsigned", (char *) TK_UNSIGNED);
  hash_put(keyword_typedef_table,"void", (char *) TK_VOID);
  hash_put(keyword_typedef_table,"volatile", (char *) TK_VOLATILE);
  hash_put(keyword_typedef_table,"while", (char *) TK_WHILE);

  /* GNU predefined type(s), expecting no conflict with user named type */

  hash_put(keyword_typedef_table,"__builtin_va_list", (char *) TK_NAMED_TYPE);

  /* typedef names are added lately */
}

void reset_keyword_typedef_table()
{
  hash_table_free(keyword_typedef_table);
}

/* This function checks if s is a C keyword/typedef name or not by using
   the hash table keyword_typedef_table.
   It returns an integer number corresponding to the keyword. 
   It returns 0 if s is not a keyword/typedef name */
intptr_t
is_c_keyword_typedef(char * s)
{
  intptr_t i = (intptr_t) hash_get(keyword_typedef_table,s);
  return ((char *) i == HASH_UNDEFINED_VALUE) ? 0: i;
}

/* parsing function generated by Bison, from cyacc.y*/
extern void c_parse();

void CParserError(char *msg)
{
  /* Reset the parser global variables ?*/

  pips_debug(4,"Reset current module entity %s\n",get_current_module_name());
  reset_current_module_entity();

  reset_entity_type_stack_table();

  /* Stacks are not allocated yet when dealing with external
     declarations. I assume that all stacks are declared
     simultaneously, hence a single test before freeing. */
  if(!stack_undefined_p(SwitchGotoStack)) {
    stack_free(&SwitchGotoStack);
    stack_free(&SwitchControllerStack);
    stack_free(&LoopStack);
    stack_free(&BlockStack);  
    /* Reset them to stack_undefined_p instead of STACK_NULL */
    SwitchGotoStack = stack_undefined;
    SwitchControllerStack = stack_undefined;
    LoopStack = stack_undefined;
    BlockStack = stack_undefined;
  }
  
  reset_current_C_line_number();
  /* get rid of all collected comments */
  reset_C_comment(TRUE);

  pips_user_warning("Recovery from C parser failure not (fully) implemented yet.\n"
		    "C parser is likely to fail later if re-used.\n");
  pips_user_error(msg);
  debug_off();
}

static bool actual_c_parser(string module_name, string dbr_file, bool is_compilation_unit_parser)
{
    string dir = db_get_current_workspace_directory();
    string file_name = 
      strdup(concatenate(dir, "/", 
		     db_get_file_resource(dbr_file,module_name,TRUE), NULL));
    entity built_in_ent = entity_undefined;

    free(dir);

    if (is_compilation_unit_parser)
      {
	compilation_unit_name = module_name;
	init_keyword_typedef_table();
      }
    else
      {
	compilation_unit_name = compilation_unit_of_module(module_name);
	keyword_typedef_table = (hash_table) db_get_memory_resource(DBR_DECLARATIONS,compilation_unit_name,TRUE); 
      }

    ContextStack = stack_make(c_parser_context_domain,0,0);
    FunctionStack = stack_make(entity_domain,0,0);
    FormalStack = stack_make(basic_domain,0,0);
    OffsetStack = stack_make(basic_domain,0,0);
    StructNameStack = stack_make(code_domain,0,0);
    
    loop_counter = 1; 
    derived_counter = 1;
    CalledModules = NIL;
    
    debug_on("C_SYNTAX_DEBUG_LEVEL");
 
    /* FI: not clean, but useful for debugging statement */
    ifdebug(1)
      is_fortran = FALSE;

    /* Predefined type(s): __builtin_va_list */
    built_in_ent = find_or_create_entity(strdup(concatenate(compilation_unit_name,
					    TYPEDEF_PREFIX,"__builtin_va_list",NULL)));
    if(storage_undefined_p(entity_storage(built_in_ent))) {
      entity_storage(built_in_ent) = make_storage_rom();
      /* Let's lie about the real type */
      entity_type(built_in_ent) = make_type(is_type_variable,
					    make_variable(make_basic_int(DEFAULT_INTEGER_TYPE_SIZE),
							  NIL, NIL));
      entity_initial(built_in_ent) = make_value_unknown();
    }

    if (compilation_unit_p(module_name))
      {
	/* Special case, set the compilation unit as the current module */
	MakeCurrentCompilationUnitEntity(module_name);
	/* I do not know to put this where to avoid repeated creations*/
	MakeTopLevelEntity(); 
      }

    /* discard_C_comment(); */
    set_current_C_line_number();
    init_C_comment();

    /* yacc parser is called */
    c_in = safe_fopen(file_name, "r");

    init_entity_type_storage_table();
    c_parse();
        
    safe_fclose(c_in, file_name);

    pips_assert("Module statement is consistent",statement_consistent_p(ModuleStatement));

    ifdebug(2)
      {
	pips_debug(2,"Module statement: \n");
	print_statement(ModuleStatement);
	pips_debug(2,"and declarations: ");
	print_entities(statement_declarations(ModuleStatement));
	if(!compilation_unit_p(module_name))
	  pips_assert("Variables are declared once",
		      gen_once_p(statement_declarations(ModuleStatement)));
	printf("\nList of callees:\n");
	MAP(STRING,s,
	{
	  printf("\t%s\n",s);
	},CalledModules);
      }  
       
    if (compilation_unit_p(module_name))
      {
	ResetCurrentCompilationUnitEntity(is_compilation_unit_parser);	
      }
  
    if (is_compilation_unit_parser)
      {
	DB_PUT_MEMORY_RESOURCE(DBR_DECLARATIONS, 
			       module_name, 
			       (void *) keyword_typedef_table);   
      }
    else 
      {
	DB_PUT_MEMORY_RESOURCE(DBR_PARSED_CODE, 
			       module_name, 
			       (char *) ModuleStatement);
	DB_PUT_MEMORY_RESOURCE(DBR_CALLEES, 
			       module_name, 
			       (char *) make_callees(CalledModules));
      }

    free(file_name);
    file_name = NULL;
    reset_current_C_line_number();
    reset_C_comment(compilation_unit_p(module_name));
    /*  reset_keyword_typedef_table();*/
    stack_free(&ContextStack);
    stack_free(&FunctionStack);
    stack_free(&FormalStack);
    stack_free(&OffsetStack);
    stack_free(&StructNameStack);
    debug_off();
    return TRUE;
}

bool c_parser(string module_name)
{
  /* When the compilation_unit is parsed, it is parsed a second time
     and multiple declarations are certain to happen. */
   return actual_c_parser(module_name,DBR_C_SOURCE_FILE,FALSE);
}

bool compilation_unit_parser(string module_name)
{
  return actual_c_parser(module_name,DBR_C_SOURCE_FILE,TRUE);
}
