/*
 * init.c
 *
 * Fabien Coelho, June 1993
 *
 * in this file there are functions to generate the 
 * run-time resolution parameters.
 *
 * SCCS stuff:
 * $RCSfile: inits.c,v $ ($Date: 1994/04/11 11:51:45 $, ) version $Revision$,
 * got on %D%, %T%
 * $Id$
 *
 */

#include <stdio.h>
extern int fprintf();

#include "genC.h"
#include "ri.h"
#include "hpf.h"

#include "misc.h"
#include "ri-util.h"
#include "hpfc.h"
#include "defines-local.h"

/*
 * create_parameters_h
 *
 * to be called after the declaration_with_overlaps() call.
 */
void create_parameters_h(file)
FILE* file;
{
    bool
	firstline = TRUE;
    
    fprintf(file, "c\nc file parameters.h\nc\n");
    fprintf(file, "c this file has been automatically generated\n");
    fprintf(file, "c by the hpf-compiler\nc\n");
    fprintf(file, "c type declarations\nc\n");
    fprintf(file, "      integer\n");
    fprintf(file, "     $     REALNBOFARRAYS,\n");
    fprintf(file, "     $     REALNBOFTEMPLATES,\n");
    fprintf(file, "     $     REALNBOFPROCESSORS,\n");
    fprintf(file, "     $     REALMAXSIZEOFPROCS\n\n");

    fprintf(file, "c\nc parameters\nc\n");

    fprintf(file, "      parameter(REALNBOFARRAYS = %d)\n", 
	    gen_length(distributedarrays));
    fprintf(file, "      parameter(REALNBOFTEMPLATES = %d)\n", 
	    gen_length(templates));
    fprintf(file, "      parameter(REALNBOFPROCESSORS = %d)\n", 
	    gen_length(processors));
    fprintf(file, "      parameter(REALMAXSIZEOFPROCS = %d)\n", 
	    max_size_of_processors());

    fprintf(file, "c\nc dimensions\nc\n");
    fprintf(file, "      integer\n");
    
    firstline = TRUE;

    MAPL(ce,
     {
	 entity
	     array = ENTITY(CAR(ce));
	 entity
	     newarray = (entity) GET_ENTITY_MAPPING(oldtonewnodevar, array);
	 int
	     i = 1;

	 for (i=1 ; i<=NumberOfDimension(newarray) ; i++)
	 {
	     fprintf(file, 
		     (firstline)?("     $     %s, %s"):(",\n     $     %s, %s"), 
		     bound_parameter_name(newarray, LOWER, i),
		     bound_parameter_name(newarray, UPPER, i));
	     firstline = FALSE;
	 }
     },
	 distributedarrays);

    fprintf(file, "\nc\nc bounds values\nc\n");
    
    MAPL(ce,
     {
	 entity
	     array = ENTITY(CAR(ce));
	 entity
	     newarray = (entity) GET_ENTITY_MAPPING(oldtonewnodevar, array);
	 int
	     i = 1;

	 for (i=1 ; i<=NumberOfDimension(newarray) ; i++)
	 {
	     dimension
		 d = FindIthDimension(newarray, i);

	     fprintf(file, 
		     "      parameter(%s = %d)\n      parameter(%s = %d)\n",
		     bound_parameter_name(newarray, LOWER, i),
		     HpfcExpressionToInt(dimension_lower(d)),
		     bound_parameter_name(newarray, UPPER, i),
		     HpfcExpressionToInt(dimension_upper(d)));
	 }
     },
	 distributedarrays);

    fprintf(file, "c\nc end of automatically generated file\nc\n");
}

/*
 * max_size_of_processors
 */
int max_size_of_processors()
{
    int 
	current_max = 1;

    MAPL(ce, 
     {
	 entity
	     e = ENTITY(CAR(ce));
	 variable 
	     a;
	 
	 pips_assert("max_size_of_processors", type_variable_p(entity_type(e)));
	 a = type_variable(entity_type(e));

	 current_max = max(current_max,
			   NumberOfElements(variable_dimensions(a)));
     }, 
	 processors);

    return(current_max);
}

/*
 * create_init_common_param
 */
void create_init_common_param(file)
FILE* file;
{

    fprintf(file, "c\nc HPFC_INIT_COMMON_PARAM\nc\n");
    fprintf(file, "c this file has been automatically generated by the hpf-compiler\nc\n");

    fprintf(file, "      subroutine HPFC_INIT_COMMON_PARAM()\n");
    fprintf(file, "      include 'hpfc_parameters.h'\n");
    fprintf(file, "      include 'hpfc_param.h'\n");

    /*
     * Arrays
     */
    fprintf(file, "c\nc Arrays Initializations\nc\n");

    MAPL(ce,
     {
	 entity
	     array = ENTITY(CAR(ce));
	 int an = (int) GET_ENTITY_MAPPING(hpfnumber, array);
	 int nd  = NumberOfDimension(array);
	 align
	     al = (align) GET_ENTITY_MAPPING(hpfalign, array);
	 entity
	     template = align_template(al);
	 int tn = (int) GET_ENTITY_MAPPING(hpfnumber, template);
	 distribute
	     di = (distribute) GET_ENTITY_MAPPING(hpfdistribute, template);
	 int i;
	 
	 fprintf(file, "c\nc initializing array %s, number %d\nc\n",
		 entity_local_name(array), an);

	 /*
	  * NODIMA: Number Of  DIMensions of an Array
	  * ATOT: Array TO Template
	  */
	 fprintf(file, "      NODIMA(%d) = %d\n", an, nd);
	 fprintf(file, "      ATOT(%d) = %d\n", an, tn);
	 
	 /*
	  * RANGEA: lower, upper, size and declaration, aso
	  */
	 i = 1;
	 MAPL(cd,
	  {
	      dimension
		  d = DIMENSION(CAR(cd));
	      int lb = HpfcExpressionToInt(dimension_lower(d));
	      int ub = HpfcExpressionToInt(dimension_upper(d));
	      int sz = (ub-lb+1);
	      int decl;
	      int j;
	      list l = (list) GET_ENTITY_MAPPING(newdeclarations, array);
	      alignment 
		  a = FindAlignmentOfDim(align_alignment(al), i);
	      

	      /* gen_find_ith()... */
	      for(j=1 ; j<i ; j++) l=CDR(l);
	      decl = INT(CAR(l));

	      /*
	       * RANGEA contents:
	       *
	       * 1: lower bound
	       * 2: upper bound
	       * 3: size, (2)-(1)+1
	       * 4: new declaration flag
	       */
	      fprintf(file, "\n");
	      fprintf(file, "      RANGEA(%d, %d, 1) = %d\n", an, i, lb);
	      fprintf(file, "      RANGEA(%d, %d, 2) = %d\n", an, i, ub);
	      fprintf(file, "      RANGEA(%d, %d, 3) = %d\n", an, i, sz);
	      fprintf(file, "c\n");
	      fprintf(file, "      RANGEA(%d, %d, 4) = %d\n", an, i, decl);
	      
	      switch(decl)
	      {
	      case NO_NEW_DECLARATION:
		  break;
	      case ALPHA_NEW_DECLARATION:
		  /*
		   * 5: 1 - lower bound
		   */
		  fprintf(file, "      RANGEA(%d, %d, 5) = %d\n", an, i, (1-lb));
		  break;
	      case BETA_NEW_DECLARATION:
	      {
		  int tdim = alignment_templatedim(a);
		  int procdim = 0;
		  distribution
		      d = FindDistributionOfDim(distribute_distribution(di), 
						tdim,
						&procdim);
		  int param = HpfcExpressionToInt(distribution_parameter(d));
		  int rate;
		  int shift;
		  dimension 
		      dim = FindIthDimension(template, tdim);
		  
		  pips_assert("create_init_common_param", 
			      style_block_p(distribution_style(d)));
		  
		  rate = HpfcExpressionToInt(alignment_rate(a));
		  shift = (HpfcExpressionToInt(alignment_constant(a)) -
			   HpfcExpressionToInt(dimension_lower(dim)));
		  /*
		   * 5: distribution parameter n, 
		   * 6: alignment rate a,
		   * 7: alignment shift, b-t_{m}
		   */
		  fprintf(file, "      RANGEA(%d, %d, 5) = %d\n", an, i, param);
		  fprintf(file, "      RANGEA(%d, %d, 6) = %d\n", an, i, rate);
		  fprintf(file, "      RANGEA(%d, %d, 7) = %d\n", an, i, shift);
	      
		  break;
	      }
	      case GAMMA_NEW_DECLARATION:
	      {
		  int tdim = alignment_templatedim(a);
		  int procdim = 0;
		  distribution
		      d = FindDistributionOfDim(distribute_distribution(di), 
						tdim,
						&procdim);
		  int param = HpfcExpressionToInt(distribution_parameter(d));
		  int sc;
		  int no;
		  int shift;
		  dimension 
		      dim = FindIthDimension(template, tdim);
		  entity
		      proc = distribute_processors(di);

		  pips_assert("create_init_common_param", 
			      style_cyclic_p(distribution_style(d)));

		  sc = param*SizeOfIthDimension(proc, procdim);
		  shift = (HpfcExpressionToInt(alignment_constant(a)) -
			   HpfcExpressionToInt(dimension_lower(dim)));
		  no = (lb + shift) / sc ;

		  /*
		   * 5: distribution parameter n,
		   * 6: cycle length n*p,
		   * 7: initial cycle number,
		   * 8: alignment shift, b-t_{m}
		   */
		  fprintf(file, "      RANGEA(%d, %d, 5) = %d\n", an, i, param);
		  fprintf(file, "      RANGEA(%d, %d, 6) = %d\n", an, i, sc);
		  fprintf(file, "      RANGEA(%d, %d, 7) = %d\n", an, i, no);
		  fprintf(file, "      RANGEA(%d, %d, 8) = %d\n", an, i, shift);

		  break;
	      }
	      case DELTA_NEW_DECLARATION:
	      {
		  int tdim = alignment_templatedim(a);
		  int rate = HpfcExpressionToInt(alignment_rate(a));
		  int cst  = HpfcExpressionToInt(alignment_constant(a));
		  int param = HpfcExpressionToInt(distribution_parameter(d));
		  int procdim = 0;
		  int sc;
		  int no;
		  int shift;
		  int chuncksize;		      
		  distribution
		      d = FindDistributionOfDim(distribute_distribution(di), 
						tdim,
						&procdim);
		  dimension 
		      templdim = FindIthDimension(template, tdim);
		  entity
		      proc = distribute_processors(di);
		  
		  pips_assert("create_init_common_param", 
			      style_cyclic_p(distribution_style(d)));
		  
		  sc = param*SizeOfIthDimension(proc, procdim);
		  shift = (cst - HpfcExpressionToInt(dimension_lower(templdim)));
		  no = (rate*lb + shift) / sc ;
		  chuncksize = iceil(param, abs(rate));
		  
		  /*
		   *  5: distribution parameter n
		   *  6: cycle length n*p,
		   *  7: initial cycle number,
		   *  8: alignment shift, b-t_{m}
		   *  9: alignment rate a,
		   * 10: chunck size ceil(n,|a|)
		   */
		  fprintf(file, "      RANGEA(%d, %d, 5) = %d\n", an, i, param);
		  fprintf(file, "      RANGEA(%d, %d, 6) = %d\n", an, i, sc);
		  fprintf(file, "      RANGEA(%d, %d, 7) = %d\n", an, i, no);
		  fprintf(file, "      RANGEA(%d, %d, 8) = %d\n", an, i, shift);
		  fprintf(file, "      RANGEA(%d, %d, 9) = %d\n", an, i, rate);
		  fprintf(file, "      RANGEA(%d, %d, 10) = %d\n", an, i, chuncksize);

		  break;
	      }
	      default:
		  pips_error("create_init_common_param", 
			     "unexpected new declaration tag (%d)\n",
			     decl);
	      }

	      i++;
	  },
	      variable_dimensions(type_variable(entity_type(array))));

	 fprintf(file, "\n");

	 /*
	  * ALIGN
	  */

	 for(i=1 ; i<=NumberOfDimension(template) ; i++)
	 {
	     alignment
		 a = FindAlignmentOfTemplateDim(align_alignment(al), i);

	      if (a==alignment_undefined)
	      {
		  fprintf(file, "      ALIGN(%d, %d, 1) = INTFLAG\n", an, i);
	      }
	     else
	     {
		 int adim = alignment_arraydim(a);

		 fprintf(file, "      ALIGN(%d, %d, 1) = %d\n", an, i, adim);
		 
		 if (adim==0)
		     fprintf(file, "      ALIGN(%d, %d, 2) = 0\n", an, i);
		 else
		     fprintf(file, "      ALIGN(%d, %d, 2) = %d\n", an, i,
			     HpfcExpressionToInt(alignment_rate(a)));

		 fprintf(file, "      ALIGN(%d, %d, 3) = %d\n", an, i,
			 HpfcExpressionToInt(alignment_constant(a)));

	     }
	  }
     },
	 distributedarrays);

    /*
     * Templates
     */
    fprintf(file, "c\nc Templates Initializations\nc\n");

    MAPL(ce,
     {
	 entity
	     template = ENTITY(CAR(ce));
	 int tn = (int) GET_ENTITY_MAPPING(hpfnumber, template);
	 int nd  = NumberOfDimension(template);
	 distribute
	     di = (distribute) GET_ENTITY_MAPPING(hpfdistribute, template);
	 entity
	     proc = distribute_processors(di);
	 int pn = (int) GET_ENTITY_MAPPING(hpfnumber, proc);
	 int procdim = 1;
	 int tempdim = 1;
	 
	 fprintf(file, "c\nc initializing template %s, number %d\nc\n",
		 entity_local_name(template), tn);

	 /*
	  * NODIMT: Number Of  DIMensions of a Template
	  * TTOP: Template TO Processors arrangement
	  */
	 fprintf(file, "      NODIMT(%d) = %d\n", tn, nd);
	 fprintf(file, "      TTOP(%d) = %d\n", tn, pn);
	 
	 /*
	  * RANGET: lower, upper, size 
	  */
	 MAPL(cd,
	  {
	      dimension
		  d = DIMENSION(CAR(cd));
	      int lb = HpfcExpressionToInt(dimension_lower(d));
	      int ub = HpfcExpressionToInt(dimension_upper(d));
	      int sz = (ub-lb+1);

	      fprintf(file, "\n");
	      fprintf(file, "      RANGET(%d, %d, 1) = %d\n", tn, tempdim, lb);
	      fprintf(file, "      RANGET(%d, %d, 2) = %d\n", tn, tempdim, ub);
	      fprintf(file, "      RANGET(%d, %d, 3) = %d\n", tn, tempdim, sz);

	      tempdim++;
	  },
	      variable_dimensions(type_variable(entity_type(template))));

	 /*
	  * DIST
	  */
	 tempdim = 1;
	 fprintf(file, "\n");
	 MAPL(cd,
	  {
	      distribution 
		  d = DISTRIBUTION(CAR(cd));
	      int param;
	      bool 
		  block_case = FALSE;

	      switch(style_tag(distribution_style(d)))
	      {
	      case is_style_none:
		  break;
	      case is_style_block:
		  block_case = TRUE;
	      case is_style_cyclic:
		  param = HpfcExpressionToInt(distribution_parameter(d));
		  if (!block_case) param = -param;
		  fprintf(file, "      DIST(%d, %d, 1) = %d\n", 
			  tn, procdim, tempdim);
		  fprintf(file, "      DIST(%d, %d, 2) = %d\n", 
			  tn, procdim, param);
		  procdim++;
		  break;
	      default:
		  pips_error("create_init_common_param", 
			     "unexpected style tag\n");
		  break;
	      }

	      tempdim++;
	  },
	      distribute_distribution(di));
     },
	 templates);

    /*
     * Processors
     */
    fprintf(file, "c\nc Processors Initializations\nc\n");

MAPL(ce,
     {
	 entity
	     proc = ENTITY(CAR(ce));
	 int pn = (int) GET_ENTITY_MAPPING(hpfnumber, proc);
	 int nd  = NumberOfDimension(proc);
	 int procdim = 1;
	 
	 fprintf(file, "c\nc initializing processors %s, number %d\nc\n",
		 entity_local_name(proc), pn);

	 /*
	  * NODIMP: Number Of  DIMensions of a Processors arrangement
	  */
	 fprintf(file, "      NODIMP(%d) = %d\n", pn, nd);
	 
	 /*
	  * RANGEP: lower, upper, size 
	  */
	 MAPL(cd,
	  {
	      dimension
		  d = DIMENSION(CAR(cd));
	      int lb = HpfcExpressionToInt(dimension_lower(d));
	      int ub = HpfcExpressionToInt(dimension_upper(d));
	      int sz = (ub-lb+1);

	      fprintf(file, "\n");
	      fprintf(file, "      RANGEP(%d, %d, 1) = %d\n", pn, procdim, lb);
	      fprintf(file, "      RANGEP(%d, %d, 2) = %d\n", pn, procdim, ub);
	      fprintf(file, "      RANGEP(%d, %d, 3) = %d\n", pn, procdim, sz);
	      
	      procdim++;
	  },
	      variable_dimensions(type_variable(entity_type(proc))));
     },
	 processors);

    fprintf(file, "      end\n");
    fprintf(file, "c\nc end of automatically generated fortran subroutine\nc\n");
}

