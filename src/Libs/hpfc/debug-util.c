/*
 * this is a set of functions to help hpfc debugging
 *
 * Fabien Coelho, May 1993.
 */

#include <stdio.h>
extern int fprintf();

#include "genC.h"
#include "ri.h"
#include "hpf.h"
#include "hpf_private.h"
#include "message.h"

#include "ri-util.h"
#include "misc.h"
#include "hpfc.h"
#include "defines-local.h"

extern char *flint_print_basic();

/*
 * print_entity_variable(e)
 * 
 * if it is just a variable, the type is printed,
 * otherwise just the entity name is printed
 */

static void print_dimension(d)
dimension d;
{
    fprintf(stderr,"dimension :\n");
    print_expression(dimension_lower(d));
    print_expression(dimension_upper(d));
}

void print_entity_variable(e)
entity e;
{
    variable v;

    (void) fprintf(stderr,"name: %s\n",entity_name(e));
    
    if (!type_variable_p(entity_type(e)))
	return;

    v = type_variable(entity_type(e));

    fprintf(stderr,"basic %s\n",flint_print_basic(variable_basic(v)));
    MAPL(cd,{print_dimension(DIMENSION(CAR(cd)));},variable_dimensions(v));
}

void print_align(a)
align a;
{
    (void) fprintf(stderr,"aligned\n");
    MAPL(ca,{print_alignment(ALIGNMENT(CAR(ca)));},align_alignment(a));
    (void) fprintf(stderr, "to template %s\n\n", entity_name(align_template(a)));
}

void print_alignment(a)
alignment a;
{
    (void) fprintf(stderr,
		   "Alignment: arraydim %d, templatedim %d,\n",
		   alignment_arraydim(a),
		   alignment_templatedim(a));
    
    (void) fprintf(stderr,"rate: ");
    print_expression(alignment_rate(a));
    (void) fprintf(stderr,"\nconstant: ");
    print_expression(alignment_constant(a));
    (void) fprintf(stderr,"\n");
}

void print_aligns()
{
    fprintf(stderr,"Aligns:\n");
    MAPL(ce,
     {
	 entity a=ENTITY(CAR(ce));

	 (void) fprintf(stderr, "of array %s\n", entity_name(a));
	 print_align(load_entity_align(a));
	 (void) fprintf(stderr,"\n");
     },
	 list_of_distributed_arrays());
}

void print_distributes()
{
    fprintf(stderr,"Distributes:\n");

    MAPL(ce,
     {
	 entity t=ENTITY(CAR(ce));

	 (void) fprintf(stderr, "of template %s\n", entity_name(t));
	 print_distribute(load_entity_distribute(t));
	 (void) fprintf(stderr,"\n");
     },
	 list_of_templates());
    
}

void print_distribute(d)
distribute d;
{
    (void) fprintf(stderr,"distributed\n");

    MAPL(cd,
     {
	 print_distribution(DISTRIBUTION(CAR(cd)));
     }, 
	 distribute_distribution(d));

    (void) fprintf(stderr, "to processors %s\n\n", 
		   entity_name(distribute_processors(d)));    
}

void print_distribution(d)
distribution d;
{
    switch(style_tag(distribution_style(d)))
    {
    case is_style_none:
	(void) fprintf(stderr,"none, ");
	break;
    case is_style_block:
	(void) fprintf(stderr,"BLOCK(");
	print_expression(distribution_parameter(d));
	(void) fprintf(stderr,"), ");
	break;
    case is_style_cyclic:
	(void) fprintf(stderr,"CYCLIC(");
	print_expression(distribution_parameter(d));
	(void) fprintf(stderr,"), ");
	break;
    default:
	pips_error("print_distribution","unexpected style tag\n");
	break;
    }
    (void) fprintf(stderr,"\n");
}

void print_hpf_dir()
{
    (void) fprintf(stderr,"HPF directives:\n");

    print_templates();
    (void) fprintf(stderr,"--------\n");
    print_processors();
    (void) fprintf(stderr,"--------\n");
    print_distributed_arrays();
    (void) fprintf(stderr,"--------\n");
    print_aligns();
    (void) fprintf(stderr,"--------\n");
    print_distributes();
}

void print_templates()
{
    (void) fprintf(stderr,"Templates:\n");

    MAPL(ce,
     {
	 print_entity_variable(ENTITY(CAR(ce)));
     },
	 list_of_templates());
}

void print_processors()
{
    (void) fprintf(stderr,"Processors:\n");

    MAPL(ce,
     {
	 print_entity_variable(ENTITY(CAR(ce)));
     },
	 list_of_processors());
}

void print_distributed_arrays()
{
    (void) fprintf(stderr,"Distributed Arrays:\n");

    MAPL(ce,
     {
	 print_entity_variable(ENTITY(CAR(ce)));
     },
	 list_of_distributed_arrays());
}


void print_alignsrc(as)
alignsrc as;
{
    switch(alignsrc_tag(as))
    {
    case is_alignsrc_star:
	fprintf(stderr,"alignsrc is *\n");
	break;
    case is_alignsrc_colon:
	fprintf(stderr,"alignsrc is :\n");
	break;
    case is_alignsrc_dummy:
	fprintf(stderr,"alignsrc is %s\n",alignsrc_dummy(as));
	break;
    default:
	pips_error("print_alignsrc","unexpected aligsrc tag\n");
	break;
    }
}

/*
 * for debug purposes:-)
 */
void DebugPrintCode(l,module,stat)
int l;
entity module;
statement stat;
{
    ifdebug(l)
    {
	hpfc_print_code(stderr, module, stat);
    }
}

/*
 * hpfc_print_code
 */
void hpfc_print_code(file, module, stat)
FILE* file;
entity module;
statement stat;
{
    text t;
    debug_off();
    
    fprintf(file, 
	    "c\nc this file has been automatically generated by the hpf-compiler\nc\n");

    t = text_module(module, stat);
    /* the includes are missing */
    print_text(file, t);
    free_text(t);
    
    fprintf(file,
	    "c\nc that's all folks!\nc\n");

    debug_on("HPFC_DEBUG_LEVEL");
}

/*
 * void fprint_range(file, r)
 */
void fprint_range(file, r)
FILE* file;
range r;
{
    int
	lo, up, in;
    bool
	blo = hpfc_integer_constant_expression_p(range_lower(r), &lo),
	bup = hpfc_integer_constant_expression_p(range_upper(r), &up),
	bin = hpfc_integer_constant_expression_p(range_increment(r), &in);

    if (blo && bup && bin)
    {
	if (in==1)
	    if (lo==up)
		fprintf(file, "%d", lo);
	    else
		fprintf(file, "%d:%d", lo, up);
	else
	    fprintf(file, "%d:%d:%d", lo, up, in);
    }
    else
	fprintf(file, "X");
}

/*
 * void fprint_lrange(file, l)
 */
void fprint_lrange(file, l)
FILE* file;
list l;
{
    bool
	firstrange = TRUE;

    MAPL(cr,
     {
	 range
	     r = RANGE(CAR(cr));

	 if (!firstrange)
	     (void) fprintf(file, ", ");

	 firstrange = FALSE;
	 fprint_range(file, r);
     },
	 l);
}

/*
 * fprint_message()
 */
void fprint_message(file, m)
FILE* file;
message m;
{
    (void) fprintf(file, "message is array %s(", 
		   entity_local_name(message_array(m)));
    fprint_lrange(file, message_content(m));
    (void) fprintf(file, ")\nto\n");
    vect_fprint(file, (Pvecteur) message_neighbour(m), variable_dump_name);
    (void) fprintf(file, "domain is ");
    fprint_lrange(file, message_dom(m));
    (void) fprintf(file, "\n");
}

/*
 * void fprint_lmessage(file, l)
 */
void fprint_lmessage(file, l)
FILE* file;
list l;
{
    if (ENDP(l))
	fprintf(file, "message list is empty\n");
    else
	MAPL(cm,
	 {
	     fprint_message(file, MESSAGE(CAR(cm)));
	 },
	     l);
}

