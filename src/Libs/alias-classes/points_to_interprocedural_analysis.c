#include <stdlib.h>
#include <stdio.h>
/* For strdup: */
#define _GNU_SOURCE
#include <string.h>

#include "genC.h"
#include "linear.h"
#include "ri.h"
#include "effects.h"
#include "database.h"
#include "ri-util.h"
#include "effects-util.h"
#include "constants.h"
#include "misc.h"
#include "parser_private.h"
#include "top-level.h"
#include "text-util.h"
#include "text.h"
#include "properties.h"
#include "effects-generic.h"
#include "effects-simple.h"
#include "effects-convex.h"
#include "pipsdbm.h"
#include "resources.h"
#include "newgen_set.h"
#include "points_to_private.h"
#include "alias-classes.h"

/*  Foreach real argument r and its formal f one create the assignment f = r
    then compute points-to set s generated by the assignment.
    The result is the union of pt_caller and s
*/
set points_to_binded(entity called_func, list real_args, set pt_caller)
{ 
  set s = set_generic_make(set_private, points_to_equal_p,
			   points_to_rank);
  set pt_binded = set_generic_make(set_private, points_to_equal_p,
				   points_to_rank);

  cons *pc;
  int ipc;
  s = set_assign(s, pt_caller);
  for (ipc = 1, pc = real_args; pc != NIL; pc = CDR(pc), ipc++) {
    expression rhs = EXPRESSION(CAR(pc));
    entity pf = find_ith_parameter(called_func, ipc);
    expression lhs = entity_to_expression(pf);
    statement stmt = make_assign_statement(lhs, rhs);
    s = set_assign(s, points_to_assignment(stmt, lhs, rhs, s));	
  }

  SET_FOREACH(points_to, pt, s) {
    reference r = cell_any_reference(points_to_sink(pt));
    entity e = reference_variable(r);
    if(entity_stub_sink_p(e))
      s = set_del_element(s,s,(void*)pt);
  }
  pt_binded = set_union(pt_binded, s, pt_caller);
  return pt_binded;
}

list written_pointers(list eff) {
  list written_l = NIL;
  list wr_eff = effects_write_effects(eff);
  FOREACH(effect, ef, wr_eff) {
    if(effect_pointer_type_p(ef))
      written_l = gen_nconc(CONS(EFFECT, ef, NIL), written_l);
  }

  return written_l; 

}

/* list formal_access_paths(set pt_in) { */
/*   reference r = reference_undefined; */
/*   entity e = entity_undefined; */
/*   list stub_l = NIL, formal_l = NIL; */
/*   SET_FOREACH(points_to, pt, pt_in){ */
    
/*     if( entity_stub_sink_p(reference_variable(cell_any_reference(points_to_source(pt)))) ) { */
/*       r = copy_reference(cell_any_reference(points_to_source(pt))); */
/*       e = reference_variable(r); */
/*       const char* str = entity_local_name(e); */
/*       char delims[] = "_"; */
/*       char *result = NULL; */
/*       result = strtok( str, delims ); */
/*       char *root = strcpy(root, result); */
/*       int i = 0; */
/*       while( result != NULL ) { */
/* 	fprintf(stderr, "result is \"%s\"\n", result ); */
/* 	result = strtok( NULL, delims ); */
/* 	i++; */
/*       } */
/*       if(i >0) { */
	
/*       } */
	
/*       /\* r = cell_any_reference(points_to_source(pt)); *\/ */
/*       stub_l = gen_nconc(CONS(REFERENCE, r, NIL), stub_l); */
/*     } */
/*     else if ( entity_stub_sink_p(reference_variable(cell_any_reference(points_to_sink(pt)))) ){ */
/*       r = copy_reference(cell_any_reference(points_to_sink(pt))); */
/*       e = reference_variable(r); */
/*       const char* str = entity_local_name(e); */
/*       char delims[] = "_"; */
/*       char *result = NULL; */
/*       result = strtok( str, delims ); */
/*       char *root = strcpy(root, result); */
/*       int i = 1; */
/*       while( result != NULL ) { */
/* 	fprintf(stderr, "result is \"%s\"\n", result ); */
/* 	result = strtok( NULL, delims ); */
/* 	i++; */
/*       } */

/*       stub_l = gen_nconc(CONS(REFERENCE, r, NIL), stub_l); */
/*     } */
/*   } */
/*   FOREACH(REFERENCE, re, stub_l){ */
/*     effect eff = reference_to_simple_effect(re, make_action_write_memory(), true); */
/*     effect_add_dereferencing_dimension(eff); */
/*     reference nr = effect_any_reference(eff); */
/*     formal_l = gen_nconc(CONS(REFERENCE, r, NIL), formal_l); */
/*   } */

/*   return formal_l; */
/* } */

bool interprocedural_points_to_analysis(char * module_name)
{
  entity module;
  type t;
  /* list pt_list = NIL; */
  /* set pts_to_set = set_generic_make(set_private, */
  /* 				    points_to_equal_p,points_to_rank); */

  set_current_module_entity(module_name_to_entity(module_name));
  module = get_current_module_entity();

  t = entity_type(module);

  debug_on("POINTS_TO_DEBUG_LEVEL");

  pips_debug(1, "considering module %s\n", module_name);

  

  /* DB_PUT_MEMORY_RESOURCE */
  /*   (DBR_INIT_POINTS_TO_LIST, module_name, init_pts_to_list); */

  reset_current_module_entity();
  debug_off();

  bool good_result_p = true;
  return (good_result_p);
}
