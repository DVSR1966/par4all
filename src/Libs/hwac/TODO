* pre-processing
+ inlining, full_unroll, dead code elim, flatten_code
+ image reuse
+ scalar deps with proper effects
- check => ok => deadcode (#define)

* input
+ may skip unrelated statements?
+ deal with |= ||= and similars
+ detect redundant operations? replace them with copies?
- what about full expressions: aipo_x() || aipo_y() || aipo_z()? atomizer?
- check that there are references where expected?
- handle different type of images (e.g. distinct BPP)
  issue: it is not clear how the image bpp can be derived from the source
- check/remove more implicit hypothesis?

* optimizations
+ remove useless images (computed but not used...) see licensePlate
+ take advantage of commutative operators to remove operations
- should keep AIPO/software calls if accelerator calls are slower?
- min commutes with dilate & max with erode, or vice-versa ?
- other simple or complex algebraic optimization ideas?

* code
+ cleanup data structures?
- record scalar deps in dag?
- split first on scalar deps, as it is true for any accelerator?
  not that simple with limited depth?
- remove type ctxcontent?
- should make elementary ops absdiff(x,y) = abs(diff(x, y)) (no.. unsigned)
- and then match back of necessary to available low level ops.
- could separate DAG optimization as a separate phase? AIPO -> AIPO

* output
+ symmetry (flipping)
+ compaction
+ handle wiring
+ tell pipsdbm about generated files
+ pipe overflow
+ show DAG!
+ select node shape depending on hardware?
+ add more comments to generated code
+ improve generated comments
+ if only one image is used as input, put it anyway on both sides?
  may help some schedules if there are multiple successors.
+ use commutator to detect more redundancy
+ must not handle copies through the pipeline...
+ should also detect "duplicate" measurements with a copy of the scalars
+ should detect "included" measurements (maxcoord includes max)?
  (done indirectly by the code generation, but could be done on the DAG?)
+ remove dead code on dag optimization
- add checks in generated code (img size and so)?
- parametric img size/depth? same as code?
- the generated code is just a file to pips. ok???

* post-processing
+ remove malloc/free if not used
+ cleanup declarations
+ it seems that some unused image are not removed (license_plate_copies)
- should cleanup dead code in generated code (ret |= 0; ...)

* validation
+ check all AIPO
+ add more (elementary) tests?
- add more application-level tests

* known bugs
+ allocs may be in the middle of the calls
+ license_plate_copies takes too much time to compile? 1mn -> 4.5s
- reuse of images in some cases when nodes are reordered... SSA?

* terapix target
+ must manage memory allocation in tiles
+ memory for measures?
+ I/O tiles : read before write
+ double buffering with additionnal tiles max(in-tiles,out-tiles)
+ in place operators
+ shadow 4-way declaration
+ handling of various parameters...
+ detect that an argument is used several times...
- sequence extraction shouldn't include
  functions not implemented for the target?
- use global max length/ops/critical path as a decision driver?
  beware: do not extract input, even if live?!
- extension: interface with SG terapix microcode generation
  hard constraint: 3 "pointers" are available; border management?

* OpenCL target
- whole image computations are okay: freia_aipo_compiler
- could use terapix-like tiling to help with cache?
- expensive memory accesses => aggregate computations would help?
- use on-demand image transfers in runtime?
- compilation benefit: only freia DAG optimizations? others??

* hardware generation target
- use optimized expression DAG(s) for hardware generation
