/* header file built by cproto */
#ifndef ri_util_header_included
#define ri_util_header_included
/* RI-UTIL Library: Functions dealing with and constants related to
    PIPS intermediate representation ri.newgen,
    that are NOT generated by NewGen */

 /* Pvecteur is an external type for NewGen and the ri data structure
  * and is not included in ri.h
  *
  * It is included here to avoid changes in many PIPS modules which
  * use ri-util
  *
  * Idem for type Ppolynome (PB 25/07/90); FI: polynomials are not
  * used in ri.newgen; they should not be mentionned here
  *
  * Idem for type Psysteme (FI 3 November 1990)
  */

#include "linear.h"

#include "text.h"

/* mapping.h inclusion
 *
 * I do that because this file was previously included in genC.h,
 * but the macros defined here use ri types (statement, entity...).
 * three typedef are also included here. ri.h is a prerequisit for 
 * mapping.h.
 *
 * FC, Feb 21, 1994
 */

/* these macros are obsolete! newgen functions (->) should be used
 * instead
 */

#ifndef STATEMENT_MAPPING_INCLUDED
#define STATEMENT_MAPPING_INCLUDED
typedef hash_table statement_mapping;
#define MAKE_STATEMENT_MAPPING() \
     (statement_mapping) hash_table_make(hash_pointer, 0)
#define FREE_STATEMENT_MAPPING(map) \
    (hash_table_free((hash_table) (map)))
#define SET_STATEMENT_MAPPING(map, stat, val) \
    hash_put((hash_table) (map), (char *)(stat), (char *)(val))
#define GET_STATEMENT_MAPPING(map, stat) \
    hash_get((hash_table) (map), (char *) (stat))
#define STATEMENT_MAPPING_COUNT(map) \
    hash_table_entry_count((hash_table) map)
#define STATEMENT_MAPPING_MAP(s, v, code, h) \
        HASH_MAP(s, v, code, h)
/*
 * this warrant BA Macro Compatibility:
 */
#define DEFINE_CURRENT_MAPPING(name, type) \
        GENERIC_CURRENT_MAPPING(name, type, statement)
#endif

#ifndef ENTITY_MAPPING_INCLUDED
#define ENTITY_MAPPING_INCLUDED
typedef hash_table entity_mapping;
#define MAKE_ENTITY_MAPPING() \
    ((entity_mapping) hash_table_make(hash_pointer, 0))
#define FREE_ENTITY_MAPPING(map) \
    (hash_table_free((hash_table) (map)))
#define SET_ENTITY_MAPPING(map, ent, val) \
    hash_put((hash_table) (map), (char *)(ent), (char *)(val))
#define GET_ENTITY_MAPPING(map, ent) \
    hash_get((hash_table) (map), (char *)(ent))
#define ENTITY_MAPPING_COUNT(map) \
    hash_table_entry_count((hash_table) map)
#define ENTITY_MAPPING_MAP(s, v, code, h) \
        HASH_MAP(s, v, code, h)
#endif

#ifndef CONTROL_MAPPING_INCLUDED
#define CONTROL_MAPPING_INCLUDED
typedef hash_table control_mapping;
#define MAKE_CONTROL_MAPPING() \
    ((control_mapping) hash_table_make(hash_pointer, 0))
#define FREE_CONTROL_MAPPING(map) \
    (hash_table_free((hash_table) (map)))
#define SET_CONTROL_MAPPING(map, cont, val) \
    hash_put((hash_table) (map), (char *)(cont), (char *)(val))
#define GET_CONTROL_MAPPING(map, cont) \
    hash_get((hash_table) (map), (char *)(cont))
#define CONTROL_MAPPING_COUNT(map) \
    hash_table_entry_count((hash_table) map)
#define CONTROL_MAPPING_MAP(s, v, code, h) \
        HASH_MAP(s, v, code, h)
#endif

/*  special characters
 */
#define MODULE_SEP 			':'

#define MODULE_SEP_STRING 		":"
#define LABEL_PREFIX 			"@"
#define MAIN_PREFIX 			"%"
#define COMMON_PREFIX 			"~"
#define BLOCKDATA_PREFIX 		"&"

/*  constant names
 */
#define BLANK_COMMON_LOCAL_NAME 	"*BLANK*"
#define DYNAMIC_AREA_LOCAL_NAME 	"*DYNAMIC*"
#define STATIC_AREA_LOCAL_NAME 		"*STATIC*"
#define HEAP_AREA_LOCAL_NAME 		"*HEAP*"
#define STACK_AREA_LOCAL_NAME 		"*STACK*"

#define EMPTY_LABEL_NAME LABEL_PREFIX
#define LIST_DIRECTED_FORMAT_NAME 	"LIST-DIRECTED"

#define TOP_LEVEL_MODULE_NAME 		"TOP-LEVEL"
#define UNBOUNDED_DIMENSION_NAME 	"UNBOUNDED-DIMENSION"
#define IMPLIED_DO_NAME 		"IMPLIED-DO"
#define RETURN_LABEL_NAME 		"00000"

#define IMPLIED_COMPLEX_NAME		"CMPLX_"
#define IMPLIED_DCOMPLEX_NAME		"DCMPLX_"

#define ASSIGN_OPERATOR_NAME 		"="
#define PLUS_OPERATOR_NAME 		"+"
#define MINUS_OPERATOR_NAME 		"-"
#define UNARY_MINUS_OPERATOR_NAME 	"--"
#define MULTIPLY_OPERATOR_NAME 		"*"
#define DIVIDE_OPERATOR_NAME 		"/"
#define INVERSE_OPERATOR_NAME           "INV"
#define POWER_OPERATOR_NAME 		"**"
#define MODULO_OPERATOR_NAME 		"MOD"
#define MIN_OPERATOR_NAME 		"MIN"
#define MIN0_OPERATOR_NAME 		"MIN0"
#define AMIN1_OPERATOR_NAME 		"AMIN1"
#define DMIN1_OPERATOR_NAME 		"DMIN1"
#define MAX_OPERATOR_NAME 		"MAX"
#define MAX0_OPERATOR_NAME 		"MAX0"
#define AMAX1_OPERATOR_NAME 		"AMAX1"
#define DMAX1_OPERATOR_NAME 		"DMAX1"
#define IABS_OPERATOR_NAME 		"IABS"

/* generic conversion names.
 */
#define INT_GENERIC_CONVERSION_NAME	"INT"
#define REAL_GENERIC_CONVERSION_NAME	"REAL"
#define DBLE_GENERIC_CONVERSION_NAME	"DBLE"
#define CMPLX_GENERIC_CONVERSION_NAME	"CMPLX"
#define DCMPLX_GENERIC_CONVERSION_NAME	"DCMPLX"

#define INT_TO_CHAR_CONVERSION_NAME	"CHAR"
#define CHAR_TO_INT_CONVERSION_NAME	"ICHAR"

/* FI: intrinsics are defined at a third place after bootstrap and effects!
 *     I guess the name should be defined here and used in table(s) there
 */

#define AND_OPERATOR_NAME 		".AND."
#define OR_OPERATOR_NAME 		".OR."
#define NOT_OPERATOR_NAME 		".NOT."
#define NON_EQUAL_OPERATOR_NAME 	".NE."
#define EQUIV_OPERATOR_NAME 		".EQV."
#define NON_EQUIV_OPERATOR_NAME 	".NEQV."

#define TRUE_OPERATOR_NAME 		".TRUE."
#define FALSE_OPERATOR_NAME 		".FALSE."

#define GREATER_OR_EQUAL_OPERATOR_NAME 	".GE."
#define GREATER_THAN_OPERATOR_NAME 	".GT."
#define LESS_OR_EQUAL_OPERATOR_NAME 	".LE."
#define LESS_THAN_OPERATOR_NAME 	".LT."
#define EQUAL_OPERATOR_NAME 		".EQ."

#define CONTINUE_FUNCTION_NAME 		"CONTINUE"
#define RETURN_FUNCTION_NAME 		"RETURN"
#define STOP_FUNCTION_NAME 		"STOP"
#define PAUSE_FUNCTION_NAME 		"PAUSE"

#define SUBSTRING_FUNCTION_NAME 	"_SUBSTR"
#define ASSIGN_SUBSTRING_FUNCTION_NAME 	"_ASSIGN_SUBSTR"

#define WRITE_FUNCTION_NAME 		"WRITE"
#define REWIND_FUNCTION_NAME 		"REWIND"
#define OPEN_FUNCTION_NAME 		"OPEN"
#define CLOSE_FUNCTION_NAME 		"CLOSE"
#define READ_FUNCTION_NAME 		"READ"
#define BUFFERIN_FUNCTION_NAME 		"BUFFERIN"
#define BUFFEROUT_FUNCTION_NAME 	"BUFFEROUT"
#define ENDFILE_FUNCTION_NAME 		"ENDFILE"
#define FORMAT_FUNCTION_NAME 		"FORMAT"

#define MOD_INTRINSIC_NAME 		"MOD"

/* These operators are used within the optimize transformation in
   order to manipulate operators such as n-ary add and multiply or
   multiply-add operators ( JZ - sept 98)
 */
#define EOLE_FMA_OPERATOR_NAME          "EOLE-FMA-OP"
#define EOLE_FMS_OPERATOR_NAME          "EOLE-FMS-OP"
#define EOLE_PROD_OPERATOR_NAME         "EOLE-PROD-OP"
#define EOLE_SUM_OPERATOR_NAME          "EOLE-SUM-OP"

/* moved from ricedg-local.h */
#define LOOP_COUNTER_MODULE_NAME 	"LOOP-COUNTER"
#define DI_VAR_MODULE_NAME 		"DI-VAR"

/* macros */
#define entity_an_operator_p(e,name) \
  (strcmp(entity_local_name(e), name##_OPERATOR_NAME)==0)
#define entity_a_function_p(e,name) \
  (strcmp(entity_local_name(e), name##_FUNCTION_NAME)==0)

#define ENTITY_CONVERSION_P(e,name) \
  (strcmp(entity_local_name(e), name##_GENERIC_CONVERSION_NAME)==0)
#define ENTITY_CONVERSION_CMPLX_P(e) ENTITY_CONVERSION_P(e, CMPLX)
#define ENTITY_CONVERSION_DCMPLX_P(e) ENTITY_CONVERSION_P(e, DCMPLX)

#define ENTITY_CONTINUE_P(e) entity_a_function_p(e, CONTINUE)
#define ENTITY_STOP_P(e) entity_a_function_p(e, STOP)
#define ENTITY_RETURN_P(e) entity_a_function_p(e, RETURN)

#define ENTITY_ASSIGN_P(e) entity_an_operator_p(e, ASSIGN)
#define ENTITY_PLUS_P(e) entity_an_operator_p(e, PLUS)
#define ENTITY_MINUS_P(e) entity_an_operator_p(e, MINUS)
#define ENTITY_UNARY_MINUS_P(e) entity_an_operator_p(e, UNARY_MINUS)
#define ENTITY_MULTIPLY_P(e) entity_an_operator_p(e, MULTIPLY)
#define ENTITY_MODULO_P(e) entity_an_operator_p(e, MODULO)
#define ENTITY_POWER_P(e) entity_an_operator_p(e, POWER)
#define ENTITY_DIVIDE_P(e) entity_an_operator_p(e, DIVIDE)
#define ENTITY_MIN_P(e) entity_an_operator_p(e, MIN)
#define ENTITY_MAX_P(e) entity_an_operator_p(e, MAX)
#define ENTITY_MIN0_P(e) entity_an_operator_p(e, MIN0)
#define ENTITY_MAX0_P(e) entity_an_operator_p(e, MAX0)
#define ENTITY_AMIN1_P(e) entity_an_operator_p(e, AMIN1)
#define ENTITY_AMAX1_P(e) entity_an_operator_p(e, AMAX1)
#define ENTITY_DMIN1_P(e) entity_an_operator_p(e, DMIN1)
#define ENTITY_DMAX1_P(e) entity_an_operator_p(e, DMAX1)
#define ENTITY_MIN_OR_MAX_P(e) (ENTITY_MIN_P(e) || ENTITY_MAX_P(e) )
#define ENTITY_IABS_P(e) entity_an_operator_p(e, IABS)

#define ENTITY_AND_P(e) entity_an_operator_p(e, AND)

#define ENTITY_OR_P(e) entity_an_operator_p(e, OR)
#define ENTITY_NOT_P(e) entity_an_operator_p(e, NOT)
#define ENTITY_NON_EQUAL_P(e) entity_an_operator_p(e, NON_EQUAL)
#define ENTITY_EQUIV_P(e) entity_an_operator_p(e, EQUIV)
#define ENTITY_NON_EQUIV_P(e) entity_an_operator_p(e, NON_EQUIV)

/* Attention : 
   This definition is different with the Fortran Standard where the logical 
   operators are the following only: AND, OR, NOT, EQUIV, NEQUIV (NN-Mars 2000)*/

#define ENTITY_LOGICAL_OPERATOR_P(e) ( ENTITY_RELATIONAL_OPERATOR_P(e) || \
                                       ENTITY_AND_P(e) || \
                                       ENTITY_OR_P(e) || \
                                       ENTITY_NOT_P(e) || \
                                       ENTITY_NON_EQUAL_P(e) || \
                                       ENTITY_EQUIV_P(e) || \
                                       ENTITY_NON_EQUIV_P(e) )

#define ENTITY_TRUE_P(e) entity_an_operator_p(e, TRUE)
#define ENTITY_FALSE_P(e) entity_an_operator_p(e, FALSE)

#define ENTITY_GREATER_OR_EQUAL_P(e) entity_an_operator_p(e, GREATER_OR_EQUAL)
#define ENTITY_GREATER_THAN_P(e)  entity_an_operator_p(e, GREATER_THAN)
#define ENTITY_LESS_OR_EQUAL_P(e) entity_an_operator_p(e, LESS_OR_EQUAL)
#define ENTITY_LESS_THAN_P(e) entity_an_operator_p(e, LESS_THAN)

#define ENTITY_EQUAL_P(e) entity_an_operator_p(e, EQUAL)

#define ENTITY_RELATIONAL_OPERATOR_P(e) ( \
					 ENTITY_GREATER_OR_EQUAL_P(e) || \
					 ENTITY_GREATER_THAN_P(e) || \
					 ENTITY_LESS_OR_EQUAL_P(e) || \
					 ENTITY_LESS_THAN_P(e) || \
					 ENTITY_NON_EQUAL_P(e) || \
					 ENTITY_EQUAL_P(e) )

/* Special areas are sometimes tested by top_level_entity_p() because they
   are not top level entities whereas user commons are. */
#define SPECIAL_AREA_P(e) \
    ((same_string_p(module_local_name(e), DYNAMIC_AREA_LOCAL_NAME)) || \
     (same_string_p(module_local_name(e), STATIC_AREA_LOCAL_NAME)) || \
     (same_string_p(module_local_name(e), HEAP_AREA_LOCAL_NAME)))

#define SPECIAL_COMMON_P(e) SPECIAL_AREA_P(e)

/* IO Management
 */
#define ENTITY_NAME_P(e, name)(same_string_p(entity_local_name(e),name))

#define ENTITY_WRITE_P(e) ENTITY_NAME_P(e, "WRITE")
#define ENTITY_REWIND_P(e) ENTITY_NAME_P(e, "REWIND")
#define ENTITY_OPEN_P(e) ENTITY_NAME_P(e, "OPEN")
#define ENTITY_CLOSE_P(e) ENTITY_NAME_P(e, "CLOSE")
#define ENTITY_READ_P(e) ENTITY_NAME_P(e, "READ")
#define ENTITY_BUFFERIN_P(e) ENTITY_NAME_P(e, "BUFFERIN")
#define ENTITY_BUFFEROUT_P(e) ENTITY_NAME_P(e, "BUFFEROUT")
#define ENTITY_ENDFILE_P(e) ENTITY_NAME_P(e, "ENDFILE")
#define ENTITY_IMPLIEDDO_P(e) ENTITY_NAME_P(e, IMPLIED_DO_NAME)
#define ENTITY_FORMAT_P(e) ENTITY_NAME_P(e, "FORMAT")

#define ENTITY_IMPLIED_CMPLX_P(e) ENTITY_NAME_P(e, IMPLIED_COMPLEX_NAME)
#define ENTITY_IMPLIED_DCMPLX_P(e) ENTITY_NAME_P(e, IMPLIED_DCOMPLEX_NAME)

#define ENTITY_FOUR_OPERATION_P(e) ( ENTITY_PLUS_P(e) || \
                                     ENTITY_MINUS_P(e) || \
				     ENTITY_UNARY_MINUS_P(e) || \
                                     ENTITY_MULTIPLY_P(e) || \
                                     ENTITY_DIVIDE_P(e) )

#define IO_CALL_P(call) io_intrinsic_p(call_function(call))

/* classification of basics
 */
#define basic_numeric_simple_p(b) (basic_int_p(b) || basic_float_p(b))
#define basic_numeric_p(b) (basic_numeric_simple_p(b) || basic_complex_p(b))
#define basic_compatible_simple_p(b1, b2) (\
                (basic_numeric_simple_p(b1) && basic_numeric_simple_p(b2)) ||\
                (basic_string_p(b1) && basic_string_p(b2)) ||\
                (basic_logical_p(b1) && basic_logical_p(b2)) ||\
                (basic_overloaded_p(b1) && basic_overloaded_p(b2)) ||\
                (basic_undefined_p(b1) && basic_undefined_p(b2)))
#define basic_compatible_p(b1, b2) (\
                (basic_numeric_p(b1) && basic_numeric_p(b2)) ||\
                (basic_string_p(b1) && basic_string_p(b2)) ||\
                (basic_logical_p(b1) && basic_logical_p(b2)) ||\
                (basic_overloaded_p(b1) && basic_overloaded_p(b2)) ||\
                (basic_undefined_p(b1) && basic_undefined_p(b2)))


/*  constant sizes
 */
#define LABEL_SIZE 5
#define INDENTATION (get_int_property("PRETTYPRINT_INDENTATION"))
#define MAXIMAL_MODULE_NAME_SIZE 36

/*   default values
 */
#define STATEMENT_NUMBER_UNDEFINED (-1)
#define STATEMENT_ORDERING_UNDEFINED (-1)
#define UNKNOWN_RAM_OFFSET (-1)

/* On devrait utiliser Newgen pour cela, mais comme on ne doit pas
   les utiliser directement (mais via statement_less_p), cela devrait
   decourager les temeraires */

#define MAKE_ORDERING(u,s) (u<<16|s)
#define ORDERING_NUMBER(o) (o>>16)
#define ORDERING_STATEMENT(o) (o & 0xffff)

#define NORMALIZE_EXPRESSION(e) \
    ((expression_normalized(e) == normalized_undefined) ? \
         (expression_normalized(e) = NormalizeExpression(e)) : \
         (expression_normalized(e)))

/*   MISC: newgen shorthands
 */
#define entity_declarations(e) (code_declarations(entity_code(e)))

#define effect_system(e) \
	(descriptor_convex_p(effect_descriptor(e))? \
	 descriptor_convex(effect_descriptor(e)) : SC_UNDEFINED)

#define effect_reference(e) \
	 preference_reference(cell_preference(effect_cell(e)))

#define entity_variable_p(e) (type_variable_p(entity_type(e)))

#define make_simple_effect(reference,action,approximation)\
    make_effect(make_cell(is_cell_preference, make_preference(reference)),\
    (action),(approximation), \
    make_descriptor(is_descriptor_none,UU))  

#define make_convex_effect(reference,action,approximation,system)\
    make_effect(make_cell(is_cell_preference, make_preference(reference)),\
    (action),(approximation), \
    make_descriptor(is_descriptor_convex,system))  


#define statement_block_p(stat) \
	(instruction_block_p(statement_instruction(stat)))

#define entity_constant_p(e) (type_functional_p(entity_type(e)) && \
  storage_rom_p(entity_storage(e)) && value_constant_p(entity_initial(e)))

/* building instruction and statements...
 */
#define instruction_to_statement(i) \
   make_statement(entity_empty_label(),\
		  STATEMENT_NUMBER_UNDEFINED, STATEMENT_ORDERING_UNDEFINED,\
		  empty_comments, i)

#define loop_to_instruction(l) make_instruction(is_instruction_loop, l)
#define test_to_instruction(t) make_instruction(is_instruction_test, t)
#define call_to_instruction(c) make_instruction(is_instruction_call, c)

#define loop_to_statement(l) instruction_to_statement(loop_to_instruction(l))
#define test_to_statement(t) instruction_to_statement(test_to_instruction(t))
#define call_to_statement(c) instruction_to_statement(call_to_instruction(c))


/***************************************************** BOOLEAN EXPRESSIONS */
/* Building quickly boolean expressions, FC.
 */

#define unary_intrinsic_expression(name, e)\
 call_to_expression(make_call(entity_intrinsic(name),CONS(EXPRESSION,e,NIL)))

#define binary_intrinsic_expression(name, e1, e2)\
 call_to_expression(make_call(entity_intrinsic(name),\
 CONS(EXPRESSION, e1, CONS(EXPRESSION, e2, NIL))))
  
#define not_expression(e) \
    unary_intrinsic_expression(NOT_OPERATOR_NAME, e)
#define or_expression(e1, e2) \
    binary_intrinsic_expression(OR_OPERATOR_NAME, e1, e2)
#define and_expression(e1, e2) \
    binary_intrinsic_expression(AND_OPERATOR_NAME, e1, e2)
#define ne_expression(e1, e2) \
    binary_intrinsic_expression(NON_EQUAL_OPERATOR_NAME, e1, e2)
#define eq_expression(e1, e2) \
    binary_intrinsic_expression(EQUAL_OPERATOR_NAME, e1, e2)
#define gt_expression(e1, e2) \
    binary_intrinsic_expression(GREATER_THAN_OPERATOR_NAME, e1, e2)
#define ge_expression(e1, e2) \
    binary_intrinsic_expression(GREATER_OR_EQUAL_OPERATOR_NAME, e1, e2)
#define lt_expression(e1, e2) \
    binary_intrinsic_expression(LESS_THAN_OPERATOR_NAME, e1, e2)
#define le_expression(e1, e2) \
    binary_intrinsic_expression(LESS_OR_EQUAL_OPERATOR_NAME, e1, e2)


/******************************************************** CONTROL GRAPH... */
/* For the control graph modifiers: */

/* To specify the way that remove_a_control_from_a_list_and_relink
   acts: */
enum remove_a_control_from_a_list_and_relink_direction 
{
   /* Put some strange number to avoid random clash as much as
      possible... */
   source_is_predecessor_and_dest_is_successor = 119,
      source_is_successor_and_dest_is_predecessor = -123
      };
typedef enum remove_a_control_from_a_list_and_relink_direction
remove_a_control_from_a_list_and_relink_direction;


/********************************************************* DUMMY VARIABLES */
#define PRIME_LETTER_FOR_VARIABLES	"p"

/* define to build the _dummy and _prime of a variable.
 */
#define GET_DUMMY_VARIABLE_ENTITY(MODULE, NAME, lname)\
entity get_ith_##lname##_dummy(int i)\
    {return(get_ith_dummy(MODULE, NAME, i));}\
entity get_ith_##lname##_prime(int i)\
    {return(get_ith_dummy(MODULE, NAME PRIME_LETTER_FOR_VARIABLES, i));}

/* Constants for some ex-atomizer variable generation */
#define TMP_ENT 1
#define AUX_ENT 2
#define DOUBLE_PRECISION_SIZE 8


/***************************************************** HPF/HPFC DIRECTIVES */

/* moved here because needed by syntax:-(
 */
/* Directive names encoding: HPF_PREFIX + one character.
 * This encoding is achieved thru a sed script that transforms directives 
 * into calls that can be parsed by the PIPS F77 parser. It's a hack but 
 * it greatly reduced the number of lines for directive analysis, and 
 * it allowed quite simply to figure out where the executable directives
 * are in the code.
 * However the syntax allowed in mapping directives is restricted to F77.
 */

/* prefix for spacial directive calls
 */
#define HPF_PREFIX		"HPFC"

/* suffixies for encoded hpf keywords
 */
#define BLOCK_SUFFIX		"K"
#define CYCLIC_SUFFIX		"C"
#define STAR_SUFFIX		"S"

/* suffixes for HPF directives managed by HPFC
 */
#define ALIGN_SUFFIX		"A"
#define REALIGN_SUFFIX		"B"
#define DISTRIBUTE_SUFFIX	"D"
#define REDISTRIBUTE_SUFFIX	"E"
#define INDEPENDENT_SUFFIX	"I"
#define NEW_SUFFIX		"N"
#define REDUCTION_SUFFIX	"R"
#define PROCESSORS_SUFFIX	"P"
#define TEMPLATE_SUFFIX		"T"
#define PURE_SUFFIX		"U"
#define DYNAMIC_SUFFIX		"Y"

/* suffixes for my own (FCD:-) directives.
 * these directives are used to instrument the code. 
 * must be used carefully. may be ignore with some properties.
 */
#define TELL_SUFFIX		"0"
#define SYNCHRO_SUFFIX		"1"
#define TIMEON_SUFFIX		"2"
#define TIMEOFF_SUFFIX		"3"
#define SETBOOL_SUFFIX		"4"
#define SETINT_SUFFIX		"5"
#define HPFCIO_SUFFIX		"6"
#define HOSTSECTION_SUFFIX	"7"
#define DEAD_SUFFIX		"8"
#define FAKE_SUFFIX		"9"

/* property prefix for ignoring FCD directives
 * TIME, SYNCHRO and SET exists.
 */
#define FCD_IGNORE_PREFIX	"HPFC_IGNORE_FCD_"

/* soft block->sequence transition
 */
#ifdef is_instruction_sequence
#define is_instruction_block is_instruction_sequence
#define instruction_block_p(i) instruction_sequence_p(i)
#define instruction_block(i) sequence_statements(instruction_sequence(i))
#endif

/* After the modification in Newgen:  unstructured = entry:control x exit:control
   we have create a macro to transform automatically unstructured_control to unstructured_entry */
#define unstructured_control unstructured_entry

/* Default type sizes */

#define DEFAULT_INTEGER_TYPE_SIZE (4)
#define DEFAULT_REAL_TYPE_SIZE (4)
#define DEFAULT_DOUBLEPRECISION_TYPE_SIZE (8)
#define DEFAULT_COMPLEX_TYPE_SIZE (8)
#define DEFAULT_DOUBLECOMPLEX_TYPE_SIZE (16)
#define DEFAULT_LOGICAL_TYPE_SIZE (4)
#define DEFAULT_CHARACTER_TYPE_SIZE (1)

/* Implicit variables to handle IO effetcs */

/* package name for io routines */
#define IO_EFFECTS_PACKAGE_NAME "__IO_EFFECTS"
/* array of Logical UNits; it is more or less handled as the current file pointer */
#define IO_EFFECTS_ARRAY_NAME "LUNS"
/* array of end of file codes */
#define IO_EOF_ARRAY_NAME "END_LUNS"
/* array of error codes for LUNs */
#define IO_ERROR_ARRAY_NAME "ERR_LUNS"
/* size of the unit specifier */
#define IO_EFFECTS_UNIT_SPECIFIER_LENGTH 4
/* Standard unit numbers depend on the operating system. Here are UNIX definitions. */
#define STDERR_LUN (0)
#define STDIN_LUN (5)
#define STDOUT_LUN (6)

/* Empty comments (i.e. default comments) */

#define empty_comments string_undefined

/* Macro to walk through controls reachable from the entry node of an
 * unstructured. Reachability is defined by successors and predecessors
 * (i.e. the control flow graph is seen as non-directed.
 *
 * A list of control is built. Most of the time, it must be freed
 * on exit from CONTROL_MAP().
 */

/*
#define CONTROL_MAP( ctl, code, c, list ) \
{ \
    cons *_cm_list_init = (list) ; \
    cons *_cm_list = _cm_list_init ; \
    if( _cm_list == NIL ) {\
	 get_blocs( c, &_cm_list ) ; \
         _cm_list = gen_nreverse( _cm_list ) ; \
    }\
    MAPL( _cm_ctls, {control ctl = CONTROL( CAR( _cm_ctls )) ; \
 \
		 code ;}, \
	  _cm_list ) ; \
   if( _cm_list_init == NIL ) \
        list = _cm_list ; \
}
*/

#define CONTROL_MAP( ctl, code, c, list ) \
    GENERIC_CONTROL_MAP( control_map_get_blocs, ctl, code, c, list ) 

#define BACKWARD_CONTROL_MAP( ctl, code, c, list ) \
    GENERIC_CONTROL_MAP( backward_control_map_get_blocs, ctl, code, c, list ) 

#define FORWARD_CONTROL_MAP( ctl, code, c, list ) \
    GENERIC_CONTROL_MAP( forward_control_map_get_blocs, ctl, code, c, list ) 

#define WIDE_FORWARD_CONTROL_MAP( ctl, code, c, list ) \
    GENERIC_CONTROL_MAP( wide_forward_control_map_get_blocs, ctl, code, c, list ) 

#define GENERIC_CONTROL_MAP( get_controls, ctl, code, c, list ) \
{ \
    cons *_cm_list_init = (list) ; \
    cons *_cm_list = _cm_list_init ; \
    if( _cm_list == NIL ) {\
	 get_controls( c, &_cm_list ) ; \
         _cm_list = gen_nreverse( _cm_list ) ; \
    }\
    MAPL( _cm_ctls, {control ctl = CONTROL( CAR( _cm_ctls )) ; \
 \
		 code ;}, \
	  _cm_list ) ; \
   if( _cm_list_init == NIL ) \
        list = _cm_list ; \
}

/* that is all for ri-util-local.h
 */
/* contrainte_to_text.c */
extern void vect_debug(Pvecteur /*v*/);
extern int compare_Pvecteur(Pvecteur */*pv1*/, Pvecteur */*pv2*/);
extern void sc_syst_debug(Psysteme /*s*/);
extern void inegalite_debug(Pcontrainte /*c*/);
extern void egalite_debug(Pcontrainte /*c*/);
extern char *contrainte_text_format(char */*aux_line*/, char */*continuation*/, text /*txt*/, Pcontrainte /*c*/, boolean /*is_inegalite*/, char *(* /*variable_name*/)(Variable), boolean /*a_la_fortran*/, boolean /*first_line*/);
extern char *egalite_text_format(char */*aux_line*/, char */*continuation*/, text /*txt*/, Pcontrainte /*eg*/, char *(* /*variable_name*/)(void), bool /*a_la_fortran*/, bool /*first_line*/);
extern char *inegalite_text_format(char */*aux_line*/, char */*continuation*/, text /*txt*/, Pcontrainte /*ineg*/, char *(* /*variable_name*/)(void), boolean /*a_la_fortran*/, boolean /*first_line*/);
extern void system_sorted_text_format(string /*line*/, string /*prefix*/, text /*txt*/, Psysteme /*ps*/, string (* /*variable_name*/)(Variable), bool (* /*put_first*/)(Pvecteur), bool /*a_la_fortran*/);
extern void system_text_format(string /*line*/, string /*prefix*/, text /*txt*/, Psysteme /*ps*/, string (* /*variable_name*/)(Variable), bool /*a_la_fortran*/);
extern void entity_list_text_format(string /*line*/, string /*continuation*/, text /*t*/, list /*le*/, string (* /*var_name*/)(entity));
/* eval.c */
extern value EvalExpression(expression /*e*/);
extern value EvalSyntax(syntax /*s*/);
extern value EvalCall(call /*c*/);
extern value EvalConstant(constant /*c*/);
extern value EvalIntrinsic(entity /*e*/, list /*la*/);
extern value EvalUnaryOp(int /*t*/, list /*la*/);
extern value EvalBinaryOp(int /*t*/, list /*la*/);
extern value EvalNaryOp(int /*t*/, list /*la*/);
extern int IsUnaryOperator(entity /*e*/);
extern int IsBinaryOperator(entity /*e*/);
extern int IsNaryOperator(entity /*e*/);
extern int ipow(int /*vg*/, int /*vd*/);
extern bool expression_integer_value(expression /*e*/, int */*pval*/);
extern bool range_count(range /*r*/, int */*pcount*/);
extern Pvecteur vect_product(Pvecteur */*pv1*/, Pvecteur */*pv2*/);
/* size.c */
extern bool SizeOfArray(entity /*e*/, int */*s*/);
extern int array_size(entity /*a*/);
extern Value ValueSizeOfArray(entity /*e*/);
extern int SizeOfElements(basic /*b*/);
extern int element_number(list /*ld*/);
extern bool NumberOfElements(list /*ld*/, int */*n*/);
extern Value ValueNumberOfElements(list /*ld*/);
extern int SizeOfIthDimension(entity /*e*/, int /*i*/);
extern int dimension_size(dimension /*d*/);
extern bool SizeOfDimension(dimension /*d*/, int */*s*/);
extern Value ValueSizeOfDimension(dimension /*d*/);
extern int ExpressionToInt(expression /*e*/);
extern int NumberOfDimension(entity /*e*/);
extern void set_entity_to_size(void);
extern void reset_entity_to_size(void);
extern int storage_space_of_variable(entity /*v*/);
extern bool entity_conflict_p(entity /*e1*/, entity /*e2*/);
/* util.c */
extern string local_name(string /*s*/);
extern string make_entity_fullname(string /*module_name*/, string /*local_name*/);
extern bool empty_local_label_name_p(string /*s*/);
extern bool return_local_label_name_p(string /*s*/);
extern bool empty_label_p(string /*s*/);
extern bool return_label_p(string /*s*/);
extern entity find_label_entity(string /*module_name*/, string /*label_local_name*/);
extern string module_name(string /*s*/);
extern string string_codefilename(char */*s*/);
extern string module_codefilename(entity /*e*/);
extern string string_par_codefilename(char */*s*/);
extern string module_par_codefilename(entity /*e*/);
extern string string_fortranfilename(char */*s*/);
extern string module_fortranfilename(entity /*e*/);
extern string string_par_fortranfilename(char */*s*/);
extern string module_par_fortranfilename(entity /*e*/);
extern string string_pp_fortranfilename(char */*s*/);
extern string module_pp_fortranfilename(entity /*e*/);
extern string string_predicat_fortranfilename(char */*s*/);
extern string module_predicat_fortranfilename(entity /*e*/);
extern string string_entitiesfilename(char */*s*/);
extern string module_entitiesfilename(entity /*e*/);
extern expression make_entity_expression(entity /*e*/, cons */*inds*/);
extern string new_label_name(entity /*module*/);
extern entity find_ith_parameter(entity /*e*/, int /*i*/);
extern bool ith_parameter_p(entity /*f*/, entity /*v*/, int /*i*/);
extern entity effect_entity(effect /*e*/);
extern expression reference_ith_index(reference /*ref*/, int /*i*/);
extern bool dynamic_area_p(entity /*aire*/);
extern bool static_area_p(entity /*aire*/);
extern bool heap_area_p(entity /*aire*/);
extern bool stack_area_p(entity /*aire*/);
extern bool comment_string_p(const string /*comment*/);
/* ordering.c */
extern bool ordering_to_statement_initialized_p(void);
extern void print_ordering_to_statement(void);
extern statement ordering_to_statement(int /*o*/);
extern void initialize_ordering_to_statement(statement /*s*/);
extern void reset_ordering_to_statement(void);
/* prettyprint.c */
extern char lib_ri_util_prettyprint_c_rcsid[];
extern text empty_text(entity /*e*/, int /*m*/, statement /*s*/);
extern void init_prettyprint(text (* /*hook*/)(entity, int, statement));
extern void close_prettyprint(void);
extern list words_loop_range(range /*obj*/);
extern list words_range(range /*obj*/);
extern list words_subscript_range(range /*obj*/);
extern list words_reference(reference /*obj*/);
extern list words_goto_label(string /*tlabel*/);
extern list eole_fma_specific_op(call /*obj*/, int /*precedence*/, bool /*leftmost*/);
extern list eole_fms_specific_op(call /*obj*/, int /*precedence*/, bool /*leftmost*/);
extern list words_call(call /*obj*/, int /*precedence*/, bool /*leftmost*/, bool /*is_a_subroutine*/);
extern list words_syntax(syntax /*obj*/);
extern list words_expression(expression /*obj*/);
extern list words_subexpression(expression /*obj*/, int /*precedence*/, bool /*leftmost*/);
extern sentence sentence_goto_label(entity /*module*/, string /*label*/, int /*margin*/, string /*tlabel*/, int /*n*/);
extern text text_loop_default(entity /*module*/, string /*label*/, int /*margin*/, loop /*obj*/, int /*n*/);
extern text text_loop(entity /*module*/, string /*label*/, int /*margin*/, loop /*obj*/, int /*n*/);
extern text init_text_statement(entity /*module*/, int /*margin*/, statement /*obj*/);
extern void set_prettyprinter_head_hook(string (* /*f*/)(entity));
extern void reset_prettyprinter_head_hook(void);
extern text text_statement(entity /*module*/, int /*margin*/, statement /*stmt*/);
extern statement find_last_statement(statement /*s*/);
extern void set_last_statement(statement /*s*/);
extern void reset_last_statement(void);
extern bool last_statement_p(statement /*s*/);
extern text text_named_module(entity /*name*/, entity /*module*/, statement /*stat*/);
extern text text_module(entity /*module*/, statement /*stat*/);
extern void output_a_graph_view_of_the_unstructured_successors(text /*r*/, entity /*module*/, int /*margin*/, control /*c*/);
extern bool output_a_graph_view_of_the_unstructured_from_a_control(text /*r*/, entity /*module*/, int /*margin*/, control /*begin_control*/, control /*exit_control*/);
extern void output_a_graph_view_of_the_unstructured(text /*r*/, entity /*module*/, string /*label*/, int /*margin*/, unstructured /*u*/, int /*num*/);
/* declarations.c */
extern list words_declaration(entity /*e*/, bool /*prettyprint_common_variable_dimensions_p*/);
extern sentence sentence_variable(entity /*e*/);
extern sentence sentence_head(entity /*e*/);
extern void set_prettyprinter_common_hook(string (* /*f*/)(entity, entity));
extern void reset_prettyprinter_common_hook(void);
extern text text_declaration(entity /*module*/);
extern text text_common_declaration(entity /*common*/, entity /*module*/);
/* unstructured.c */
extern text text_unstructured(entity /*module*/, string /*label*/, int /*margin*/, unstructured /*u*/, int /*num*/);
extern list unstructured_to_trail(unstructured /*u*/);
extern void dump_trail(list /*trail*/);
extern void dump_control_to_label_name(hash_table /*h*/);
/* attachment_pretty_print.c */
extern list attachments_before_sorting;
extern void begin_attachment_prettyprint(void);
extern void end_attachment_prettyprint(void);
extern void attach_loop_to_sentence_up_to_end_of_text(sentence /*s*/, text /*t*/, loop /*l*/);
extern sentence attach_head_to_sentence(sentence /*s*/, entity /*module*/);
extern void attach_reference_to_word_list(string /*begin_word*/, string /*end_word*/, reference /*r*/);
extern void attach_regular_call_to_word(string /*word*/, call /*c*/);
extern void attach_declaration_to_words(list /*l*/, entity /*e*/);
extern void attach_declaration_type_to_words(list /*l*/, string /*declaration_type*/);
extern void attach_declaration_size_type_to_words(list /*l*/, string /*declaration_type*/, int /*size*/);
extern void attach_statement_information_to_text(text /*t*/, statement /*s*/);
extern void attach_decoration_to_text(text /*t*/);
extern void attach_cumulated_effects_decoration_to_text(text /*t*/);
extern void attach_proper_effects_decoration_to_text(text /*t*/);
extern void attach_preconditions_decoration_to_text(text /*t*/);
extern void attach_total_preconditions_decoration_to_text(text /*t*/);
extern void attach_transformers_decoration_to_text(text /*t*/);
extern void deal_with_attachments_at_this_character(char */*a_character*/, int /*position_in_the_output*/);
extern void deal_with_attachments_in_this_string(string /*a_string*/, int /*position_in_the_output*/);
extern void deal_with_attachments_in_this_string_length(string /*a_string*/, int /*position_in_the_output*/, int /*a_length*/);
extern void relocate_attachments(char */*source*/, char */*new_position*/);
extern char *strcat_word_and_migrate_attachments(char */*target*/, char */*source*/);
extern char *strdup_and_migrate_attachments(char */*a_string*/);
extern void write_an_attachment_file(string /*file_name*/);
/* loop.c */
extern bool enclosing_loops_map_undefined_p(void);
extern void set_enclosing_loops_map(statement_mapping /*m*/);
extern statement_mapping get_enclosing_loops_map(void);
extern void reset_enclosing_loops_map(void);
extern void free_enclosing_loops_map(void);
extern void make_enclosing_loops_map(void);
extern list load_statement_enclosing_loops(statement /*s*/);
extern bool statement_enclosing_loops_undefined_p(statement /*s*/);
extern void store_statement_enclosing_loops(statement /*s*/, list /*t*/);
extern void update_statement_enclosing_loops(statement /*s*/, list /*t*/);
extern void clean_enclosing_loops(void);
extern statement_mapping loops_mapping_of_statement(statement /*stat*/);
extern set distributable_loop(statement /*l*/);
extern bool index_private_p(loop /*lo*/);
extern set region_of_loop(statement /*l*/);
extern void region_of_statement(statement /*stat*/, set /*region*/);
extern void sort_all_loop_locals(statement /*s*/);
/* fortran90.c */
extern expression update_range(entity /*f*/, range /*r*/, expression /*lw*/, expression /*up*/, expression /*in*/, bool /*left*/);
extern expression expand_reference(syntax /*s*/, expression /*e*/, entity /*i*/, range /*r*/);
extern expression expand_expression(expression /*e*/, entity /*i*/, range /*r*/);
extern text text_loop_90(entity /*module*/, string /*label*/, int /*margin*/, loop /*obj*/, int /*n*/);
/* constant.c */
extern entity find_entity_1(void);
extern expression make_expression_1(void);
extern int DefaultLengthOfBasic(tag /*t*/);
extern entity make_constant_entity(string /*name*/, tag /*bt*/, int /*size*/);
extern entity MakeConstant(string /*name*/, tag /*bt*/);
extern entity MakeComplexConstant(expression /*r*/, expression /*i*/);
extern expression MakeComplexConstantExpression(expression /*r*/, expression /*i*/);
extern expression MakeIntegerConstantExpression(string /*s*/);
extern expression make_constant_boolean_expression(bool /*b*/);
extern expression int_expr(int /*i*/);
extern bool integer_constant_p(entity /*ent*/, int */*int_p*/);
extern bool integer_symbolic_constant_p(entity /*ent*/, int */*int_p*/);
extern expression MakeCharacterConstantExpression(string /*s*/);
extern value MakeValueSymbolic(expression /*e*/);
extern bool signed_constant_expression_p(expression /*e*/);
extern basic constant_basic(entity /*c*/);
extern double float_constant_to_double(entity /*c*/);
extern bool expression_is_constant_p(expression /*e*/);
/* bound_generation.c */
extern string nom_de_variable(string /*e*/);
extern expression make_contrainte_expression(Pcontrainte /*pc*/, Variable /*index*/);
extern void make_bound_expression(Variable /*index*/, Pbase /*base*/, Psysteme /*sc*/, expression */*lower*/, expression */*upper*/);
/* entity.c */
extern entity make_empty_program(string /*name*/);
extern entity make_empty_subroutine(string /*name*/);
extern entity make_empty_function(string /*name*/, type /*r*/);
extern entity make_empty_blockdata(string /*name*/);
extern code EntityCode(entity /*e*/);
extern entity make_label(string /*strg*/);
extern entity make_new_label(char */*module_name*/);
extern entity make_loop_label(int /*desired_number*/, char */*module_name*/);
extern string entity_local_name(entity /*e*/);
extern string module_local_name(entity /*e*/);
extern string label_local_name(entity /*e*/);
extern string entity_minimal_name(entity /*e*/);
extern string entity_and_common_name(entity /*e*/);
extern bool entity_empty_label_p(entity /*e*/);
extern bool entity_return_label_p(entity /*e*/);
extern bool entity_label_p(entity /*e*/);
extern bool entity_module_p(entity /*e*/);
extern bool entity_main_module_p(entity /*e*/);
extern bool entity_blockdata_p(entity /*e*/);
extern bool entity_common_p(entity /*e*/);
extern bool entity_function_p(entity /*e*/);
extern bool entity_subroutine_p(entity /*e*/);
extern bool local_entity_of_module_p(entity /*e*/, entity /*module*/);
extern bool entity_in_common_p(entity /*e*/);
extern string entity_module_name(entity /*e*/);
extern code entity_code(entity /*e*/);
extern entity entity_empty_label(void);
extern bool top_level_entity_p(entity /*e*/);
extern bool io_entity_p(entity /*e*/);
extern bool intrinsic_entity_p(entity /*e*/);
extern entity entity_intrinsic(string /*name*/);
extern entity CreateIntrinsic(string /*name*/);
extern bool same_entity_p(entity /*e1*/, entity /*e2*/);
extern int compare_entities(entity */*pe1*/, entity */*pe2*/);
extern void sort_list_of_entities(list /*l*/);
extern bool lexicographic_order_p(entity /*var1*/, entity /*var2*/);
extern basic entity_basic(entity /*e*/);
extern bool entity_basic_p(entity /*e*/, int /*basictag*/);
extern entity local_name_to_top_level_entity(string /*n*/);
extern entity global_name_to_entity(string /*m*/, string /*n*/);
extern entity find_or_create_entity(string /*full_name*/);
extern entity FindOrCreateEntity(string /*package*/, string /*name*/);
extern constant MakeConstantLitteral(void);
extern storage MakeStorageRom(void);
extern value MakeValueUnknown(void);
extern expression entity_ith_bounds(entity /*e*/, int /*i*/);
extern bool io_intrinsic_p(entity /*e*/);
extern bool entity_continue_p(entity /*f*/);
extern list common_members_of_module(entity /*common*/, entity /*module*/, bool /*only_primary*/);
extern bool check_common_inclusion(entity /*common*/);
extern entity find_ith_formal_parameter(entity /*the_fnct*/, int /*rank*/);
extern bool some_main_entity_p(void);
extern list string_to_entity_list(string /*module*/, string /*names*/);
/* variable.c */
extern bool variable_entity_p(entity /*e*/);
extern bool symbolic_constant_entity_p(entity /*e*/);
extern void AddEntityToDeclarations(entity /*e*/, entity /*f*/);
extern entity make_scalar_entity(string /*name*/, string /*module_name*/, basic /*base*/);
extern void reset_unique_variable_numbers(void);
extern entity make_new_scalar_variable_with_prefix(string /*prefix*/, entity /*module*/, basic /*b*/);
extern entity make_new_scalar_variable(entity /*module*/, basic /*b*/);
extern entity find_or_create_scalar_entity(string /*name*/, string /*module_name*/, tag /*base*/);
extern entity find_or_create_typed_entity(string /*name*/, string /*module_name*/, tag /*base*/);
extern entity make_scalar_integer_entity(char */*name*/, char */*module_name*/);
extern bool entity_scalar_p(entity /*e*/);
extern bool entity_integer_scalar_p(entity /*e*/);
extern bool integer_scalar_entity_p(entity /*e*/);
extern dimension entity_ith_dimension(entity /*e*/, int /*i*/);
extern boolean entity_unbounded_p(entity /*e*/);
extern bool array_with_numerical_bounds_p(entity /*a*/);
extern int variable_entity_dimension(entity /*v*/);
extern void remove_variable_entity(entity /*v*/);
extern entity make_integer_constant_entity(int /*c*/);
extern int add_variable_to_area(entity /*a*/, entity /*v*/);
extern void add_variable_declaration_to_module(entity /*m*/, entity /*v*/);
extern bool formal_parameter_p(entity /*v*/);
extern bool variable_return_p(entity /*v*/);
extern bool variable_is_a_module_formal_parameter_p(entity /*a_variable*/, entity /*a_module*/);
extern bool variable_in_common_p(entity /*v*/);
extern bool variable_static_p(entity /*v*/);
extern bool variable_dynamic_p(entity /*v*/);
extern bool variable_in_module_p(entity /*v*/, entity /*m*/);
extern bool variable_in_list_p(entity /*e*/, list /*l*/);
extern void discard_module_declaration_text(entity /*a_module*/);
extern entity get_ith_dummy(string /*prefix*/, string /*suffix*/, int /*i*/);
extern entity make_new_module_variable(entity /*module*/, int /*d*/);
extern entity make_new_entity(basic /*ba*/, int /*kind*/);
/* statement.c */
extern bool empty_code_p(statement /*s*/);
extern bool empty_code_list_p(list /*l*/);
extern void flatten_block_if_necessary(instruction /*i*/);
extern void number_of_sequential_and_parallel_loops(statement /*stat*/, int */*pseq*/, int */*ppar*/);
extern void print_number_of_loop_statistics(FILE */*out*/, string /*msg*/, statement /*s*/);
extern void print_parallelization_statistics(string /*module*/, string /*msg*/, statement /*s*/);
extern bool empty_comments_p(string /*s*/);
extern bool empty_statement_p(statement /*st*/);
extern bool assignment_statement_p(statement /*s*/);
extern bool return_statement_p(statement /*s*/);
extern bool continue_statement_p(statement /*s*/);
extern bool stop_statement_p(statement /*s*/);
extern bool format_statement_p(statement /*s*/);
extern bool statement_less_p(statement /*st1*/, statement /*st2*/);
extern bool statement_possible_less_p(statement /*st1*/, statement /*st2*/);
extern bool block_statement_p(statement /*s*/);
extern bool statement_test_p(statement /*s*/);
extern bool statement_loop_p(statement /*s*/);
extern bool unstructured_statement_p(statement /*s*/);
extern bool statement_continue_p(statement /*s*/);
extern bool unlabelled_statement_p(statement /*st*/);
extern bool nop_statement_p(statement /*s*/);
extern bool empty_statement_or_labelless_continue_p(statement /*st*/);
extern bool empty_statement_or_continue_p(statement /*st*/);
extern bool empty_statement_or_continue_without_comment_p(statement /*st*/);
extern bool statement_call_p(statement /*s*/);
extern bool check_io_statement_p(statement /*s*/);
extern bool perfectly_nested_loop_p(statement /*stat*/);
extern bool assignment_block_p(instruction /*i*/);
extern statement make_empty_statement(void);
extern statement make_stmt_of_instr(instruction /*instr*/);
extern instruction make_assign_instruction(expression /*l*/, expression /*r*/);
extern statement make_assign_statement(expression /*l*/, expression /*r*/);
extern statement make_block_statement_with_stop(void);
extern statement make_nop_statement(void);
extern statement make_empty_block_statement(void);
extern statement make_block_statement(list /*body*/);
extern instruction make_instruction_block(list /*statements*/);
extern statement make_return_statement(entity /*module*/);
extern statement make_stop_statement(string /*message*/);
extern void insure_return_as_last_statement(entity /*module*/, statement */*ps*/);
extern instruction make_continue_instruction(void);
extern statement make_continue_statement(entity /*l*/);
extern instruction MakeUnaryCallInst(entity /*f*/, expression /*e*/);
extern expression MakeNullaryCall(entity /*f*/);
extern expression MakeUnaryCall(entity /*f*/, expression /*a*/);
extern statement make_call_statement(string /*function_name*/, list /*args*/, entity /*l*/, string /*c*/);
extern statement perfectly_nested_loop_to_body(statement /*loop_nest*/);
extern loop statement_loop(statement /*s*/);
extern test statement_test(statement /*s*/);
extern call statement_call(statement /*s*/);
extern list statement_block(statement /*s*/);
extern bool instruction_assign_p(instruction /*i*/);
extern bool instruction_continue_p(instruction /*i*/);
extern bool instruction_return_p(instruction /*i*/);
extern bool instruction_stop_p(instruction /*i*/);
extern bool instruction_format_p(instruction /*i*/);
extern bool fortran_instruction_p(instruction /*i*/, string /*s*/);
extern int loop_increment_value(loop /*l*/);
extern bool assignment_block_or_statement_p(statement /*s*/);
extern void print_statement_set(FILE */*fd*/, set /*r*/);
extern void print_statement(statement /*s*/);
extern statement apply_number_to_statement(hash_table /*nts*/, int /*n*/);
extern hash_table build_number_to_statement(hash_table /*nts*/, statement /*s*/);
extern void print_number_to_statement(hash_table /*nts*/);
extern hash_table allocate_number_to_statement(void);
extern statement clear_labels(statement /*s*/);
extern void clear_label(statement /*s*/);
extern statement list_to_statement(list /*l*/);
extern statement st_make_nice_test(expression /*condition*/, list /*ltrue*/, list /*lfalse*/);
extern statement makeloopbody(loop /*l*/, statement /*s_old*/);
extern statement make_block_with_stmt(statement /*stmt*/);
extern string instruction_identification(instruction /*i*/);
extern string statement_identification(statement /*s*/);
extern bool statement_with_empty_comment_p(statement /*s*/);
extern string gather_all_comments_of_a_statement(statement /*s*/);
extern string find_first_statement_comment(statement /*s*/);
extern bool try_to_put_a_comment_on_a_statement(statement /*s*/, string /*the_comments*/);
extern void put_a_comment_on_a_statement(statement /*s*/, string /*the_comments*/);
extern void append_comments_to_statement(statement /*s*/, string /*the_comments*/);
extern void insert_comments_to_statement(statement /*s*/, string /*the_comments*/);
extern void fix_sequence_statement_attributes(statement /*s*/);
extern void fix_sequence_statement_attributes_if_sequence(statement /*s*/);
extern entity statement_to_label(statement /*s*/);
extern bool statement_does_return(statement /*s*/);
extern bool unstructured_does_return(unstructured /*u*/);
extern void insert_a_statement_list_in_a_statement(statement /*target*/, list /*s_list*/);
extern void append_a_statement_list_to_a_statement(statement /*target*/, list /*s_list*/);
extern void gather_and_remove_all_format_statements_rewrite(statement /*s*/);
extern list gather_and_remove_all_format_statements(statement /*s*/);
extern void put_formats_at_module_beginning(statement /*s*/);
extern void put_formats_at_module_end(statement /*s*/);
extern bool figure_out_if_it_is_a_format(instruction /*i*/);
extern bool format_inside_statement_p(statement /*s*/);
extern int statement_to_comment_length(statement /*stmt*/);
extern persistant_statement_to_int statement_to_line_number(statement /*s*/);
extern void insert_statement(statement /*s*/, statement /*s1*/, bool /*before*/);
extern statement update_statement_instruction(statement /*s*/, instruction /*i*/);
extern void add_one_line_of_comment(statement /*s*/, string /*format*/, ...);
/* expression.c */
extern int fortran_string_compare(string /*fs1*/, string /*fs2*/);
extern tag suggest_basic_for_expression(expression /*e*/);
extern expression expression_dup(expression /*ex*/);
extern syntax syntax_dup(syntax /*s*/);
extern normalized normalized_dup(normalized /*n*/);
extern reference reference_dup(reference /*r*/);
extern range range_dup(range /*r*/);
extern call call_dup(call /*c*/);
extern expression expression_mult(expression /*ex*/);
extern expression entity_to_expression(entity /*e*/);
extern expression reference_to_expression(reference /*r*/);
extern expression MakeBinaryCall(entity /*f*/, expression /*eg*/, expression /*ed*/);
extern expression call_to_expression(call /*c*/);
extern expression make_call_expression(entity /*e*/, list /*l*/);
extern expression MakeTernaryCallExpr(entity /*f*/, expression /*e1*/, expression /*e2*/, expression /*e3*/);
extern bool expression_call_p(expression /*e*/);
extern bool expression_reference_p(expression /*e*/);
extern bool same_expression_in_list_p(expression /*e*/, list /*le*/);
extern bool logical_operator_expression_p(expression /*e*/);
extern bool relational_expression_p(expression /*e*/);
extern bool logical_expression_p(expression /*e*/);
extern int trivial_expression_p(expression /*e*/);
extern bool expression_implied_do_p(expression /*e*/);
extern bool expression_list_directed_p(expression /*e*/);
extern bool integer_constant_expression_p(expression /*e*/);
extern bool signed_integer_constant_expression_p(expression /*e*/);
extern bool expression_with_constant_signed_integer_value_p(expression /*e*/);
extern bool modulo_expression_p(expression /*e*/);
extern bool divide_expression_p(expression /*e*/);
extern bool power_expression_p(expression /*e*/);
extern bool iabs_expression_p(expression /*e*/);
extern bool min0_expression_p(expression /*e*/);
extern bool max0_expression_p(expression /*e*/);
extern bool user_function_call_p(expression /*e*/);
extern bool operator_expression_p(expression /*e*/, string /*op_name*/);
extern expression make_true_expression(void);
extern expression make_false_expression(void);
extern bool true_expression_p(expression /*e*/);
extern bool false_expression_p(expression /*e*/);
extern boolean unbounded_dimension_p(dimension /*dim*/);
extern expression find_ith_argument(list /*args*/, int /*n*/);
extern expression find_ith_expression(list /*le*/, int /*r*/);
extern expression int_to_expression(int /*i*/);
extern expression Value_to_expression(Value /*v*/);
extern list expression_to_reference_list(expression /*e*/, list /*lr*/);
extern list syntax_to_reference_list(syntax /*s*/, list /*lr*/);
extern void print_expression(expression /*e*/);
extern void print_expressions(list /*le*/);
extern void print_syntax_expressions(list /*le*/);
extern void print_syntax(syntax /*s*/);
extern void print_reference(reference /*r*/);
extern void print_reference_list(list /*lr*/);
extern void print_normalized(normalized /*n*/);
extern bool expression_equal_p(expression /*e1*/, expression /*e2*/);
extern bool same_expression_p(expression /*e1*/, expression /*e2*/);
extern bool syntax_equal_p(syntax /*s1*/, syntax /*s2*/);
extern bool reference_equal_p(reference /*r1*/, reference /*r2*/);
extern bool range_equal_p(range /*r1*/, range /*r2*/);
extern bool call_equal_p(call /*c1*/, call /*c2*/);
extern expression make_integer_constant_expression(int /*c*/);
extern int integer_constant_expression_value(expression /*e*/);
extern int signed_integer_constant_expression_value(expression /*e*/);
extern expression make_factor_expression(int /*coeff*/, entity /*vari*/);
extern expression make_vecteur_expression(Pvecteur /*pv*/);
extern statement Pvecteur_to_assign_statement(entity /*var*/, Pvecteur /*v*/);
extern reference expression_reference(expression /*e*/);
extern bool array_reference_p(reference /*r*/);
extern bool references_do_not_conflict_p(reference /*r1*/, reference /*r2*/);
extern expression expression_list_to_binary_operator_call(list /*l*/, entity /*op*/);
extern expression expression_list_to_conjonction(list /*l*/);
extern bool expression_intrinsic_operation_p(expression /*exp*/);
extern bool call_constant_p(call /*c*/);
extern expression Pvecteur_to_expression(Pvecteur /*vect*/);
extern bool expression_equal_integer_p(expression /*exp*/, int /*i*/);
extern expression make_op_exp(char */*op_name*/, expression /*exp1*/, expression /*exp2*/);
extern expression make_lin_op_exp(entity /*op_ent*/, expression /*exp1*/, expression /*exp2*/);
extern void unnormalize_expression(expression /*exp*/);
extern int expression_to_int(expression /*exp*/);
extern bool expression_constant_p(expression /*exp*/);
extern bool same_lexpr_name_p(list /*l1*/, list /*l2*/);
extern bool same_entity_lname_p(entity /*e1*/, entity /*e2*/);
extern bool same_call_name_p(call /*c1*/, call /*c2*/);
extern bool same_ref_name_p(reference /*r1*/, reference /*r2*/);
extern bool same_range_name_p(range /*r1*/, range /*r2*/);
extern bool same_syntax_name_p(syntax /*s1*/, syntax /*s2*/);
extern bool same_expression_name_p(expression /*e1*/, expression /*e2*/);
extern void davinci_dump_expression(FILE */*out*/, expression /*e*/);
extern void davinci_dump_all_expressions(FILE */*out*/, statement /*s*/);
extern expression substitute_entity_in_expression(entity /*old*/, entity /*new*/, expression /*e*/);
/* type.c */
extern basic MakeBasicOverloaded(void);
extern mode MakeModeReference(void);
extern mode MakeModeValue(void);
extern type MakeTypeStatement(void);
extern type MakeTypeUnknown(void);
extern type MakeTypeVoid(void);
extern type MakeTypeVariable(basic /*b*/, cons */*ld*/);
extern basic MakeBasic(int /*the_tag*/);
extern type MakeTypeArray(basic /*b*/, cons */*ld*/);
extern parameter MakeOverloadedParameter(void);
extern parameter MakeIntegerParameter(void);
extern parameter MakeRealParameter(void);
extern parameter MakeDoubleprecisionParameter(void);
extern parameter MakeLogicalParameter(void);
extern parameter MakeComplexParameter(void);
extern parameter MakeDoublecomplexParameter(void);
extern parameter MakeCharacterParameter(void);
extern parameter MakeAnyScalarParameter(tag /*t*/, int /*size*/);
extern type MakeOverloadedResult(void);
extern type MakeIntegerResult(void);
extern type MakeRealResult(void);
extern type MakeDoubleprecisionResult(void);
extern type MakeLogicalResult(void);
extern type MakeComplexResult(void);
extern type MakeDoublecomplexResult(void);
extern type MakeCharacterResult(void);
extern type MakeAnyScalarResult(tag /*t*/, int /*size*/);
extern bool type_equal_p(type /*t1*/, type /*t2*/);
extern type make_scalar_integer_type(int /*n*/);
extern bool area_equal_p(area /*a1*/, area /*a2*/);
extern bool dimension_equal_p(dimension /*d1*/, dimension /*d2*/);
extern bool variable_equal_p(variable /*v1*/, variable /*v2*/);
extern bool basic_equal_p(basic /*b1*/, basic /*b2*/);
extern bool functional_equal_p(functional /*f1*/, functional /*f2*/);
extern bool parameter_equal_p(parameter /*p1*/, parameter /*p2*/);
extern bool mode_equal_p(mode /*m1*/, mode /*m2*/);
extern int string_type_size(basic /*b*/);
extern int basic_type_size(basic /*b*/);
extern basic expression_basic(expression /*expr*/);
extern basic please_give_me_a_basic_for_an_expression(expression /*e*/);
extern dimension dimension_dup(dimension /*d*/);
extern list ldimensions_dup(list /*l*/);
extern dimension FindIthDimension(entity /*e*/, int /*i*/);
extern string type_to_string(type /*t*/);
extern string basic_to_string(basic /*b*/);
extern basic basic_of_expression(expression /*exp*/);
extern basic basic_of_call(call /*c*/);
extern basic basic_of_external(call /*c*/);
extern basic basic_of_intrinsic(call /*c*/);
extern basic basic_of_constant(call /*c*/);
extern basic basic_union(expression /*exp1*/, expression /*exp2*/);
extern basic basic_maximum(basic /*b1*/, basic /*b2*/);
extern bool overloaded_type_p(type /*t*/);
extern bool is_inferior_basic(basic /*b1*/, basic /*b2*/);
extern basic simple_basic_dup(basic /*b*/);
extern entity basic_to_generic_conversion(basic /*b*/);
/* normalize.c */
extern normalized NormalizeExpression(expression /*e*/);
extern normalized NormalizeSyntax(syntax /*s*/);
extern normalized NormalizeCall(call /*c*/);
extern normalized NormalizeConstant(constant /*c*/);
extern normalized NormalizeReference(reference /*r*/);
extern normalized NormalizeIntrinsic(entity /*e*/, list /*la*/);
extern normalized binary_to_normalized(list /*la*/, int /*op*/);
extern bool EvalNormalized(normalized /*n*/, int */*pv*/);
extern void FreeNormalized(normalized /*n*/);
extern void free_expression_normalized(expression /*e*/);
extern void recursive_free_normalized(void */*st*/);
extern Pvecteur expression_to_affine(expression /*e*/);
extern normalized normalize_reference(reference /*r*/);
extern void normalize_all_expressions_of(void */*obj*/);
extern void normalize_first_expressions_of(void */*obj*/);
/* static.c */
extern void set_current_module_entity(entity /*e*/);
extern entity get_current_module_entity(void);
extern void reset_current_module_entity(void);
extern void error_reset_current_module_entity(void);
extern string get_current_module_name(void);
extern void set_current_module_statement(statement /*s*/);
extern statement get_current_module_statement(void);
extern void reset_current_module_statement(void);
extern void error_reset_current_module_statement(void);
/* arguments.c */
extern void print_arguments(cons */*args*/);
extern void dump_arguments(cons */*args*/);
extern cons *arguments_add_entity(cons */*a*/, entity /*e*/);
extern cons *arguments_rm_entity(cons */*a*/, entity /*e*/);
extern cons *arguments_union(cons */*a1*/, cons */*a2*/);
extern bool arguments_equal_p(cons */*a1*/, cons */*a2*/);
extern bool entity_is_argument_p(entity /*e*/, cons */*args*/);
extern cons *arguments_intersection(cons */*a1*/, cons */*a2*/);
extern void free_arguments(cons */*args*/);
extern cons *dup_arguments(cons */*args*/);
extern cons *arguments_difference(cons */*a1*/, cons */*a2*/);
/* module.c */
extern bool variable_in_module_p2(entity /*v*/, entity /*m*/);
extern void variable_declaration_verify(reference /*ref*/);
extern void symbolic_constant_declaration_verify(call /*c*/);
extern void add_non_declared_reference_to_declaration(reference /*ref*/);
extern void add_symbolic_constant_to_declaration(call /*c*/);
extern bool variable_declaration_coherency_p(entity /*module*/, statement /*st*/);
extern bool referenced_variables_undefined_p(void);
extern void reset_referenced_variables(void);
extern void error_reset_referenced_variables(void);
extern void set_referenced_variables(entity_int /*o*/);
extern entity_int get_referenced_variables(void);
extern void init_referenced_variables(void);
extern void close_referenced_variables(void);
extern void store_referenced_variables(entity /*k*/, int /*v*/);
extern void update_referenced_variables(entity /*k*/, int /*v*/);
extern int load_referenced_variables(entity /*k*/);
extern int delete_referenced_variables(entity /*k*/);
extern bool bound_referenced_variables_p(entity /*k*/);
extern void store_or_update_referenced_variables(entity /*k*/, int /*v*/);
extern void insure_global_declaration_coherency(entity /*module*/, statement /*stat*/, list /*le*/);
extern void insure_declaration_coherency(entity /*module*/, statement /*stat*/, list /*le*/);
extern void insure_declaration_coherency_of_module(entity /*module*/, statement /*stat*/);
extern sentence get_header_comments(entity /*module*/);
extern sentence get_declaration_comments(entity /*module*/);
extern list module_formal_parameters(entity /*func*/);
extern int module_to_declaration_length(entity /*func*/);
/* effects.c */
extern effects list_to_effects(list /*l_eff*/);
extern list effects_to_list(effects /*efs*/);
extern statement_mapping listmap_to_effectsmap(statement_mapping /*l_map*/);
extern statement_mapping effectsmap_to_listmap(statement_mapping /*efs_map*/);
extern bool statement_has_a_module_formal_argument_write_effect_p(statement /*s*/, entity /*module*/, statement_mapping /*effects_list_map*/);
/* cmfortran.c */
extern cons *words_cmf_loop_range(range /*obj*/);
extern text text_loop_cmf(entity /*module*/, string /*label*/, int /*margin*/, loop /*obj*/, int /*n*/, list /*lr*/, list /*lidx*/);
/* craft.c */
extern expression remove_modulo(expression /*exp*/);
extern text text_loop_craft(entity /*module*/, string /*label*/, int /*margin*/, loop /*obj*/, int /*n*/, list /*lr*/, list /*lidx*/);
/* control.c */
extern char vcid_ri_util_control[];
extern void control_map_get_blocs(control /*c*/, cons **/*l*/);
extern void backward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern void backward_control_map_get_blocs_but(control /*c*/, control /*f*/, list */*l*/);
extern void forward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern void forward_control_map_get_blocs_but(control /*c*/, control /*f*/, list */*l*/);
extern void wide_forward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern bool is_control_in_list_p(control /*c*/, list /*cs*/);
extern int occurences_in_control_list(control /*c*/, list /*cs*/);
extern void check_control_coherency(control /*c*/);
extern void display_address_of_control_nodes(list /*cs*/);
extern void display_linked_control_nodes(control /*c*/);
extern void remove_unreachable_following_control(control /*c*/, control /*do_not_delete_node*/, control /*do_not_delete_node_either*/);
extern void remove_some_unreachable_controls_of_an_unstructured(unstructured /*u*/);
extern void remove_all_unreachable_controls_of_an_unstructured(unstructured /*u*/);
extern void remove_a_control_from_a_list_and_relink(control /*c*/, list /*a_source_control_list_of_c*/, list /*a_dest_control_list_of_c*/, remove_a_control_from_a_list_and_relink_direction /*which_way*/);
extern void remove_a_control_from_an_unstructured(control /*c*/);
extern void remove_a_control_from_an_unstructured_without_relinking(control /*c*/);
extern void discard_an_unstructured_without_its_statements(unstructured /*u*/);
extern void discard_a_control_sequence_without_its_statements(control /*begin*/, control /*end*/);
extern list generate_a_statement_list_from_a_control_sequence(control /*begin*/, control /*end*/);
extern void link_2_control_nodes(control /*source*/, control /*target*/);
extern void unlink_2_control_nodes(control /*source*/, control /*target*/);
extern void fuse_2_control_nodes(control /*first*/, control /*second*/);
/* hpfc.c */
extern bool hpf_directive_string_p(string /*s*/);
extern bool hpf_directive_entity_p(entity /*e*/);
extern bool realign_directive_p(entity /*f*/);
extern bool redistribute_directive_p(entity /*f*/);
extern bool dead_fcd_directive_p(entity /*f*/);
extern bool fcd_directive_string_p(string /*s*/);
extern bool fcd_directive_p(entity /*f*/);
extern bool keep_directive_in_code_p(string /*s*/);
/* misc_paf_utils.c */
extern list base_to_list(Pbase /*b*/);
extern Pbase list_to_base(list /*l*/);
extern void fprint_entity_list(FILE */*fp*/, list /*l*/);
extern bool normalizable_loop_p(loop /*l*/);
extern bool normal_loop_p(loop /*l*/);
extern expression make_max_exp(entity /*ent*/, expression /*exp1*/, expression /*exp2*/);
extern entity make_nlc_entity(int */*Gcount_nlc*/);
extern int Gcount_nsp;
extern int Gcount_nub;
extern entity make_nsp_entity(void);
extern entity make_nub_entity(void);
extern entity current_module(entity /*mod*/);
extern list make_undefined_list(void);
extern range forward_substitute_in_range(range */*pr*/, hash_table /*fst*/);
extern call forward_substitute_in_call(call */*pc*/, hash_table /*fst*/);
extern loop forward_substitute_in_loop(loop */*pl*/, hash_table /*fst*/);
extern list forward_substitute_in_list(list */*pl*/, hash_table /*fst*/);
extern expression forward_substitute_in_exp(expression */*pexp*/, hash_table /*fst*/);
extern void fprint_list_of_exp(FILE */*fp*/, list /*exp_l*/);
extern bool undefined_statement_list_p(list /*l*/);
extern entity expression_int_scalar(expression /*exp*/);
extern entity scalar_assign_call(call /*c*/);
extern void scalar_written_in_call(call /*the_call*/, list */*ell*/, list */*etl*/, list */*swfl*/);
/* convex_hull.c */
extern Psysteme cute_convex_union(Psysteme /*s1*/, Psysteme /*s2*/);
#endif /* ri_util_header_included */
