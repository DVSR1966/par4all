 /* RI-UTIL Library: Functions dealing with and constants related to
    PIPS intermediate representation ri.newgen,
    that are NOT generated by NewGen */

 /* Pvecteur is an external type for NewGen and the ri data structure
  * and is not included in ri.h
  *
  * It is included here to avoid changes in many PIPS modules which
  * use ri-util
  *
  * Idem for type Ppolynome (PB 25/07/90); FI: polynomials are not
  * used in ri.newgen; they should not be mentionned here
  *
  * Idem for type Psysteme (FI 3 November 1990)
  */

#include "boolean.h"
#include "vecteur.h"
#include "contrainte.h"
#include "sc.h"
#include "polynome.h"
#include "matrice.h"

#include "text.h"

/*
 * mapping.h inclusion
 *
 * I do that because this file was previously included in genC.h,
 * but the macros defined here use ri types (statement, entity...).
 * three typedef are also included here. ri.h is a prerequisit for 
 * mapping.h.
 *
 * FC, Feb 21, 1994
 */
#include "mapping.h"

/*  special characters
 */
#define MODULE_SEP ':'
#define MODULE_SEP_STRING ":"
#define LABEL_PREFIX "@"
#define MAIN_PREFIX "%"

/*  constant names
 */
#define BLANK_COMMON_LOCAL_NAME "*BLANK*"
#define DYNAMIC_AREA_LOCAL_NAME "DYNAMIC"
#define EMPTY_LABEL_NAME LABEL_PREFIX
#define LIST_DIRECTED_FORMAT_NAME "LIST-DIRECTED"
#define STATIC_AREA_LOCAL_NAME "STATIC"


#define TOP_LEVEL_MODULE_NAME "TOP-LEVEL"
#define UNBOUNDED_DIMENSION_NAME "UNBOUNDED-DIMENSION"
#define IMPLIED_DO_NAME "IMPLIED-DO"
#define RETURN_LABEL_NAME "00000"

#define ASSIGN_OPERATOR_NAME "="
#define PLUS_OPERATOR_NAME "+"
#define MINUS_OPERATOR_NAME "-"
#define UNARY_MINUS_OPERATOR_NAME "--"
#define MULTIPLY_OPERATOR_NAME "*"
#define DIVIDE_OPERATOR_NAME "/"
#define MODULO_OPERATOR_NAME "MOD"
#define MIN0_OPERATOR_NAME "MIN0"
#define MAX0_OPERATOR_NAME "MAX0"


/* FI: intrinsics are defined at a third place after bootstrap and effects!
 *     I guess the name should be defined here and used in table(s) there
 */

#define AND_OPERATOR_NAME ".AND."
#define OR_OPERATOR_NAME ".OR."
#define NOT_OPERATOR_NAME ".NOT."
#define NON_EQUAL_OPERATOR_NAME ".NE."
#define EQUIV_OPERATOR_NAME ".EQV."
#define NON_EQUIV_OPERATOR_NAME ".NEQV."

#define GREATER_OR_EQUAL_OPERATOR_NAME ".GE."
#define GREATER_THAN_OPERATOR_NAME ".GT."
#define LESS_OR_EQUAL_OPERATOR_NAME ".LE."
#define LESS_THAN_OPERATOR_NAME ".LT."
#define EQUAL_OPERATOR_NAME ".EQ."

#define CONTINUE_FUNCTION_NAME "CONTINUE"
#define RETURN_FUNCTION_NAME "RETURN"
#define STOP_FUNCTION_NAME "STOP"

#define MOD_INTRINSIC_NAME "MOD"

/* moved from ricedg-local.h */
#define LOOP_COUNTER_MODULE_NAME "LOOP-COUNTER"
#define DI_VAR_MODULE_NAME "DI-VAR"

/* macros */
#define ENTITY_ASSIGN_P(e) (strcmp(entity_local_name(e), \
				   ASSIGN_OPERATOR_NAME) == 0)
#define ENTITY_STOP_P(e) (strcmp(entity_local_name(e), \
				   STOP_FUNCTION_NAME) == 0)
#define ENTITY_PLUS_P(e) (strcmp(entity_local_name(e), \
				   PLUS_OPERATOR_NAME) == 0)
#define ENTITY_MINUS_P(e) (strcmp(entity_local_name(e), \
				   MINUS_OPERATOR_NAME) == 0)
#define ENTITY_UNARY_MINUS_P(e) (strcmp(entity_local_name(e), \
				   UNARY_MINUS_OPERATOR_NAME) == 0)
#define ENTITY_MULTIPLY_P(e) (strcmp(entity_local_name(e), \
				   MULTIPLY_OPERATOR_NAME) == 0)
#define ENTITY_DIVIDE_P(e) (strcmp(entity_local_name(e), \
				   DIVIDE_OPERATOR_NAME) == 0)

#define ENTITY_AND_P(e) (strcmp(entity_local_name(e), \
				   AND_OPERATOR_NAME) == 0)

#define ENTITY_OR_P(e) (strcmp(entity_local_name(e), \
                        OR_OPERATOR_NAME) == 0)
#define ENTITY_NOT_P(e) (strcmp(entity_local_name(e), \
                        NOT_OPERATOR_NAME) == 0)
#define ENTITY_NON_EQUAL_P(e) (strcmp(entity_local_name(e), \
                        NON_EQUAL_OPERATOR_NAME) == 0)
#define ENTITY_EQUIV_P(e) (strcmp(entity_local_name(e), \
                        EQUIV_OPERATOR_NAME) == 0)
#define ENTITY_NON_EQUIV_P(e) (strcmp(entity_local_name(e), \
                        NON_EQUIV_OPERATOR_NAME) == 0)

#define ENTITY_LOGICAL_OPERATOR_P(e) ( ENTITY_RELATIONAL_OPERATOR_P(e) || \
                                       ENTITY_AND_P(e) || \
                                       ENTITY_OR_P(e) || \
                                       ENTITY_NOT_P(e) || \
                                       ENTITY_NON_EQUAL_P(e) || \
                                       ENTITY_EQUIV_P(e) || \
                                       ENTITY_NON_EQUIV_P(e) )

#define ENTITY_GREATER_OR_EQUAL_P(e) (strcmp(entity_local_name(e), \
				   GREATER_OR_EQUAL_OPERATOR_NAME) == 0)
#define ENTITY_GREATER_THAN_P(e) (strcmp(entity_local_name(e), \
				   GREATER_THAN_OPERATOR_NAME) == 0)
#define ENTITY_LESS_OR_EQUAL_P(e) (strcmp(entity_local_name(e), \
				   LESS_OR_EQUAL_OPERATOR_NAME) == 0)
#define ENTITY_LESS_THAN_P(e) (strcmp(entity_local_name(e), \
				   LESS_THAN_OPERATOR_NAME) == 0)

#define ENTITY_EQUAL_P(e) (strcmp(entity_local_name(e), \
				   EQUAL_OPERATOR_NAME) == 0)

#define ENTITY_RELATIONAL_OPERATOR_P(e) ( \
					 ENTITY_GREATER_OR_EQUAL_P(e) || \
					 ENTITY_GREATER_THAN_P(e) || \
					 ENTITY_LESS_OR_EQUAL_P(e) || \
					 ENTITY_LESS_THAN_P(e) || \
					 ENTITY_NON_EQUAL_P(e) || \
					 ENTITY_EQUAL_P(e) )


#define SPECIAL_COMMON_P(e) \
    ((same_string_p(entity_local_name(e), DYNAMIC_AREA_LOCAL_NAME)) || \
     (same_string_p(entity_local_name(e), STATIC_AREA_LOCAL_NAME)))

/*  constant sizes
 */
#define LABEL_SIZE 5
#define INDENTATION 3
#define MAXIMAL_MODULE_NAME_SIZE 36

/*   default values
 */
#define STATEMENT_NUMBER_UNDEFINED (-1)
#define STATEMENT_ORDERING_UNDEFINED (-1)

/* On devrait utiliser Newgen pour cela, mais comme on ne doit pas
   les utiliser directement (mais via statement_less_p), cela devrait
   decourager les temeraires */

#define MAKE_ORDERING(u,s) (u<<16|s)
#define ORDERING_NUMBER(o) (o>>16)
#define ORDERING_STATEMENT(o) (o & 0xffff)

#define NORMALIZE_EXPRESSION(e) \
    ((expression_normalized(e) == normalized_undefined) ? \
         (expression_normalized(e) = NormalizeExpression(e)) : \
         (expression_normalized(e)))

/*   MISC: newgen shorthands
 */
#define entity_declarations(e) (code_declarations(entity_code(e)))

#define effect_system(e) \
	(predicate_system(transformer_relation(effect_context(e))))

#define entity_variable_p(e) (type_variable_p(entity_type(e)))

#define statement_block_p(stat) \
	(instruction_block_p(statement_instruction(stat)))

#define instruction_to_statement(i) \
   make_statement(entity_empty_label(),\
		  STATEMENT_NUMBER_UNDEFINED, STATEMENT_ORDERING_UNDEFINED,\
		  string_undefined, i)

#define loop_to_instruction(l) make_instruction(is_instruction_loop, l)
#define test_to_instruction(t) make_instruction(is_instruction_test, t)

#define loop_to_statement(l) instruction_to_statement(loop_to_instruction(l))
#define test_to_statement(t) instruction_to_statement(test_to_instruction(t))

/* that is all for $RCSfile: ri-util-local.h,v $
 */
