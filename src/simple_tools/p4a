#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Authors:
# - Grégoire Péan <gregoire.pean@hpc-project.com>
# - Ronan Keryell <ronan.keryell@hpc-project.com>
#

'''
Par4All Frontend Script
'''

import string, sys, os, re, optparse
from p4a_util import *
from p4a_processor import *
from p4a_builder import *
from p4a_git import *
from p4a_version import *

def main():
    '''The function called when this program is executed by its own'''

    parser = optparse.OptionParser(description = __doc__,
                                   usage = "%prog [options] [<files>]",
                                   version = guess_file_revision(__file__))

    main_group = optparse.OptionGroup(parser, "General Options")

    main_group.add_option("--project-name", "--project", "-p",
                          metavar = "NAME", default = None,
                          help = "Name for the project (and for the program database). If you do not specify the project, a random name will be used.")

    main_group.add_option("--keep-database", "-k",
                          action = "store_true", default = False,
                          help = "Keep database directory after processing.")

    main_group.add_option("--verbose", "-v", action = "count",
                          default = get_verbosity(),
                          help = "Run in verbose mode (you can have several -v, such as -vvv which will display the most debugging information).")

    main_group.add_option("--nocolor", action = "store_true", default = False,
                          help = "Disable coloring of terminal output.")

    parser.add_option_group(main_group)

    cpp_group = optparse.OptionGroup(parser, "Preprocessing Options")

    cpp_group.add_option("-I", dest="include_dirs",
                         action = "append", metavar = "DIR", default = [],
                         help = "Add an include search directory. Same as the compiler -I option. Several are allowed.")

    cpp_group.add_option("-D", dest="defines", action = "append",
                         metavar = "NAME[=VALUE]", default = [],
                         help = "Add a preprocessor define. Same as passing the preprocessor a -D option. Several are allowed.")

    cpp_group.add_option("-U", dest="undefines", action = "append",
                         metavar = "NAME", default = [],
                         help = "Remove a preprocessor define. Same as passing the preprocessor a -U option. Several are allowed.")

    cpp_group.add_option("--cppflags", action = "append",
                         metavar = "FLAGS", default = [],
                         help = "Add additional flags for the C preprocessor. Several are allowed.")

    cpp_group.add_option("--skip-recover-includes", action = "store_true",
                         default = False,
                         help = "By default, try to recover standard #include. To skip this phase, use this option.")

    parser.add_option_group(cpp_group)

    proc_group = optparse.OptionGroup(parser, "Processing Options")

    proc_group.add_option("--accel", "-A", action = "store_true",
                          default = False,
                          help = "Parallelize with output using the Par4All accel run-time that can execute code for various hardware accelerators such as GPU or even OpenMP emulation.")

    proc_group.add_option("--cuda", "-C", action = "store_true",
                          default = False,
                          help = "Enable CUDA generation. Implies --accel.")

    proc_group.add_option("--openmp", "-O", action = "store_true",
                          default = False,
                          help = "Parallelize with OpenMP output. If combined with the --accel option, generate Par4All accel run-time call with OpenMP implementation instead of native OpenMP output. If --cuda is not specified, this option is set by default.")

    proc_group.add_option("--simple", "-S", dest = "simple",
                          action = "store_true", default = False,
                          help = "This cancels --openmp and --cuda and does a simple transformation (no parallelization): simply parse the code and regenerate it.")

    proc_group.add_option("--fine", "-F", action = "store_true",
                          default = False,
                          help = "Use a fine-grained parallelization algorithm instead of a coarse-grained one.")

    proc_group.add_option("--include-modules", metavar = "REGEXP",
                          default = None,
                          help = "Process only the modules which names match the regular expression.")

    proc_group.add_option("--exclude-modules", metavar = "REGEXP",
                          default = None,
                          help = "Exclude the modules matching the regular expression from the parallelization.")

    proc_group.add_option("--noprocess", "-N", action = "store_true",
                          default = False,
                          help = "Bypass all processing (no parallelizing). This voids all processing options. Merely useful for testing compilation/linking option.")

    parser.add_option_group(proc_group)

    compile_group = optparse.OptionGroup(parser, "Compilation Options")

    compile_group.add_option("--output-file", "-o", action = "append",
                             metavar = "FILE", default = [],
                             help = "This enables automatic compilation of binaries. There can be several of them. Output files can be .o, .so, .a files or have no extension in which case an executable will be built.")

    compile_group.add_option("--cc", metavar = "COMPILER", default = None,
                             help = "C compiler to use (defaults to gcc).")

    compile_group.add_option("--nvcc", metavar = "COMPILER", default = None,
                             help = "NVCC compiler to use (defaults to nvcc). Note that the NVCC compiler is used only to transform .cu files into .cpp files, but not compiling the final binary.")

    compile_group.add_option("--icc", action = "store_true", default = False,
                             help = "Automatically switch to Intel's icc/xild/xiar for --cc/--ld/--ar.")

    compile_group.add_option("--nofast", "--notfast", action = "store_true",
                             default = False,
                             help = "Do not add optimized compilation flags automatically.")

    compile_group.add_option("--debug", "-g", action = "store_true",
                             default = False,
                             help = "Compile in debug mode (same as specifying -g for --cflags). Implies --nofast.")

    compile_group.add_option("--cflags", action = "append",
                             metavar = "FLAGS", default = [],
                             help = "Specify flags to pass to the C compiler. Several are allowed. Note that --cppflags will be automatically prepended to the actual flags passed to the compiler.")

    compile_group.add_option("--nvccflags", action = "append",
                             metavar = "FLAGS", default = [],
                             help = "Specify flags to pass to the NVCC compiler. Several are allowed. Note that --cppflags will be automatically prepended to the actual flags passed to the compiler.")

    compile_group.add_option("--extra", action = "append",
                             metavar = "FILE", default = [],
                             help = "Add additional file for compilation. Several are allowed. They will not be parallelized and will be passed as is.")

    compile_group.add_option("--arch", "-m", metavar = "32|64", default = None,
                         help = "Specify compilation target architecture (defaults to current native architecture).")

    compile_group.add_option("--keep-build-dir", "-K", action = "store_true", default = False,
                         help = "Do not remove build directory after compilation. If an error occurs, it will not be removed anyways.")

    parser.add_option_group(compile_group)

    link_group = optparse.OptionGroup(parser, "Linking Options")

    link_group.add_option("--ld", metavar = "LINKER", default = None,
                          help = "Linker to use (defaults to ld).")

    link_group.add_option("--ar", metavar = "ARCHIVER", default = None,
                          help = "Archiver to use (defaults to ar).")

    link_group.add_option("-L", dest = "lib_dirs", action = "append",
                          metavar = "DIR", default = [],
                          help = "Add a library search directory. Same as the linker -L option. Several are allowed.")

    link_group.add_option("-l", dest = "libs", action = "append",
                          metavar = "LIB", default = [],
                          help = "Specify an input library to link against. Same as the linker -l option. Several are allowed.")

    link_group.add_option("--ldflags", action = "append",
                          metavar = "FLAGS", default = [],
                          help = "Specify additional flags to pass to the linker. Several are allowed.")

    link_group.add_option("--extra-obj", action = "append",
                          metavar = "FILE", default = [],
                          help = "Add an additional object file for linking. Several are allowed.")

    parser.add_option_group(link_group)

    (options, args) = parser.parse_args()

    set_verbosity(options.verbose)

    if options.nocolor:
        p4a_term.disabled = True

    # Preliminary check.
    if not os.path.exists(os.environ["P4A_ROOT"]) or not os.path.exists(os.environ["P4A_ACCEL_DIR"]):
        die("Invalid P4A_* environment variables -- Have you run \"source .../par4all-rc.sh\"?")

    # Check options and set up defaults.
    if len(args) == 0:
        die("Missing input files")

    if options.simple and (options.cuda or options.openmp):
        die("Cannot combine --simple with --cuda and/or --openmp")

    if not options.simple and not options.cuda and not options.openmp:
        info("Defaulting to --openmp")
        options.openmp = True

    if options.cuda and not options.accel:
        info("Enabling --accel because of --cuda")
        options.accel = True

    if options.debug:
        options.nofast = True

    # If no project name is provided, try some random names for which 
    # you cannot find any resembling files in the current working directory.
    if not options.project_name:
        while True:
            options.project_name = gen_name()
            found_files = find(".*" + re.escape(options.project_name) + ".*", dir = os.getcwd(), match_dirs = True, match_files = True)
            if len(found_files) == 0:
                break
        info("Generated project name: " + options.project_name)

    files = []
    other_files = []
    # Make all paths absolute for input files, and check passed files extension.
    # Put all files not supported by the p4a_processor class in a separate list.
    for file in args:
        abs_file = os.path.abspath(os.path.expanduser(file))
        ext = get_file_ext(abs_file)
        if ext == ".c" or ext == ".f":
            files += [ abs_file ]
            debug("Input file: " + abs_file)
        elif ext == ".cpp" or ext == ".cxx" or ext == ".cu":
            other_files += [ abs_file ]
            info("File format not supported by parallelizer, will not be parallelized: " + abs_file)
        elif ext == ".h" or ext == ".hpp":
            info("Ignoring header file: " + abs_file)
        else:
            die("File format not supported: " + abs_file)

    # Make up C preprocessor flags.
    cppflags = options.cppflags
    for include_dir in options.include_dirs:
        cppflags += [ "-I" + include_dir ]
    for define in options.defines:
        cppflags += [ "-D" + define ]
    for undefine in options.undefines:
        cppflags += [ "-U" + undefine ]
    if len(cppflags):
        info("CPP flags: " + " ".join(cppflags))
    
    # Add specific flags and settings for --accel:
    if options.accel:
        if options.cuda:
            # Tell the run-time we generate CUDA:
            cppflags += [ "-DP4A_ACCEL_CUDA" ]
            
            # Add required include directories:
            cppflags += get_cuda_cppflags()
            
            # Add the run-time:
            other_files.append(os.path.join(os.environ["P4A_ACCEL_DIR"], "p4a_accel.cu"))
        else:
            # It is OpenMP:
            cppflags += [ "-DP4A_ACCEL_OPENMP" ]
            # Add the run-time:
            other_files.append(os.path.join(os.environ["P4A_ACCEL_DIR"], "p4a_accel.c"))
            
        # We will need to look into this directory for the run-time #include:
        cppflags.append("-I" + os.environ["P4A_ACCEL_DIR"])

    # Process (parallelize) files (or not).
    database_dir = "?"
    processor_output_files = []
    if options.noprocess:
        warn("Bypassing processor")
        processor_output_files = files
    elif len(files) == 0:
        warn("No supported files to process!")
    else:
        try:
            # Create a workspace with PIPS:
            processor = p4a_processor(files = files,
                                  project_name = options.project_name,
                                  verbose = (verbosity != 0),
                                  cppflags = " ".join(cppflags),
                                  recover_includes = not options.skip_recover_includes,
                                  filter_include = options.include_modules,
                                  filter_exclude = options.exclude_modules,
                                  accel = options.accel,
                                  cuda = options.cuda)
            # Save it for later.
            database_dir = os.path.abspath(processor.workspace.directory())

            # First apply some generic parallelization:
            processor.parallelize(options.fine)

            if options.cuda:
                processor.gpuify()

            if options.openmp:
                processor.ompify()
            processor_output_files = processor.save()
            
        except p4a_error:
            error("Processing of " + ", ".join(files) + " failed: " + sys.exc_info()[1].msg)
            error("Database directory was " + database_dir)
            die("aborting")
        #except:
        #    die("Processing of " + ", ".join(files) + " failed: " + str(sys.exc_info()[1]))

    if os.path.isdir(database_dir):
        # Remove database unless otherwise specified.
        if options.keep_database:
            warn("Not removing database directory " + database_dir) 
        else:
            # To improve later with a workspace.close() and
            # workspace.delete() some days... -> Yes because some files are left open
            # and we cannot remote the database everytime :-(
            # We should be able to work on an existing database too!
            rmtree(database_dir, can_fail = True)

    if len(options.output_file) == 0:
        # Build not requested.
        return

    all_buildable_files = processor_output_files + other_files + options.extra
    if len(all_buildable_files) == 0:
        die("No buildable input files")

    # Build requested binaries.
    ldflags = options.ldflags
    for lib_dir in options.lib_dirs:
        ldflags += [ "-L" + lib_dir ]
    for lib in options.libs:
        ldflags += [ "-l" + lib ]
    #~ print all_buildable_files

    build_dir = os.path.join(os.getcwd(), options.project_name + ".build")
    last_output_file = "?"
    try:
        for output_file in options.output_file:
            last_output_file = output_file = os.path.abspath(os.path.expanduser(output_file))
            info("Building " + output_file)
            builder = p4a_builder(files = all_buildable_files,
                              output_file = output_file,
                              cppflags = cppflags,
                              cflags = options.cflags,
                              ldflags = ldflags,
                              nvccflags = options.nvccflags,
                              extra_obj = options.extra_obj,
                              cc = options.cc,
                              ld = options.ld,
                              ar = options.ar,
                              nvcc = options.nvcc,
                              debug_flags = options.debug,
                              optimize = not options.nofast,
                              openmp = options.openmp,
                              icc = options.icc,
                              arch = options.arch,
                              build_dir = build_dir,
                              )
    except p4a_error:
        error("Building of " + last_output_file + " failed: " + sys.exc_info()[1].msg)
        error("Build directory was " + build_dir)
        die("aborting")
    #except:
    #    die("Building of " + output_file + " failed: " + str(sys.exc_info()[1]))
    
    if os.path.isdir(build_dir):
        if options.keep_build_dir:
            warn("Not removing build directory " + build_dir)
        else:
            rmtree(build_dir, can_fail = True)
    

if __name__ == "__main__":
    main()

# Some Emacs stuff:
### Local Variables:
### mode: python
### mode: flyspell
### ispell-local-dictionary: "american"
### tab-width: 4
### End:
