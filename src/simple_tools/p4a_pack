#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Authors:
# - Grégoire Péan <gregoire.pean@hpc-project.com>
#

'''
Par4All packing script: allows you to create .deb or .tar.gz packages of Par4all.
'''

import string, sys, os, re, optparse, tempfile, shutil, time
from p4a_util import *
from p4a_rc import *
from p4a_git import *
from p4a_version import *

default_install_prefix = "usr/local/par4all" # NO beginning slash please.
package_name = "par4all"
default_publish_host = "download.par4all.org"
default_deb_publish_dir = "/srv/www-par4all/download/dists/custom/main"
default_publish_dir = "/srv/www-par4all/download"

actual_script = change_file_ext(os.path.abspath(os.path.realpath(os.path.expanduser(__file__))), ".py", if_ext = ".pyc")
script_dir = os.path.split(actual_script)[0]
debian_dir = os.path.join(script_dir, "DEBIAN")
auto_remove_temp_dirs_on_break = []

def create_dist(dist_dir, install_prefix, revision):
    '''Creates a temporary directory and copy the whole installation directory (dist_dir), under the prefix designated by install_prefix.
    Also writes updated rc files (shell scripts for setting the environment), and a version file.
    Returns a list with the temporary directory created and the full path of the temporary directory and the appended install_prefix.'''
    global auto_remove_temp_dirs_on_break
    temp_dir = tempfile.mkdtemp(prefix = "p4a_pack_")
    auto_remove_temp_dirs_on_break += temp_dir
    temp_dir_with_prefix = os.path.join(temp_dir, install_prefix)
    os.makedirs(os.path.split(temp_dir_with_prefix)[0])
    info("Copying " + dist_dir + " to " + temp_dir_with_prefix)
    shutil.copytree(dist_dir, temp_dir_with_prefix)
    abs_prefix = "/" + install_prefix
    # XXX: gfortran or not??
    p4a_write_rc(os.path.join(temp_dir_with_prefix, "etc"), 
        dict(root = abs_prefix, dist = abs_prefix, accel = os.path.join(abs_prefix, "share/p4a_accel"), fortran = "gfortran"))
    # XXX: version file path hard coded in 3 different scripts
    dump(get_version_file_path(temp_dir_with_prefix), revision)
    return [ temp_dir, temp_dir_with_prefix ]

def create_deb(dist_dir, install_prefix, revision, keep_temp = False, arch = None):
    '''Creates a .deb package. Simply adds the necessary DEBIAN directory in the temporary directory
    and substitute some values in files in this DEBIAN directory. No modification of the
    distribution is made.'''
    global debian_dir, package_name
    (temp_dir, temp_dir_with_prefix) = create_dist(dist_dir, install_prefix, revision)
    temp_debian_dir = os.path.join(temp_dir, "DEBIAN")
    info("Copying " + debian_dir + " to " + temp_debian_dir)
    shutil.copytree(debian_dir, temp_debian_dir)
    control_file = os.path.join(temp_debian_dir, "control.tpl")
    if not arch:
        arch = get_machine_arch()
        if arch == "x86_64":
            arch = "amd64"
        elif re.match("i\d86", arch):
            arch = "i386"
        else:
            die("Unknown architecture " + arch + ", use --arch")
    subs_map = dict(NAME = package_name, VERSION = revision, ARCH = arch, DIST = "/" + install_prefix)
    info("Adjusting values in " + control_file)
    subs_template_file(control_file, subs_map)
    postinst_file = os.path.join(temp_debian_dir, "postinst.tpl")
    info("Adjusting values in " + postinst_file)
    subs_template_file(postinst_file, subs_map)
    package_file_name = "_".join([ package_name, revision, arch ]) + ".deb"
    package_file = os.path.abspath(package_file_name)
    run([ "fakeroot", "dpkg-deb", "--build", temp_dir, package_file_name ])
    if os.path.exists(package_file_name):
        done("Created " + package_file_name)
    else:
        warn(package_file_name + " file not created!?")
    if keep_temp:
        warn("Temporary directory was " + temp_dir)
    else:
        rmtree(temp_dir, can_fail = 1)
    return package_file_name

def publish_deb(file, host, remote_dir):
    arch = change_file_ext(file, "").split("_")[-1]
    info("Publishing " + file + " (" + arch + ")")
    warn("Removing existing .deb file for arch " + arch)
    run([ "ssh", host, "rm -fv " + remote_dir + "/binary-" + arch + "/*.deb" ])
    warn("Copying " + file + " on " + host)
    run([ "scp", file, host + ":" + remote_dir + "/binary-" + arch ])
    warn("Please wait 5 minute for repository indexes to get updated by cron")
    warn("Alternatively, you can run /srv/update-par4all.sh on " + host + " as root")

def publish_tgz(file, host, remote_dir):
    warn("Copying " + file + " on " + host)
    run([ "scp", file, host + ":" + remote_dir ])

def publish_files(files):
    global default_publish_host, default_deb_publish_dir, default_publish_dir
    for file in files:
        file = os.path.abspath(os.path.expanduser(file))
        if not os.path.exists(file):
            die("Invalid file: " + file)
        ext = get_file_ext(file)
        if ext == ".deb":
            publish_deb(file, default_publish_host, default_deb_publish_dir)
        else:
            warn("Copying " + file + " on " + default_publish_host)
            run([ "scp", file, default_publish_host + ":" + remote_dir ])

def create_sdeb(dist_dir, install_prefix, revision, keep_temp = False, arch = None):
    die("create_sdeb is TODO")

def create_tgz(dist_dir, install_prefix, revision, keep_temp = False, arch = None):
    '''Creates a simple .tar.gz package.'''
    global package_name
    (temp_dir, temp_dir_with_prefix) = create_dist(dist_dir, install_prefix, revision)
    if not arch:
        arch = get_machine_arch()
    package_file_name = "_".join([ package_name, revision, arch ]) + ".tar.gz"
    package_file = os.path.abspath(package_file_name)
    if os.path.exists(package_file):
        os.remove(package_file)
    run([ "tar", "czf", package_file_name, "-C " + temp_dir, "." ])
    if os.path.exists(package_file_name):
        done("Created " + package_file_name)
    else:
        warn(package_file_name + " file not created!?")
    if keep_temp:
        warn("Temporary directory was " + temp_dir)
    else:
        rmtree(temp_dir, can_fail = 1)
    return package_file

def create_stgz(dist_dir, install_prefix, revision, keep_temp = False, arch = None):
    global package_name
    package_full_name = "_".join([ package_name, revision, "src" ])
    package_file_name = package_full_name + ".tar.gz"
    package_file = os.path.abspath(package_file_name)
    git = p4a_git(script_dir)
    current_branch = git.current_branch()
    if current_branch != "p4a":
        die("Not on branch p4a! (" + current_branch + ")")
    git.archive(change_file_ext(package_file, ""), prefix = package_full_name + "/")
    run([ "gzip", "-9", change_file_ext(package_file_name, "") ])
    if os.path.exists(package_file_name):
        done("Created " + package_file_name)
    return package_file

def main():
    '''The function called when this program is executed by its own'''

    parser = optparse.OptionParser(description = __doc__, usage = "%prog <--deb|--tgz|-stgz> --revision=0.1 [--append-date] --dir=/current/install/dir [--prefix=/final/install/dir] [--publish] [...]")

    main_group = optparse.OptionGroup(parser, "General Options")

    main_group.add_option("--dir", "-d", metavar = "DIR", default = None,
        help = "Directory where the distribution to package is currently installed. Defaults to environment variable P4A_DIST if defined.")
    
    main_group.add_option("--deb", "-D", action = "store_true", default = False,
        help = "Build a .deb package.")
    
    #~ main_group.add_option("--sdeb", action = "store_true", default = False,
        #~ help = "Create a source .deb package.")
    
    #~ main_group.add_option("--rpm", "-R", action = "store_true", default = False,
        #~ help = "Build a .rpm package.")
    
    #~ main_group.add_option("--srpm", action = "store_true", default = False,
        #~ help = "Build a source .rpm package.")
    
    main_group.add_option("--tgz", "-T", action = "store_true", default = False,
        help = "Create a .tar.gz archive.")
    
    main_group.add_option("--stgz", action = "store_true", default = False,
        help = "Create a source .tar.gz archive.")
    
    main_group.add_option("--arch", metavar = "ARCH", default = None,
        help = "Specify the package architecture manually. By default, the current machine architecture is used.")
    
    main_group.add_option("--revision", "-r", metavar = "REVISION",
        help = "Specify package version. Current Git revision will be automatically appended.")
    
    main_group.add_option("--append-date", "-a", action = "store_true", default = False,
        help = "Automatically append date to version string.")
    
    main_group.add_option("--publish", "-P", action = "store_true", default = False,
        help = "Create a .tar.gz archive.")
    
    global default_install_prefix
    main_group.add_option("--prefix", "-p", metavar = "DIR", default = default_install_prefix,
        help = "Specify the installation prefix. Default is: " + default_install_prefix)
        
    main_group.add_option("--keep", "-k", action = "store_true", default = False,
        help = "Do not remove temporary directories after script execution.")
    
    main_group.add_option("--verbose", "-v", action = "count", default = get_verbosity(),
        help = "Run in verbose mode (you can have several -v, such as -vvv which will display the most debugging information).")
    
    main_group.add_option("--nocolor", action = "store_true", default = False,
        help = "Disable coloring of terminal output.")
    
    main_group.add_option("--version", "-V", action = "store_true", default = False,
        help = "Display script version and exit.")
    
    parser.add_option_group(main_group)

    (options, args) = parser.parse_args()

    if options.nocolor:
        p4a_term.disabled = True
    
    set_verbosity(options.verbose)
    
    if options.version:
        print(guess_file_revision(__file__))
        return
    
    if len(args):
        if not options.publish:
            die("You specified files on command line but did not specify --publish")
        publish_files(args)
        return
    
    if (not options.deb #and not options.sdeb 
        and not options.tgz and not options.stgz):
        die("Please specify any of --deb, --tgz, --stgz")

    dir = options.dir
    if options.deb or options.tgz:
        if not dir and "P4A_DIST" in os.environ:
            dir = os.environ["P4A_DIST"]
        if not dir:
            die("Please specify --dir")
        dir = os.path.abspath(os.path.expanduser(dir))
        warn("Taking dist from " + dir)
        if not os.path.isdir(dir):
            die("Invalid dist directory: " + dir)

    if not options.revision:
        die("Please use --revision to specify the package version/revision")
    tmp = options.revision.split("-")
    if len(tmp) > 2:
        die("Invalid revision format: it can have only one '-', e.g. 0.2-beta~foo")
    if options.append_date and len(tmp) > 1:
        die("Invalid revision format: no '-' permitted with --append-date")
    if not re.match("\d\.\d(\.\d)?", tmp[0]):
        die("Revision must begin with a version string, e.g. 1.2.3 or 0.2")
    for i in range(len(tmp)):
        tmp[i] = re.sub("[^\w~\.]", "", tmp[i])
    if options.append_date:
        tmp.append(time.strftime("%Y%m%dT%H%M%S"))
    revision = "-".join(tmp)

    if not revision:
        die("Invalid characters in revision")

    append_revision_bin = ""
    git_revision = guess_file_revision(dir)
    if git_revision:
        append_revision_bin = git_revision.replace("~exported", "").split("~")[-1]

    append_revision_src = p4a_git(script_dir).current_revision()

    # Check that fakeroot is available.
    if not which("fakeroot"):
        die("fakeroot not found, please install it (sudo aptitude install fakeroot)")

    output_files = []
    try:
        if options.deb:
            output_files.append(create_deb(dist_dir = dir, install_prefix = options.prefix, 
                revision = revision + "~" + append_revision_bin,
                keep_temp = options.keep, arch = options.arch))
        #~ if options.sdeb:
            #~ output_files.append(create_sdeb(dist_dir = dir, install_prefix = options.prefix, revision = revision,
                #~ keep_temp = options.keep, arch = options.arch))
        if options.tgz:
            output_files.append(create_tgz(dist_dir = dir, install_prefix = options.prefix,
                revision = revision + "~" + append_revision_bin,
                keep_temp = options.keep, arch = options.arch))
        if options.stgz:
            output_files.append(create_stgz(dist_dir = dir, install_prefix = options.prefix,
                revision = revision + "~" + append_revision_src,
                keep_temp = options.keep, arch = options.arch))
    except KeyboardInterrupt:
        if not options.keep:
            global auto_remove_temp_dirs_on_break
            for dir in auto_remove_temp_dirs_on_break:
                if os.path.isdir(dir):
                    warn("Removing " + dir)
                    rmtree(dir, can_fail = 1)
                    return
    
    if options.publish:
        publish_files(output_files)


if __name__ == "__main__":
    try:
        main()
    except p4a_error:
        error(str(sys.exc_info()[1]))
        error("To get verbose output, try passing -v, -vv, or -vvv")
    except:
        error(str(sys.exc_info()[1]))
        error("To get verbose output from the build, try passing -v, -vv, or -vvv")
        stop_all_spinners()
        raise
    stop_all_spinners() # Make sure no spinner is hindering script from exiting.


# Some Emacs stuff:
### Local Variables:
### mode: python
### mode: flyspell
### ispell-local-dictionary: "american"
### tab-width: 4
### End:
