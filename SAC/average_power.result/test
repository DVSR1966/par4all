void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1) {
            F_0 = ptrin[th][rg][v].re*ptrin[th][rg][v].re;
            F_1 = ptrin[th][rg][v].im*ptrin[th][rg][v].im;
            F_2 = F_0+F_1;

            PP = PP+F_2;
         }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_2 = F_0+F_1;

            PP = PP+F_2;
         }
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
         }
      }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            PP = PP+F_1;

            PP = PP+F_0;
         }
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            PP = PP+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            PP = PP+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            PP = PP+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            PP = PP+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_0;
         }
      }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2];



   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED0[0] = RED0[0]+F_1;

            RED0[1] = RED0[1]+F_0;
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            RED1[0] = RED1[0]+F_1;
            //c SIMD_COMMENT_3

            RED1[1] = RED1[1]+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            RED1[2] = RED1[2]+F_1;
            //c SIMD_COMMENT_3

            RED1[3] = RED1[3]+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            RED1[4] = RED1[4]+F_1;
            //c SIMD_COMMENT_3

            RED1[5] = RED1[5]+F_0;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            RED1[6] = RED1[6]+F_1;
            //c SIMD_COMMENT_3

            RED1[7] = RED1[7]+F_0;
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP = RED2[1]+RED2[0]+PP;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            F_04 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_14 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED0[0] = RED0[0]+F_14;

            RED0[1] = RED0[1]+F_04;
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_03 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_13 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            RED1[0] = RED1[0]+F_13;
            //c SIMD_COMMENT_3

            RED1[1] = RED1[1]+F_03;
            //c SIMD_COMMENT_0
            F_02 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_12 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            RED1[2] = RED1[2]+F_12;
            //c SIMD_COMMENT_3

            RED1[3] = RED1[3]+F_02;
            //c SIMD_COMMENT_0
            F_01 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_11 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            RED1[4] = RED1[4]+F_11;
            //c SIMD_COMMENT_3

            RED1[5] = RED1[5]+F_01;
            //c SIMD_COMMENT_0
            F_00 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_10 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            RED1[6] = RED1[6]+F_10;
            //c SIMD_COMMENT_3

            RED1[7] = RED1[7]+F_00;
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+RED2[0]+PP;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            //PIPS:SAC generated double vector(s)
            double v2df_vec2[2], v2df_vec3[2];
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            SIMD_LOAD_GENERIC_V2DF(v2df_vec2, RED0[1], RED0[0]);
            SIMD_ADDPD(v2df_vec2, v2df_vec0, v2df_vec2);
            SIMD_SAVE_GENERIC_V2DF(v2df_vec2, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec4[4], v4sf_vec5[4];
            //SAC generated temporary array
            float aligned0[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4], v4sf_vec7[4];
            //SAC generated temporary array
            float aligned1[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec8[4], v4sf_vec9[4], v4sf_vec10[4], v4sf_vec11[4];
            SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
            SIMD_SAVE_V4SF(v4sf_vec4, &aligned0[0]);
            SIMD_LOAD_V4SF(v4sf_vec7, &ptrin[th][rg][2+LU_IND0].re);
            SIMD_MULPS(v4sf_vec6, v4sf_vec7, v4sf_vec7);
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned1[0]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_ADDPS(v4sf_vec8, v4sf_vec4, v4sf_vec8);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec8, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec10, RED1[5], RED1[4], RED1[7], RED1[6]);
            SIMD_ADDPS(v4sf_vec10, v4sf_vec6, v4sf_vec10);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec10, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            //PIPS:SAC generated double vector(s)
            double v2df_vec2[2], v2df_vec3[2];
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            SIMD_LOAD_GENERIC_V2DF(v2df_vec2, RED0[1], RED0[0]);
            SIMD_ADDPD(v2df_vec2, v2df_vec0, v2df_vec2);
            SIMD_SAVE_GENERIC_V2DF(v2df_vec2, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec8[4], v4sf_vec10[4];
            //SAC generated temporary array
            float aligned1[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4];
            //SAC generated temporary array
            float aligned0[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec4[4];
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec10, RED1[5], RED1[4], RED1[7], RED1[6]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated float vector(s)
               float v4sf_vec5[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec7[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec9[4], v4sf_vec11[4];
               SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
               SIMD_LOAD_V4SF(v4sf_vec7, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(v4sf_vec6, v4sf_vec7, v4sf_vec7);
               SIMD_ADDPS(v4sf_vec8, v4sf_vec4, v4sf_vec8);
               SIMD_ADDPS(v4sf_vec10, v4sf_vec6, v4sf_vec10);
            }
            SIMD_SAVE_V4SF(v4sf_vec4, &aligned0[0]);
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned1[0]);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec8, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec10, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   int LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            //PIPS:SAC generated double vector(s)
            double v2df_vec2[2], v2df_vec3[2];
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            SIMD_LOAD_GENERIC_V2DF(v2df_vec2, RED0[1], RED0[0]);
            SIMD_ADDPD(v2df_vec2, v2df_vec0, v2df_vec2);
            SIMD_SAVE_GENERIC_V2DF(v2df_vec2, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec8[4], v4sf_vec10[4];
            //SAC generated temporary array
            float aligned1[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4];
            //SAC generated temporary array
            float aligned0[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec4[4];
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec10, RED1[5], RED1[4], RED1[7], RED1[6]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated float vector(s)
               float v4sf_vec5[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec7[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec9[4], v4sf_vec11[4];
               SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
               SIMD_LOAD_V4SF(v4sf_vec7, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(v4sf_vec6, v4sf_vec7, v4sf_vec7);
               SIMD_ADDPS(v4sf_vec8, v4sf_vec4, v4sf_vec8);
               SIMD_ADDPS(v4sf_vec10, v4sf_vec6, v4sf_vec10);
            }
            SIMD_SAVE_V4SF(v4sf_vec4, &aligned0[0]);
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned1[0]);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec8, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_SAVE_GENERIC_V4SF(v4sf_vec10, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
seq-ok
sse-ok

