% -*- Mode: TeX -*-
\documentstyle[11pt]{article}
\input{/usr/share/local/lib/tex/macroslocales/Dimensions}

\title{\Huge NewGen}
\author{\huge {\em Pierre Jouvelot} \\
        \\
        \huge CRI, Ecole des Mines (France) \\
        \huge LCS, MIT (U.S.A.)}
\date{}

\newcommand{\newgen}{NewGen}

\begin{document}

{\LARGE
\sloppypar

\maketitle

\vskip 3cm

\begin{center}
Confe'rence GRECO de Programmation
~\\
Paris, 28 Novembre 1991
\end{center}

\vskip 3cm

\begin{center}
$\copyright$ Pierre Jouvelot (1991)
\end{center}

\newpage

\begin{center}
{\huge\bf Qu'est-ce que NewGen}
\end{center}

\vskip 2cm

\begin{itemize}
\item \newgen~(New Generation)
\item Outil de ge'nie logiciel
\item Aide a` l'e'criture de logiciels de taille importante
\item De'veloppement a` l'Ecole des Mines de Paris (Automne 1988)
\item Prototype ``Public Domain'' distribue' (Mines, Bull, NASA, Boeing, ...)
\item Applications: Paralle'liseurs (environ 50 klignes)
\end{itemize}

\newpage

\begin{center}
{\huge\bf \newgen~en re'sume'}
\end{center}

\vskip 2cm

\begin{itemize}
\item Outil de gestion de structures de donne'es
\item Me'ta-langage de de'finition de {\em domaines}: base, somme,
produit, liste, ensemble, tableau
\item Ge'ne'ration automatique de fonctions de cre'ation, manipulation,
mise a` jour, libe'ration, stockage ...
\item Bibliothe`que ge'ne'rale (listes, tableaux, ite'rateurs, ...)
\item Inte'gration dans logiciels existants (externe)
\item Modularite' (import)
\item Efficacite' temps/espace
\end{itemize}

\newpage 

\begin{center}
{\huge\bf Plan}
\end{center}

\vskip 2cm

\begin{itemize}
\item Proble'matique
\item Atouts
\item Description du langage de spe'cification
\item Fonctions de manipulation (en C)
\item Bibliothe`ques
\item Un Premier Exemple
\item \newgen~``avance''' :  tabulation, importation, external
\item Retour sur l'exemple
\item NewGen et CommonLISP
\item Aspects de l'imple'mentation
\item PIPS: Un exemple ``vraie grandeur''
\item Autres syste`mes
\item Conclusion
\end{itemize}

\newpage

\begin{center}
{\huge\bf Proble'matique}
\end{center}

\vskip 2cm

\begin{itemize}
\item Mode`les de De'veloppement Logiciel: {\em waterfall}, prototypage
\item Prototypage: Spe'cification vs. Imple'mentation
\item Spe'cification: Exe'cutabilite' vs. Expressivite'
\item Imple'mentation: Efficacite' vs. Simplicite'
\item Solution: {\em Interope'rabilite'}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Interope'rabilite'}
\end{center}

\vskip 2cm

\begin{itemize}
\item Inde'pendance par rapport au langage cible
\item Paradigme uniforme de programmation
\item Etat: support pour CommonLISP (oriente' spe'cification) et C
(oriente' imple'mentation)
\item Compatibilite' comple`te au niveau fichier
\item Maintien de la cohe'rence (persistence)
\item Transition souple (conception modulaire)
\end{itemize}

\newpage

\begin{center}
{\huge\bf Atouts}
\end{center}

\vskip 2cm

\begin{itemize}
\item {\em Abstraction Fonctionnelle}: 
        \begin{itemize}
        \item Constructions de haut niveau (fonctions)
        \item Inde'pendance de l'imple'mentation
        \item Extensions/rede'finitions possibles
        \end{itemize}
\item {\em Processus Evolutif}: 
        \begin{itemize}
        \item Support pour logiciel multi-passes
        \item Gestion de persistence (partage, cycle)
        \item Multi-langages
        \item Inte'gration progressive (fichiers, pipes, variables
                globales) 
        \end{itemize}
\item {\em Environnement de Programmation}:
        \begin{itemize}
        \item Lisibilite' inter-langages
        \item Re'utilisation des bibliothe`ques
        \item Mise-au-point aise'e (tests dynamiques possibles)
        \end{itemize}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Langage de Description de Domaines}
\end{center}

\vskip 2cm

\begin{itemize}
\item {\tt --} pour les commentaires
\item De'finitions de domaines: 

\begin{verbatim}
name = expression ;
\end{verbatim}
\item Pre'de'finis: {\tt unit}, {\tt bool}, {\tt char}, {\tt int}, {\tt
string}, {\tt float} 
\item Produit de {\em membres}:

\begin{verbatim}
    user = name:string x id:int x 
           passwd x shell:string ;
\end{verbatim}
\item Somme de membres:

\begin{verbatim}
    passwd = crypted:string + 
             clear:string ;
\end{verbatim}
\item Enume'ration (vue comme somme):

\begin{verbatim}
    passwd_status = {crypted, clear} ;
\end{verbatim}
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item Les {\em membres} peuvent e^tre complexes
\item De'finitions re'cursives autorise'es
\item Liste ordonne'e de domaines:

\begin{verbatim}
    node = information:int x 
           children:node* ;
\end{verbatim}
\item Ensemble (non ordonne') de domaines:

\begin{verbatim}
    group = elements:user{} ;
\end{verbatim}
\item Tableau (indexe') de domaines:

\begin{verbatim}
    #define BUFFER_SIZE 100

    buffer = first:int x lats:int x 
             elements:char[ BUFFER_SIZE ] ;
\end{verbatim}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Fonctions de Manipulation: \\
Cre'ation}
\end{center}

\vskip 2cm

\begin{itemize}
\item Tout domaine {\em domain} de'finit:
        \begin{itemize}
        \item un type {\em domain}
        \item un {\em constructeur} {\tt make\_{\em domain}}
        \item une valeur par de'faut {\tt {\em domain}\_undefined}
        \end{itemize}

\item Domaines produit: cre'ation a` partir des membres:

\begin{verbatim}
    user pierre = 
        make_user( "jouvelot", 
                   110, 
                   passwd_undefined,
                   "/usr/local/bin/ksh" ) ;
\end{verbatim}
\item Domaines somme: cre'ation a` partir d'un {\em tag} et d'une
valeur
\item Chaque membre {\em member} d'une somme {\em domain} a un
tag {\tt is\_{\em domain}\_{\em member}}:

\begin{verbatim}
    char buffer[ 8 ] ;
    passwd at_login = 
       make_passwd( is_passwd_encrypted,
                    crypt( gets( buffer ), 
                           "aa" )) ;
\end{verbatim}
\item Il existe un type {\tt tag}.
\end{itemize}

\newpage

\begin{center}
{\huge\bf Fonctions de Manipulation: \\
Acce`s}
\end{center}

\vskip 2cm

\begin{itemize}
\item Call-by-sharing (vs. call-by-value, call-by-reference)
\item Un domaine {\em domain} et un membre {\em member} de'finissent un
{\em accesseur} {\tt {\em domain}\_{\em member}}:

\begin{verbatim}
    printf( "User %s logged on\n", 
            user_name( pierre )) ;
\end{verbatim}
\item Le tag d'une somme {\em domain} s'obtient par {\tt {\em domain}\_tag}:

\begin{verbatim}
    if( passwd_tag( at_login ) == 
        is_passwd_encrypted ) {
        check( passwd_crypted( at_login )) ;
    }
\end{verbatim}
\item Des pre'dicats {\tt {\em domain}\_{\em member}\_p} existent pour
les som\-mes: 

\begin{verbatim}
    if( passwd_encrypted_p( at_login )) {
        check( passwd_crypted( at_login )) ;
    }
\end{verbatim}
\item Imple'mentation sous forme de macros.
\end{itemize}

\newpage

\begin{center}
{\huge\bf Fonctions de Manipulation: \\
Modification}
\end{center}

\vskip 2cm

\begin{itemize}
\item Utilisation de {\tt =}:

\begin{verbatim}
    passwd_tag( at_login ) = 
         is_passwd_clear ;
    passwd_clear( at_login ) = "go ahead" ;
\end{verbatim}
\item Cre'ation de partage et cycle:

\begin{verbatim}
    node = info:int x next:node ;

    node n = 
       make_node( 1, node_undefined ) ;
    next( n ) = n ; 
\end{verbatim}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Fonctions de Manipulation: \\
Ope'rations I/O}
\end{center}

\vskip 2cm

\begin{itemize}
\item Tout domaine {\em domain} de'finit:
    \begin{itemize}
    \item une fonction d'e'criture {\tt write\_{\em domain}}
    \item une fonction de lecture {\tt read\_{\em domain}}
    \end{itemize}

\begin{verbatim}
    user pierre = read_user( open_db()) ;
    fprintf( stderr, 
             "Read data for user %s\n", 
             user_name( pierre )) ;
\end{verbatim}
\item Le partage (sharing) est preserve' dans la sous-structure.
\item Gestion des cycles.
\end{itemize}

\newpage

\begin{center}
{\huge\bf Fonctions de Manipulation: \\
Libe'ration}
\end{center}

\vskip 2cm

\begin{itemize}
\item Tout domaine {\em domain} de'finit {\tt free\_{\em domain}}.

\begin{verbatim}
    if( denied_access( pierre )) {
        fprintf( sdterr, 
                 "Permission denied: %s\n", 
                 user_name( pierre )) ;
        free_user( pierre ) ;
        restart_top_level() ;
    }
\end{verbatim}
\item Re'clamation re'cursive des structures de donne'es
\item Gestion des cycles et partage {\em dans la sous-structure}
(attention au partage transverse)
\item Remarque: pas ne'cessaire en CommonLISP!
\end{itemize}

\newpage

\begin{center}
{\huge\bf Bibliothe`ques}
\end{center}

\vskip 2cm

\begin{itemize}
\item A chaque constructeur de type est associe'e une bibliothe`que
\item Listes
\item Ensembles
\item Remarque: tables de hachage
\end{itemize}

\newpage

\begin{center}
{\huge\bf Bibliothe`que: \\
Listes}
\end{center}

\vskip 2cm

\begin{itemize}
\item Constructeurs classiques de Lisp: CONS, CAR, CDR, NIL, ENDP, ...
\item Ne'cessite' de typage explicite (listes polymorphes)
\item Tout domain {\em domain} de'finit la conversion {\em DOMAIN}:

\begin{verbatim}
    list logged_on = NIL ;

    void add_to_users( u )
    user u ;
    {
        logged_on =
            CONS( USER, u, logged_on ) ;
    }
\end{verbatim}
\item Ite'rateurs:

\begin{verbatim}
    printf( "Users logged on: " ) ;
    MAPL( users, {
        user u = USER( CAR( users )) ;
        printf( "%s ", user_name( u )) ;
    }, logged_on ) ;
\end{verbatim}  
\item Mise-a`-jour simple:

\begin{verbatim}
    CAR( logged_on ) = pierre ;
\end{verbatim}
\item Ensemble ``extensible{}'' de fonctions ({\tt remove}, {\tt nconc},
{\tt copy}, {\tt find}, {\tt length}, ...)
\end{itemize}

\newpage

\begin{center}
{\huge\bf Bibliothe`que: \\
Ensembles}
\end{center}

\vskip 2cm

\begin{itemize}
\item Proble`me: gestion d'ensemble (et non multi-ensembles),
imple'mentation efficace
\item Support pour chaines, entiers et pointeurs
\item Convention d'allocation a` l'appelant (solution simple pour appels
emboite's).
\item Ope'rations triadiques:

\begin{verbatim}
    set_op( result, operand1, operand2 ) ;
\end{verbatim}
\item Ne'cessite' d'allocation:

\begin{verbatim}
    set logged_on = set_undefined ;

    void add_to_users( u )
    user u ;
    {
        if( set_undefined_p( logged_on )) {
            logged_on = 
                 set_make( set_pointer) ;
        }
        set_add_element( logged_on, 
                         logged_on, 
                         u ) ;
    }
\end{verbatim}
\item Ite'rateurs:

\begin{verbatim}
    printf( "Users logged on: " ) ;
    SET_MAP( u, {
        printf( "%s ", user_name( u )) ;
    }, logged_on ) ;
\end{verbatim}  
\item Ensemble ``extensible{}'' de fonctions:
  \begin{itemize}
  \item {\tt set\_intersection}, 
  \item {\tt set\_union},
  \item {\tt set\_equal\_p}, 
  \item {\tt set\_free}, 
  \item {\tt set\_size} ...
  \end{itemize}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Bibliothe`que: \\
Tables de hachage}
\end{center}

\vskip 2cm

\begin{itemize}
\item Tables dans Unix SV ``inutilisables''
\item Utilisation fre'quente: ensembles, \newgen, ...
\item Ite'rateurs:

\begin{verbatim}
    #define SET_MAP(element,code,set) { \
        HASH_MAP(_set_map_key, element, \
               code, \
        (set)->table); \
        }
\end{verbatim}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Un Premier Exemple}
\end{center}

\vskip 2cm

\begin{itemize}
\item SIMPLE est un petit langage d'expression
\item Fichier {\tt expression.tex}:

\begin{verbatim}
\title{SIMPLE Language Specifications}
\author{Pierre Jouvelot}

\begin{document}
\domain{expression = constant:int +
                     identifier:string + 
                     binary + 
                     let ;} {
An expression is either an integer constant, 
an identifier, a binary expression, or a 
nested let construct.
}

\domain{binary = operator:string x 
                 lhs:expression x
                 rhs:expression ;} {
A binary expression consists of an operator 
and two subexpressions.
}

\domain{let = bindings:binding* x 
              expression ;} {
A let construct includes a binding list and 
a body expression.
}

\domain{binding = name:string x 
                  value:expression ;} {
A binding binds a name to a value.
}
\end{verbatim}
\item Fichier {\tt expression.newgen} trie', automatiquement ge'ne're'

\begin{verbatim}
binary = operator:string x 
         lhs:expression x rhs:expression ;
binding = name:string x value:expression ;
expression = constant:int + 
             identifier:string +
             binary + let ;
let = bindings:binding* x expression ;
\end{verbatim}

\item Fichier {\tt expression.dvi} de documentation automatiquement
ge'ne're'. 
\end{itemize}

\newpage

\begin{center}
{\huge\bf Frontal pour SIMPLE}
\end{center}

\vskip 2cm

\begin{itemize}
\item Syntaxe d'entre'e a` la Lisp:

\begin{verbatim}
. 1
. (+ x 1)
. (let ((x 1)) (+ x 2))
. (let ((x 1))
    (let ((y (* 2 x)))
      (+ x y)))
\end{verbatim}
\item Ge'ne'ration des structures de donne'es NewGen:

\begin{verbatim}
. make_expression(is_expression_constant,1)
. make_expression( 
    is_expression_binary,
    make_binary( 
      "+",
      make_expression( 
        is_expression_identifier,
        "x"),
      make_expression( 
        is_expression_constant,
        1)))
\end{verbatim}
\item NewGen est compatible avec tous les outils Unix
\item Frontal ge'ne're' automatiquement par Yacc
\end{itemize}

\newpage

\vskip 2cm

\begin{verbatim}
%{

#include <stdio.h>       /* Unix standard IO */
#include <string.h>      /* String managt. */
#include "genC.h"        /* Newgen basic 
                            C library */
#include "expression.h"  /* Newgen-generated 
                            header files */ 

expression Top ;
%}

%token LP RP 
%token LET 

%term INT
%term STRING

%union {
    expression expression ;
    let let ;
    list list ;
    identifier identifier ;
    string string ;
}

%type <expression> Axiom Expression
%type <let> Let
%type <identifier> Identifier

%type <list> Bindings
%type <string> String 

%% 
Axiom   : Expression {
            Top = $1 ;
        }
        ;

Expression  
        : INT {
            $$ = make_expression(
                 is_expression_constant, 
                 atoi( yytext )) ;
        } 
        | Identifier {
            $$ = make_expression( 
                 is_expression_identifier,$1);
        } 
        | LP String Expression Expression RP {
            binary b = 
            make_binary( $2, $3, $4 ) ; 
               
            $$ = make_expression(
                 is_expression_binary, b );
        }
\end{verbatim}

\newpage

\vskip 2cm

\begin{verbatim}
        | Let {
            $$ = make_expression( 
                 is_expression_let, $1 ) ;
        } 
        ; 
 
Let     : LP LET LP Bindings RP Expression RP {
            $$ = make_let( $4, $6 ) ;
        } 
        ; 
 
Bindings   
        : {
            $$ = NIL ;
        } 
        | Bindings LP String Expression RP {
            $$ = CONS( BINDING,
                       make_binding( $3, $4 ), 
                       $1 ) ;
        } 
        ; 
 
Identifier  
        : String {
            $$ = make_identifier( $1 ) ;
        }
        ;

String  : STRING {
            $$ = strdup( yytext ) ;
        }
        ;
%%
\end{verbatim}

\newpage

\begin{center}
{\huge\bf Commande {\tt newgen}}
\end{center}

\vskip 2cm

\begin{itemize}
\item Commande shell de ge'ne'ration de code
\item {\tt newgen} prend en arguments:
  \begin{itemize}
  \item Language objet ({\tt -C}, {\tt -Lisp}),
  \item Fichiers {\tt .newgen}
  \end{itemize}

\begin{verbatim}
% newgen -C expression.newgen
GEN_READ_SPEC order:
expression.spec
% ls
expression.newgen       expression.h    expression.spec
%
\end{verbatim}
\item Pour chaque fichier {\tt foo.newgen}, on obtient deux fichiers:
  \begin{itemize}
  \item De'clarations C: {\tt foo.h},
  \item Spe'cifications: {\tt foo.spec}
  \end{itemize}
\item Remarque: les {\tt spec} devraient disparaitre dans une
nouvelle version de \newgen
\item Fichiers {\tt spec} lus a` l'exe'cution, {\em avant}
tout appel de fonctions \newgen.
\item Ordre des fichiers {\tt spec} donne' par {\tt newgen}
\end{itemize}

\newpage

\vskip 2cm

\begin{verbatim}
#include <stdio.h>       
#include "genC.h"        
#include "expression.h"  

expression Top ; 


main() 
{ 
    gen_read_spec( "expression.spec", 
                   (char*) NULL) ; 
    yyparse() ; 
    fprintf( stdout, "%d\n", 
             constant_fold( Top )) ; 
    free_expression( Top ) ;
}
\end{verbatim}

\newpage

\vskip 2cm

\begin{verbatim}
int
constant_fold( e )
expression e ;
{
    int value ;
    tag t ;

    switch( t = expression_tag( e )) {
    case is_expression_constant:
        value = expression_constant( e ) ;      
        break ;
    case is_expression_binary:
        binary b = expression_binary( e ) ;
        int lhs = constant_fold(binary_lhs(b));
        int rhs = constant_fold(binary_rhs(b));

        value = 
           eval_primitive( binary_operator(b), 
                           lhs, rhs ) ;
        break ;
    default:
        fprintf( stderr, 
                 "Unimplemented %d\n",
                  t ) ;
        exit( 1 ) ;
    }
    return( value ) ;
}

int
eval_primitive( op, lhs, rhs )
char *op ;
int lhs, rhs ;
{
    if( strcmp( op, "+" ) == 0 ) 
        return( lhs+rhs ) ;
    if( strcmp( op, "-" ) == 0 ) 
        return( lhs-rhs ) ;
    if( strcmp( op, "*" ) == 0 )
        return( lhs*rhs ) ;
    if( strcmp( op, "/" ) == 0 )
        return( lhs/rhs ) ;

    fprintf( stderr, "Primitive %s unknown\n", 
             op ) ;
    exit( 1 ) ;
}
\end{verbatim}

\newpage

\begin{center}
{\huge\bf Aspects Avance's \\
Tabulation}
\end{center}

\vskip 2cm

\begin{itemize}
\item Domaines {\em tabule's}
\item Acce`s global aux objets d'un me^me type
\item Le premier membre {\em doit} e^tre une chaine (unique par objet):

\begin{verbatim}
    tabulated user = name:string x id:int x 
                     passwd x shell:string ;
\end{verbatim}
\item Permet une dissociation entre de'finition et re'fe'rence
\item Notion de {\em object-id} en programmation persistente
\item Unicite' des objets ({\tt name} est une cle' utilise'e a` la
cre'ation des objets)
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item Utilisation: de'allocation, acce`s fichiers, ...

\begin{verbatim}
    user pierre, francois, michel ;

    list roots = CONS( USER, pierre, 
                       CONS( USER, francois, 
                                   NIL )) ;
    list admins = CONS( USER, michel, 
                        CONS( USER, pierre, 
                                    NIL )) ;

    group root = make_group( roots ) ;
    group admin = make_group( admins ) ;

    free_group( admin ) ;

    --> CAR( group_elements( root )) ????
\end{verbatim}
\item Si {\tt user} est tabulte', pas de libe'ration automatique
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item Chaque domaine tabule' {\em tab} de'finit {\tt {\em tab}\_domain}
\item Manipulation globale d'objets tabule's en me'moire:

\begin{verbatim}
    TABULATED_MAP( u, {
        fprintf( stdout, "User %s\n", 
                 user_name( u )) ;
    }, user_domain ) ;
\end{verbatim}
\item Libe'ration explicite (me^me en CommonLISP) et IO:

\begin{verbatim}
    FILE *db = fopen("user.database","w");

    gen_write_tabulated( db, user_domain ) ;
    gen_free_tabulated( user_domain ) ;
\end{verbatim}
\item Remarque: Attention au proble`me de partage
\item Remarque: Tabulation automatique dans une future version de \newgen
\end{itemize}

\newpage

\begin{center}
{\huge\bf Aspects Avance's \\
Importation}
\end{center}

\vskip 2cm

\begin{itemize}
\item De'finition modulaire de spe'cifications \newgen
\item Spe'cification multifichiers 
\item Comple'tude requise (mais voir {\em external})

\begin{verbatim}
    -- network.newgen

    import workstation from 
           "Include/workstation.newgen" ;
    import gateway from 
           "Include/gateway.newgen" ;
 
    network = nodes:node* ;
    node = workstation + gateway + 
           repeater:node*;
\end{verbatim}
\item {\tt newgen} donne l'ordre pour {\tt gen\_read\_spec}

\begin{verbatim}
% newgen -C network.newgen \
  workstation.newgen gateway.newgen
GEN_READ_SPEC order:
workstation.spec
gateway.spec
network.spec
% 
\end{verbatim}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Aspects Avance's \\
Externes}
\end{center}

\vskip 2cm

\begin{itemize}
\item Compatibilite' ascendante ("dusty data")
\item Utilisation de \newgen\ en pre'sence de donne'es non-\newgen
\item Contrainte: Compatible avec {\tt char *} en C et pointeur en
CommonLISP 

\begin{verbatim}
    external punch ;
    import laser from "printers.newgen" ;
    import daisy from "printers.newgen" ;

    output_device = laser + daisy + punch ;
\end{verbatim}
\item Routines de lecture, e'criture, libe'ration et copie a` fournir par
l'utilisateur
\item {\tt gen\_init\_external} a` appeler avant toute utilisation.
\item De'finition de {\em DOMAIN} pour premier argument de {\tt
gen\_init\_external} 
\end{itemize}

\newpage

\begin{center}
{\huge\bf Retour sur l'exemple}
\end{center}

\vskip 2cm

\begin{itemize}
\item Tabulation des identificateurs
\item De'finition se'pare'e de {\tt identifier}:

\begin{verbatim}
-- File identifier.newgen

tabulated identifier = name:string ;
\end{verbatim}
\item Forme ASCII compacte {\tt external}

\begin{verbatim}
-- File expression.newgen

import identifier from "identifier.newgen" ;
external compacted ;

binary = operator:string x 
         lhs:expression x rhs:expression ;
binding = name:string x value:expression ;
expression = constant:int + identifier + 
             compacted + binary + let ;
let = bindings:binding* x expression ;
\end{verbatim}
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item Appel de {\tt newgen}:

\begin{verbatim}
% newgen -C expression.newgen \
  identifier.newgen
GEN_READ_SPEC order
identifier.spec
expression.spec
%
\end{verbatim}
\item Cre'ation des identificateurs:

\begin{verbatim}
    | Identifier {
        $$ = make_expression( 
             is_expression_identifier, 
             make_identifier( $1 )) ;
    } 
\end{verbatim}
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item Initialisation de {\tt compacted} dans {\tt main}:

\begin{verbatim}
void compacted_write( FILE *, compacted ) ;
compacted compacted_read( FILE *, 
                          char (*)()) ;
void compacted_free( compacted ) ;
compacted compacted_copy( compacted ) ;

main() 
{ 
    gen_read_spec( "identifier.spec", 
                   "expression.spec", 
                   (char*) NULL) ; 
    gen_init_external( COMPACTED, 
                       compacted_read, 
                       compacted_write, 
                       compacted_free,
                       compacted_copy ) ;

    yyparse() ; 
    fprintf( stdout, "%d\n", 
             constant_fold( Top )) ; 

#ifdef DEBUG
    fprintf( stderr,"Bound Identifiers:\n");

    TABULATED_MAP( i, {
        fprintf( stderr, "%s,", 
                 identifier_name( i )) ;
    }, identifier_domain ) ;
#endif

    free_expression( Top ) ;
    gen_free_tabulated(identifier_domain);
}
\end{verbatim}
\item Support pour externes

\begin{verbatim}
void compacted_write( fd, c )
FILE *fd ;
compacted c ;
{
    int val = *(int *)(char *)c ;

    fprintf( fd, "%d", 
             (int)log2( (double)val )) ;
}

compacted
compacted_read( fd, read )
FILE *fd ;
char (*read)() ;
{
    int *c = (int *)malloc( sizeof( int )) ;

    fscanf( fd, "%d", c ) ;
    return( (compacted)(char *)c ) ;
}

void
compacted_free( c )
compacted c ;
{
    free( c ) ;
}

compacted
compacted_copy( c )
compacted c ;
{
    int *cc = (int *)malloc( sizeof( int ));

    *cc = *c ;
    return( (compacted)(char *)cc ) ;
}
\end{verbatim}
\end{itemize}

\newpage

\begin{center}
{\huge\bf \newgen\ et CommonLISP}
\end{center}

\vskip 2cm

\begin{itemize}
\item Inte're^t: Facilite' de prototypage, de'veloppement,
spe'cifications
\item Permettre le de'veloppement ``souple{}'': LISP
fonctionnel, LISP impe'ratif, C
\item Inte'rope'rabilite' C/LISP limite'e en ge'ne'ral ({\em foreign
function interface})
\item \newgen: pont entre deux mondes
\item CommonLISP: {\em de facto} standard, plus norme ANSI en
pre'paration
\item Similitude de programmation (listes), mais GC
\item Compatibilite' ``fichiers'' ou pipes
\end{itemize}

\newpage

\begin{center}
{\huge\bf Changements}
\end{center}

\vskip 2cm

\begin{itemize}
\item Type \newgen: {\tt defstruct}
\item Adaptation a` la syntaxe CommonLISP:

\begin{verbatim}
    (setf pierre 
          (make-user 
             :name "jouvelot"
             :id 110
             :passwd passwd-undefined
             :shell "/usr/local/bin/ksh"))
\end{verbatim}
\item Modification via {\tt setf}:

\begin{verbatim}
    (setf (user-id pierre) 120)
\end{verbatim}
\item Le {\tt switch} de C est de'finit comme une macro:

\begin{verbatim}
    (gen-switch (expression-tag e)
            (is-expression-constant 
               (expression-constant e))
            (:default 
               (error "~%Incorrect tag")))
\end{verbatim}
\item {\tt gen-switch} peut aussi cre'er des liaisons:

\begin{verbatim}
    (gen-switch (expression-tag e)
            ((is-expression-constant c) c)
            (:default 
              (error "~%Incorrect tag")))
\end{verbatim}
\item Pas de libe'ration explicite (sauf pour domaines tabule's)
\item Visibilite' des fonctions de manipulation via {\tt use-package}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Evaluateur pour SIMPLE}
\end{center}

\vskip 2cm

\begin{itemize}
\item Cre'ation des fichiers Lisp:

\begin{verbatim}
% newgen -lisp expression.newgen \
  identifier.newgen
REQUIRE order:
identifier.cl
expression.cl
% ls
expression.cl   expression.spec	  
identifier.cl   identifier.spec
%
\end{verbatim}
\item {\tt require} pour chargement des fichiers
\item Pas d'arguments a` {\tt gen-read-spec}: auto-initialisation des
fichiers CommonLISP
\end{itemize}

\newpage

\begin{center}
{\huge\bf Top Level}
\end{center}

\vskip 2cm

\begin{verbatim}
(require "genLisplib")    ; Newgen basic 
                          ; Lisp library 
(require "identifier")    ; Newgen-generated 
                          ; header files 
(require "expression") 
 
(use-package '(:newgen 
               :identifier 
               :expression))

(defun test (&optional (file *standard-input*))
  "FILE contains the parser output."
  (gen-read-spec) 
  (let ((*standard-input* (open file))) 
    (eval-expression (read-expression) '())))
\end{verbatim}

\newpage

\begin{center}
{\huge\bf Boucle d'e'valuation}
\end{center}

\vskip 2cm

\begin{verbatim}
(defun eval-expression (e env) 
  (gen-switch e 
    ((is-expression-constant c) c) 
    ((is-expression-identifier i) 
     (eval-identifier i env)) 
    ((is-expression-binary b) 
     (eval-binary b env))
    ((is-expression-let l) 
      (eval-let l env))))

(defun eval-identifier (i env) 
  (let ((var-val (assoc (identifier-name i) env 
                        :test #'string-equal))) 
    (if (null var-val) 
        (error "~%Unbound identifier ~S" 
               (identifier-name i)) 
        (cdr var-val))))

(defparameter operators 
  `((,"add" . ,\#'+) 
    (,"sub" . ,\#'-) 
    (,"times" . ,\#'*) 
    (,"cons" . ,\#'cons) 
    (,"eq" . ,\#'eq)))

(defun eval-binary (b env) 
  (let ((op (assoc (binary-operator b) 
                   operators 
                   :test #'string-equal))) 
    (if (null op) 
        (error "~\%Incorrect op code ~S" 
               (binary-operator b)) 
        (funcall 
           (cdr op) 
           (eval-expression (binary-lhs b) 
                            env) 
           (eval-expression (binary-rhs b) 
                            env)))))
 
(defun eval-let (l env) 
  (let ((new-env
           (mapcar 
               #'(lambda (b) 
                    `(,(binding-name b) . 
                      ,(eval-expression
                          (binding-value b) 
                          env))) 
               (let-bindings l)))) 
    (eval-expression (let-expression l) 
                     (append new-env env)))) 
\end{verbatim}

\newpage

\begin{center}
{\huge\bf Aspects avance's \\
      Exemples}
\end{center}

\vskip 2cm

\begin{itemize}
\item {\tt gen-recurse}: Couplage appels re'cursifs et dispatch:

\begin{verbatim}
(defun eval-expression (e env) 
    (gen-recurse e 
        ((expression tag) tag)
        (identifier 
          (cdr (assoc 
                   (identifier-name i) 
                   env 
                   :test #'string-equal)))
        ((binary lhs rhs) 
          (funcall 
            (cdr (assoc 
                    (binary-operator b) 
                    operators 
                    :test #'string-equal))
            lhs rhs))))
\end{verbatim}
\item Ope'rations implicitement ite're'es (sur listes)
\item Utilisation des domaines tabule's:
\end{itemize}

\newpage

\vskip 2cm

\begin{verbatim}
(defun gensym () 
  "Generate a brand new identifier."
  (do ((i 0 (+ i 1))) 
      ((gen-find-tabulated 
           (format nil "gensym-~D" i)
           identifier-domain)
       (make-identifier 
           :name (format nil "gensym-~D"
                         i)))))
\end{verbatim}

\newpage

\begin{center}
{\huge\bf Aspects de l'imple'mentation}
\end{center}

\vskip 2cm

\begin{itemize}
\item Outil ``le'ger'': 
  \begin{itemize}
  \item 6 klignes de C, Yacc{}, Lex et Korn shell
  \item 800 lignes de CommonLISP
  \end{itemize}
\item Compilateur:
  \begin{description}
  \item[token.l] Lexe`mes du langage \newgen
  \item[gram.y] Syntaxe du langage \newgen
  \item[build.c] Compilation en fichier spec{}, cre'ation dynamique des
descripteurs de domaines
  \item[genC.c{}, genLisp.c] Ge'ne'ration de code C et Lisp
  \item[newgen] Commande shell
  \end{description}
\item Run time C/Lisp:
  \begin{description}
  \item[genClib.c{},genLisplib.cl] Bibliothe`que run-time C et Lisp
  \item[list.c] Support de listes en C
  \item[set.c{},set.cl] Support d'ensembles en C et Lisp
  \item[hash.c] Package de hash-coding dynamique (interne et externe --
set) par {\em open coding}
  \item[read.l,read.y] Parser C de structures de donne'es \newgen 
(utilisation de macros en Lisp)
  \end{description}
\item Structure me'moire tagge'e, avec inlining
\item Ve'rification dynamique de types ({\tt gen\_debug})
\item Parcours ge'ne'rique paralle`le descripteurs/structures:
gestion de partage, e'criture, copie, libe'ration
\item Un mot supple'mentaire pour objets tabule's 
\item Ecriture compacte sur disque (mais pas binaire)
\end{itemize}

\newpage

\begin{center}
{\huge\bf PIPS: Un exemple ``vraie grandeur''}
\end{center}

\vskip 2cm

\begin{itemize}
\item PIPS: Paralle'liseur Interproce'dural de Programmes Scientifiques
\item Tranformation DO en DOALL (Fortran77)
\item Projet de recherche: structure modulaire en phases (50 klignes)
\item Prise en compte comple`te de Fortran:

\begin{verbatim}
-- Entities

tabulated entity = name:string x type x 
                   value x storage ;

-- Expressions

expression = reference + range + call ;
reference = variable:entity x 
            indices:expression* ;
range = lower:expression x 
        upper:expression x 
        increment:expression ;
call = function:entity x 
       arguments:expression* ;

-- Statements

statement = label:entity x 
            number:int x 
            comments:string x 
            instruction ;

instruction = block:statement* + test + 
              loop + call + unstructured ;
test = condition:expression x 
       true:statement x 
       false:statement ;
loop = index:entity x 
       range x 
       body:statement x 
       label:entity ;

unstructured = control x exit:control ;
control = statement x 
          predecessors:control* x 
          successors:control* ;
\end{verbatim}
\item Gestion de la persistence par {\tt pipsdbm}
\item Prototypes du linker incre'mental, prettyprinter et de'tection des 
re'ductions en CommonLISP
\end{itemize}

\newpage

\begin{center}
{\huge\bf Autres syste`mes}
\end{center}

\vskip 2cm

\begin{itemize}
\item IDL
  \begin{itemize}
  \item Outil logiciel (North-Carolina U., de'veloppe' chez Tartan)
  \item Ge'ne'ration de structures de donne'es (C, Pascal)
  \item Description des phases ({\em processes}) et des interconnexions
  \item GC 
  \item Forme limite'e de sous-typage
  \item Assertions (de'finition d'un langage complet d'assertions)
  \item Format binaire
  \item Conclusion: industriel, moins abstrait, plus lourd
  \end{itemize}
\item OODB (O2, ORION, VBASE, Exodus, Postgres)
  \begin{itemize}
  \item Extension des mode`les oriente'-objet aux DB (limitation du
mode`le relationnel)
  \item Manipulation et langage de reque^tes inte'gre's dans un langage
classique (CO2, CommonLISP, C, C++)
  \item Oriente' acce`s interactif (SQL)
  \item Conclusion: plus puissant que \newgen, acce`s cou^teux
(persistence implicite)
  \end{itemize}
\end{itemize}

\newpage

\vskip 2cm

\begin{itemize}
\item OOL (C++, CLOS, Smalltalk, Trellis)
  \begin{itemize}
  \item De'pendent d'un langage, pas {\em upward} compatible (sauf C++)
  \item Plus puissant que \newgen: he'ritage, rede'finition
  \item Performances?
  \item Pas de persistence
  \end{itemize}
\item Langages Persistants
  \begin{itemize}
  \item Ne'cessite des modifications de compilateurs (Pascal/P,
PS-algol)
  \item Pas de standard dans les primitives
  \end{itemize}
\item RPC, XDR
  \begin{itemize}
  \item Bas niveau (oriente' transferts de donne'es)
  \item Pas de gestion de sharing ou de cycle
  \end{itemize}
\end{itemize}

\newpage

\begin{center}
{\huge\bf Conclusion}
\end{center}

\vskip 2cm

\begin{itemize}
\item \newgen: outil de ge'nie logiciel (Ecole des Mines de Paris)
\item Abstraction fonctionnelle, Multi-langages (C, CommonLISP),
Compatibilite' 
\item Prototype ``Public Domain'' distribue' par ftp anonyme (Mines,
Bull, NASA, Boeing, ...)
\item Applications: PIPS, PMACS (Bull)
\item Futur: extensions aux fonctions (tabulation automatique):

\begin{verbatim}
typing = expression -> type ;
\end{verbatim}
\end{itemize}

}

\end{document}


