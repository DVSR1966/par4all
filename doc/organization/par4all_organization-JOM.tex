\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{a4wide}
\usepackage{url}

\usepackage{alltt}
% Hmmm... Do not work with UTF-8:
% \usepackage{verbatim}

\usepackage{listings}%[hyper,procnames]
\lstset{extendedchars=true, language=C++, basicstyle=\scriptsize\ttfamily, numbers=left,
  numberstyle=\tiny, stepnumber=5, numberfirstline=true,
  tabsize=8, tab=\rightarrowfill, keywordstyle=\bf,
  stringstyle=\rmfamily, commentstyle=\rmfamily\itshape}

\usepackage{abbrev_reactive}
\let\OldRightarrow=\Rightarrow
\RequirePackage{marvosym}
\let\MarvosymRightarrow=\Rightarrow
\let\Rightarrow=\OldRightarrow
\RequirePackage{wasysym}
\let\Lightning\UnTrucIndefini% Car conflit entre ifsym et marvosym
\let\Sun\UnTrucIndefini%
\RequirePackage[weather]{ifsym}


\newcommand{\LINK}[1]{\url{#1}\xspace}
\newcommand{\PfaOrganizationPDF}{\LINK{http://download.par4all.org/doc/organization/par4all_organization.pdf}}
\newcommand{\PfaAllOrganizationHTDOC}{\LINK{http://download.par4all.org/doc/organization/par4all_organization.htdoc}}

\sloppy

% Number everything in the TOC:
\setcounter{secnumdepth}{10}
\setcounter{tocdepth}{10}

\begin{document}

\title{Par4All organization\\
  ---\\
  HPC Project}

\author{Amaury \textsc{Darsch} \and Serge \textsc{Guelton} \and Ronan
  \textsc{Keryell} \and Grégoire \textsc{Péan} \and Claire \textsc{Seguin}
  \and Mickaël \textsc{Thievent} \and Pierre \textsc{Villalon}}

\maketitle

You can get this document in PDF format on \PfaOrganizationPDF and in HTML
on \PfaAllOrganizationHTDOC.

% To automatically build reports from this content:
%%ContentBegin

\section{Introduction}
\label{sec:introduction}

\Apfa is a platform that merges various open source developments to ease
the migration of sequential software to multicore and other parallel
processors.
\Apfa is mainly developed by \Ahpcp, MINES ParisTech/\Acri, Institut
Télécom/Télécom Bretagne and others.
This document describes the internal organization of \Apfa and how its
construction relies on \Agit repositories, \Asvn repositories and other
projects.
This document describes also the internal workings of \Apfa.
This information may be useful not only for \Apfa core developers but
also for advanced users desiring more functionality from \Apfa.
Since \Apfa relies on other tool projects, the documentation of these other
projects should also be consulted independently and is not included here.

The first section contains the release notes for \Apfa, including
installations instructions. For detailed information on \Apfa
infrastructure, including instructions for compilation, see
sections~\ref{sec:compilation} and above.

\tableofcontents{}

\bigskip{}

\input{release-notes-extract}


\section{Compilation}
\label{sec:compilation}

\subsection{Packages needed to build and run Par4All}
\label{sec:pack-need-build}

The installation has been tested on Ubuntu/Linux 9.10 \& 10.04,
Fedora Core 13 \& 14 and Debian/unstable.

To run \Apfa with Debian or Ubuntu, the following packages are needed:
\begin{quote}
  \texttt{libncurses5}, \texttt{libreadline5}, \texttt{python},
  \texttt{python-ply}, \texttt{python3.1}, \texttt{gfortran},
  \texttt{ipython}.
\end{quote}

To run \Apfa with Fedora Core 14 or 13, the following packages are needed:
\begin{quote}
  \texttt{ncurses-5}, \texttt{readline}, \texttt{python},
  \texttt{python-ply}, \texttt{python3}, \texttt{gcc-gfortran},
  \texttt{ipython}.
\end{quote}

% To ease copy/paste:
% libncurses5 libreadline5 python python-ply python3.1 gfortran

To compile \Apfa with Debian or Ubuntu, the following additional
packages are needed:
\begin{quote}
  \texttt{cproto}, \texttt{indent}, \texttt{flex}, \texttt{bison},
  \texttt{automake}, \texttt{libtool}, \texttt{autoconf},
  \texttt{libreadline5-dev}, \texttt{python-dev}, \texttt{swig},
  \texttt{python-ply}, \texttt{python3.1}, \texttt{libgmp3-dev},
  \texttt{libmpfr-dev}, \texttt{gfortran}, \texttt{subversion},
  \texttt{git}
\end{quote}

To compile \Apfa with Fedora Core 14 or 13, the following additional
packages are needed:
\begin{quote}
  \texttt{cproto}, \texttt{indent}, \texttt{flex}, \texttt{bison},
  \texttt{automake}, \texttt{libtool}, \texttt{autoconf},
  \texttt{readline-devel}, \texttt{python-devel}, \texttt{swig},
  \texttt{python-ply}, \texttt{python3}, \texttt{gmp-devel},
  \texttt{mpfr-devel}, \texttt{gcc-gfortran}, \texttt{subversion},
  \texttt{git}
\end{quote}

% To ease copy/paste:
% cproto indent flex bison automake libtool autoconf libreadline5-dev python-dev swig python-ply python3.1 libgmp3-dev libmpfr-dev gfortran subversion git

To compile the documentation with Debian or Ubuntu, the following
additional packages are needed:
\begin{quote}
  \texttt{texlive-full}, \texttt{tex4ht}
\end{quote}

To compile the documentation with Fedora Core 14 or 13, the following
additional packages are needed:
\begin{quote}
  \texttt{texlive}, \texttt{tex4ht}
\end{quote}

\subsection{The compilation process}
\label{sec:compilation-process}

From the \Apfa source directory, \Apfa is compiled and configured
by running \verb|src/simple_tools/p4a_setup.py|. See
section~\ref{sec:public-repositories} for details.

To download and compile \Apfa from the \Agit, do the following:
\begin{alltt}
# Get a working copy of the Par4All public read-only git repository:
git clone --branch p4a git://git.hpc-project.com/git/par4all.git
# Go into the working copy:
cd par4all
# Build everything using 8 processes to speed up things:
src/simple_tools/p4a_setup.py [--prefix=\emph{/install/dir}] [-v[v[v]]] --jobs=8 [...]
\end{alltt}%
\Apfa will be installed into \verb|/usr/local/par4all| by default.
The target directory must be writable by the installer, either by running
as \texttt{root} with \texttt{sudo} or by creating a
writable target directory as follows:
\begin{alltt}
mkdir /usr/local/par4all
chown \emph{your_login_name} /usr/local/par4all
\end{alltt}
In general, it is less dangerous to limit the number of commands
executed as \texttt{root}, therefore, the latter approach to \Apfa
installation is preferable.

To install in another location, the \verb|--prefix| option can be
used. To see more installation options (including specifying
the locations for other packages), run \verb|p4a_setup.py -h|
or see section~\ref{sec:p4a_s-comp-script}.

To pull a new version, do:
\begin{verbatim}
git pull origin p4a
\end{verbatim}

and run \verb|p4a_setup.py| again. The
\verb|--rebuild| and \verb|--clean| parameters should be used to
ensure that all sources are recompiled
(since \Apips is a frequently-updated project, incremental build is
not always guaranteed to succeed). Removing the \texttt{build}
directory 
when the \verb|--prefix| directory changes is also recommended
in order to remove obsolete
information about the installation directory that may remain in
the \texttt{build} directory and cause the compilation to fail.

To create a \texttt{.deb} or \texttt{.tar.gz} package of a \Apfa installation
created with \verb|p4a_setup.py|, see \S~\ref{sec:making-distributions}.

In general, to commit changes to the \Agit repository, the
\texttt{p4a-own} branch should be used and not any of the \Apfa
sub-packages. If a branch must be used, see section~\ref{sec:packages}
to ensure consistency with the \Apfa compilation process. It is highly
advisable to compile work before
committing it on the central repositories and to make sure that all
files are committed so that the code compiles in all user
environments. In addition to providing
consistency, this has the added advantage of
allowing one to test one's code before releasing it for general
consumption! \smiley

A nice feature of \Agit over \Asvn is that since the commit is separated from
the publication, a commtted state can be tested independently from the
rest of the team before pushing to the global server.

For example, one can create a light\footnote{Because the objects are
  shared with symbolic links and not copied, since we did not use the
  \texttt{file://} syntax.} clone with
\begin{verbatim}
git clone --branch p4a par4all par4all-compile
\end{verbatim}
and after testing and committing modifications inside the
\texttt{par4all} working copy, one does the same into the
\texttt{par4all-compile} working copy after a \texttt{git pull}.
If some files are lacking from the commit, git will be detect the discrepancy.

Afterwards, a \texttt{git push} into the central \Apfa
repository will have fewer associated risks.

The classical \Aautotools environment variables can be used to influence
the compilation, however, some are directly set up from the \verb|p4a_setup.py|
script. Therefore, to set the \texttt{CFLAGS} and \texttt{CPPFLAGS}
to compile \Apfa in debug mode, value changes should be passed through 
a \verb|p4a_setup.py| option. For example,
\begin{verbatim}
--configure-options="CFLAGS='-ggdb -g3 -Wall -std=c99'"
\end{verbatim}
sets debugging options that allow \texttt{gdb} to access macro
definitions that are heavily used in \Apips. Indeed this case is so common
when debugging \Apfa that the \verb|--debug| or \verb|-g| options are just
doing this for simplicity.

The installation process can be modified by passing options to
\verb|p4a_setup.py|. For example, to skip the (re)compilation of a package,
\verb/--skip-polylib/) is used. The complete set of options is described in
\S~\ref{sec:p4a_s-comp-script}.

The \texttt{make} command has options for speeding up the compilation. For
example, to run on 8 processes, the \verb/--jobs=8/ option is added.

To compile \Apfa directly from source packages that are not
inside the \Apfa directory hierarchy, see \S~\ref{sec:direct-organ}. In
this case, \texttt{-{}-\emph{PACKAGE}-src=...} specifies the
location of the sources of \texttt{\emph{package}}, (e.g.,
\verb|-pips-src=...| or \verb|--polylib-src=...|). If all these options are
set (e.g., if the source locations point to working copies of the
\Apips{} \Asvn), then the \texttt{p4a-own} branch can be used for
compilation. For the \Apips
packages, there must be links to \texttt{nlpmake/makes} to enable compilation.
See \S~\ref{sec:comp-from-sourc} for more information on alternate
source locations.

The options passed to \texttt{configure} for a package can be changed by
using the \texttt{-{}-\emph{PACKAGE}-c-opts=...}

For example, to compile \Apips with Fortran 95 support, use:
\begin{verbatim}
p4a_setup.py --only=pips --pips-c-opts="--enable-tpips --enable-pyps \
  --enable-hpfc --enable-fortran95" --reconf --no-final
\end{verbatim}

To recompile and intall \Apips after subsequent modifications, use:
\begin{verbatim}
p4a_setup.py --only=pips --no-final
\end{verbatim}

Beware that if \verb|--pips-src| is used to designate a \Apips
directory that has been previously build in a classical way (such as
the classical \Asvn build), the compilation will fail because of
incorrect dependencies between the files contained therein (which are not
related to \Apfa \texttt{build} directory location). Prior to running
the script, run the following in the \Apips source directory.
\begin{verbatim}
make clean
\end{verbatim}

To recompile a part of \Apfa (for example to debug
one of the components) without using \verb|p4a_setup.py|, change to
the directory \verb|$P4A_ROOT/build| in the relevant component. For
example, change to \verb|$P4A_ROOT/build/newgen| and type:
\begin{verbatim}
make
\end{verbatim}
and upon completion, type:
\begin{verbatim}
make install
\end{verbatim}
to complete the build process. The direct \texttt{install}
approach can be used to avoid testing the compilation a
priori. However, the 2-step 
approach is most useful if, for example, there is a debug session or a
validation on the installed version and at the same time, a parallel
development and verification effort. One can work in the latter
without invalidating the running version.

\subsection{The \protect\texttt{p4a\_setup.py} compilation and installation
script}
\label{sec:p4a_s-comp-script}

The compilation and installation of \Apfa is controlled by the
\verb|p4a_setup.py| script, with the usage and options described in
this section.

\input{p4a_setup-help}


\section{Collaborative repositories}
\label{sec:coll-repos}


\subsection{Public repositories}
\label{sec:public-repositories}

There are several \Agit repositories used by the project.

To have access without authentication and only for reading/cloning, use
the \texttt{git:} prefix instead of \texttt{ssh:}, e.g.,
\url{git://git.hpc-project.com/git/par4all.git}.

The main repository for the project is located at
\url{ssh://git.hpc-project.com/git/par4all.git}

This repository can be viewed with a \Awww browser at
\url{https://git.hpc-project.com/cgit/par4all}

To get directly involved into the project with full commit capability
directly into the repositories, ask \Ahpcp.

There are also ancillary \Agit repositories that provide a \Agit interface to
the trunk of the \Asvn repositories for the \Apips components from
\Acri:
\begin{itemize}
\item \url{ssh://git.hpc-project.com/git/svn-linear.git}
\item \url{ssh://git.hpc-project.com/git/svn-newgen.git}
\item \url{ssh://git.hpc-project.com/git/svn-nlpmake.git}
\item \url{ssh://git.hpc-project.com/git/svn-pips.git}
\item \url{ssh://git.hpc-project.com/git/svn-validation.git}
\end{itemize}
These ancillary gateways only include the \texttt{trunk} history since the
\Acri branches are not public.

In the case of \texttt{nlpmake}, another \Agit{} \Asvn gateway at the top
level has been used for the integration with \texttt{trunk},
\texttt{branch} and \texttt{tag}. This is due to the fact that
\texttt{nlpmake} started without the standard 
layout, which was added later at approximately revision 750. Because
of this prior history, this gateway is not published in a public git.

\subsection{Private repositories}
\label{sec:private-repositories}

There is a private directory shared between core developers and used mainly
for validation of the project on non public codes, benchmarks, demos,
and for developing private reports, phases, scripts and so on:
\url{ssh://git.hpc-project.com/git/par4all-private.git}

For \Ahpcp-confidential information,
\url{ssh://git.hpc-project.com/git/par4all-private-hpc.git} is used.

Other repositories can be created and used on demand according to the
needs of evolving private collaborations.

\section{Packages}
\label{sec:packages}

\Apfa integrates different tools from different projects. Currently, \Apfa
is composed of \Apips, \Apipsgfc, \Apolylib, with some extensions. Each
project is included in \Apfa as a package and is placed in a directory
inside the \texttt{package} top-level directory. 
These directories exist as \Agit subtrees to ease revision control and
integration, including off-line revisions.

Since \Apfa is an integration project, to modify or develop in
a particular package, please work in the upstream package and not in
\Apfa\footnote{In fact, this method is used for \Apfa development at Rensselaer
  Polytechnic Institute; global developments in \Apips are created
  directly and easily into \texttt{package/PIPS}. However,
  the re-integration becomes more difficult since it requires extracting the
  patch history in \texttt{package/PIPS} and merging it into the \Apips
  upstream \Asvn repository.}. Working in this manner facilitates
compilation of \Apfa with package sources outside of \Apfa (see
\S~\ref{sec:p4a_s-comp-script}), which can be committed into their own upstream
version control systems.

\section{Directory organization}
\label{sec:direct-organ}
The \Apfa distribution contains the following directories:

\begin{description}
\item[\texttt{build}] is created when compiling the various
  \Apfa packages from the \Aautotools;
\item[\texttt{doc}] contains the sources of the \Apfa documentation,
  including those for the user and the programmer as well as those
  about the infrastructure;
\item[\texttt{examples}] contains some examples to exercise \Apfa;
\item[\texttt{packages}] contains the different components of \Apfa:
  \begin{description}
  \item[\texttt{PIPS}] contains the components of \Apips framework
    itself, including:
    \begin{description}
    \item[\texttt{linear}:] the main linear library of \Apips;
    \item[\texttt{newgen}:] the object management infrastructure used by
      \Apips;
    \item[\texttt{nlpmake}:] the makefile common infrastructure used by
      all the \Apips components
    \item[\texttt{pips}:] the \Apips core;
    \item[\texttt{validation}:] the validation of \Apips;
    \end{description}
  \item[\texttt{pips-gfc}] contains a \Agcc 4.4 source patch to be
    compiled and linked with \Apips that adds a Fortran 95+ parser to \Apips;
  \item[\texttt{polylib}] contains the \Apolylib linear library source;
  \end{description}
\item[\texttt{src}] contains sources of tools used for the internal
  organization of \Apfa itself, such as repository and product management,
  product publication, or run-time management (e.g., \verb|p4a_accel|);
\item[\texttt{\emph{PREFIX-DIR}}] contains the usable \Apfa is installed
  after compilation:
  \begin{description}
  \item[\texttt{bin}] contains the executable programs from \Apfa;
  \item[\texttt{doc}] contains the generated documentation for the \Apfa
    infrastructure;
  \item[\texttt{etc}] contains some generated configuration files;
  \item[\texttt{examples}] contains with some examples to exercise \Apfa;
  \item[\texttt{include}] contains the include files used for the
    compilation of \Apfa;
  \item[\texttt{lib}] contains the libraries used to run \Apfa;
  \item[\texttt{makes}] contains \texttt{make}-file tools for the
    \Apips validation;
  \item[\texttt{RELEASE-NOTES.txt}] is the release notes of this \Apfa
    instance;
  \item[\texttt{share}] contains shared files for run-time and
    configuration files
  \item[\texttt{VERSION}] is the current version of this \Apfa
    instance.
  \end{description}
\end{description}


\section{Repositories and work-flow}
\label{sec:repos-workfl}

For history tracking and collaborative development, \Apfa relies on a main
\Agit repository that is accessed by \Apfa developers, users, integrators,
and the production and quality assurance team.

The script \verb|p4a_git| is used to automate the management of the
workflow.

Since \Apfa extends some tools such as \Apips, their are some
ancillary repositories to ease the impedance matching between \Apfa and
those other projects.

Since \Apolylib is already a \Agit repository, it is simply fetched as a
remote \Agit into the \Apfa at the right place.

The process is more complex with \Apips, which is a project split in 5
independent \Asvn repositories requiring more effort for coherent presentation.
Toward this end, \Asvn-\Agit gateways are used to offer freedom of
development and independence from other review hierarchies. Using
these dateways, light
branches are stored into a common \Agit view of the \Apips{} \Asvn
repositories; these light branches can be pushed back into the \Apips{} \Asvn.

\subsection{The p4a\_git script to deal with workflow}
\label{sec:p4a_git-script-deal}

The \verb|p4a_git| script is used to manage the workflow of \Apfa
involving all the related \Agit and \Asvn repositories.

For easy rollback to a robust state, a branch can be created with
\texttt{git checkout -b} and tested independently prior to merging
with the public repository. If the independent branch fails, then it
can be deleted without impacting other work.
See the \texttt{git reset} documentation for more details.

Some use cases of \verb|p4a_git| require that the \verb|P4A_TOP|
environment variable be set to the top directory of the \Apfa
infrastructure wherein reside the various \Agit working copies involved in the
project.

The following section presents some examples, after which the full
list of options is described in detail.

\subsubsection{\protect\texttt{p4a\_git} and \protect\texttt{git} typical use cases}
\label{sec:p4a_git-typical-use}

The \Apfa \testtt{p4a} reference branches are used to contstruct \Apfa
and potentially contain integration work performed by \Apfa team
members beyond the current release. To retrieve an up-to-date version
of a reference branch, use:
\begin{verbatim}
p4a_git --branch-action "git checkout p4a\$suffix; git pull origin p4a\$suffix"
\end{verbatim}

Work performed on \Apfa itself without integrating new versions of upstream
packages is first integrated into the \texttt{p4a-own} branch using:
\texttt{git} stuff:
\begin{verbatim}
git checkout p4a
git merge p4a-own
\end{verbatim}
When the results are validated and reread, work is published to the
main \testtt{p4a} branch using:
\begin{verbatim}
git push origin p4a-own
git push origin p4a
\end{verbatim}

A typical example to build a \Apfa with the latest \Apips version into the
reference \verb|p4a| branch infrastructure after having merged
reference branches is as follows:
\begin{itemize}
\item fetch the most recent developments of upstream packets (\Apips,
  \Apolylib...):
\begin{verbatim}
p4a_git --update-git-svn
\end{verbatim}
\item merge the new versions of the upstream packages into the \Apfa
  reference branches
\begin{verbatim}
p4a_git --fetch-remote-git
\end{verbatim}
\item fuse all the component branches into the \Apfa integration
  branch hierarchy:
\begin{verbatim}
p4a_git --pull-remote-git
\end{verbatim}
\end{itemize}
At the end of this sequence of steps, the most recent developments in
all of \Apfa is contained in the \verb|p4a| branch infrastructure.
After testing and validation, this branch can be published as the latest
official version with:
\begin{verbatim}
p4a_git --branch-action git push origin p4a\$suffix
\end{verbatim}
If someone else updates a branch in the meantime, the new branches
must be merged back into the local versions by re-executing the sequence
of steps at the beginning of this section.

\subsubsection{More advanced use cases for \protect\texttt{p4a\_git}}
\label{sec:more-advanced-use}

The previous section provides enough guidance for simple integration
and maintenance of \Apfa. In this section, more advanced use cases are
presented.

The developer can create from \texttt{p4a} a branch infrastructure
\verb|p4a-very-personal|, with \verb|p4a-very-personal-pips| for
\Apips, \verb|p4a-very-personal-polylib| for \Apolylib, etc.,
with each attached to the main \verb|p4a|-prefixed branch
infrastructure. To do this, use;
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal
\end{verbatim}

To start from \texttt{p4a-0.2-alpha}, use:
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal p4a-0.2-alpha
\end{verbatim}

When finished, these branches can be pushed for sharing or merged 
into the main \Apfa \texttt{p4a} with:
\begin{verbatim}
p4a_git --branch-action git push origin p4a-very-personal\$suffix
\end{verbatim}

To pull all the different \Apfa branches that may have been
changed by others:
\begin{verbatim}
p4a_git --branch-action "git checkout p4a\$suffix; git pull origin p4a\$suffix"
\end{verbatim}

To set up all the tracking branches for version
\texttt{p4a-0.2-alpha} before you can use them:
\begin{verbatim}
p4a_git --branch-action git branch p4a-0.2-alpha\$suffix \
        remotes/origin/p4a-0.2-alpha\$suffix
\end{verbatim}
\texttt{}
Developing and trying a new version of the scripts dealing with
the \Apfa infrastructure itself, such as \verb|p4a_setup.py|, is
complicated by the fact that script execution changes the branch. This may
cause the script to disappear during execution since it has not been
committed into the final branch\footnote{This occurs when the script
  modifies its own branch. \smiley}..

To test script modifications, first clone the repository into a new
one in the \verb|$P4A_TOP| %$
directory. Then, set \verb|P4A_ROOT| to the new repository.
For a more independent development environment, one could also set
\verb|P4A_TOP| to a new world.
Then, set \verb|P4A_ETC| to point to the directory
that contains the \verb|p4a_git_lib.bash| that will be
used. Subsequent executions of the \verb|p4a_setup.py| under revision 
will act on the new sand-box repository working copy.

To test a \texttt{par4all} repository before the final push by
merging and building into a new \texttt{p5} repository, use the
following sequence of steps:
\begin{verbatim}
cd $P4A_TOP
git clone par4all p5
export P4A_ROOT=$P4A_TOP/p5
export P4A_ETC=$P4A_TOP/par4all/src/dev
$P4A_TOP/par4all/src/dev/p4a_git --add-remotes
# To recreate the tracking branches:
$P4A_TOP/par4all/src/dev/p4a_git --merge-remote-branches p4a remotes/origin/p4a
# Update the svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --update-git-svn
# Get the content of svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --fetch-remote-git
# Merge all the component branches into the p4a branch:
$P4A_TOP/par4all/src/dev/p4a_git --pull-remote-git
# Build all the infrastructure:
$P4A_TOP/par4all/src/dev/p4a_setup.py
# Source the new environment. Be carefull, it override the P4A_ETC
# variable above:
source $P4A_ROOT/run/etc/par4all-rc.sh
# Just try it now...
\end{verbatim}


\subsubsection{\protect\texttt{p4a\_git} options}
\label{sec:p4a_git-options}

The \verb|p4a_git| options are available in short and long forms:
\begin{description}
\item[\texttt{-h} or \texttt{--help}] display the usual help message;
\item[\texttt{-v} or \texttt{--verbose}] increase the verbosity of the
  script. For example, if used twice, the script enters into command
  tracing mode;
\item[\texttt{-u} or \texttt{--update-git-svn}] update the \Apips{}
  \Agit-\Asvn gateways that are into \verb|$P4A_TOP/CRI-git-svn|;%$
\item[\texttt{-g} or \texttt{--recursive-git-svn}] apply a \Agit command
  to all the git working copies inside the current directory
  recursively. If no argument is given, a \texttt{git svn rebase} is done;
\item[\texttt{-f} or \texttt{--fetch-remote-git}] fetch the objects from
  the remote \Agit repositories (the \Apips{} \Agit-\Asvn gateways and the
  \Apolylib{} \Agit);
\item[\texttt{-p} or \texttt{--pull-remote-git}] pull the objects from the
  remote \Agit repositories into their respective branches and update the
  \texttt{p4a} branch hierarchy to point to the last version of \Apfa;
\item[\texttt{-m} or \texttt{--merge-remote-branches}
  \texttt{\emph{<to-prefix>}} \texttt{\emph{[<origin-prefix>]}}] merge
  the entire
  \texttt{p4a} branch infrastructure into the
  \texttt{\emph{<to-prefix>}} branch architecture. If the
  \texttt{\emph{<to-prefix>}} branch infrastructure does not exist, it is
  created from the \texttt{\emph{<origin-prefix>}} branch infrastructure
  if provided, else from the \texttt{p4a} branch architecture;
\item[\texttt{-b} or \texttt{--branch-action} \texttt{\emph{args+}}] apply
  the \texttt{\emph{args+}} shell-script to a branch hierarchy, with the
  branch suffix available to the \texttt{\emph{args+}} script in the
  \verb|$suffix| variable. Do not forget to escape special shell
  characters you want in the final shell;
\item[\texttt{-a} or \texttt{--add-remotes}] create the remotes pointing
  to \verb|$P4A_CRI_GIT_SVN| and on the \Apolylib{} \Agit;
\item[\texttt{-r} or \texttt{--root} \texttt{<\emph{directory}>}] to
  change the git working repository.
\end{description}


\subsection{PolyLib work-flow}
\label{sec:polylib-workflow}

The basic workflow for \Apolylib is first to develop new features into the
original \Apolylib{} \Agit repository, and then to fetch into the
\Apfa{} \Agit and select particular features for the
\texttt{packages/polylib} of \Apfa. 

The script \verb|p4a_git| is used to automate the management of the
workflow.

\verb|p4a_git --pull-remote-git| pulls the \Apolylib into the
\texttt{polylib} branch so that global modifications can be applied there
if needed and later \texttt{git merge}d into the local working branch. In
this way, global modifications are persistent and available to everybody.

The following presents information on the direct management of the
\Apolylib workflow.

Since the \Apolylib is already in a \Agit repository, the
\texttt{polylib} is simply a remote reference in the \Apfa{} \Agit.
Therefore, to import the latest \Apolylib development into the \Apfa{}
\Agit for
inspection and inclusion, fetch \Apolylib with:
\begin{verbatim}
git fetch ICPS/polylib
\end{verbatim}

then merge the desired feature with
\begin{verbatim}
git merge -s subtree remotes/polylib/master
\end{verbatim}
or using any tree identifier. The \texttt{-s subtree} is necessary since in
\Apfa the \Apolylib files are not at the top-level directory. This should
be done into the \texttt{polylib} branch for compatibility with
the workflow chosen in \Apfa.


\subsection{PIPS work-flow}
\label{sec:pips-workflow}

\subsubsection{Compilation from sources outside of Par4All}
\label{sec:comp-from-sourc}

When developing \Apfa packages, it is of critical importance to test them
\emph{before} including them into \Apfa.
For example, a new \Apips version is developed in the
\Acri{} \Asvn repository before building \Apfa to test the integration.

This process has been described in section~\ref{sec:compilation};
further details are provided in the following example.

Assuming there is a \Asvn working copy of \Apips (including the \texttt{trunk}
into \texttt{prod}, your branch in \verb|pips_dev|, etc. Refer
to the \Apips developer guide for more information). Use the
\verb|--pips-src=| to make \Apfa point to this directory.

Verify that the correctd \Apfa variable is set in your shell, that
the previous configuration file from the \Apips \Asvn environment from
\Acri is not automatically sourced in your shell and that there are no
incorrect environment variables from previous invocations of a script
(e.g., \verb|PATH|, etc.)

Clean this directory to remove any dangling dependencies that may
result from previous
usage by \Apfa of a \Apips directory that was installed in the
classical manner. This is accomplished using:
\begin{verbatim}
cd <where the wanted PIPS is>
make clean
\end{verbatim}

Subsequently, a new \Apfa version is built using the new \Apips
version in debug mode using the following command, which uses
four compilation processes (assuming a 4-core machine):
\begin{verbatim}
src/simple_tools/p4a_setup.py -vvv --pips-src=<where the desired PIPS is> --debug --jobs=4
\end{verbatim}

After building the complete infrastructure, subsequent changes to
\Apips do not require rebuilding all packages or reconfiguring
\Apips. The following command recompiles \Apips only and skips the
installation of other \Apfa components:
\begin{verbatim}
src/simple_tools/p4a_setup.py -vvv --pips-src=<where the wanted PIPS is> \
   --debug --only=pips --no-final --jobs=4
\end{verbatim}

An example script performs all of the above actions can be found in:
\verb|src/simple_tools/p4a_setup_with_my_PIPS|:
\lstinputlisting[language=bash]{p4a_setup_with_my_PIPS}


\subsubsection{Debuging PIPS and p4a}
\label{sec:debuging-pips-p4a}

To debug \texttt{tpips} in \Apfa, it is sufficient to run \texttt{gdb
  tpips}\footnote{Or an equivalent debugger or frontend such as Eclipse or
  Emacs. For example with Emacs, use \texttt{M-x gdb} and then select
  many windows in the \texttt{Gud/Gdb-UI} menu.} and then \texttt{run
  \emph{the}.tpips} file in parameter.

To debug a \Apyps program, since indeed it is a Python program that uses
\Apips libraries, you then need to launch \texttt{gdb python} and inside
the debugger run the program with \texttt{run \emph{the\_PyPS\_file}.py}

To debug \texttt{p4a}, it is still a Python program, but you need to run
\texttt{p4a} and passing arguments to it. Since \texttt{p4a} itself
launch many processes, it is difficult to debug a \Apips directly for
example.

A first way is to ask the debugger to follow the
\texttt{fork()} and \texttt{exec()} system calls. For example in
\texttt{gdb}, setting \texttt{detach-on-fork off} and also looking at
\texttt{follow-exec-mode}.

A second easier way is to avoid \texttt{p4a} launching processes. This is
done with the \verb/--no-spawn/ option. Avoiding colors and other
decoration is useful when debugging, so the \verb/--plain/ is useful too.

So a good way to debug \texttt{p4a} from \texttt{gdb} it to launch first a
\texttt{gdb python} and then run \texttt{p4a} like:
\begin{verbatim}
run /usr/local/par4all/bin/p4a --plain --no-spawn
    -o hyantes-static-99_openmp hyantes-static-99.c -lm
\end{verbatim}

To run your own version of \texttt{p4a}, you can put the directory
containing your \texttt{p4a} \texttt{.py} libraries first into the
\texttt{PYTHONPATH} environment variable.

For memory debugging with Valgrind, look at
section~\ref{sec:scripts-debugging}.


\subsubsection{Internal organization}
\label{sec:intern-organ}

The work-flow related to \Apips is quite more complex since we must
consolidate data from 5 different \Asvn repositories. The script
\verb|p4a_git| is used to automate the management of this workflow too,
but we describes it further here if you want to dig into it.

The basic \Apips work-flow is to develop into the 5 original \Apips{}
\Asvn repositories at MINES ParisTech/\Acri and to import the selected
developments into the \Apfa{} \Agit.

For this, we use 5 \Agit repositories that are gateways with these \Asvn
repositories. For technical reasons, it is better that this kind of subtle
gateway exists in only one place and this is currently done on the laptop
of Ronan \textsc{Keryell}. Then these 5 gateways are used as remotes into
the \Apfa{} \Agit. To synchronize these gateways to the latest version of
the \Apips{} \Asvn repositories, use a \verb|pips_git| in the directory
owning these \Agit-\Asvn repositories.

But since we have then a \Agit interface of the original \Apips{} \Asvn
repositories and \Agit is quite more powerful than \Asvn, some people may
want to develop into \Apips with \Agit by using these gateways. For
example they may want to develop with common branches easily and when they
are right with them push them back into the \Apips{} \Asvn trunk. To have
a public interface for them, these \Agit gateways are pushed to public
\Agit repository programmers can play with. Regularly these public
gateways are synchronized manually with the \Apips{} \Asvn. Nevertheless,
\Asvn may not be credited with the right owner of the commit but with the
one running the gateway, which is not fair. So the preferred way is to
directly develop in the original \Apips \Asvn repository (eventually with
her own \Agit-\Asvn gateway).

The 5 public gateway \Agit repositories are also defined as 5 remotes into
the \Apfa{} \Agit:
\begin{description}
\item[\texttt{remotes/CRI/linear}]
\item[\texttt{remotes/CRI/newgen}]
\item[\texttt{remotes/CRI/nlpmake}]
\item[\texttt{remotes/CRI/pips}]
\item[\texttt{remotes/CRI/validation}]
\end{description}

These remote repositories are merged into \Apfa in the following
respective subtree directories:
\begin{description}
\item[\texttt{packages/PIPS/linear}]
\item[\texttt{packages/PIPS/newgen}]
\item[\texttt{packages/PIPS/nlpmake}]
\item[\texttt{packages/PIPS/pips}]
\item[\texttt{packages/PIPS/validation}]
\end{description}

To import the latest \Apips development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch the repositories you want
with:
\begin{verbatim}
git fetch CRI/linear
git fetch CRI/newgen
git fetch CRI/nlpmake
git fetch CRI/pips
git fetch CRI/validation
\end{verbatim}
These commands are also done by a \verb|p4a_fetch_all| that fetches also the
\Apolylib part.

You can then merge the feature you want with a \texttt{git merge -s
  subtree} from \texttt{remotes/CRI/.../master} as:
\begin{verbatim}
git merge -strategy=subtree remotes/CRI/linear/master
git merge -strategy=subtree remotes/CRI/newgen/master
git merge -strategy=subtree remotes/CRI/nlpmake/master
git merge -strategy=subtree remotes/CRI/pips/master
git merge -strategy=subtree remotes/CRI/validation/master
\end{verbatim}
or from any tree identifier to do more precise version selection. The
\texttt{-s subtree} is necessary since in \Apfa the \Apips files are not
at the top-level directory and you do not want them to appear at the
top-level directory.

To pull everything at one for testing, this is done with the
\verb|p4a_git| script described in \S~\ref{sec:p4a_git-script-deal}. Do
not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback.


\subsection{PIPS-GFC extension workflow}
\label{sec:pips-gfc-workflow}

\subsubsection{New version}
\label{sec:new-version}

In the work of Mehdi \textsc{Amini}, the branch
\texttt{p4a-gcc-gfc-4.4.3} contains the sources of \Agcc-\Agfc 4.4.3 to
get the Fortran~95. Then the branch is named also \texttt{p4a-gcc-gfc}
which is merged into \texttt{p4a-packages}.

During \Apfa construction, these sources are patched and compiled into the
\Apips Fortran~95 parser.

Concretely, to add for example the new 4.4.4 version, you do a:
\begin{verbatim}
git checkout p4a-gcc-gfc
git checkout -b p4a-gcc-gfc-4.4.4
<do your work and commit>
git checkout p4a-gcc-gfc
git merge p4a-gcc-gfc-4.4.4
\end{verbatim}


\subsubsection{Old version (historical)}
\label{sec:old-version}


This describes the organization at the begin of the project, if you want
to understand the past organization for historical reasons.

This part from Raphaël \textsc{Roosz}is into the \texttt{package/pips-gfc}
directory. It contains plain \Agcc core and Fortran 4.4.1 distribution,
pointed by the branch \texttt{gcc-4.4.1}

The development of \Apipsgfc should be done in the branch
\texttt{pips-gfc-4.4.1} and this branch should be merged with the
branch \texttt{gcc-4.4.1} into a branch \texttt{pips-gfc+gcc-4.4.1} with a
more global name \texttt{pips-gfc+gcc} tracking which version is to be
merged into the global \texttt{master} branch.

So in \texttt{pips-gfc-4.4.1} there should be only files different from
the \Agcc distribution. In this way, if we want to have more subtle
construction methods, later, it will be clearer how to get the real
content.

There is the same variation in branches for version 4.4.2.

So to develop and test the \Apipsgfc extension, you get into for example
\texttt{pips-gfc-4.4.1} with
\begin{verbatim}
git checkout pips-gfc-4.4.1
\end{verbatim}
and develop your code in this branch.

To test, you commit and change to the \texttt{pips-gfc+gcc-4.4.1} branch with
\begin{verbatim}
git checkout pips-gfc+gcc-4.4.1
\end{verbatim}
where you merge with a
\begin{verbatim}
git merge pips-gfc-4.4.1
\end{verbatim}
and compile. If you are happy, you commit or you revert and then go back
into branch \texttt{pips-gfc-4.4.1}.

If you want to avoid spoiling the branches \texttt{pips-gfc-4.4.1} and
\texttt{pips-gfc+gcc-4.4.1}, you can create sub-branches of them, commit in
them and merge this work in the former one back (with the \verb|--slashed|
if you want to be modest about your gory hesitations \smiley{} and delete
these branches).


\subsection{Setting and running the infrastructure up}
\label{sec:setup}

There are scripts to ease the developer and user life.


\subsubsection{Scripts for an everyday work}
\label{sec:an-everyday-work}

\begin{itemize}
\item to automate the \Apfa workflow and deal with \texttt{git} stuff, the
  \verb|p4a_git| is available, as described in
  \S~\ref{sec:p4a_git-script-deal};
\item \verb|p4a_post_processor.py| is used to generate programs that use
  the \Apfa Accel runtime from the \Apips output. This script is more
  detailed on section~\ref{sec:p4a_p-script-from};
\item \verb|p4a_recover_includes| is mainly used to get standard
  \verb|#include| back after \Apips digestion. See
  section~\ref{sec:p4a_recover_includes} for the use case;
\item \verb|p4a_setup.py| is used to compile all the \Apfa infrastructure and
  to set up many things. It should be used at least for the first
  compilation. See \S~\ref{sec:p4a_s-comp-script} for more details;
\item \verb|p4a_validate| is used to leverage the \Apips validation.
\end{itemize}


\subsubsection{Scripts for debugging}
\label{sec:scripts-debugging}

\begin{itemize}
\item \verb|p4a_recover_includes| can be used to evaluate the inclusion of
  \Apfa Accel to ease debugging this package without evaluating other
  preprocessor inclusion. See section~\ref{sec:p4a_recover_includes} for
  the use case;
\item \verb|p4a_valgrind| launch a command with Valgrind with a memory
  checker in paranoid mode, mainly with the options described in the
  \Apips development guide. As seen in section
  \ref{sec:debuging-pips-p4a}, to debug \Apips in \texttt{p4a}, it is
  useful to call it like in:
\begin{verbatim}
p4a_valgrind python /usr/local/par4all/bin/p4a --plain --no-spawn
             -o hyantes-static-99_openmp hyantes-static-99.c -lm
\end{verbatim}
  Of course you can also use \texttt{valgrind} instead of
  \verb/p4a_valgrind/ for less verbosity.
\end{itemize}


\subsubsection{Scripts used to setup the infrastructure}
\label{sec:scripts-used-setup}

Some scripts used to setup the infrastructure. They have been used to
bootstrap the \Apfa infrastructure and should not be used by ordinary
people but contain some interesting hacks that could be usefull for other
projects or if things go really wrong. There are located in
\texttt{src/dev}, that should be used in this order:
\begin{itemize}
\item \verb/p4a_create_CRI_git_svn/ is used once to create the \Apips{}
  \Asvn-\Agit gateways. This script is here to show how it can be done but
  also to keep track of the exact parameters used to create them in the
  case we loose them and want to recreate them with exactly with the same
  identifiers (that depends from the creation parameters);
\item \verb/p4a_import_external_gits/ imports all the external \Agit
  repositories into the \Apfa{} \Agit repository. It should be used only
  once but are included as example for other projects or to help adding
  other repositories later;
\item \verb/p4a_apply_pips_patches/ is used to patch the original \Apips
  files to fit the \Apfa architecture. It should be used only once, after
  external \Agit import. It is no longer used since we switch to the
  \Aautotools version of \Apips;
\end{itemize}


\subsubsection{Script to deal with the documentation}
\label{sec:script-deal-with}

\begin{itemize}
\item \verb|optparse_help_to_tex| is a small compiler that transforms a
  help output message of a command (using the \texttt{optparse} format)
  when launched with \texttt{-h} into La\TeX{} code for inclusion in
  articles or slides. See \S~\ref{sec:help-docum-tex} for more details;
\item \verb|p4a_doc| in \verb|src/dev| is used to compile the \Apfa
  documentation and publish it on the server. Have a look to
  \texttt{p4a\_doc -h} for the help.
\end{itemize}


\subsubsection{Making distributions}
\label{sec:making-distributions}

The \verb|p4a_pack.py| is used to build compressed \texttt{tar} balls or Debian
\texttt{.deb} packet files.

The place of where the \Apfa files are looked for is specified according
to the \verb|P4A_DIST| variable or \texttt{--dir} option, but there may be
some hard-coded locations at configure and build time, so moving the
installation directory afterwards and changing \verb|P4A_ROOT| to follow
the new location may not be enough.

So you should choose the location at build time. To have a distribution
that build up into for example \texttt{/usr/local/par4all}, you should
first create a \texttt{/usr/local/par4all} \emph{writable by you} (you may
create this directory as super-user and change the owner to you with a
\texttt{chown}), and do a \verb|p4a_setup.py|.

Then you can pack this directory into what format you want with for
example:
\begin{alltt}
src/simple_tools/p4a_pack.py <--deb|--tgz> --revision=\emph{0.1-mybuild} \(\backslash\)
  --dir=\emph{/current/install/dir} [--prefix=\emph{/final/install/dir}]
\end{alltt}

Here are the usage and full option list of this command.

\input{p4a_pack-help}


\subsubsection{Making releases}
\label{sec:releases}

After validating, a release is done by making some branch at a given state
a tag.

There is also a \verb|p4a_coffee.py| script to build and publish everything
at once.

\input{p4a_coffee-help}


\section{Examples and demos}
\label{sec:examples-demos}

The \texttt{examples} directory comes with examples to show some aspects
of \Apfa. Of course there are far more examples in the validation of \Apfa
(\S~\ref{sec:validation}) but it is often less pedagogical.


\section{Validation}
\label{sec:validation}


Validation of \Apfa is done inside the \texttt{validation} directory with
\texttt{make validate}.

But right now it is still mostly done in the
\texttt{package/PIPS/validation} directory.


\subsection{\protect\texttt{p4a\_validate} utility}
\label{sec:p4a_validate-utility}


To ease interacting with the validation, the \verb|p4a_validate| is a
script that adds the concept of validation classes to the \Apips
validation. A class is a set of validation cases.

TODO: For example we may have a class for \texttt{ALL} the validation, the
\texttt{CHANGED}, \texttt{FAILED}, \texttt{PASS}, \verb|PREVIOUS_ALL|,
\verb|PREVIOUS_CHANGED|, \verb|PREVIOUS_FAILED|, \verb|PREVIOUS_PASS|,
whatever user class and it is possible to make actions with them, combine
them with operators (unions, intersections...).

TODO: Some other classes can be defined directly in the validation
directories with \texttt{.vclass} line-oriented regexp filter lines or
generic Python code \texttt{.vclasspy}.

\verb|p4a_validate| has a small script interface, but the power user
should use the Python classes directly, for example from \texttt{iPython}
to add interactivity.

The first use in \Apfa is to select from \Apips only the test cases that
pass the validation (futuristic cases are interesting for \Apips but from
least interest for \Apfa...), defining smaller validation classes such as
a \Amat (Minimal Acceptance Test).


\subsubsection{Example}
\label{sec:example}

To display from the last validation the test cases marked as
\texttt{changed} only in \verb|C_syntax|, you can use:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/' \
             --keep-status=changed --list
\end{verbatim}

To show what changed compared to the reference:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/decl' \
             --keep-status=changed --show-diff-files
\end{verbatim}

To accept the validation of what changed in \texttt{C\_syntax/decl\emph{*}}:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/decl' \
             --keep-status=changed --accept
\end{verbatim}
then if you are happy with it you can commit with \Agit or revert back to
previous state with \Agit.

You may want to move all the currently failing test of the validation for
\texttt{Control} into a new validation directory \texttt{Control-Bugs} to
clean up the mainstream validation. You can do with:
\begin{verbatim}
mkdir Control-Bugs
p4a_validate --file=RESULTS/SUMMARY  --list --filter=^Control/ --keep-status=failed \
 | sed -n -e 's,failed: ,,p' > files-to-move
\end{verbatim}
If you are happy after inspection of \texttt{files-to-move} after some
cleaning with a
\begin{verbatim}
rm -rf Control/*.database
\end{verbatim}
you can really move stuffs into with:
\begin{verbatim}
for f in `cat files-to-move` ; do git mv $f* Control-Bugs ; done
\end{verbatim}


\subsubsection{Option list of \protect\texttt{p4a\_validate}}
\label{sec:opti-list-p4a_v-1}

Here is a small description of the usage and options of
\verb|p4a_validate|, that are processed in the order of class
construction, filtering, display and acceptance, so that you can pipe
actions. To be useful, \verb|pips_validate| should be run with the
\texttt{-k} (history keeping) option before, so that you can operate on
differences between different validations.

\input{p4a_validate-help}


\subsection{Validation script}
\label{sec:validation_script}

It is possible to select different options to test with the python script
\verb|p4a_validate_class.py|

Currently, available options are:
\begin{description}
\item[\texttt{--pips}:] validate tests which are done by default file (in
  \texttt{packages/PIPS/validation})

\item[\texttt{--p4a}:] validate tests which are done by
  \verb|par4all_validation.txt| (which must be previously created in
  \texttt{src/validation})

\item[\texttt{--diff}:] this command make a diff between tests done by
  \texttt{--pips} and \texttt{--p4a} options. The list of the tests which
  are not done by \texttt{--p4a} options are into \texttt{diff.txt}

\item[\texttt{--dir}:] Validate tests which are done in \verb|packages/PIPS/validation/directory_name|. Syntax is \verb|./p4a_validate_class.py --dir dir1 dir2 dir3|

\item[\texttt{--test}:] Validate tests which are done in argument. Syntax is \verb|./p4a_validate_class.py --test directory_test/test.f| for example

\item[\texttt{-h} or \texttt{--help}:] Help for \verb|p4a_validate_class.py|
\end{description}

Examples with \verb|p4a_validate_class.py|:
\begin{verbatim}
python p4a_validate_class.py --pips
\end{verbatim}
or
\begin{verbatim}
python p4a_validate_class.py --p4a
\end{verbatim}

To use the option \texttt{--p4a}, a \verb|par4all_validation.txt| must be
previously created. This file lists all tests that the validation will do.
Syntax to add a new test is: \verb|directory_test/name_test|.

Be careful when adding a test to \verb|par4all_validation.txt|, put the
correct extension (\texttt{.c}, \texttt{.f}, \texttt{.F},
\texttt{.F90}). Don't use \texttt{.tpips}, \texttt{.tpips2}... extensions.

Example of a \verb|par4all_validation.txt| with 2 tests:
\begin{verbatim}
Syntax/alias.f
Syntax/altret01.f
\end{verbatim}


\section{Branches}
\label{sec:branches}

Since there are restrictions on the use of \texttt{/} in branch names, we
prefer to use \texttt{-} to add hierarchy.

To ease the developments and the organization, there are some already
defined branches:
\begin{description}
\item[\texttt{gcc-4.4.1}] is the original \Agcc 4.4.1 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{gcc-4.4.2}] is the original \Agcc 4.4.2 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{initial}] points to the initial commit of the \Apfa
  repository. It is useful to add stuff directly add the root of the
  repository to set the branch for the different packages. It should not
  be useful for normal people;
\item[\texttt{p4a-\emph{numerical}}] a branch corresponding to a given version
  snapshot;
\item[\texttt{p4a-\emph{numerical}-alpha}] a branch corresponding to an alpha
  version of a given version snapshot;
\item[\texttt{p4a-\emph{numerical}-beta}] a branch corresponding to an beta
  version of a given version snapshot;
\item[\texttt{p4a}] is the branch to get the full latest \Apfa version
  with all the different components, that is the merge of the branches
  \texttt{p4a-own} and \texttt{p4a-packages};
\item[\texttt{p4a-linear}] points to the import of \Apips \texttt{linear}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/linear} and used to merge from when you want to use
  the last version from \texttt{linear};
\item[\texttt{p4a-newgen}] points to the import of \Apips \texttt{newgen}
  part. So this branch should contain only the files from
  \texttt{package/PIPS/newgen};
\item[\texttt{p4a-nlpmake}] points to the import of \Apips \texttt{nlpmake}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/nlpmake};
\item[\texttt{p4a-own}] points to the last development of the \Apfa own files,
  without packages, etc;
\item[\texttt{p4a-packages}] points to the last merge of all the \Apfa
  package components;
\item[\texttt{p4a-pips}] points to the import of \Apips \texttt{pips}
  par. Thus this branch should contain only the files from
  \texttt{package/PIPS/pips} and used to merge from when you want to use
  the last version from \texttt{pips};
\item[\texttt{p4a-polylib}] points to the import of \Apips \texttt{polylib}
  par. Thus this branch should contain only the files from
  \texttt{package/polylib} and used to merge from when you want to use
  the last version from \texttt{polylib};
\item[\texttt{p4a-validation}] points to the import of \Apips
  \texttt{validation} part, with only files into
  \texttt{package/PIPS/validation};
\item[\texttt{pips-gfc+gcc}] points to a working \Apipsgfc implementation
  of the Fortran 95 extension for \Apips in \texttt{package/pips-gfc};
\item[\texttt{pips-gfc-4.4.1}] points to the original developments of
  Raphaël in \Agcc in \texttt{package/pips-gfc}.
\end{description}


Of course, for a better tractability, there are also branches that point
to specific versions of conceptual branches such as
\texttt{p4a-0.2-alpha-nlpmake}, \texttt{p4a-own-0.1} or
\texttt{p4a-packages-0.2-beta}.


\section{Some \protect\Agit tricks useful in \protect\Apfa}
\label{sec:some-agit-tricks}

\subsection{You have committed to the wrong branch}
\label{sec:you-have-comited}

There are (too) many branches in \Apfa, right? It is so easy for example
to do a commit on the \texttt{p4a} for example instead of the
\texttt{p4a-own} one. The good new is that since \Agit separate commit and
publish phase, if you reread what you have done with for example
\texttt{gitk}, you should figure out what you did wrong before it explode
to the faces of your colleagues.

Here is an example of a wrong \texttt{p4a} commit and how to get your work
in a good way before pushing to others.

First create a branch to ease following of what you did wrong:
\begin{verbatim}
git checkout -b wrong
\end{verbatim}
Go back up to a clean state (here only 1 \verb|^| so only to the previous
commit):
\begin{verbatim}
git branch -f p4a p4a^
\end{verbatim}
Move what you did wrong to the branch where it should always have been:
\begin{verbatim}
git rebase --onto p4a-own p4a wrong
\end{verbatim}
The go to the target branch:
\begin{verbatim}
git checkout p4a-own
\end{verbatim}
and merge in it your work:
\begin{verbatim}
git merge wrong
\end{verbatim}
and delete your helping branch:
\begin{verbatim}
git branch -d wrong
\end{verbatim}
Magic isn't it? \smiley

You can see that your wrong work is still connected to the branch
\texttt{p4a}, but no longer \emph{in} the branch. It is typical
representative of all the work done in \Apfa to avoid loosing information.


\appendix

\section{Various script details}
\label{sec:vari-script-deta}

Here are described the options or various minor scripts that should have
obfuscated the main part.

\subsection{The \protect\texttt{p4a\_recover\_includes} script}
\label{sec:p4a_recover_includes}

\verb|p4a_recover_includes| is used to get C standard \verb|#include|
after \Apips digestion to have nicer recompilation (for \Acuda it is a
requirement) and of course nicer code instead of ugly macro inclusion at
the beginning of all the files.

This script can also be use to do expansion of the \verb|#include| of
\Apfa Accel only to have a look for example to the real \Acuda or \Aopenmp
that is generated.

\input{p4a_recover_includes-help}


\subsection{The \protect\texttt{p4a\_post\_processor.py} script from
  Par4All Accel}
\label{sec:p4a_p-script-from}

\verb|p4a_post_processor.py| is the script that transforms the \Apips
output into calls to \Apfa Accel. It is mainly used by the \texttt{p4a}
script but can be used for power users that need to write their own
specialized \Apips scripts with \texttt{tpips} or \texttt{PyPS}.

\input{p4a_post_processor.py-help}


\subsection{The \protect\texttt{optparse\_help\_to\_tex} help
  documentation to \TeX{} compiler}
\label{sec:help-docum-tex}

\verb|optparse_help_to_tex| is a small compiler that translates a help
output message of a command using the \texttt{optparse} format when
launched with \texttt{-h} into La\TeX{} code with section for inclusion in
an article or slide generation with Beamer.

The following section should be a very demonstration of this tool
indeed. \smiley

\input{optparse_help_to_tex-help}

%%ContentEnd

\end{document}


%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

