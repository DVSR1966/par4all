\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{alltt}
\usepackage{abbrev_reactive}
\let\OldRightarrow=\Rightarrow
\RequirePackage{marvosym}
\let\MarvosymRightarrow=\Rightarrow
\let\Rightarrow=\OldRightarrow
\RequirePackage{wasysym}
\let\Lightning\UnTrucIndefini% Car conflit entre ifsym et marvosym
\let\Sun\UnTrucIndefini%
\RequirePackage[weather]{ifsym}


\sloppy

\begin{document}

\title{Par4All organization\\
  \textsc{draft}\\
  ---\\
  HPC Project}

\author{Serge \textsc{Guelton} \and Ronan \textsc{Keryell} \and Grégoire
  \textsc{Péan} \and Claire \textsc{Seguin} \and Mickaël \textsc{Thievent}
  \and Pierre \textsc{Villalon}}

\maketitle

\tableofcontents{}

\section{Introduction}
\label{sec:introduction}

\Apfa is a platform that merges various open source developments
to aim at achieving the migration of software to multicore and other
parallel processors.

It is mainly developed by \Ahpcp, MINES ParisTech/\Acri, Institut
Télécom/Télécom Bretagne and others.

This document describes the internal organization of \Apfa and how its
construction relies on \Agit repositories, \Asvn repositories and other
projects.

Since it relies on other tool projects, the documentation of these other
projects should also be taken into account.

Before using \Apips, once it is installed, you should do, according to your
shell, a
\begin{verbatim}
source run/etc/par4all-rc.sh
\end{verbatim}
or a
\begin{verbatim}
source run/etc/par4all-rc.csh
\end{verbatim}


\section{Compilation}
\label{sec:compilation}

Once you have the \Apfa source directory (have a look to
section~\ref{sec:public-repositories}), \Apfa is compiled and configured
by running \verb|src/dev/p4a_setup| in it.

If you want to download \Apfa from the \Agit and compile it, try:
\begin{alltt}
  export P4A_ROOT=\emph{some-dir}
  git clone git://git.hpc-project.com/git/par4all.git $P4A_ROOT
  cd $P4A_ROOT
  git checkout -b p4a remotes/origin/p4a
  src/dev/p4a_setup
\end{alltt}%$
Everything is built into \verb|$P4A_ROOT/build| and installed into
\verb|$P4A_ROOT/run|.

If you want to pull a new version, try
\begin{verbatim}
git pull origin p4a
\end{verbatim}
and recompile.

To be sure you do not break the compilation process, you should compile
your work before committing it on the central repositories. By a nice side
effect, it allows you to test your code. \smiley

More seriously, it is not obvious that it may compile on your account but
not for other people. For example because you forgot to commit some files.

A nice feature of \Agit over \Asvn is that since you split the commit from
the publication, you can test your own committed state before it hurts the
team when you push it on the global server.

For example, you can create a light\footnote{Because the objects are
  shared with symbolic links and not copied since we did not use the
  \texttt{file://} syntax.} clone with a
\begin{verbatim}
git clone par4all par4all-compile
\end{verbatim}
and after you have tested and committed your modifications inside the
\texttt{par4all} working copy, you do the same into the
\texttt{par4all-compile} working copy after a \texttt{git pull}.
If some files are lacking from the commit, it will be detected.

Afterwards you can do a \texttt{git push} into the central \Apfa
repository with less risks.

The classical \Aautotools environment variables can be used to influence
the compilation. The most important one are \texttt{CFLAGS} and
\texttt{CPPFLAGS} to compile \Apfa in debug mode. For example,
\begin{verbatim}
export CFLAGS='-ggdb -g3 -Wall -std=c99'
\end{verbatim}
are good debugging options (to set \emph{before} using the \Aautotools,
that is, \emph{before} using \verb|p4a_setup|) that allow \texttt{gdb} to
access macro definitions that are heavily used in \Apips.

You can pass some options to \verb|src/dev/p4a_setup| to modify the
installation process:
\begin{description}
\item[\texttt{--skip-polylib}:] skip the \Apolylib installation;
\item[\texttt{--skip-newgen}:] skip the \Anewgen installation;
\item[\texttt{--skip-linear}:] skip the \Alinear installation;
\item[\texttt{--skip-pips}:] skip the \Apips installation;
\item[\texttt{-v|--verbose}:] be verbose;
\item[\texttt{-h|--help}:] display this usage;
\item[\texttt{\emph{compilation targets}}:] the targets that are built, by
  default it is \texttt{autoreconf configure install}.
\end{description}

If you often want to skip the compilation of a package you can define with
some value respective environment variable: \verb|P4A_SKIP_POLYLIB|,
\verb|P4A_SKIP_NEWGEN|, \verb|P4A_SKIP_LINEAR|, \verb|P4A_SKIP_PIPS|.

To speed up the compilation, you can pass options to the compilation with
the \verb|P4A_MAKE_OPTS| environment variable, such as with
\begin{verbatim}
export P4A_MAKE_OPTS=--jobs=8
\end{verbatim}
to compile with 8 processes.

You may want to compile \Apfa directly from source packages that are not
inside the \Apfa directory hierarchy (see \S~\ref{sec:direct-organ}). For
this, you can specify in the \texttt{P4A\_\emph{PACKAGE}\_SRC} the
location of the sources of \texttt{\emph{package}}, for example
\verb|P4A_PIPS_SRC| or \verb|P4A_POLYLIB_SRC|. If all these variables are
set (for example to a working copy of the \Apips{} \Asvn), you should be
able to compile with only the \texttt{p4a-own} branch. For the \Apips
packages, you should have the links to \texttt{nlpmake/makes} to have them
to compile.

You can change the options passed to \texttt{configure} for a package by
setting the \texttt{P4A\_\emph{PACKAGE}\_CONFIGURE\_OPTIONS} environment
variable.

For example, if you want just to compile \Apips with Fortran 95 support:
\begin{verbatim}
export P4A_PIPS_CONFIGURE_OPTIONS="--enable-tpips --enable-pyps \
  --enable-hpfc --enable-fortran95"
p4a_setup --skip-polylib --skip-newgen --skip-linear
\end{verbatim}

Then, if you have modified \Apips and you just want to recompile and
install it, just use:
\begin{verbatim}
p4a_setup --skip-polylib --skip-newgen --skip-linear install
\end{verbatim}

Beware that if you have used a \Apips directory to compile in an other
context (such as the classical \Asvn build), the compilation will fail
because of the wrong dependencies between files. You should do a
\begin{verbatim}
make clean
\end{verbatim}
there first.

Another way to recompile a part of \Apfa, for example when you are
debugging one of the components, without using \verb|p4a_setup|, you go to
\verb|$P4A_ROOT/build|, in the component you are interested, such as
\verb|$P4A_ROOT/build/newgen| and type a
\begin{verbatim}
make
\end{verbatim}
and when you are happy do a
\begin{verbatim}
make install
\end{verbatim}
to put it on production. You can also try directly the \texttt{install}
approach if you do not want to test the compilation first. But this 2-step
approach is interesting for example if you have a debug session or a
validation on the installed version and you want in parallel develop and
verify it still compiles at the same time without breaking the running
version.



\section{Collaborative repositories}
\label{sec:coll-repos}


\subsection{Public repositories}
\label{sec:public-repositories}

There are few \Agit repositories used by the project.

To have access without authentication and only for reading/cloning, you
can use the \texttt{git:} prefix instead of \texttt{ssh:}, such as
\url{git://git.hpc-project.com/git/par4all.git}.

The main repository for the project is:
\url{ssh://git.hpc-project.com/git/par4all.git}

It can be seen with a \Awww browser at
\url{https://git.hpc-project.com/cgit/par4all}

To get directly involved into the project with full commit right in the
repositories, ask \Ahpcp.

There are also ancillary \Agit repositories to offer a \Agit interface to
the trunk of the \Asvn repositories for the \Apips components from \Acri:
\begin{itemize}
\item \url{ssh://git.hpc-project.com/git/svn-linear.git}
\item \url{ssh://git.hpc-project.com/git/svn-newgen.git}
\item \url{ssh://git.hpc-project.com/git/svn-nlpmake.git}
\item \url{ssh://git.hpc-project.com/git/svn-pips.git}
\item \url{ssh://git.hpc-project.com/git/svn-validation.git}
\end{itemize}
These ancillary gateways only include the \texttt{trunk} history since at
\Acri branches are not public.

In the case of \texttt{nlpmake}, another \Agit{} \Asvn gateway of the top
level has been used for the integration (but is not published in a public
git because it is old history) with \texttt{trunk}, \texttt{branch} and
\texttt{tag} because \texttt{nlpmake} started without this standard
layout, that was added later around revision 750.


\subsection{Private repositories}
\label{sec:private-repositories}

There is a private directory shared between core developers used mainly
for validation of the project on non public codes, benchmarks, demos, for
developing private reports, phases, scripts and so on:
\url{ssh://git.hpc-project.com/git/par4all-private.git}

For \Ahpcp-confidential information,
\url{ssh://git.hpc-project.com/git/par4all-private-hpc.git} is used.

According to the evolving private collaborations, other repositories can
be created and used on demand.


\section{Packages}
\label{sec:packages}

\Apfa integrate different tools from different projects. Right now \Apfa
is composed by \Apips, \Apipsgfc, \Apolylib, with some extensions. Each
project is included in \Apfa as a package and is placed in a directory
inside the \texttt{package} top-level directory.


\section{Directory organization}
\label{sec:direct-organ}

\begin{description}
\item[\texttt{build}] is the directory created with the various productions
  of the compilation of all the \Apfa packages from the \Aautotools;
\item[\texttt{doc}] are the sources of the \Apfa infrastructure;
\item[\texttt{examples}] comes with some examples to exercise \Apfa;
\item[\texttt{packages}] contains the different components of \Apfa; of
  all the \Apfa packages: binaries, header files, documentation;
  \begin{description}
  \item[\texttt{PIPS}] contains the components of \Apips framework itself
    with
    \begin{description}
    \item[\texttt{linear}] is the \Apips linear library of \Apips;
    \item[\texttt{newgen}] is the object management infrastructure used by
      \Apips;
    \item[\texttt{nlpmake}] is the makefile common infrastructure used by
      all the \Apips components
    \item[\texttt{pips}] is the \Apips core;
    \item[\texttt{validation}] is the validation of \Apips
    \end{description}
  \item[\texttt{pips-gfc}] contains a \Agcc 4.4 source patched to be
    compiled and linked with \Apips to add a Fortran 95+ parser to \Apips;
  \item[\texttt{polylib}] contains the \Apolylib library source
  \end{description}
\item[\texttt{src}] contains source of tools used for the internal
  organization of \Apfa itself, such as repository and product management,
  publication process or some run-time, such as \verb|p4a_accel|;
\item[\texttt{run}] is where the usable \Apfa is installed after
  compilation:
  \begin{description}
  \item[\texttt{bin}] contains the executable programs from \Apfa;
  \item[\texttt{doc}] is the generated documentation for the \Apfa
    infrastructure; \marginpar{in share/doc/pips ?}
  \item[\texttt{etc}] contains some generated configuration files;
  \item[\texttt{include}] contains the include files used for the
    compilation of \Apfa;
  \item[\texttt{lib}] owns the libraries used to run \Apfa;
  \item[\texttt{makes}] contains some make stuff for the \Apips
    validation;
  \item[\texttt{share}] contains shared files for run-time and
    configuration files
  \end{description}
\end{description}


\section{Repositories and work-flow}
\label{sec:repos-workfl}

For history tracking and collaborative development, \Apfa relies on a main
\Agit repository that is accessed by \Apfa developers, users, integrators
and the product and quality team.

The script \verb|p4a_git| is used to automate the management of the
workflow.

Since \Apfa intimately extends some tools such as \Apips, their are some
ancillary repositories to ease the impedance matching between \Apfa and
those other project.

Since \Apolylib is already a \Agit repository, it is simply fetched as a
remote \Agit into the \Apfa at the right place.

But this is far more complex with \Apips which is a project split in 5
independent \Asvn repositories, so its organization needs more massage to
be presented in a coherent way, with some \Asvn-\Agit gateways. We can
take advantage of these gateways to offer more free developments with
light branches stored into a common \Agit view of the \Apips{} \Asvn
repositories that can be pushed back into the \Apips{} \Asvn .


\subsection{The p4a\_git script to deal with workflow}
\label{sec:p4a_git-script-deal}

The \verb|p4a_git| is used to manage the workflow of \Apfa involving all
the related \Agit and \Asvn repositories.

Do not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback. Have a look to the \texttt{git reset} documentation to undo
things if things go wrong.

Some commands of \verb|p4a_git| need to have the \verb|P4A_TOP|
environment variable defined to the top directory of the \Apfa
infrastructure that owns the various \Agit working copies involved in the
project.

The \verb|p4a_git| options come into short and long form:
\begin{description}
\item[\texttt{-h} or \texttt{--help}] display the usual help message;
\item[\texttt{-v} or \texttt{--verbose}] increase the verbosity of the
  script. For example, if used twice, the script enters into command
  tracing mode;
\item[\texttt{-u} or \texttt{--update-git-svn}] update the \Apips{}
  \Agit-\Asvn gateways that are into \verb|$P4A_TOP/CRI-git-svn|;%$
\item[\texttt{-g} or \texttt{--recursive-git-svn}] apply a \Agit command
  to all the git working copies inside the current directory
  recursively. If no argument is given, a \texttt{git svn rebase} is done;
\item[\texttt{-f} or \texttt{--fetch-remote-git}] fetch the objects from
  the remote \Agit repositories (the \Apips{} \Agit-\Asvn gateways and the
  \Apolylib{} \Agit);
\item[\texttt{-p} or \texttt{--pull-remote-git}] pull the objects from the
  remote \Agit repositories into their respective branches and update the
  \texttt{p4a} branch hierarchy to point to the last version of \Apfa;
\item[\texttt{-m} or \texttt{--merge-remote-branches}
  \texttt{\emph{<to-prefix>}} \texttt{\emph{[<origin-prefix>]}}] merge all
  the \texttt{p4a} branch infrastructure into the
  \texttt{\emph{<to-prefix>}} branch architecture. If the
  \texttt{\emph{<to-prefix>}} branch infrastructure does not exist, it is
  created from the \texttt{\emph{<origin-prefix>}} branch infrastructure
  if provided, else from the \texttt{p4a} branch architecture;
\item[\texttt{-b} or \texttt{--branch-action} \texttt{\emph{args+}}] apply
  the \texttt{\emph{args+}} shell-script to a branch hierarchy, with the
  branch suffix available to the \texttt{\emph{args+}} script in the
  \verb|$suffix| variable;
\item[\texttt{-a} or \texttt{--add-remotes}] create the remotes pointing
  into \verb|$P4A_CRI_GIT_SVN| and on the \Apolylib{} \Agit;
\item[\texttt{-r} or \texttt{--root} \texttt{<\emph{directory}>}] to
  change the git repository to work on.
\end{description}

A typical example to have a \Apfa with the last \Apips version into a very
personal \verb|p4a-very-personal| branch infrastructure:
\begin{verbatim}
p4a_git --update-git-svn
p4a_git --fetch-remote-git
p4a_git --pull-remote-git
\end{verbatim}
Then you have all \Apfa into the \verb|p4a| branch infrastructure.

If you want to begin from this \texttt{p4a} your own branch infrastructure
\verb|p4a-very-personal|, with \verb|p4a-very-personal-pips| for the
\Apips, \verb|p4a-very-personal-polylib| for the \Apolylib and so on,
attached to the main \verb|p4a|-prefixed branch infrastructure, you have
to do a:
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal
\end{verbatim}

If you want to start from the \texttt{p4a-0.2-alpha}, use a
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal p4a-0.2-alpha
\end{verbatim}

When you are happy with this version, you can push these branches for
sharing or merge them into the main \Apfa \texttt{p4a} with
\begin{verbatim}
p4a_git --branch-action git push origin p4a-very-personal\$suffix
\end{verbatim}

To push the official version, just use a:
\begin{verbatim}
p4a_git --branch-action git push origin p4a\$suffix
\end{verbatim}

An example to set up all the tracking branches for version
\texttt{p4a-0.2-alpha} before you can use them:
\begin{verbatim}
p4a_git --branch-action git branch p4a-0.2-alpha\$suffix \
        remotes/origin/p4a-0.2-alpha\$suffix
\end{verbatim}
\texttt{}
If you want to develop and try a new version of the scripts dealing with
the \Apfa infrastructure itself such as \verb|p4a_setup|, it becomes
really tricky since it change the branch when executing and the script
itself may disappear during it execution since it not committed into the
final branch\footnote{It is really a case where it cuts the branch it sits
on. \smiley}.

To test this, you can first clone the repository into a new one into the
\verb|$P4A_TOP| %$
directory. Then set \verb|P4A_ROOT| to the new repository,
and may be even \verb|P4A_TOP| to a new world if you really want to do
quite independent stuff. You set \verb|P4A_ETC| to point to the directory
where the \verb|p4a_git_lib.bash| you want to use is. Then you can execute
the \verb|p4a_setup| you are working on to do some action to the new
sand-box repository working copy.

Example to test the merge and build process into a new \texttt{p5}
repository from an old \texttt{par4all} one you want to test before
pushing all the stuff:
\begin{verbatim}
cd $P4A_TOP
git clone par4all p5
export P4A_ROOT=$P4A_TOP/p5
export P4A_ETC=$P4A_TOP/par4all/src/dev
$P4A_TOP/par4all/src/dev/p4a_git --add-remotes
# To recreate the tracking branches:
$P4A_TOP/par4all/src/dev/p4a_git --merge-remote-branches p4a remotes/origin/p4a
# Update the svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --update-git-svn
# Get the content of svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --fetch-remote-git
# Merge all the component branches into the p4a branch:
$P4A_TOP/par4all/src/dev/p4a_git --pull-remote-git
# Build all the infrastructure:
$P4A_TOP/par4all/src/dev/p4a_setup
# Source the new environment. Be carefull, it override the P4A_ETC
# variable above:
source $P4A_ROOT/run/etc/par4all-rc.sh
# Just try it now...
\end{verbatim}


\subsection{PolyLib work-flow}
\label{sec:polylib-workflow}

The basic workflow for \Apolylib is to develop new features into the
original \Apolylib{} \Agit, to fetch it into the \Apfa{} \Agit and select what
feature we want to have into the \texttt{packages/polylib} of \Apfa.

The script \verb|p4a_git| is used to automate the management of the
workflow.

\verb|p4a_git --pull-remote-git| pulls the \Apolylib into the
\texttt{polylib} branch so that you can apply global modifications there
if needed and later \texttt{git merge} it into your working branch. In
this way global modifications are persistent and available to everybody.

If you want to directly manage the \Apolylib workflow, here are some
details about how it works.

Since the \Apolylib is already in a \Agit, the \texttt{polylib} is simply
a remote in the \Apfa{} \Agit.

So to import the latest \Apolylib development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch \Apolylib with:
\begin{verbatim}
git fetch ICPS/polylib
\end{verbatim}

You can then merge the feature you want with
\begin{verbatim}
git merge -s subtree remotes/polylib/master
\end{verbatim}
or from any tree identifier. The \texttt{-s subtree} is necessary since in
\Apfa the \Apolylib files are not at the top-level directory. This should
be done into the \texttt{polylib} branch if you want to be compatible with
the workflow chosen in \Apfa.


\subsection{PIPS work-flow}
\label{sec:pips-workflow}

\subsubsection{Compilation from sources outside of Par4All }
\label{sec:comp-from-sourc}

Before digging into details, the most important thing when developing some
\Apfa packages is to be able to test them \emph{before} being included
into \Apfa.

For example, you may want to develop a new \Apips version that is in the
\Acri{} \Asvn repository and build all \Apfa to test it does work with.

The way to achieve it has been described in section~\ref{sec:compilation}
but we can detail it a bit further for this example.

For example, you have a \Asvn working copy of \Apips (the \texttt{trunk}
into \texttt{prod}, your branch in \verb|pips_dev|, or whatever. Refer
to the \Apips developer guide for more informations). You just need to
point this directory to \Apfa by setting the \verb|P4A_PIPS_SRC|
environment variable.

Be sure you do not have sourced the old configuration file of the \Apips
\Asvn environment from \Acri in your shell and that you do not have old
environment variables referring to it (\verb|PATH|...). You need to have
instead the right \Apfa variable set in your shell.

Then you clean this directory to remove dangling dependencies the first
time you use a classical \Apips directory with \Apfa with:
\begin{verbatim}
cd $P4A_PIPS_SRC
make clean
\end{verbatim}

You build a new \Apfa version using this \Apips version just with:
\begin{verbatim}
p4a_setup
\end{verbatim}


\subsubsection{Internal organization}
\label{sec:intern-organ}


The work-flow related to \Apips is quite more complex since we must
consolidate data from 5 different \Asvn repositories. The script
\verb|p4a_git| is used to automate the management of this workflow too,
but we describes it further here if you want to dig into it.

The basic \Apips work-flow is to develop into the 5 original \Apips{}
\Asvn repositories at MINES ParisTech/\Acri and to import the selected
developments into the \Apfa{} \Agit.

For this, we use 5 \Agit repositories that are gateways with these \Asvn
repositories. For technical reasons, it is better that this kind of subtle
gateway exists in only one place and this is currently done on the laptop
of Ronan \textsc{Keryell}. Then these 5 gateways are used as remotes into
the \Apfa{} \Agit. To synchronize these gateways to the latest version of
the \Apips{} \Asvn repositories, use a \verb|pips_git| in the directory
owning these \Agit-\Asvn repositories.

But since we have then a \Agit interface of the original \Apips{} \Asvn
repositories and \Agit is quite more powerful than \Asvn, some people may
want to develop into \Apips with \Agit by using these gateways. For
example they may want to develop with common branches easily and when they
are right with them push them back into the \Apips{} \Asvn trunk. To have
a public interface for them, these \Agit gateways are pushed to public
\Agit repository programmers can play with. Regularly these public
gateways are synchronized manually with the \Apips{} \Asvn. Nevertheless,
\Asvn may not be credited with the right owner of the commit but with the
one running the gateway, which is not fair. So the preferred way is to
directly develop in the original \Apips \Asvn repository (eventually with
her own \Agit-\Asvn gateway).

The 5 public gateway \Agit repositories are also defined as 5 remotes into
the \Apfa{} \Agit:
\begin{description}
\item[\texttt{remotes/CRI/linear}]
\item[\texttt{remotes/CRI/newgen}]
\item[\texttt{remotes/CRI/nlpmake}]
\item[\texttt{remotes/CRI/pips}]
\item[\texttt{remotes/CRI/validation}]
\end{description}

These remote repositories are merged into \Apfa in the following
respective directories:
\begin{description}
\item[\texttt{packages/PIPS/linear}]
\item[\texttt{packages/PIPS/newgen}]
\item[\texttt{packages/PIPS/nlpmake}]
\item[\texttt{packages/PIPS/pips}]
\item[\texttt{packages/PIPS/validation}]
\end{description}

To import the latest \Apips development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch the repositories you want
with:
\begin{verbatim}
git fetch CRI/linear
git fetch CRI/newgen
git fetch CRI/nlpmake
git fetch CRI/pips
git fetch CRI/validation
\end{verbatim}
These commands are also done by a \verb|p4a_fetch_all| that fetches also the
\Apolylib part.

You can then merge the feature you want with a \texttt{git merge -s
  subtree} from \texttt{remotes/CRI/.../master} as:
\begin{verbatim}
git merge -strategy=subtree remotes/CRI/linear/master
git merge -strategy=subtree remotes/CRI/newgen/master
git merge -strategy=subtree remotes/CRI/nlpmake/master
git merge -strategy=subtree remotes/CRI/pips/master
git merge -strategy=subtree remotes/CRI/validation/master
\end{verbatim}
or from any tree identifier to do more precise version selection. The
\texttt{-s subtree} is necessary since in \Apfa the \Apips files are not
at the top-level directory and you do not want them to appear at the
top-level directory.

To pull everything at one for testing, this is done with the
\verb|p4a_git| script described in \S~\ref{sec:p4a_git-script-deal}. Do
not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback.


\subsection{PIPS-GFC extension workflow}
\label{sec:pips-gfc-workflow}

\subsubsection{New version}
\label{sec:new-version}

In the work of Mehdi, \textsc{Amini}, the branch
\texttt{p4a-gcc-gfc-4.4.3} contains the sources of \Agcc-\Agfc 4.4.3 to
get the Fortran~95. Then the branch is named also \texttt{p4a-gcc-gfc}
which is merged into \texttt{p4a-packages}.

During \Apfa construction, these sources are patched and compiled into the
\Apips Fortran~95 parser.


\subsubsection{Old version}
\label{sec:old-version}


This part from Raphaël \textsc{Roosz}is into the \texttt{package/pips-gfc}
directory. It contains plain \Agcc core and Fortran 4.4.1 distribution,
pointed by the branch \texttt{gcc-4.4.1}

The development of \Apipsgfc should be done in the branch
\texttt{pips-gfc-4.4.1} and this branch should be merged with the
branch \texttt{gcc-4.4.1} into a branch \texttt{pips-gfc+gcc-4.4.1} with a
more global name \texttt{pips-gfc+gcc} tracking which version is to be
merged into the global \texttt{master} branch.

So in \texttt{pips-gfc-4.4.1} there should be only files different from
the \Agcc distribution. In this way, if we want to have more subtle
construction methods, later, it will be clearer how to get the real
content.

There is the same variation in branches for version 4.4.2.

So to develop and test the \Apipsgfc extension, you get into for example
\texttt{pips-gfc-4.4.1} with
\begin{verbatim}
git checkout pips-gfc-4.4.1
\end{verbatim}
and develop your code in this branch.

To test, you commit and change to the \texttt{pips-gfc+gcc-4.4.1} branch with
\begin{verbatim}
git checkout pips-gfc+gcc-4.4.1
\end{verbatim}
where you merge with a
\begin{verbatim}
git merge pips-gfc-4.4.1
\end{verbatim}
and compile. If you are happy, you commit or you revert and then go back
into branch \texttt{pips-gfc-4.4.1}.

If you want to avoid spoiling the branches \texttt{pips-gfc-4.4.1} and
\texttt{pips-gfc+gcc-4.4.1}, you can create sub-branches of them, commit in
them and merge this work in the former one back (with the \verb|--slashed|
if you want to be modest about your gory hesitations \smiley{} and delete
these branches).


\subsection{Setting and running the infrastructure up}
\label{sec:setup}

The installation has been tested on Ubuntu/Linux 9.10 and you need to have
at least these packages installed:
\marginpar{À compléter par Mickael \& Claire !}


There are scripts to ease the developer and user life.


\subsubsection{Scripts for an everyday work}
\label{sec:an-everyday-work}

\begin{itemize}
\item To automate the \Apfa workflow and deal with \texttt{git} stuff, the
  \verb|p4a_git| is available, as described in
  \S~\ref{sec:p4a_git-script-deal};
\item \verb|p4a_setup| is used to compile all the \Apfa infrastructure and
  setting up many things. It should be used at least for the first
  compilation;
\item \verb|p4a_validate| is used to leverage the \Apips validation.
\end{itemize}


\subsubsection{Scripts for debugging}
\label{sec:scripts-debugging}

\begin{itemize}
\item \verb|p4a_valgrind| launch a command with Valgrind with a memory
  checker in paranoid mode, mainly with the options described in the
  \Apips development guide.
\end{itemize}


\subsubsection{Scripts used to setup the infrastructure}
\label{sec:scripts-used-setup}


Some scripts used to setup the infrastructure. They have been used to
bootstrap the \Apfa infrastructure and should not be used by ordinary
people but contain some interesting hacks that could be usefull for other
projects or if things go really wrong. There are located in
\texttt{src/dev}, that should be used in this order:
\begin{itemize}
\item \verb/p4a_create_CRI_git_svn/ is used once to create the \Apips
  \Asvn-\Agit gateways. This script is here to show how it can be done but
  also to keep track of the exact parameters used to create them in the
  case we loose them and want to recreate them with exactly with the same
  identifiers (that depends from the creation parameters);
\item \verb/p4a_import_external_gits/ imports all the external \Agit
  repositories into the \Apfa{} \Agit repository. It should be used only
  once but are included as example for other projects or to help adding
  other repositories later;
\item \verb/p4a_apply_pips_patches/ is used to patch the original \Apips
  files to fit the \Apfa architecture. It should be used only once, after
  external \Agit import. It is no longer used since we switch to the
  \Aautotools version of \Apips;
\end{itemize}


\section{Examples and demos}
\label{sec:examples-demos}

The \texttt{examples} directory comes with examples to show some aspects
of \Apfa. Of course there are far more examples in the validation of \Apfa
(\S~\ref{sec:validation}) but it is often less pedagogical.


\section{Validation}
\label{sec:validation}


Validation of \Apfa is done inside the \texttt{validation} directory with
\texttt{make validate}.

But right now it is still mostly done in the
\texttt{package/PIPS/validation} directory.

To ease interacting with the validation, the \verb|p4a_validate| is a
script that adds the concept of validation classes to the \Apips
validation. A class is a set of validation cases.

TODO: For example we may have a class for \texttt{ALL} the validation, the
\texttt{CHANGED}, \texttt{FAILED}, \texttt{PASS}, \verb|PREVIOUS_ALL|,
\verb|PREVIOUS_CHANGED|, \verb|PREVIOUS_FAILED|, \verb|PREVIOUS_PASS|,
whatever user class and it is possible to make actions with them, combine
them with operators (unions, intersections...).

TODO: Some other classes can be defined directly in the validation
directories with \texttt{.vclass} line-oriented regexp filter lines or
generic Python code \texttt{.vclasspy}.

\verb|p4a_validate| has a small script interface, but the power user
should use the Python classes directly, for example from \texttt{iPython}
to add interactivity.

The first use in \Apfa is to select from \Apips only the test cases that
pass the validation (futuristic cases are interesting for \Apips but from
least interest for \Apfa...), defining smaller validation classes such as
a \Amat (Minimal Acceptance Test).

Here is a small description of the options of \verb|p4a_validate|, that
are processed in this very order, so that you can pipe actions. To be
useful, \verb|pips_validate| should be run with the \texttt{-k} (history
keeping) option before.

\begin{description}
\item[\texttt{--version}:] show program's version number and exit;

\item[\texttt{-h} or \texttt{--help}:] show this help message and exit;

\item[\texttt{--file=\emph{FILE}}:] Initialize a validation class from a plain
  line-oriented file of validation case names;

\item[\texttt{--old-diff-file=\emph{FILE}}:] add to a validation class the
  items from the old differences found in a validation diff output file;

\item[\texttt{--new-diff-file=\emph{FILE}}:] add to a validation class the
  items from the new differences found in a validation diff output file;

\item[\texttt{--keep-changed}:] filter the current validation class by
  keeping the "changed" elements only;

\item[\texttt{--keep-failed}:] filter the current validation class by
  keeping the ``failed'' elements only;

\item[\texttt{--keep-skipped}:] filter the current validation class by
  keeping the ``skipped'' elements only;

\item[\texttt{-f \emph{REGULAR-EXPRESSION}} or
  \texttt{--filter=\emph{REGULAR-EXPRESSION}}:] filter the current class
  by keeping all the validation items with a name matching a regular
  expression;

\item[\texttt{--filter-out=\emph{REGULAR-EXPRESSION}}:] filter out the
  current class by removing all the validation items with a name matching
  a regular expression;

\item[\texttt{-l} or \texttt{--list}:] list the elements of the validation
  class;

\item[\texttt{-s} or \texttt{--show-diff-files}:] show the output
  differences for the current class by looking into the \texttt{*.results}
  directories;
\item[\texttt{--show-diff-results}:] show the output differences for the
  current class from the \texttt{RESULTS} directory;

\item[\texttt{-a} or \texttt{--accept}:] accept for the current validation
  class;

\item[\texttt{-c \emph{MESSAGE}} or \texttt{--commit=\emph{MESSAGE}}:]
  commit in git the accepted modifications with the given message.
\end{description}

There are also some debug options:
\begin{description}
\item[\texttt{-v} or \texttt{--verbose}:] run in verbose mode;

\item[\texttt{-q} or \texttt{--quiet}:] run in quiet mode (default mode).
\end{description}


\section{Branches}
\label{sec:branches}

Since there are restrictions on the use of \texttt{/} in branch names, we
prefer to use \texttt{-} to add hierarchy.

To ease the developments and the organization, there are some already
defined branches:
\begin{description}
\item[\texttt{gcc-4.4.1}] is the original \Agcc 4.4.1 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{gcc-4.4.2}] is the original \Agcc 4.4.2 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{initial}] points to the initial commit of the \Apfa
  repository. It is useful to add stuff directly add the root of the
  repository to set the branch for the different packages. It should not
  be useful for normal people;
\item[\texttt{p4a-\emph{numerical}}] a branch corresponding to a given version
  snapshot;
\item[\texttt{p4a-\emph{numerical}-alpha}] a branch corresponding to an alpha
  version of a given version snapshot;
\item[\texttt{p4a-\emph{numerical}-beta}] a branch corresponding to an beta
  version of a given version snapshot;
\item[\texttt{p4a}] is the branch to get the full latest \Apfa version
  with all the different components, that is the merge of the branches
  \texttt{p4a-own} and \texttt{p4a-packages};
\item[\texttt{p4a-linear}] points to the import of \Apips \texttt{linear}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/linear} and used to merge from when you want to use
  the last version from \texttt{linear};
\item[\texttt{p4a-newgen}] points to the import of \Apips \texttt{newgen}
  part. So this branch should contain only the files from
  \texttt{package/PIPS/newgen};
\item[\texttt{p4a-nlpmake}] points to the import of \Apips \texttt{nlpmake}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/nlpmake};
\item[\texttt{p4a-own}] points to the last development of the \Apfa own files,
  without packages, etc;
\item[\texttt{p4a-packages}] points to the last merge of all the \Apfa
  package components;
\item[\texttt{p4a-pips}] points to the import of \Apips \texttt{pips}
  par. Thus this branch should contain only the files from
  \texttt{package/PIPS/pips} and used to merge from when you want to use
  the last version from \texttt{pips};
\item[\texttt{p4a-polylib}] points to the import of \Apips \texttt{polylib}
  par. Thus this branch should contain only the files from
  \texttt{package/polylib} and used to merge from when you want to use
  the last version from \texttt{polylib};
\item[\texttt{p4a-validation}] points to the import of \Apips
  \texttt{validation} part, with only files into
  \texttt{package/PIPS/validation};
\item[\texttt{pips-gfc+gcc}] points to a working \Apipsgfc implementation
  of the Fortran 95 extension for \Apips in \texttt{package/pips-gfc};
\item[\texttt{pips-gfc-4.4.1}] points to the original developments of
  Raphaël in \Agcc in \texttt{package/pips-gfc}.
\end{description}


Of course, for a better tractability, there are also branches that point
to specific versions of conceptual branches such as
\texttt{p4a-0.2-alpha-nlpmake}, \texttt{p4a-own-0.1} or
\texttt{p4a-packages-0.2-beta}.


\section{Making releases}
\label{sec:releases}

After validating, a release is done by making some branch at a given state
a tag.


\end{document}


%%% Local Variables: 
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

