\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{a4wide}
\usepackage{url}

\usepackage{alltt}
% Hmmm... Do not work with UTF-8:
% \usepackage{verbatim}

\usepackage{listings}%[hyper,procnames]
\lstset{extendedchars=true, language=C++, basicstyle=\scriptsize\ttfamily, numbers=left,
  numberstyle=\tiny, stepnumber=5, numberfirstline=true,
  tabsize=8, tab=\rightarrowfill, keywordstyle=\bf,
  stringstyle=\rmfamily, commentstyle=\rmfamily\itshape}

\usepackage{abbrev_reactive}
\let\OldRightarrow=\Rightarrow
\RequirePackage{marvosym}
\let\MarvosymRightarrow=\Rightarrow
\let\Rightarrow=\OldRightarrow
\RequirePackage{wasysym}
\let\Lightning\UnTrucIndefini% Car conflit entre ifsym et marvosym
\let\Sun\UnTrucIndefini%
\RequirePackage[weather]{ifsym}


\newcommand{\LINK}[1]{\url{#1}\xspace}
\newcommand{\PfaOrganizationPDF}{\LINK{http://download.par4all.org/doc/organization/par4all_organization.pdf}}
\newcommand{\PfaAllOrganizationHTDOC}{\LINK{http://download.par4all.org/doc/organization/par4all_organization.htdoc}}

\sloppy

% Number everything in the TOC:
\setcounter{secnumdepth}{10}
\setcounter{tocdepth}{10}

\begin{document}

\title{Par4All organization\\
  ---\\
  HPC Project}

\author{Amaury \textsc{Darsch} \and Serge \textsc{Guelton} \and Ronan
  \textsc{Keryell} \and Grégoire \textsc{Péan} \and Claire \textsc{Seguin}
  \and Mickaël \textsc{Thievent} \and Pierre \textsc{Villalon}}

\maketitle

You can get this document in PDF format on \PfaOrganizationPDF and in HTML
on \PfaAllOrganizationHTDOC.

% To automatically build reports from this content:
%%ContentBegin

\section{Introduction}
\label{sec:introduction}

\Apfa is a platform that merges various open source developments to ease
the migration of sequential software to multicore and other parallel
processors.

It is mainly developed by \Ahpcp, MINES ParisTech/\Acri, Institut
Télécom/Télécom Bretagne and others.

This document describes the internal organization of \Apfa and how its
construction relies on \Agit repositories, \Asvn repositories and other
projects.

Since it relies on other tool projects, the documentation of these other
projects should also be taken into account and are not included here.

This document describes also some internal details about how \Apfa works
and this can be useful to power user wanting to get more from \Apfa, not
only the \Apfa core developers.


\tableofcontents{}

\bigskip{}

\input{release-notes-extract}


\section{Compilation}
\label{sec:compilation}

\subsection{Packages needed to build and run Par4All}
\label{sec:pack-need-build}

The installation has been tested on Ubuntu/Linux 9.10 \& 10.04,
Fedora Core 13 and Debian/unstable.

To only run \Apfa with Debian or Ubuntu, the following packages are needed:
\begin{quote}
  \texttt{libncurses5}, \texttt{libreadline5}, \texttt{python},
  \texttt{python-ply}, \texttt{python3.1}, \texttt{gfortran}
\end{quote}

To only run \Apfa with Fedora Core 13, the following packages 13 are needed:
\begin{quote}
  \texttt{ncurses-5}, \texttt{readline}, \texttt{python},
  \texttt{python-ply}, \texttt{python3}, \texttt{gcc-gfortran}
\end{quote}

% To ease copy/paste:
% libncurses5 libreadline5 python python-ply python3.1 gfortran

If you want to compile \Apfa by your own with Debian or Ubuntu, you also 
need to the following packages:
\begin{quote}
  \texttt{cproto}, \texttt{indent}, \texttt{flex}, \texttt{bison},
  \texttt{automake}, \texttt{libtool}, \texttt{autoconf},
  \texttt{libreadline5-dev}, \texttt{python-dev}, \texttt{swig},
  \texttt{python-ply}, \texttt{python3.1}, \texttt{libgmp3-dev},
  \texttt{libmpfr-dev}, \texttt{gfortran}, \texttt{subversion},
  \texttt{git}
\end{quote}

If you want to compile \Apfa by your own with Fedora Core 13, you also
need to install the following packages:
\begin{quote}
  \texttt{cproto}, \texttt{indent}, \texttt{flex}, \texttt{bison},
  \texttt{automake}, \texttt{libtool}, \texttt{autoconf},
  \texttt{readline-devel}, \texttt{python-devel}, \texttt{swig},
  \texttt{python-ply}, \texttt{python3}, \texttt{gmp-devel},
  \texttt{mpfr-devel}, \texttt{gcc-gfortran}, \texttt{subversion},
  \texttt{git}
\end{quote}

% To ease copy/paste:
% cproto indent flex bison automake libtool autoconf libreadline5-dev python-dev swig python-ply python3.1 libgmp3-dev libmpfr-dev gfortran subversion git

If you want also to compile the documentation with Debian or Ubuntu, you 
also need:
\begin{quote}
  \texttt{texlive-full}, \texttt{tex4ht}
\end{quote}

If you want also to compile the documentation with Fedora Core 13, you 
also need:
\begin{quote}
  \texttt{texlive-2007}, \texttt{tetex-tex4ht}
\end{quote}

\subsection{The compilation process}
\label{sec:compilation-process}

Once you have the \Apfa source directory (have a look to
section~\ref{sec:public-repositories}), \Apfa is compiled and configured
by running \verb|src/simple_tools/p4a_setup| in it.

If you want to download \Apfa from the \Agit and compile it, do:
\begin{alltt}
# Get a working copy of the Par4All public read-only git repository:
git clone git://git.hpc-project.com/git/par4all.git
# Go into the working copy:
cd par4all
# Switch to the p4a branch, where everything is assembled:
git checkout -b p4a remotes/origin/p4a
# Build everything using 8 processes to speed up things:
src/simple_tools/p4a_setup [--prefix=\emph{/install/dir}] [-v[v[v]]] --jobs=8 [...]
\end{alltt}%
Everything will be installed into \verb|/usr/local/par4all| by default.
If you want to install in another location, use the \verb|--prefix|
option.  If you need more installation options (such as if you want to
specify the location for the various packages), run \verb|p4a_setup -h| to
list them or look at section~\ref{sec:p4a_s-comp-script}.

If you want to pull a new version, do:
\begin{verbatim}
git pull origin p4a
\end{verbatim}

And run \verb|p4a_setup| again. It is wise to do it with the
\verb|--rebuild| and \verb|--clean| parameters to make sure you recompile
everything (\Apips being a quickly moving project, incremental build is
not always guaranteed to work).

To create a \texttt{.deb} or \texttt{.tar.gz} package of the installation
you have made using \verb|p4a_setup| as explained in
\S~\ref{sec:making-distributions}.

About committing your change to the \Agit repository (assuming you work
only in the \texttt{p4a-own} branch itself and not in one of the \Apfa
sub-packages, in this case see section~\ref{sec:packages} to make sure you
do not break the compilation process, you should compile your work before
committing it on the central repositories. By a nice side effect, it
allows you to test your code. \smiley

More seriously, it is not obvious that it may compile on your account but
not for other people. For example because you forgot to commit some
files...

A nice feature of \Agit over \Asvn is that since you split the commit from
the publication, you can test your own committed state before it hurts the
team when you push it on the global server.

For example, you can create a light\footnote{Because the objects are
  shared with symbolic links and not copied, since we did not use the
  \texttt{file://} syntax.} clone with a
\begin{verbatim}
git clone par4all par4all-compile
\end{verbatim}
and after you have tested and committed your modifications inside the
\texttt{par4all} working copy, you do the same into the
\texttt{par4all-compile} working copy after a \texttt{git pull}.
If some files are lacking from the commit, it will be detected.

Afterwards you can do a \texttt{git push} into the central \Apfa
repository with less risks.

The classical \Aautotools environment variables can be used to influence
the compilation but some are directly set up from the \verb|p4a_setup|
script. So, if you want to set the \texttt{CFLAGS} and \texttt{CPPFLAGS}
to compile \Apfa in debug mode you should pass their value change through
a \verb|p4a_setup| option, for example with
\begin{verbatim}
--configure-options="CFLAGS='-ggdb -g3 -Wall -std=c99'"
\end{verbatim}
to set good debugging options that allow \texttt{gdb} to access macro
definitions that are heavily used in \Apips. Indeed this case is so common
when debugging \Apfa that the \verb|--debug| or \verb|-g| options are just
doing this for simplicity.

You can pass some options to \verb|p4a_setup| to modify the
installation process as explained in \S~\ref{sec:p4a_s-comp-script} for
all the options, for example to skip the (re)compilation of a package (for
example with \verb/--skip-polylib/).

To speed up the compilation, you can pass options to \texttt{make}, and more
specifically you can run on, say, 8 processes by adding the
\verb/--jobs=8/ option.

You may want to compile \Apfa directly from source packages that are not
inside the \Apfa directory hierarchy (see \S~\ref{sec:direct-organ}). For
this, you can specify with \texttt{-{}-\emph{PACKAGE}-src=...} the
location of the sources of \texttt{\emph{package}}, for example
\verb|-pips-src=...| or \verb|--polylib-src=...|. If all these options are
set (for example to a working copy of the \Apips{} \Asvn), you should be
able to compile with only the \texttt{p4a-own} branch. For the \Apips
packages, you should have the links to \texttt{nlpmake/makes} to have them
to compile. Have a look to \S~\ref{sec:comp-from-sourc} for more
information on this.

You can change the options passed to \texttt{configure} for a package by
using the \texttt{-{}-\emph{PACKAGE}-c-opts=...}

For example, if you want just to reconfigure to compile \Apips with
Fortran 95 support:
\begin{verbatim}
p4a_setup --only=pips --pips-c-opts="--enable-tpips --enable-pyps \
  --enable-hpfc --enable-fortran95" --reconf --no-final
\end{verbatim}

Then, if you have modified \Apips and you just want to recompile and
install it, just use:
\begin{verbatim}
p4a_setup --only=pips --no-final
\end{verbatim}

Beware that if you use a \Apips directory with \verb|--pips-src| and that
you also used before this directory to build \Apips in a classical way
(such as the classical \Asvn build), the compilation will fail because of
the wrong dependencies between files existing there and not related to the
\Apfa \texttt{build} directory location. You should do a
\begin{verbatim}
make clean
\end{verbatim}
in the \Apips source directory you are really using first.

Another way to recompile a part of \Apfa, for example when you are
debugging one of the components, without using \verb|p4a_setup|, you go to
\verb|$P4A_ROOT/build|, in the component you are interested, such as
\verb|$P4A_ROOT/build/newgen| and type a
\begin{verbatim}
make
\end{verbatim}
and when you are happy do a
\begin{verbatim}
make install
\end{verbatim}
to put it on production. You can also try directly the \texttt{install}
approach if you do not want to test the compilation first. But this 2-step
approach is interesting for example if you have a debug session or a
validation on the installed version and you want in parallel develop and
verify it still compiles at the same time without breaking the running
version.


\subsection{The \protect\texttt{p4a\_setup} compilation and installation
script}
\label{sec:p4a_s-comp-script}

The compilation and installation of \Apfa is controlled by the
\verb|p4a_setup| that has the following usage and options.

\input{p4a_setup-help}


\section{Collaborative repositories}
\label{sec:coll-repos}


\subsection{Public repositories}
\label{sec:public-repositories}

There are few \Agit repositories used by the project.

To have access without authentication and only for reading/cloning, you
can use the \texttt{git:} prefix instead of \texttt{ssh:}, such as
\url{git://git.hpc-project.com/git/par4all.git}.

The main repository for the project is:
\url{ssh://git.hpc-project.com/git/par4all.git}

It can be seen with a \Awww browser at
\url{https://git.hpc-project.com/cgit/par4all}

To get directly involved into the project with full commit right in the
repositories, ask \Ahpcp.

There are also ancillary \Agit repositories to offer a \Agit interface to
the trunk of the \Asvn repositories for the \Apips components from
\Acri:
\begin{itemize}
\item \url{ssh://git.hpc-project.com/git/svn-linear.git}
\item \url{ssh://git.hpc-project.com/git/svn-newgen.git}
\item \url{ssh://git.hpc-project.com/git/svn-nlpmake.git}
\item \url{ssh://git.hpc-project.com/git/svn-pips.git}
\item \url{ssh://git.hpc-project.com/git/svn-validation.git}
\end{itemize}
These ancillary gateways only include the \texttt{trunk} history since at
\Acri branches are not public.

In the case of \texttt{nlpmake}, another \Agit{} \Asvn gateway of the top
level has been used for the integration (but is not published in a public
git because it is old history) with \texttt{trunk}, \texttt{branch} and
\texttt{tag} because \texttt{nlpmake} started without this standard
layout, that was added later around revision 750.


\subsection{Private repositories}
\label{sec:private-repositories}

There is a private directory shared between core developers used mainly
for validation of the project on non public codes, benchmarks, demos, for
developing private reports, phases, scripts and so on:
\url{ssh://git.hpc-project.com/git/par4all-private.git}

For \Ahpcp-confidential information,
\url{ssh://git.hpc-project.com/git/par4all-private-hpc.git} is used.

According to the evolving private collaborations, other repositories can
be created and used on demand.


\section{Packages}
\label{sec:packages}

\Apfa integrates different tools from different projects. Right now \Apfa
is composed by \Apips, \Apipsgfc, \Apolylib, with some extensions. Each
project is included in \Apfa as a package and is placed in a directory
inside the \texttt{package} top-level directory.

Since \Apfa is an integration project, if you want to modify or develop in
some packages, please work in the upstream package and not in
\Apfa\footnote{Well, indeed this is the way \Apfa is used at Rensselaer
  Polytechnic Institute, with easy global developments in \Apips directly
  into the \texttt{package/PIPS} directory. It is quite easy to do so, but
  the re-integration is quite more difficult since you need to extract the
  patch history in \texttt{package/PIPS} and merge it into the \Apips
  upstream \Asvn repository anyway.}. Since it is easy to compile \Apfa
with some package stuff outside of \Apfa (see
\S~\ref{sec:p4a_s-comp-script}) and commit them onto their own upstream
version control systems.


\section{Directory organization}
\label{sec:direct-organ}

\begin{description}
\item[\texttt{build}] is the directory created when compiling the various
  \Apfa packages from the \Aautotools;
\item[\texttt{doc}] are the sources of the \Apfa documentation, for the
  user, the programmer and about the infrastructure;
\item[\texttt{examples}] comes with some examples to exercise \Apfa;
\item[\texttt{packages}] contains the different components of \Apfa:
  \begin{description}
  \item[\texttt{PIPS}] contains the components of \Apips framework itself
    with:
    \begin{description}
    \item[\texttt{linear}:] the main linear library of \Apips;
    \item[\texttt{newgen}:] the object management infrastructure used by
      \Apips;
    \item[\texttt{nlpmake}:] the makefile common infrastructure used by
      all the \Apips components
    \item[\texttt{pips}:] the \Apips core;
    \item[\texttt{validation}:] the validation of \Apips;
    \end{description}
  \item[\texttt{pips-gfc}] contains a \Agcc 4.4 source patched to be
    compiled and linked with \Apips to add a Fortran 95+ parser to \Apips;
  \item[\texttt{polylib}] contains the \Apolylib linear library source;
  \end{description}
\item[\texttt{src}] contains source of tools used for the internal
  organization of \Apfa itself, such as repository and product management,
  publication process or some run-time, such as \verb|p4a_accel|;
\item[\texttt{\emph{PREFIX-DIR}}] is where the usable \Apfa is installed
  after compilation:
  \begin{description}
  \item[\texttt{bin}] contains the executable programs from \Apfa;
  \item[\texttt{doc}] is the generated documentation for the \Apfa
    infrastructure;
  \item[\texttt{etc}] contains some generated configuration files;
  \item[\texttt{examples}] comes with some examples to exercise \Apfa;
  \item[\texttt{include}] contains the include files used for the
    compilation of \Apfa;
  \item[\texttt{lib}] owns the libraries used to run \Apfa;
  \item[\texttt{makes}] contains some \texttt{make}-file stuff for the
    \Apips validation;
  \item[\texttt{RELEASE-NOTES.txt}] stores the release notes of this \Apfa
    instance;
  \item[\texttt{share}] contains shared files for run-time and
    configuration files
  \item[\texttt{VERSION}] stores the current version of this \Apfa
    instance.
  \end{description}
\end{description}


\section{Repositories and work-flow}
\label{sec:repos-workfl}

For history tracking and collaborative development, \Apfa relies on a main
\Agit repository that is accessed by \Apfa developers, users, integrators
and the product and quality team.

The script \verb|p4a_git| is used to automate the management of the
workflow.

Since \Apfa intimately extends some tools such as \Apips, their are some
ancillary repositories to ease the impedance matching between \Apfa and
those other projects.

Since \Apolylib is already a \Agit repository, it is simply fetched as a
remote \Agit into the \Apfa at the right place.

But this is far more complex with \Apips which is a project split in 5
independent \Asvn repositories, so its organization needs more massage to
be presented in a coherent way, with some \Asvn-\Agit gateways. We can
take advantage of these gateways to offer more free developments, more
independent with some other review hierarchies, with light branches stored
into a common \Agit view of the \Apips{} \Asvn repositories that can be
pushed back into the \Apips{} \Asvn.


\subsection{The p4a\_git script to deal with workflow}
\label{sec:p4a_git-script-deal}

The \verb|p4a_git| script is used to manage the workflow of \Apfa
involving all the related \Agit and \Asvn repositories.

Do not forget it may be useful to create a branch with a \texttt{git
  checkout -b} before to test it, so the branch can be deleted for an easy
rollback. Have a look to the \texttt{git reset} documentation to undo
things if things go wrong.

Some commands of \verb|p4a_git| need to have the \verb|P4A_TOP|
environment variable defined to the top directory of the \Apfa
infrastructure that owns the various \Agit working copies involved in the
project.

We first introduce some examples before detailing all the options.


\subsubsection{\protect\texttt{p4a\_git} and \protect\texttt{git} typical use cases}
\label{sec:p4a_git-typical-use}

To get an up-to-date version of the \Apfa \texttt{p4a} reference branches
used to construct \Apfa, you can merge in all these branches containing
the integration work potentially done by your colleagues, if any, with a:
\begin{verbatim}
p4a_git --branch-action "git checkout p4a\$suffix; git pull origin p4a\$suffix"
\end{verbatim}

If you are only working in \Apfa it-self, that is into the
\texttt{p4a-own} branch, and you do not integrate new versions of upstream
packages, you can integrate your work with only simple classical
\texttt{git} stuff:
\begin{verbatim}
git checkout p4a
git merge p4a-own
\end{verbatim}
and if you are happy with the result (reread, validate...), publish it
with:
\begin{verbatim}
git push origin p4a-own
git push origin p4a
\end{verbatim}

A typical example to build a \Apfa with the last \Apips version into the
reference \verb|p4a| branch infrastructure after having merged potentially
colleague works as previously shown:
\begin{itemize}
\item you fetch all the development of upstream packets (\Apips,
  \Apolylib...):
\begin{verbatim}
p4a_git --update-git-svn
\end{verbatim}
\item then merge the new versions of the upstream packages into the \Apfa
  reference branches:
\begin{verbatim}
p4a_git --fetch-remote-git
\end{verbatim}
\item then fuse all the component branches into the \Apfa integration
  branch hierarchy:
\begin{verbatim}
p4a_git --pull-remote-git
\end{verbatim}
\end{itemize}
Then you have all \Apfa into the \verb|p4a| branch infrastructure. You can
test it, validate it. When all is correct, publish it as the last official
version with:
\begin{verbatim}
p4a_git --branch-action git push origin p4a\$suffix
\end{verbatim}
If someone update one of these branch in the meantime, you should merge
back the new branches into your own versions by restarting a cycle as
shown at the begin of this section.


\subsubsection{More advanced use cases for \protect\texttt{p4a\_git}}
\label{sec:more-advanced-use}

Previous section should be enough for normal integration and maintenance
of \Apfa, but here are described more actions in details.

If you want to begin from this \texttt{p4a} your own branch infrastructure
\verb|p4a-very-personal|, with \verb|p4a-very-personal-pips| for the
\Apips, \verb|p4a-very-personal-polylib| for the \Apolylib and so on,
attached to the main \verb|p4a|-prefixed branch infrastructure, you have
to do a:
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal
\end{verbatim}

If you want to start from the \texttt{p4a-0.2-alpha}, use a
\begin{verbatim}
p4a_git --merge-remote-branches p4a-very-personal p4a-0.2-alpha
\end{verbatim}

When you are happy with this version, you can push these branches for
sharing or merge them into the main \Apfa \texttt{p4a} with
\begin{verbatim}
p4a_git --branch-action git push origin p4a-very-personal\$suffix
\end{verbatim}

If you want to pull all the different \Apfa branches that may have been
changed by others:
\begin{verbatim}
p4a_git --branch-action "git checkout p4a\$suffix; git pull origin p4a\$suffix"
\end{verbatim}

An example to set up all the tracking branches for version
\texttt{p4a-0.2-alpha} before you can use them:
\begin{verbatim}
p4a_git --branch-action git branch p4a-0.2-alpha\$suffix \
        remotes/origin/p4a-0.2-alpha\$suffix
\end{verbatim}
\texttt{}
If you want to develop and try a new version of the scripts dealing with
the \Apfa infrastructure itself such as \verb|p4a_setup|, it becomes
really tricky since it change the branch when executing and the script
itself may disappear during it execution since it not committed into the
final branch\footnote{It is really a case where it cuts the branch it sits
on. \smiley}.

To test this, you can first clone the repository into a new one into the
\verb|$P4A_TOP| %$
directory. Then set \verb|P4A_ROOT| to the new repository,
and may be even \verb|P4A_TOP| to a new world if you really want to do
quite independent stuff. You set \verb|P4A_ETC| to point to the directory
where the \verb|p4a_git_lib.bash| you want to use is. Then you can execute
the \verb|p4a_setup| you are working on to do some action to the new
sand-box repository working copy.

Example to test the merge and build process into a new \texttt{p5}
repository from an old \texttt{par4all} one you want to test before
pushing all the stuff:
\begin{verbatim}
cd $P4A_TOP
git clone par4all p5
export P4A_ROOT=$P4A_TOP/p5
export P4A_ETC=$P4A_TOP/par4all/src/dev
$P4A_TOP/par4all/src/dev/p4a_git --add-remotes
# To recreate the tracking branches:
$P4A_TOP/par4all/src/dev/p4a_git --merge-remote-branches p4a remotes/origin/p4a
# Update the svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --update-git-svn
# Get the content of svn-git gateways:
$P4A_TOP/par4all/src/dev/p4a_git --fetch-remote-git
# Merge all the component branches into the p4a branch:
$P4A_TOP/par4all/src/dev/p4a_git --pull-remote-git
# Build all the infrastructure:
$P4A_TOP/par4all/src/dev/p4a_setup
# Source the new environment. Be carefull, it override the P4A_ETC
# variable above:
source $P4A_ROOT/run/etc/par4all-rc.sh
# Just try it now...
\end{verbatim}


\subsubsection{\protect\texttt{p4a\_git} options}
\label{sec:p4a_git-options}

The \verb|p4a_git| options come into short and long form:
\begin{description}
\item[\texttt{-h} or \texttt{--help}] display the usual help message;
\item[\texttt{-v} or \texttt{--verbose}] increase the verbosity of the
  script. For example, if used twice, the script enters into command
  tracing mode;
\item[\texttt{-u} or \texttt{--update-git-svn}] update the \Apips{}
  \Agit-\Asvn gateways that are into \verb|$P4A_TOP/CRI-git-svn|;%$
\item[\texttt{-g} or \texttt{--recursive-git-svn}] apply a \Agit command
  to all the git working copies inside the current directory
  recursively. If no argument is given, a \texttt{git svn rebase} is done;
\item[\texttt{-f} or \texttt{--fetch-remote-git}] fetch the objects from
  the remote \Agit repositories (the \Apips{} \Agit-\Asvn gateways and the
  \Apolylib{} \Agit);
\item[\texttt{-p} or \texttt{--pull-remote-git}] pull the objects from the
  remote \Agit repositories into their respective branches and update the
  \texttt{p4a} branch hierarchy to point to the last version of \Apfa;
\item[\texttt{-m} or \texttt{--merge-remote-branches}
  \texttt{\emph{<to-prefix>}} \texttt{\emph{[<origin-prefix>]}}] merge all
  the \texttt{p4a} branch infrastructure into the
  \texttt{\emph{<to-prefix>}} branch architecture. If the
  \texttt{\emph{<to-prefix>}} branch infrastructure does not exist, it is
  created from the \texttt{\emph{<origin-prefix>}} branch infrastructure
  if provided, else from the \texttt{p4a} branch architecture;
\item[\texttt{-b} or \texttt{--branch-action} \texttt{\emph{args+}}] apply
  the \texttt{\emph{args+}} shell-script to a branch hierarchy, with the
  branch suffix available to the \texttt{\emph{args+}} script in the
  \verb|$suffix| variable. Do not forget to escape special shell
  characters you want in the final shell;
\item[\texttt{-a} or \texttt{--add-remotes}] create the remotes pointing
  into \verb|$P4A_CRI_GIT_SVN| and on the \Apolylib{} \Agit;
\item[\texttt{-r} or \texttt{--root} \texttt{<\emph{directory}>}] to
  change the git repository to work on.
\end{description}


\subsection{PolyLib work-flow}
\label{sec:polylib-workflow}

The basic workflow for \Apolylib is to develop new features into the
original \Apolylib{} \Agit, to fetch it into the \Apfa{} \Agit and select what
feature we want to have into the \texttt{packages/polylib} of \Apfa.

The script \verb|p4a_git| is used to automate the management of the
workflow.

\verb|p4a_git --pull-remote-git| pulls the \Apolylib into the
\texttt{polylib} branch so that you can apply global modifications there
if needed and later \texttt{git merge} it into your working branch. In
this way global modifications are persistent and available to everybody.

If you want to directly manage the \Apolylib workflow, here are some
details about how it works.

Since the \Apolylib is already in a \Agit, the \texttt{polylib} is simply
a remote in the \Apfa{} \Agit.

So to import the latest \Apolylib development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch \Apolylib with:
\begin{verbatim}
git fetch ICPS/polylib
\end{verbatim}

You can then merge the feature you want with
\begin{verbatim}
git merge -s subtree remotes/polylib/master
\end{verbatim}
or from any tree identifier. The \texttt{-s subtree} is necessary since in
\Apfa the \Apolylib files are not at the top-level directory. This should
be done into the \texttt{polylib} branch if you want to be compatible with
the workflow chosen in \Apfa.


\subsection{PIPS work-flow}
\label{sec:pips-workflow}

\subsubsection{Compilation from sources outside of Par4All}
\label{sec:comp-from-sourc}

Before digging into details, the most important thing when developing some
\Apfa packages is to be able to test them \emph{before} being included
into \Apfa.

For example, you may want to develop a new \Apips version that is in the
\Acri{} \Asvn repository and build all \Apfa to test it does work with.

The way to achieve it has been described in section~\ref{sec:compilation}
but we can detail it a bit further for this example.

For example, you have a \Asvn working copy of \Apips (the \texttt{trunk}
into \texttt{prod}, your branch in \verb|pips_dev|, or whatever. Refer
to the \Apips developer guide for more informations). You just need to
point this directory to \Apfa by using the \verb|--pips-src=| option.

Be sure you do not have sourced the old configuration file of the \Apips
\Asvn environment from \Acri in your shell and that you do not have old
environment variables referring to it (\verb|PATH|...). You need to have
instead the right \Apfa variable set in your shell.

Then you clean this directory to remove dangling dependencies the first
time you use a classical \Apips directory with \Apfa with:
\begin{verbatim}
cd <where the wanted PIPS is>
make clean
\end{verbatim}

You build a new \Apfa version using this \Apips version in debug mode,
compiled with 4 compilation processes to take advantage of your 4-core
machine, just with:
\begin{verbatim}
src/simple_tools/p4a_setup -vvv --pips-src=<where the wanted PIPS is> --debug --jobs=4
\end{verbatim}

It runs everything. Once you have all the infrastructure setup, it is
useless to recompile everything, or even reconfigure \Apips when you only
change few things. You can just recompile \Apips and skip the installation
of typical \Apfa things, with a:
\begin{verbatim}
src/simple_tools/p4a_setup -vvv --pips-src=<where the wanted PIPS is> \
   --debug --only=pips --no-final --jobs=4
\end{verbatim}

An example of script that does this is
\verb|src/simple_tools/p4a_setup_with_my_PIPS|:
\lstinputlisting[language=bash]{p4a_setup_with_my_PIPS}


\subsubsection{Debuging PIPS and p4a}
\label{sec:debuging-pips-p4a}

To debug \texttt{tpips} in \Apfa, you just need to run \texttt{gdb
  tpips}\footnote{Or whatever debugger or frontend such as Eclipse or
  Emacs. For example with Emacs, use \texttt{M-x gdb} and then ask for
  many windows in the \texttt{Gud/Gdb-UI} menu.} and then \texttt{run
  \emph{the}.tpips} file in parameter.

To debug a \Apyps program, since indeed it is a Python program that uses
\Apips libraries, you then need to launch \texttt{gdb python} and inside
the debugger run the program with \texttt{run \emph{the\_PyPS\_file}.py}

To debug \texttt{p4a}, it is still a Python program, but you need to run
\texttt{p4a} and passing arguments to it. Since \texttt{p4a} itself
launch many processes, it is difficult to debug a \Apips directly for
example.

A first way is to ask the debugger to follow the
\texttt{fork()} and \texttt{exec()} system calls. For example in
\texttt{gdb}, setting \texttt{detach-on-fork off} and also looking at
\texttt{follow-exec-mode}.

A second easier way is to avoid \texttt{p4a} launching processes. This is
done with the \verb/--no-spawn/ option. Avoiding colors and other
decoration is useful when debugging, so the \verb/--plain/ is useful too.

So a good way to debug \texttt{p4a} from \texttt{gdb} it to launch first a
\texttt{gdb python} and then run \texttt{p4a} like:
\begin{verbatim}
run /usr/local/par4all/bin/p4a --plain --no-spawn
    -o hyantes-static-99_openmp hyantes-static-99.c -lm
\end{verbatim}

To run your own version of \texttt{p4a}, you can put the directory
containing your \texttt{p4a} \texttt{.py} libraries first into the
\texttt{PYTHONPATH} environment variable.

For memory debugging with Valgrind, look at
section~\ref{sec:scripts-debugging}.


\subsubsection{Internal organization}
\label{sec:intern-organ}

The work-flow related to \Apips is quite more complex since we must
consolidate data from 5 different \Asvn repositories. The script
\verb|p4a_git| is used to automate the management of this workflow too,
but we describes it further here if you want to dig into it.

The basic \Apips work-flow is to develop into the 5 original \Apips{}
\Asvn repositories at MINES ParisTech/\Acri and to import the selected
developments into the \Apfa{} \Agit.

For this, we use 5 \Agit repositories that are gateways with these \Asvn
repositories. For technical reasons, it is better that this kind of subtle
gateway exists in only one place and this is currently done on the laptop
of Ronan \textsc{Keryell}. Then these 5 gateways are used as remotes into
the \Apfa{} \Agit. To synchronize these gateways to the latest version of
the \Apips{} \Asvn repositories, use a \verb|pips_git| in the directory
owning these \Agit-\Asvn repositories.

But since we have then a \Agit interface of the original \Apips{} \Asvn
repositories and \Agit is quite more powerful than \Asvn, some people may
want to develop into \Apips with \Agit by using these gateways. For
example they may want to develop with common branches easily and when they
are right with them push them back into the \Apips{} \Asvn trunk. To have
a public interface for them, these \Agit gateways are pushed to public
\Agit repository programmers can play with. Regularly these public
gateways are synchronized manually with the \Apips{} \Asvn. Nevertheless,
\Asvn may not be credited with the right owner of the commit but with the
one running the gateway, which is not fair. So the preferred way is to
directly develop in the original \Apips \Asvn repository (eventually with
her own \Agit-\Asvn gateway).

The 5 public gateway \Agit repositories are also defined as 5 remotes into
the \Apfa{} \Agit:
\begin{description}
\item[\texttt{remotes/CRI/linear}]
\item[\texttt{remotes/CRI/newgen}]
\item[\texttt{remotes/CRI/nlpmake}]
\item[\texttt{remotes/CRI/pips}]
\item[\texttt{remotes/CRI/validation}]
\end{description}

These remote repositories are merged into \Apfa in the following
respective directories:
\begin{description}
\item[\texttt{packages/PIPS/linear}]
\item[\texttt{packages/PIPS/newgen}]
\item[\texttt{packages/PIPS/nlpmake}]
\item[\texttt{packages/PIPS/pips}]
\item[\texttt{packages/PIPS/validation}]
\end{description}

To import the latest \Apips development into the \Apfa{} \Agit for
inspection, choice for inclusion, you fetch the repositories you want
with:
\begin{verbatim}
git fetch CRI/linear
git fetch CRI/newgen
git fetch CRI/nlpmake
git fetch CRI/pips
git fetch CRI/validation
\end{verbatim}
These commands are also done by a \verb|p4a_fetch_all| that fetches also the
\Apolylib part.

You can then merge the feature you want with a \texttt{git merge -s
  subtree} from \texttt{remotes/CRI/.../master} as:
\begin{verbatim}
git merge -strategy=subtree remotes/CRI/linear/master
git merge -strategy=subtree remotes/CRI/newgen/master
git merge -strategy=subtree remotes/CRI/nlpmake/master
git merge -strategy=subtree remotes/CRI/pips/master
git merge -strategy=subtree remotes/CRI/validation/master
\end{verbatim}
or from any tree identifier to do more precise version selection. The
\texttt{-s subtree} is necessary since in \Apfa the \Apips files are not
at the top-level directory and you do not want them to appear at the
top-level directory.

To pull everything at one for testing, this is done with the
\verb|p4a_git| script described in \S~\ref{sec:p4a_git-script-deal}. Do
not forget it may useful to create a branch with a \texttt{git checkout
  -b} before to test it, so the branch can be deleted for an easy
rollback.


\subsection{PIPS-GFC extension workflow}
\label{sec:pips-gfc-workflow}

\subsubsection{New version}
\label{sec:new-version}

In the work of Mehdi \textsc{Amini}, the branch
\texttt{p4a-gcc-gfc-4.4.3} contains the sources of \Agcc-\Agfc 4.4.3 to
get the Fortran~95. Then the branch is named also \texttt{p4a-gcc-gfc}
which is merged into \texttt{p4a-packages}.

During \Apfa construction, these sources are patched and compiled into the
\Apips Fortran~95 parser.


\subsubsection{Old version}
\label{sec:old-version}


This part from Raphaël \textsc{Roosz}is into the \texttt{package/pips-gfc}
directory. It contains plain \Agcc core and Fortran 4.4.1 distribution,
pointed by the branch \texttt{gcc-4.4.1}

The development of \Apipsgfc should be done in the branch
\texttt{pips-gfc-4.4.1} and this branch should be merged with the
branch \texttt{gcc-4.4.1} into a branch \texttt{pips-gfc+gcc-4.4.1} with a
more global name \texttt{pips-gfc+gcc} tracking which version is to be
merged into the global \texttt{master} branch.

So in \texttt{pips-gfc-4.4.1} there should be only files different from
the \Agcc distribution. In this way, if we want to have more subtle
construction methods, later, it will be clearer how to get the real
content.

There is the same variation in branches for version 4.4.2.

So to develop and test the \Apipsgfc extension, you get into for example
\texttt{pips-gfc-4.4.1} with
\begin{verbatim}
git checkout pips-gfc-4.4.1
\end{verbatim}
and develop your code in this branch.

To test, you commit and change to the \texttt{pips-gfc+gcc-4.4.1} branch with
\begin{verbatim}
git checkout pips-gfc+gcc-4.4.1
\end{verbatim}
where you merge with a
\begin{verbatim}
git merge pips-gfc-4.4.1
\end{verbatim}
and compile. If you are happy, you commit or you revert and then go back
into branch \texttt{pips-gfc-4.4.1}.

If you want to avoid spoiling the branches \texttt{pips-gfc-4.4.1} and
\texttt{pips-gfc+gcc-4.4.1}, you can create sub-branches of them, commit in
them and merge this work in the former one back (with the \verb|--slashed|
if you want to be modest about your gory hesitations \smiley{} and delete
these branches).


\subsection{Setting and running the infrastructure up}
\label{sec:setup}

There are scripts to ease the developer and user life.


\subsubsection{Scripts for an everyday work}
\label{sec:an-everyday-work}

\begin{itemize}
\item to automate the \Apfa workflow and deal with \texttt{git} stuff, the
  \verb|p4a_git| is available, as described in
  \S~\ref{sec:p4a_git-script-deal};
\item \verb|p4a_post_processor.py| is used to generate programs that use
  the \Apfa Accel runtime from the \Apips output. This script is more
  detailed on section~\ref{sec:p4a_p-script-from};
\item \verb|p4a_recover_includes| is mainly used to get standard
  \verb|#include| back after \Apips digestion. See
  section~\ref{sec:p4a_recover_includes} for the use case;
\item \verb|p4a_setup| is used to compile all the \Apfa infrastructure and
  to set up many things. It should be used at least for the first
  compilation. See \S~\ref{sec:p4a_s-comp-script} for more details;
\item \verb|p4a_validate| is used to leverage the \Apips validation.
\end{itemize}


\subsubsection{Scripts for debugging}
\label{sec:scripts-debugging}

\begin{itemize}
\item \verb|p4a_recover_includes| can be used to evaluate the inclusion of
  \Apfa Accel to ease debugging this package without evaluating other
  preprocessor inclusion. See section~\ref{sec:p4a_recover_includes} for
  the use case;
\item \verb|p4a_valgrind| launch a command with Valgrind with a memory
  checker in paranoid mode, mainly with the options described in the
  \Apips development guide. As seen in section
  \ref{sec:debuging-pips-p4a}, to debug \Apips in \texttt{p4a}, it is
  useful to call it like in:
\begin{verbatim}
p4a_valgrind python /usr/local/par4all/bin/p4a --plain --no-spawn
             -o hyantes-static-99_openmp hyantes-static-99.c -lm
\end{verbatim}
  Of course you can also use \texttt{valgrind} instead of
  \verb/p4a_valgrind/ for less verbosity.
\end{itemize}


\subsubsection{Scripts used to setup the infrastructure}
\label{sec:scripts-used-setup}

Some scripts used to setup the infrastructure. They have been used to
bootstrap the \Apfa infrastructure and should not be used by ordinary
people but contain some interesting hacks that could be usefull for other
projects or if things go really wrong. There are located in
\texttt{src/dev}, that should be used in this order:
\begin{itemize}
\item \verb/p4a_create_CRI_git_svn/ is used once to create the \Apips{}
  \Asvn-\Agit gateways. This script is here to show how it can be done but
  also to keep track of the exact parameters used to create them in the
  case we loose them and want to recreate them with exactly with the same
  identifiers (that depends from the creation parameters);
\item \verb/p4a_import_external_gits/ imports all the external \Agit
  repositories into the \Apfa{} \Agit repository. It should be used only
  once but are included as example for other projects or to help adding
  other repositories later;
\item \verb/p4a_apply_pips_patches/ is used to patch the original \Apips
  files to fit the \Apfa architecture. It should be used only once, after
  external \Agit import. It is no longer used since we switch to the
  \Aautotools version of \Apips;
\end{itemize}


\subsubsection{Script to deal with the documentation}
\label{sec:script-deal-with}

\begin{itemize}
\item \verb|optparse_help_to_tex| is a small compiler that transforms a
  help output message of a command (using the \texttt{optparse} format)
  when launched with \texttt{-h} into La\TeX{} code for inclusion in
  articles or slides. See \S~\ref{sec:help-docum-tex} for more details;
\item \verb|p4a_doc| in \verb|src/dev| is used to compile the \Apfa
  documentation and publish it on the server. Have a look to
  \texttt{p4a\_doc -h} for the help.
\end{itemize}


\subsubsection{Making distributions}
\label{sec:making-distributions}

The \verb|p4a_pack| is used to build compressed \texttt{tar} balls or Debian
\texttt{.deb} packet files.

The place of where the \Apfa files are looked for is specified according
to the \verb|P4A_DIST| variable or \texttt{--dir} option, but there may be
some hard-coded locations at configure and build time, so moving the
installation directory afterwards and changing \verb|P4A_ROOT| to follow
the new location may not be enough.

So you should choose the location at build time. To have a distribution
that build up into for example \texttt{/usr/local/par4all}, you should
first create a \texttt{/usr/local/par4all} \emph{writable by you} (you may
create this directory as super-user and change the owner to you with a
\texttt{chown}), and do a \verb|p4a_setup|.

Then you can pack this directory into what format you want with for
example:
\begin{alltt}
src/simple_tools/p4a_pack <--deb|--tgz> --revision=\emph{0.1-mybuild} \(\backslash\)
  --dir=\emph{/current/install/dir} [--prefix=\emph{/final/install/dir}]
\end{alltt}

Here are the usage and full option list of this command.

\input{p4a_pack-help}


\subsubsection{Making releases}
\label{sec:releases}

After validating, a release is done by making some branch at a given state
a tag.

There is also a \verb|p4a_coffee| script to build and publish everything
at once.

\input{p4a_coffee-help}


\section{Examples and demos}
\label{sec:examples-demos}

The \texttt{examples} directory comes with examples to show some aspects
of \Apfa. Of course there are far more examples in the validation of \Apfa
(\S~\ref{sec:validation}) but it is often less pedagogical.


\section{Validation}
\label{sec:validation}


Validation of \Apfa is done inside the \texttt{validation} directory with
\texttt{make validate}.

But right now it is still mostly done in the
\texttt{package/PIPS/validation} directory.


\subsection{\protect\texttt{p4a\_validate} utility}
\label{sec:p4a_validate-utility}


To ease interacting with the validation, the \verb|p4a_validate| is a
script that adds the concept of validation classes to the \Apips
validation. A class is a set of validation cases.

TODO: For example we may have a class for \texttt{ALL} the validation, the
\texttt{CHANGED}, \texttt{FAILED}, \texttt{PASS}, \verb|PREVIOUS_ALL|,
\verb|PREVIOUS_CHANGED|, \verb|PREVIOUS_FAILED|, \verb|PREVIOUS_PASS|,
whatever user class and it is possible to make actions with them, combine
them with operators (unions, intersections...).

TODO: Some other classes can be defined directly in the validation
directories with \texttt{.vclass} line-oriented regexp filter lines or
generic Python code \texttt{.vclasspy}.

\verb|p4a_validate| has a small script interface, but the power user
should use the Python classes directly, for example from \texttt{iPython}
to add interactivity.

The first use in \Apfa is to select from \Apips only the test cases that
pass the validation (futuristic cases are interesting for \Apips but from
least interest for \Apfa...), defining smaller validation classes such as
a \Amat (Minimal Acceptance Test).


\subsubsection{Example}
\label{sec:example}

To display from the last validation the test cases marked as
\texttt{changed} only in \verb|C_syntax|, you can use:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/' \
             --keep-status=changed --list
\end{verbatim}

To show what changed compared to the reference:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/decl' \
             --keep-status=changed --show-diff-files
\end{verbatim}

To accept the validation of what changed in \texttt{C\_syntax/decl\emph{*}}:
\begin{verbatim}
p4a_validate --file=SUMMARY_Archive/SUMMARY-last --filter='^C_syntax/decl' \
             --keep-status=changed --accept
\end{verbatim}
then if you are happy with it you can commit with \Agit or revert back to
previous state with \Agit.

You may want to move all the currently failing test of the validation for
\texttt{Control} into a new validation directory \texttt{Control-Bugs} to
clean up the mainstream validation. You can do with:
\begin{verbatim}
mkdir Control-Bugs
p4a_validate --file=RESULTS/SUMMARY  --list --filter=^Control/ --keep-status=failed \
 | sed -n -e 's,failed: ,,p' > files-to-move
\end{verbatim}
If you are happy after inspection of \texttt{files-to-move} after some
cleaning with a
\begin{verbatim}
rm -rf Control/*.database
\end{verbatim}
you can really move stuffs into with:
\begin{verbatim}
for f in `cat files-to-move` ; do git mv $f* Control-Bugs ; done
\end{verbatim}


\subsubsection{Option list of \protect\texttt{p4a\_validate}}
\label{sec:opti-list-p4a_v-1}

Here is a small description of the usage and options of
\verb|p4a_validate|, that are processed in the order of class
construction, filtering, display and acceptance, so that you can pipe
actions. To be useful, \verb|pips_validate| should be run with the
\texttt{-k} (history keeping) option before, so that you can operate on
differences between different validations.

\input{p4a_validate-help}


\subsection{Validation script}
\label{sec:validation_script}

It is possible to select different options to test with the python script
\verb|p4a_validate_class.py|

Currently, available options are:
\begin{description}
\item[\texttt{--pips}:] validate tests which are done by default file (in
  \texttt{packages/PIPS/validation})

\item[\texttt{--p4a}:] validate tests which are done by
  \verb|par4all_validation.txt| (which must be previously created in
  \texttt{src/validation})

\item[\texttt{--diff}:] this command make a diff between tests done by
  \texttt{--pips} and \texttt{--p4a} options. The list of the tests which
  are not done by \texttt{--p4a} options are into \texttt{diff.txt}

\item[\texttt{--dir}:] Validate tests which are done in \verb|packages/PIPS/validation/directory_name|. Syntax is \verb|./p4a_validate_class.py --dir dir1 dir2 dir3|

\item[\texttt{--test}:] Validate tests which are done in argument. Syntax is \verb|./p4a_validate_class.py --test directory_test/test.f| for example

\item[\texttt{-h} or \texttt{--help}:] Help for \verb|p4a_validate_class.py|
\end{description}

Examples with \verb|p4a_validate_class.py|:
\begin{verbatim}
python p4a_validate_class.py --pips
\end{verbatim}
or
\begin{verbatim}
python p4a_validate_class.py --p4a
\end{verbatim}

To use the option \texttt{--p4a}, a \verb|par4all_validation.txt| must be
previously created. This file lists all tests that the validation will do.
Syntax to add a new test is: \verb|directory_test/name_test|.

Be careful when adding a test to \verb|par4all_validation.txt|, put the
correct extension (\texttt{.c}, \texttt{.f}, \texttt{.F},
\texttt{.F90}). Don't use \texttt{.tpips}, \texttt{.tpips2}... extensions.

Example of a \verb|par4all_validation.txt| with 2 tests:
\begin{verbatim}
Syntax/alias.f
Syntax/altret01.f
\end{verbatim}


\section{Branches}
\label{sec:branches}

Since there are restrictions on the use of \texttt{/} in branch names, we
prefer to use \texttt{-} to add hierarchy.

To ease the developments and the organization, there are some already
defined branches:
\begin{description}
\item[\texttt{gcc-4.4.1}] is the original \Agcc 4.4.1 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{gcc-4.4.2}] is the original \Agcc 4.4.2 core \& Fortran in
  \texttt{package/pips-gfc};
\item[\texttt{initial}] points to the initial commit of the \Apfa
  repository. It is useful to add stuff directly add the root of the
  repository to set the branch for the different packages. It should not
  be useful for normal people;
\item[\texttt{p4a-\emph{numerical}}] a branch corresponding to a given version
  snapshot;
\item[\texttt{p4a-\emph{numerical}-alpha}] a branch corresponding to an alpha
  version of a given version snapshot;
\item[\texttt{p4a-\emph{numerical}-beta}] a branch corresponding to an beta
  version of a given version snapshot;
\item[\texttt{p4a}] is the branch to get the full latest \Apfa version
  with all the different components, that is the merge of the branches
  \texttt{p4a-own} and \texttt{p4a-packages};
\item[\texttt{p4a-linear}] points to the import of \Apips \texttt{linear}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/linear} and used to merge from when you want to use
  the last version from \texttt{linear};
\item[\texttt{p4a-newgen}] points to the import of \Apips \texttt{newgen}
  part. So this branch should contain only the files from
  \texttt{package/PIPS/newgen};
\item[\texttt{p4a-nlpmake}] points to the import of \Apips \texttt{nlpmake}
  part. Thus this branch should contain only the files from
  \texttt{package/PIPS/nlpmake};
\item[\texttt{p4a-own}] points to the last development of the \Apfa own files,
  without packages, etc;
\item[\texttt{p4a-packages}] points to the last merge of all the \Apfa
  package components;
\item[\texttt{p4a-pips}] points to the import of \Apips \texttt{pips}
  par. Thus this branch should contain only the files from
  \texttt{package/PIPS/pips} and used to merge from when you want to use
  the last version from \texttt{pips};
\item[\texttt{p4a-polylib}] points to the import of \Apips \texttt{polylib}
  par. Thus this branch should contain only the files from
  \texttt{package/polylib} and used to merge from when you want to use
  the last version from \texttt{polylib};
\item[\texttt{p4a-validation}] points to the import of \Apips
  \texttt{validation} part, with only files into
  \texttt{package/PIPS/validation};
\item[\texttt{pips-gfc+gcc}] points to a working \Apipsgfc implementation
  of the Fortran 95 extension for \Apips in \texttt{package/pips-gfc};
\item[\texttt{pips-gfc-4.4.1}] points to the original developments of
  Raphaël in \Agcc in \texttt{package/pips-gfc}.
\end{description}


Of course, for a better tractability, there are also branches that point
to specific versions of conceptual branches such as
\texttt{p4a-0.2-alpha-nlpmake}, \texttt{p4a-own-0.1} or
\texttt{p4a-packages-0.2-beta}.


\section{Some \protect\Agit tricks useful in \protect\Apfa}
\label{sec:some-agit-tricks}

\subsection{You have committed to the wrong branch}
\label{sec:you-have-comited}

There are (too) many branches in \Apfa, right? It is so easy for example
to do a commit on the \texttt{p4a} for example instead of the
\texttt{p4a-own} one. The good new is that since \Agit separate commit and
publish phase, if you reread what you have done with for example
\texttt{gitk}, you should figure out what you did wrong before it explode
to the faces of your colleagues.

Here is an example of a wrong \texttt{p4a} commit and how to get your work
in a good way before pushing to others.

First create a branch to ease following of what you did wrong:
\begin{verbatim}
git checkout -b wrong
\end{verbatim}
Go back up to a clean state (here only 1 \verb|^| so only to the previous
commit):
\begin{verbatim}
git branch -f p4a p4a^
\end{verbatim}
Move what you did wrong to the branch where it should always have been:
\begin{verbatim}
git rebase --onto p4a-own p4a wrong
\end{verbatim}
The go to the target branch:
\begin{verbatim}
git checkout p4a-own
\end{verbatim}
and merge in it your work:
\begin{verbatim}
git merge wrong
\end{verbatim}
and delete your helping branch:
\begin{verbatim}
git branch -d wrong
\end{verbatim}
Magic isn't it? \smiley

You can see that your wrong work is still connected to the branch
\texttt{p4a}, but no longer \emph{in} the branch. It is typical
representative of all the work done in \Apfa to avoid loosing information.


\appendix

\section{Various script details}
\label{sec:vari-script-deta}

Here are described the options or various minor scripts that should have
obfuscated the main part.

\subsection{The \protect\texttt{p4a\_recover\_includes} script}
\label{sec:p4a_recover_includes}

\verb|p4a_recover_includes| is used to get C standard \verb|#include|
after \Apips digestion to have nicer recompilation (for \Acuda it is a
requirement) and of course nicer code instead of ugly macro inclusion at
the beginning of all the files.

This script can also be use to do expansion of the \verb|#include| of
\Apfa Accel only to have a look for example to the real \Acuda or \Aopenmp
that is generated.

\input{p4a_recover_includes-help}


\subsection{The \protect\texttt{p4a\_post\_processor.py} script from
  Par4All Accel}
\label{sec:p4a_p-script-from}

\verb|p4a_post_processor.py| is the script that transforms the \Apips
output into calls to \Apfa Accel. It is mainly used by the \texttt{p4a}
script but can be used for power users that need to write their own
specialized \Apips scripts with \texttt{tpips} or \texttt{PyPS}.

\input{p4a_post_processor.py-help}


\subsection{The \protect\texttt{optparse\_help\_to\_tex} help
  documentation to \TeX{} compiler}
\label{sec:help-docum-tex}

\verb|optparse_help_to_tex| is a small compiler that translates a help
output message of a command using the \texttt{optparse} format when
launched with \texttt{-h} into La\TeX{} code with section for inclusion in
an article or slide generation with Beamer.

The following section should be a very demonstration of this tool
indeed. \smiley

\input{optparse_help_to_tex-help}

%%ContentEnd

\end{document}


%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

