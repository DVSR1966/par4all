tidy the code just in case of
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   for(y = 2; y <= n-3; y += 1)
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   for(y = 2; y <= n-3; y += 1)
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   for(y = 2; y <= n-3; y += 1)
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
tiling
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0;
l99998:
   for(y = 2; y <= n-3; y += 1)
l99999:
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement to check
   for(y = n-2; y <= 2+__TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH)-1; y += 1)
l99997:
      for(x0 = 0; x0 <= n-1; x0 += 1)
         img_out[y-2][x0] = MIN(MIN(MIN(MIN(img[y-2][x0], img[y-1][x0]), img[y][x0]), img[y+1][x0]), img[y+2][x0]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0;
l99998:
   for(y = 2; y <= n-3; y += 1)
l99999:
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement
   for(y = n-2; y <= 2+__TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH)-1; y += 1)
l99997:
      for(x0 = 0; x0 <= n-1; x0 += 1)
         img_out[y-2][x0] = MIN(MIN(MIN(MIN(img[y-2][x0], img[y-1][x0]), img[y][x0]), img[y+1][x0]), img[y+2][x0]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= 2+__TERAPYPS_WIDTH*I_0-1; y += 1)
l99999:
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= __TERAPYPS_WIDTH*I_0+1; y += 1)
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= __TERAPYPS_WIDTH*I_0+1; y += 1) {
l99996:
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement to check
      for(x = n; x <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
   }

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= __TERAPYPS_WIDTH*I_0+1; y += 1) {
l99996:
      for(x = 0; x <= n-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement
      for(x = n; x <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
   }

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= __TERAPYPS_WIDTH*I_0+1; y += 1) {
l99996:
      for(x = 0; x <= __TERAPYPS_HEIGHT*I_1-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);

   }

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(y = 2; y <= __TERAPYPS_WIDTH*I_0+1; y += 1)
      for(x = 0; x <= __TERAPYPS_HEIGHT*I_1-1; x += 1)
         img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);

}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 2; yt <= __TERAPYPS_WIDTH*I_0+1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0+1+1)-1; y += 1)
#pragma omp parallel for 
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 2; yt <= __TERAPYPS_WIDTH*I_0+1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0+1+1)-1; y += 1)
#pragma omp parallel for 
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
group constants and isolate

//  <img[PHI1][PHI2]-R-MAY-{5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{5<=n}>

void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;

//  <img[PHI1][PHI2]-R-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{1<=__TERAPYPS_HEIGHT,
//    1<=__TERAPYPS_WIDTH, 5<=n}>

l99998:
   for(yt = 2; yt <= __TERAPYPS_WIDTH*I_0+1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)

//  <img[PHI1][PHI2]-R-MAY-{PHI1<=__TERAPYPS_WIDTH+yt+1, yt<=PHI1+2,
//    1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1+3<=__TERAPYPS_WIDTH+yt,
//    yt<=PHI1+2, 1<=__TERAPYPS_HEIGHT, 5<=n}>

#pragma omp parallel for private(x)
l99993:
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)

//  <img[PHI1][PHI2]-R-MAY-{PHI1<=__TERAPYPS_WIDTH+yt+1, yt<=PHI1+2,
//    PHI2+1<=__TERAPYPS_HEIGHT+xt, xt<=PHI2, 1<=__TERAPYPS_WIDTH,
//    5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1+3<=__TERAPYPS_WIDTH+yt,
//    yt<=PHI1+2, PHI2+1<=__TERAPYPS_HEIGHT+xt, xt<=PHI2, 5<=n}>

#pragma omp parallel for 
l99994:
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0+1+1)-1; y += 1)

//  <img[PHI1][PHI2]-R-MAY-{y<=PHI1+2, PHI1<=y+2,
//    PHI2+1<=__TERAPYPS_HEIGHT+xt, xt<=PHI2,
//    y+1<=__TERAPYPS_WIDTH+yt, yt<=y, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1==y-2,
//    PHI2+1<=__TERAPYPS_HEIGHT+xt, xt<=PHI2,
//    y+1<=__TERAPYPS_WIDTH+yt, yt<=y, 5<=n}>

#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1+2, PHI1<=y+2,
//    x+1<=__TERAPYPS_HEIGHT+xt, y+1<=__TERAPYPS_WIDTH+yt, xt<=x,
//    yt<=y, 5<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, PHI2==x,
//    x+1<=__TERAPYPS_HEIGHT+xt, y+1<=__TERAPYPS_WIDTH+yt, xt<=x,
//    yt<=y, 5<=n}>

               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-5)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 2; yt <= __TERAPYPS_WIDTH*I_0+1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
l99993:
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0+1+1)-1; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+119)/124;
l99998:
   for(yt = 2; yt <= 124*I_0-122; yt += 124)
#pragma omp parallel for private(x)
l99993:
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= yt+123; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1)-1; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -124 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -124I_0 + n + 119 >= 0
         124I_0 - yt  -122 >= 0
         yt  -2 >= 0
         124I_0 - n + 4 >= 0

Vertices:
[ yt+121,  xt ]
[ yt+121,  __TERAPYPS_HEIGHT+xt-1 ]
[ yt-2,  xt ]
[ yt-2,  __TERAPYPS_HEIGHT+xt-1 ]

Ehrhart Polynomial:
( 124 * __TERAPYPS_HEIGHT + 0 )

---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -124 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -124I_0 + n + 119 >= 0
         124I_0 - n + 4 >= 0
         124I_0 - yt  -122 >= 0
         yt  -2 >= 0

Vertices:
[ yt+125,  __TERAPYPS_HEIGHT+xt-1 ]
[ yt-2,  __TERAPYPS_HEIGHT+xt-1 ]
[ yt+125,  xt ]
[ yt-2,  xt ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
#pragma psolve '-65536+( 124 * __TERAPYPS_HEIGHT + 0 ) +( 128 * __TERAPYPS_HEIGHT + 0 ) ' '__TERAPYPS_HEIGHT'

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+119)/124;
l99998:
   for(yt = 2; yt <= 124*I_0-122; yt += 124)
#pragma omp parallel for private(x)
l99993:
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= yt+123; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1)-1; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+118, 0<=PHI2, 5<=n}>

void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 16384/63;

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+119)/124;

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=124I_0+3, 0<=PHI2,
//    PHI2+1<=260I_1, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    1<=I_0, n<=124I_0+4, 124I_0<=n+119}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1+1<=124I_0, 0<=PHI2,
//    PHI2+1<=260I_1, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    1<=I_0, n<=124I_0+4, 124I_0<=n+119, 1<=I_1}>

l99998:
   for(yt = 2; yt <= 124*I_0-122; yt += 124)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1+2, PHI1<=yt+125, 0<=PHI2,
//    PHI2+1<=260I_1, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, 2<=yt}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1+2, PHI1<=yt+121, 0<=PHI2,
//    PHI2+1<=260I_1, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, 1<=I_1, 2<=yt}>

l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; xt += __TERAPYPS_HEIGHT)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1+2, PHI1<=yt+125, xt<=PHI2,
//    PHI2<=xt+259, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1,
//    0<=xt, 2<=yt}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1+2, PHI1<=yt+121, xt<=PHI2,
//    PHI2<=xt+259, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1,
//    0<=xt, 2<=yt}>

l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)

//  <img[PHI1][PHI2]-R-MAY-{y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1,
//    0<=xt, yt<=y, y<=yt+123, 2<=yt}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1==y-2, xt<=PHI2, PHI2<=xt+259,
//    __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124, yt+122<=124I_0,
//    n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1, 0<=xt, yt<=y,
//    y<=yt+123, 2<=yt}>

l99995:
#pragma  omp parallel for 
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1)-1; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124,
//    yt+122<=124I_0, n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1,
//    0<=xt, yt<=y, y<=yt+123, 2<=yt}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, PHI2==x,
//    __TERAPYPS_HEIGHT==260, __TERAPYPS_WIDTH==124, yt+122<=124I_0,
//    n<=124I_0+4, 124I_0<=n+119, xt+260<=260I_1, xt<=x, x<=xt+259,
//    0<=xt, yt<=y, y<=yt+123, 2<=yt}>

               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 260;

   I_1 = (n+259)/260;
   I_0 = (n+119)/124;
l99998:
   for(yt = 2; yt <= 124*I_0-122; yt += 124)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*I_1-260; xt += 260)
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 124, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 260;

   I_1 = (n+259)/260;
   I_0 = (n+119)/124;
l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+118, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;





//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+118, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1+2, PHI1<=yt+125, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1+2, PHI1<=yt+121, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>

l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1+2, PHI1<=yt+125, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1+2, PHI1<=yt+121, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>

l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+123, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, xt<=PHI2, PHI2<=xt+259,
//    0<=xt, xt+1<=n, yt<=y, y<=yt+123, 2<=yt, yt+3<=n}>

l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+123, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, PHI2==x, xt<=x,
//    x<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+123, 2<=yt, yt+3<=n}>

               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;




l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement to check
         for(y = yt+124; y <= yt+127; y += 1)
l99999:
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
      }
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;




l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+123; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
#pragma pips inserted statement to check
         for(y = yt+124; y <= yt+127; y += 1)
l99999:
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
      }
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;
   I_2 = 1;




l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= 128*I_2+yt-1; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);

      }
}
void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

void runner(int n, int img_out[n-4][n], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;






//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1+2, PHI1<=yt+129, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1+2, PHI1<=yt+125, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>

#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1+2, PHI1<=yt+129, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1+2, PHI1<=yt+125, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>

#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, xt<=PHI2, PHI2<=xt+259,
//    0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>

#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, PHI2==x, xt<=x,
//    x<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>

               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)
               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}

//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>
//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1}>
//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>

int main(int argc, char **argv)
{

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1, 5<=n}>

   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n-4][n], in[n][n];

//  <in[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         in[i][j] = j;

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+258,
//    n<=i, 5<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, n<=i, 5<=n}>

   runner(n, out, in);
   check = 0;

//  <out[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1+5<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-4-1; i += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+5<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, 0<=i, i+5<=n, 0<=j,
//    j+1<=n}>

         check += out[i][j];

//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>
//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>

   printf("%d\n", check);
   return 0;
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+122+1][n+258+1], in[n+126+1][n+258+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in[i][j] = j;
   runner(n, out, in);
   check = 0;
   for(i = 0; i <= n-4-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;






//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+122, 0<=PHI2,
//    PHI2<=n+258, 5<=n}>

l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1+2, PHI1<=yt+129, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1+2, PHI1<=yt+125, 0<=PHI2,
//    PHI2<=n+258, 2<=yt, yt+3<=n}>

l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1+2, PHI1<=yt+129, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1+2, PHI1<=yt+125, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, 2<=yt, yt+3<=n}>

l99996:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, xt<=PHI2, PHI2<=xt+259,
//    0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>

l99997:
#pragma  omp parallel for 
            for(x = xt; x <= xt+259; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1+2, PHI1<=y+2, xt<=PHI2,
//    PHI2<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y-2, PHI2==x, xt<=x,
//    x<=xt+259, 0<=xt, xt+1<=n, yt<=y, y<=yt+127, 2<=yt, yt+3<=n}>

               img_out[y-2][x] = MIN(MIN(MIN(MIN(img[y-2][x], img[y-1][x]), img[y][x]), img[y+1][x]), img[y+2][x]);
}
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 2; yt <= 124*((n+119)/124)-122; yt += 124)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= 260*((n+259)/260)-260; xt += 260) {
         {
            //PIPS generated variable
            int (*img_out0)[128][260] = (int (*)[128][260]) 0, (*img0)[132][260] = (int (*)[132][260]) 0;
            P4A_accel_malloc((void **) &img0, sizeof(int)*34320);
            P4A_accel_malloc((void **) &img_out0, sizeof(int)*33280);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+259, 132, 260, yt-2, xt, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = yt; y <= yt+127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = xt; x <= xt+259; x += 1)
                  (*img_out0)[y-2-(yt-2)][x-xt] = MIN(MIN(MIN(MIN((*img0)[y-2-(yt-2)][x-xt], (*img0)[y-1-(yt-2)][x-xt]), (*img0)[y-(yt-2)][x-xt]), (*img0)[y+1-(yt-2)][x-xt]), (*img0)[y+2-(yt-2)][x-xt]);
            P4A_copy_from_accel_2d(sizeof(int), n+123, n+259, 128, 260, yt-2, xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img0);
            P4A_accel_free(img_out0);
         }
      }
}
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (124*((n+119)/124)-122-2+124)/124+-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (260*((n+259)/260)-260+260)/260+-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img_out0)[128][260] = (int (*)[128][260]) 0, (*img0)[132][260] = (int (*)[132][260]) 0;
            P4A_accel_malloc((void **) &img0, sizeof(int)*34320);
            P4A_accel_malloc((void **) &img_out0, sizeof(int)*33280);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+259, 132, 260, 124*yt+2-2, 260*xt, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = 0; y <= 127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = 0; x <= 259; x += 1)
                  (*img_out0)[y+124*yt+2-2-(124*yt+2-2)][x+260*xt-260*xt] = MIN(MIN(MIN(MIN((*img0)[y+124*yt+2-2-(124*yt+2-2)][x+260*xt-260*xt], (*img0)[y+124*yt+2-1-(124*yt+2-2)][x+260*xt-260*xt]), (*img0)[y+124*yt+2-(124*yt+2-2)][x+260*xt-260*xt]), (*img0)[y+124*yt+2+1-(124*yt+2-2)][x+260*xt-260*xt]), (*img0)[y+124*yt+2+2-(124*yt+2-2)][x+260*xt-260*xt]);
            P4A_copy_from_accel_2d(sizeof(int), n+123, n+259, 128, 260, 124*yt+2-2, 260*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img0);
            P4A_accel_free(img_out0);
         }
      }
}
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+119)/124-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+259)/260-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img_out0)[128][260] = (int (*)[128][260]) 0, (*img0)[132][260] = (int (*)[132][260]) 0;
            P4A_accel_malloc((void **) &img0, 34320*sizeof(int));
            P4A_accel_malloc((void **) &img_out0, 33280*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+259, 132, 260, 124*yt, 260*xt, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = 0; y <= 127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = 0; x <= 259; x += 1)
                  (*img_out0)[y][x] = MIN(MIN(MIN(MIN((*img0)[y][x], (*img0)[y+1][x]), (*img0)[y+2][x]), (*img0)[y+3][x]), (*img0)[y+4][x]);
            P4A_copy_from_accel_2d(sizeof(int), n+123, n+259, 128, 260, 124*yt, 260*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img0);
            P4A_accel_free(img_out0);
         }
      }
}
outlining to launcher
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+119)/124-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+259)/260-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img_out0)[128][260] = (int (*)[128][260]) 0, (*img0)[132][260] = (int (*)[132][260]) 0;
            P4A_accel_malloc((void **) &img0, 34320*sizeof(int));
            P4A_accel_malloc((void **) &img_out0, 33280*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+259, 132, 260, 124*yt, 260*xt, &img[0][0], *img0);

l99996:            launcher_0(259, *img0, *img_out0);
            P4A_copy_from_accel_2d(sizeof(int), n+123, n+259, 128, 260, 124*yt, 260*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img0);
            P4A_accel_free(img_out0);
         }
      }
}

//  <img0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=131, 0<=PHI2, PHI2<=259,
//    I_3==259}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2,
//    PHI2<=259, I_3==259}>

void launcher_0(int I_3, int img0[132][260], int img_out0[128][260])
{
   //PIPS generated variable
   int x, y;

//  <img0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=131, 0<=PHI2, PHI2<=259,
//    I_3==259}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2,
//    PHI2<=259, I_3==259}>

l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)

//  <img0[PHI1][PHI2]-R-EXACT-{y<=PHI1, PHI1<=y+4, 0<=PHI2, PHI2<=259,
//    I_3==259, 0<=y, y<=127}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{PHI1==y, 0<=PHI2, PHI2<=259,
//    I_3==259, 0<=y, y<=127}>

l99997:
#pragma   omp parallel for 
      for(x = 0; x <= I_3; x += 1)

//  <img0[PHI1][PHI2]-R-EXACT-{PHI2==x, y<=PHI1, PHI1<=y+4, I_3==259,
//    0<=x, x<=259, 0<=y, y<=127}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x, I_3==259, 0<=x,
//    x<=259, 0<=y, y<=127}>

         img_out0[y][x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y+1][x]), img0[y+2][x]), img0[y+3][x]), img0[y+4][x]);
}
outlining to microcode
void launcher_0(int I_3, int img0[132][260], int img_out0[128][260])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:
#pragma   omp parallel for 
      for(x = 0; x <= I_3; x += 1)
         img_out0[y][x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y+1][x]), img0[y+2][x]), img0[y+3][x]), img0[y+4][x]);
}
label: l99997
void runner(int n, int img_out[n+122+1][n+258+1], int img[n+126+1][n+258+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+119)/124-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+259)/260-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img_out0)[128][260] = (int (*)[128][260]) 0, (*img0)[132][260] = (int (*)[132][260]) 0;
            P4A_accel_malloc((void **) &img0, 34320*sizeof(int));
            P4A_accel_malloc((void **) &img_out0, 33280*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+259, 132, 260, 124*yt, 260*xt, &img[0][0], *img0);

l99996:            launcher_0(259, *img0, *img_out0);
            P4A_copy_from_accel_2d(sizeof(int), n+123, n+259, 128, 260, 124*yt, 260*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img0);
            P4A_accel_free(img_out0);
         }
      }
}
void launcher_0(int I_3, int img0[132][260], int img_out0[128][260])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:      launcher_0_microcode(y, I_3, img0, *&img_out0[y]);
}
void launcher_0_microcode(int y, int I_3, int img0[132][260], int img_out00[260])
{
   //PIPS generated variable
   int x;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3; x += 1)
      img_out00[x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y+1][x]), img0[y+2][x]), img0[y+3][x]), img0[y+4][x]);
}
**** check ok ******
