tidy the code just in case of
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
}
tiling
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in[i][j]+2;

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
group constants and isolate
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 256;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         //PIPS generated variable
         int caillou[1];
         caillou[0] = 2;

#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+caillou[0];
      }
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         //PIPS generated variable
         int caillou[1];
         caillou[0] = 2;

#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+caillou[0];
      }
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+126+1][n+254+1], in[n+126+1][n+254+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in[i][j] = 1;
   runner(n, out, in);
   check = 0;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         //PIPS generated variable
         int caillou[1];
         caillou[0] = 2;

#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+caillou[0];
      }
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         //PIPS generated variable
         int caillou[1];
         caillou[0] = 2;

         {
            //PIPS generated variable
            int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
            P4A_accel_malloc((void **) &out0, sizeof(int)*32768);
            P4A_accel_malloc((void **) &caillou0, sizeof(int)*1);
            P4A_accel_malloc((void **) &in0, sizeof(int)*32768);
            P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, it, jt, &in[0][0], *in0);

#pragma omp parallel for 
l99994:
            for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
               for(j = jt; j <= jt+255; j += 1)
                  (*out0)[i-it][j-jt] = (*in0)[i-it][j-jt]+(*caillou0)[0-0];
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, it, jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(caillou0);
            P4A_accel_free(in0);
         }
      }
}
outlining to launcher
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
#pragma omp parallel for 
l99993:
      for(jt = 0; jt <= (n+255)/256-1; jt += 1) {
         //PIPS generated variable
         int caillou[1];
         caillou[0] = 2;

         {
            //PIPS generated variable
            int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
            P4A_accel_malloc((void **) &out0, 32768*sizeof(int));
            P4A_accel_malloc((void **) &caillou0, sizeof(int));
            P4A_accel_malloc((void **) &in0, 32768*sizeof(int));
            P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &in[0][0], *in0);

l99994:            launcher_0(255+1, *caillou0, *in0, *out0);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(caillou0);
            P4A_accel_free(in0);
         }
      }
}

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_2==256}>
//  <in0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_2==256}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_2==256}>

void launcher_0(int I_2, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_2==256}>
//  <in0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_2==256}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_2==256}>

l99994:
   for(i = 0; i <= 127; i += 1)

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_2==256, 0<=i, i<=127}>
//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=255, I_2==256,
//    0<=i, i<=127}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2<=255, I_2==256,
//    0<=i, i<=127}>

l99995:
      for(j = 0; j <= I_2-1; j += 1)

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_2==256, 0<=i, i<=127, 0<=j,
//    j<=255}>
//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_2==256, 0<=i,
//    i<=127, 0<=j, j<=255}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, I_2==256, 0<=i,
//    i<=127, 0<=j, j<=255}>

         out0[i][j] = in0[i][j]+caillou0[0];
}
outlining to microcode
void launcher_0(int I_2, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99994:
   for(i = 0; i <= 127; i += 1)
l99995:      launcher_0_microcode(I_2, *&in0[i], *&out0[i], caillou0[0]);
}
void launcher_0_microcode(int I_2, int in00[256], int out00[256], int caillou0)
{
   //PIPS generated variable
   int j;
l99995:
   for(j = 0; j <= I_2-1; j += 1)
      out00[j] = in00[j]+caillou0;
}
**** check ok ******
refining microcode
void launcher_0_microcode(int I_2, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
l99995:
   for(j = 0; j <= I_2-1; j += 1)
      *(out00+j) = *(in00+j)+caillou0;
}
**** check ok ******
void launcher_0_microcode(int I_2, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in000;
   in000 = in00;
   out000 = out00;
l99995:
   for(j = 0; j <= I_2-1; j += 1) {
      *out000 = *in000+caillou0;
      in000 = in000+1;
      out000 = out000+1;
   }
}
**** check ok ******
I_2 belongs to a loop bound
in00 seems an image
out00 seems an image
caillou0 seems a mask
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *ma4;
   //PIPS generated variable
   int re0;
   ma4 = FIFO2;
   im3 = FIFO1;
   im2 = FIFO0;
   im0 = im2;
   im1 = im3;
   for(re0 = 0; re0 <= N0; re0 += 1) {
      *im1 = *im0+*ma4;
      im0 = im0+1;
      im1 = im1+1;
   }
}
void launcher_0(int I_2, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99994:
   for(i = 0; i <= 127; i += 1)
l99995:      launcher_0_microcode(&caillou0[0], *&out0[i], *&in0[i], I_2);
}
**** check ok ******
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *ma4;
   //PIPS generated variable
   int re0;
   seti(ma4, FIFO2);
   seti(im3, FIFO1);
   seti(im2, FIFO0);
   seti(im0, im2);
   seti(im1, im3);
   for(re0 = 0; re0 <= N0; re0 += 1) {
      addi(*im1, *im0, *ma4);
      paddi(im0, im0, 1);
      paddi(im1, im1, 1);
   }
}
sub launcher_0_microcode
                        ||       ma4=FIFO2        ||                        ||                        ||                        
      im,im3=FIFO1      ||                        ||                        ||                        ||                        
      im,im2=FIFO0      ||                        ||                        ||                        ||                        
       im,im0=im2       ||                        ||                        ||                        ||                        
       im,im1=im3       ||                        ||                        ||                        ||                        
                        ||                        ||                        ||         do_N0          ||                        
                        ||                        ||     P,im1=im0+ma4      ||                        ||                        
      im,im0=im0+E      ||                        ||                        ||                        ||                        
      im,im1=im1+E      ||                        ||                        ||                        ||                        
                        ||                        ||                        ||          loop          ||                        
endsub
