
Inital code

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1)
         run_kernel(i, j, 512, 512, new_image, image, kernel);
}
void run_kernel(int i, int j, int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   int ki, kj;
   new_image[i][j] = 0.;
   for(ki = 0; ki <= 2; ki += 1)
      for(kj = 0; kj <= 2; kj += 1)
         
         
         new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
   new_image[i][j] = new_image[i][j]/(3*3);
}

After Inlining

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            new_image[i][j] = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            new_image[i][j] = new_image[i][j]/(3*3);
         }
      }
}

After scalarization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= 510; i += 1)
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
            for(ki = 0; ki <= 2; ki += 1)
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         new_image[i][j] = __scalar__0;
      }
}

After privatization + loop expansion

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
l99997:
   for(i = 0; i <= 511; i += 1)
l99998:
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l99993:
   for(i = 1; i <= 630; i += 1)
l99994:
      for(j = 1; j <= 510; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 0; ki <= 2; ki += 1)
l99996:
               for(kj = 0; kj <= 2; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
            __scalar__0 = __scalar__0/(3*3);
         }
         if (i>=1&&i<=510) 
            new_image[i][j] = __scalar__0;
      }
}

After tiling

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 0; i <= 511; i += 1)
l99998:
      for(j = 0; j <= 511; j += 1)
         new_image[i][j] = image[i][j];

l99993:
   for(i_t = 0; i_t <= 4; i_t += 1)
      for(j_t = 0; j_t <= 101; j_t += 1)

         for(i = 126*i_t+1; i <= 126*i_t+126; i += 1)
            for(j = 5*j_t+1; j <= 5*j_t+5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 0; ki <= 2; ki += 1)
l99996:
                     for(kj = 0; kj <= 2; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i-1][kj+j-1]*kernel[ki][kj];
                  __scalar__0 = __scalar__0/9;
               }
               if (i>=1&&i<=510) 
                  new_image[i][j] = __scalar__0;
            }
}

After loop normalization

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 1; i <= 126; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               if (i+126*i_t-126>=1&&i+126*i_t-126<=510) 
                  new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
            }
}

loop expansion again

void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 0; i <= 127; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               if (i>=1&&i<=126&&i+126*i_t-126>=1&&i+126*i_t-126<=510) 
                  new_image[i+126*i_t-126][j+5*j_t-5] = __scalar__0;
            }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
   //PIPS generated variable
   int L_0;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1)

l99991:
         for(i = 0; i <= 127; i += 1)
l99992:
            for(j = 1; j <= 5; j += 1) {
               {
                  int ki, kj;
                  __scalar__0 = 0.;
l99995:
                  for(ki = 1; ki <= 3; ki += 1)
l99996:
                     for(kj = 1; kj <= 3; kj += 1)
                        
                        
                        __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
                  __scalar__0 = __scalar__0/9;
               }
               L_0 = i>=1&&i<=126&&i+126*i_t-126>=1&&i+126*i_t-126<=510;
               new_image[i+126*i_t-126][j+5*j_t-5] = L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
               ;
            }
}

After Double Outlining and load - store generation

void microcode_launcher(int isi, int isj, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_0;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 0; i <= 127; i += 1)
l99992:
      for(j = 1; j <= 5; j += 1) {
         {
            int ki, kj;
            __scalar__0 = 0.;
l99995:
            for(ki = 1; ki <= 3; ki += 1)
l99996:
               for(kj = 1; kj <= 3; kj += 1)
                  
                  
                  __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
            __scalar__0 = __scalar__0/9;
         }
         L_0 = i>=1&&i<=126&&i+126*i_t-126>=1&&i+126*i_t-126<=510;
         new_image[i+126*i_t-126][j+5*j_t-5] = L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   int i, j;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i_t, j_t;
   //PIPS generated variable
   int L_0;
l99997:
   for(i = 1; i <= 512; i += 1)
l99998:
      for(j = 1; j <= 512; j += 1)
         new_image[i-1][j-1] = image[i-1][j-1];

l99993:
   for(i_t = 1; i_t <= 5; i_t += 1)
l99990:
      for(j_t = 1; j_t <= 102; j_t += 1) {
         //PIPS generated variable
         float (*new_image0)[isi][isj] = (float (*)[isi][isj]) 0, (*kernel0)[3][3] = (float (*)[3][3]) 0, (*image0)[isi][isj] = (float (*)[isi][isj]) 0;
         P4A_accel_malloc((void **) &image0, sizeof(float)*isi*isj);
         P4A_accel_malloc((void **) &kernel0, sizeof(float)*9);
         P4A_accel_malloc((void **) &new_image0, sizeof(float)*isi*isj);
         P4A_copy_to_accel2d(*image0, &image[0][0], sizeof(float), isi, isj, 0, 0, isi, isj);
         P4A_copy_to_accel2d(*kernel0, &kernel[0][0], sizeof(float), 3, 3, 0, 0, 3, 3);
         P4A_copy_to_accel2d(*new_image0, &new_image[0][0], sizeof(float), isi, isj, 0, 0, isi, isj);


l99991:         microcode_launcher(isi, isj, i_t, j_t, (*image0), (*kernel0), (*new_image0));
         P4A_copy_from_accel2d(&new_image[0][0], *new_image0, sizeof(float), isi, isj, 0, 0, isi, isj);
         P4A_accel_free((void **) &image0);
         P4A_accel_free((void **) &kernel0);
         P4A_accel_free((void **) &new_image0);
      }
}
void microcode_launcher(int isi, int isj, int i_t, int j_t, float image[isi][isj], float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_0;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int i, j;

l99991:
   for(i = 0; i <= 127; i += 1)
l99992:      convol_microcode(isi, isj, i, i_t, image, j_t, kernel, new_image);
}
void convol_microcode(int isi, int isj, int i, int i_t, float image[isi][isj], int j_t, float kernel[3][3], float new_image[isi][isj])
{
   //PIPS generated variable
   int L_0;
   //PIPS generated variable
   float __scalar__0;
   //PIPS generated variable
   int j;
l99992:
   for(j = 1; j <= 5; j += 1) {
      {
         int ki, kj;
         __scalar__0 = 0.;
l99995:
         for(ki = 1; ki <= 3; ki += 1)
l99996:
            for(kj = 1; kj <= 3; kj += 1)
               
               
               __scalar__0 = __scalar__0+image[ki+i+126*i_t-128][kj+j+5*j_t-7]*kernel[ki-1][kj-1];
         __scalar__0 = __scalar__0/9;
      }
      L_0 = i>=1&&i<=126&&i+126*i_t-126>=1&&i+126*i_t-126<=510;
      new_image[i+126*i_t-126][j+5*j_t-5] = L_0?__scalar__0:new_image[i+126*i_t-126][j+5*j_t-5];
   }
}
