tidy the code just in case of
I have to do this early
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
}
tiling
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
#pragma pips inserted statement to check
   for(i = n; i <= 128*((127+n)/128)-1; i += 1)
l99997:
      for(I_0 = 0; I_0 <= n-1; I_0 += 1)
         result[i][I_0] = (40*src0[i][I_0]+60*src1[i][I_0])*(1/100<<4)>>4;
}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
#pragma pips inserted statement
   for(i = n; i <= 128*((127+n)/128)-1; i += 1)
l99997:
      for(I_0 = 0; I_0 <= n-1; I_0 += 1)
         result[i][I_0] = (40*src0[i][I_0]+60*src1[i][I_0])*(1/100<<4)>>4;
}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= 128*((127+n)/128)-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;

}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= 128*((127+n)/128)-1; i += 1) {
l99999:
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
#pragma pips inserted statement to check
      for(j = n; j <= 8*((7+n)/8)-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
   }

}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= 128*((127+n)/128)-1; i += 1) {
l99999:
      for(j = 0; j <= n-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
#pragma pips inserted statement
      for(j = n; j <= 8*((7+n)/8)-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
   }

}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0;
l99998:
   for(i = 0; i <= 128*((127+n)/128)-1; i += 1) {
l99999:
      for(j = 0; j <= 8*((7+n)/8)-1; j += 1)
         result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;

   }

}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
#pragma omp parallel for private(i,j)
l99998:
   for(it = 0; it <= 128*((127+n)/128)-1; it += 128)
#pragma omp parallel for private(j)
l99999:
      for(jt = 0; jt <= 8*((7+n)/8)-1; jt += 8)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+128, 128*((127+n)/128)-1); i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+8, 8*((7+n)/8)-1); j += 1)
               result[i][j] = (40*src0[i][j]+60*src1[i][j])*(1/100<<4)>>4;
}
group constants and isolate
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
#pragma omp parallel for private(i,j)
l99998:
   for(it = 0; it <= 128*((127+n)/128)-1; it += 128)
#pragma omp parallel for private(j)
l99999:
      for(jt = 0; jt <= 8*((7+n)/8)-1; jt += 8) {
         //PIPS generated variable
         int caillou[8];
         caillou[0] = 1;
         caillou[1] = 100;
         caillou[2] = 4;
         caillou[3] = 40;
         caillou[4] = 60;
         caillou[5] = it;
         caillou[6] = jt;
         caillou[7] = n;

#pragma omp parallel for 
l99995:
         for(i = it; i <= MIN(it+128, 128*((127+n)/128)-1); i += 1)
#pragma omp parallel for 
l99996:
            for(j = jt; j <= MIN(jt+8, 8*((7+n)/8)-1); j += 1)
               result[i][j] = (caillou[3]*src0[i][j]+caillou[4]*src1[i][j])*(caillou[0]/caillou[1]<<caillou[2])>>caillou[2];
      }
}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
   //PIPS generated variable
   int i0, i1, i2, i3, i4, i5, i6;
#pragma omp parallel for private(i,j)
l99998:
   for(it = 0; it <= 128*((127+n)/128)-1; it += 128)
#pragma omp parallel for private(j)
l99999:
      for(jt = 0; jt <= 8*((7+n)/8)-1; jt += 8) {
         //PIPS generated variable
         int caillou[8];
         caillou[0] = 1;
         caillou[1] = 100;
         caillou[2] = 4;
         caillou[3] = 40;
         caillou[4] = 60;
         caillou[5] = it;
         caillou[6] = jt;
         caillou[7] = n;

         {
            //PIPS generated variable
            short result0[129][9];
            //PIPS generated variable
            int caillou0[5];
            //PIPS generated variable
            short src10[129][9], src00[129][9];
            /* transfer loop generated by PIPS from src0 to src00 */
            for(i5 = 0; i5 <= MIN(jt+8, n+6)-jt; i5 += 1)
               for(i6 = 0; i6 <= MIN(it+128, n+126)-it; i6 += 1)
                  src00[i6][i5] = src0[it+i6][jt+i5];
            /* transfer loop generated by PIPS from src1 to src10 */
            for(i3 = 0; i3 <= MIN(jt+8, n+6)-jt; i3 += 1)
               for(i4 = 0; i4 <= MIN(it+128, n+126)-it; i4 += 1)
                  src10[i4][i3] = src1[it+i4][jt+i3];
            /* transfer loop generated by PIPS from caillou to caillou0 */
            for(i2 = 0; i2 <= 4; i2 += 1)
               caillou0[i2] = caillou[i2];

#pragma omp parallel for 
l99995:
            for(i = it; i <= MIN(it+128, 128*((127+n)/128)-1); i += 1)
#pragma omp parallel for 
l99996:
               for(j = jt; j <= MIN(jt+8, 8*((7+n)/8)-1); j += 1)
                  result0[i-it][j-jt] = (caillou0[3-0]*src00[i-it][j-jt]+caillou0[4-0]*src10[i-it][j-jt])*(caillou0[0-0]/caillou0[1-0]<<caillou0[2-0])>>caillou0[2-0];
            /* transfer loop generated by PIPS from result0 to result */
            for(i0 = 0; i0 <= MIN(jt+8, n+6)-jt; i0 += 1)
               for(i1 = 0; i1 <= MIN(it+128, n+126)-it; i1 += 1)
                  result[it+i1][jt+i0] = result0[i1][i0];
         }
      }
}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
   //PIPS generated variable
   int i0, i1, i2, i3, i4, i5, i6;
#pragma omp parallel for private(i,j)
l99998:
   for(it = 1; it <= (128*((127+n)/128)-1+128)/128; it += 1)
#pragma omp parallel for private(j)
l99999:
      for(jt = 1; jt <= (8*((7+n)/8)-1+8)/8; jt += 1) {
         //PIPS generated variable
         int caillou[8];
         caillou[0] = 1;
         caillou[1] = 100;
         caillou[2] = 4;
         caillou[3] = 40;
         caillou[4] = 60;
         caillou[5] = -128+128*it;
         caillou[6] = -8+8*jt;
         caillou[7] = n;

         {
            //PIPS generated variable
            short result0[129][9];
            //PIPS generated variable
            int caillou0[5];
            //PIPS generated variable
            short src10[129][9], src00[129][9];
            /* transfer loop generated by PIPS from src0 to src00 */
            for(i5 = 1; i5 <= MIN(-8+8*jt+8, n+6)-(-8+8*jt)+1; i5 += 1)
               for(i6 = 1; i6 <= MIN(-128+128*it+128, n+126)-(-128+128*it)+1; i6 += 1)
                  src00[-1+i6][-1+i5] = src0[-128+128*it+-1+i6][-8+8*jt+-1+i5];
            /* transfer loop generated by PIPS from src1 to src10 */
            for(i3 = 1; i3 <= MIN(-8+8*jt+8, n+6)-(-8+8*jt)+1; i3 += 1)
               for(i4 = 1; i4 <= MIN(-128+128*it+128, n+126)-(-128+128*it)+1; i4 += 1)
                  src10[-1+i4][-1+i3] = src1[-128+128*it+-1+i4][-8+8*jt+-1+i3];
            /* transfer loop generated by PIPS from caillou to caillou0 */
            for(i2 = 1; i2 <= 5; i2 += 1)
               caillou0[-1+i2] = caillou[-1+i2];

#pragma omp parallel for 
l99995:
            for(i = 1; i <= MIN(-128+128*it+128, 128*((127+n)/128)-1)-(-128+128*it)+1; i += 1)
#pragma omp parallel for 
l99996:
               for(j = 1; j <= MIN(-8+8*jt+8, 8*((7+n)/8)-1)-(-8+8*jt)+1; j += 1)
                  result0[-1+i+-128+128*it-(-128+128*it)][-1+j+-8+8*jt-(-8+8*jt)] = (caillou0[3-0]*src00[-1+i+-128+128*it-(-128+128*it)][-1+j+-8+8*jt-(-8+8*jt)]+caillou0[4-0]*src10[-1+i+-128+128*it-(-128+128*it)][-1+j+-8+8*jt-(-8+8*jt)])*(caillou0[0-0]/caillou0[1-0]<<caillou0[2-0])>>caillou0[2-0];
            /* transfer loop generated by PIPS from result0 to result */
            for(i0 = 1; i0 <= MIN(-8+8*jt+8, n+6)-(-8+8*jt)+1; i0 += 1)
               for(i1 = 1; i1 <= MIN(-128+128*it+128, n+126)-(-128+128*it)+1; i1 += 1)
                  result[-128+128*it+-1+i1][-8+8*jt+-1+i0] = result0[-1+i1][-1+i0];
         }
      }
}
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
   //PIPS generated variable
   int i0, i1, i2, i3, i4, i5, i6;
#pragma omp parallel for private(i,j)
l99998:
   for(it = 1; it <= (128*((n+127)/128)+127)/128; it += 1)
#pragma omp parallel for private(j)
l99999:
      for(jt = 1; jt <= (8*((n+7)/8)+7)/8; jt += 1) {
         //PIPS generated variable
         int caillou[8];
         caillou[0] = 1;
         caillou[1] = 100;
         caillou[2] = 4;
         caillou[3] = 40;
         caillou[4] = 60;
         caillou[5] = 128*it-128;
         caillou[6] = 8*jt-8;
         caillou[7] = n;

         {
            //PIPS generated variable
            short result0[129][9];
            //PIPS generated variable
            int caillou0[5];
            //PIPS generated variable
            short src10[129][9], src00[129][9];
            /* transfer loop generated by PIPS from src0 to src00 */
            for(i5 = 1; i5 <= MIN(8*jt, n+6)-8*jt+9; i5 += 1)
               for(i6 = 1; i6 <= MIN(128*it, n+126)-128*it+129; i6 += 1)
                  src00[i6-1][i5-1] = src0[i6+128*it-129][i5+8*jt-9];
            /* transfer loop generated by PIPS from src1 to src10 */
            for(i3 = 1; i3 <= MIN(8*jt, n+6)-8*jt+9; i3 += 1)
               for(i4 = 1; i4 <= MIN(128*it, n+126)-128*it+129; i4 += 1)
                  src10[i4-1][i3-1] = src1[i4+128*it-129][i3+8*jt-9];
            /* transfer loop generated by PIPS from caillou to caillou0 */
            for(i2 = 1; i2 <= 5; i2 += 1)
               caillou0[i2-1] = caillou[i2-1];

#pragma omp parallel for 
l99995:
            for(i = 1; i <= MIN(128*it, 128*((n+127)/128)-1)-128*it+129; i += 1)
#pragma omp parallel for 
l99996:
               for(j = 1; j <= MIN(8*jt, 8*((n+7)/8)-1)-8*jt+9; j += 1)
                  result0[i-1][j-1] = (caillou0[3]*src00[i-1][j-1]+caillou0[4]*src10[i-1][j-1])*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
            /* transfer loop generated by PIPS from result0 to result */
            for(i0 = 1; i0 <= MIN(8*jt, n+6)-8*jt+9; i0 += 1)
               for(i1 = 1; i1 <= MIN(128*it, n+126)-128*it+129; i1 += 1)
                  result[i1+128*it-129][i0+8*jt-9] = result0[i1-1][i0-1];
         }
      }
}
outlining to launcher
void alphablending(int n, short src0[n][n], short src1[n][n], short result[n][n])
{
   unsigned int i, j;
   //PIPS generated variable
   unsigned int I_0, it, jt;
   //PIPS generated variable
   int i0, i1, i2, i3, i4, i5, i6;
#pragma omp parallel for private(i,i0,i1,i2,i3,i4,i5,i6,jt)
l99998:
   for(it = 1; it <= (128*((n+127)/128)+127)/128; it += 1)
#pragma omp parallel for private(i,i0,i1,i2,i3,i4,i5,i6,j)
l99999:
      for(jt = 1; jt <= (8*((n+7)/8)+7)/8; jt += 1) {
         //PIPS generated variable
         int caillou[8];
         caillou[0] = 1;
         caillou[1] = 100;
         caillou[2] = 4;
         caillou[3] = 40;
         caillou[4] = 60;
         caillou[5] = 128*it-128;
         caillou[6] = 8*jt-8;
         caillou[7] = n;

         {
            //PIPS generated variable
            short result0[129][9];
            //PIPS generated variable
            int caillou0[5];
            //PIPS generated variable
            short src10[129][9], src00[129][9];
            /* transfer loop generated by PIPS from src0 to src00 */
l99993:
            for(i5 = 1; i5 <= MIN(8*jt, n+6)-8*jt+9; i5 += 1)
l99994:
               for(i6 = 1; i6 <= MIN(128*it, n+126)-128*it+129; i6 += 1)
                  src00[i6-1][i5-1] = src0[i6+128*it-129][i5+8*jt-9];
            /* transfer loop generated by PIPS from src1 to src10 */
l99991:
            for(i3 = 1; i3 <= MIN(8*jt, n+6)-8*jt+9; i3 += 1)
l99992:
               for(i4 = 1; i4 <= MIN(128*it, n+126)-128*it+129; i4 += 1)
                  src10[i4-1][i3-1] = src1[i4+128*it-129][i3+8*jt-9];
            /* transfer loop generated by PIPS from caillou to caillou0 */
l99990:
            for(i2 = 1; i2 <= 5; i2 += 1)
               caillou0[i2-1] = caillou[i2-1];

l99995:            launcher_0(MIN(8*jt, 8*((n+7)/8)-1)-8*jt+9, it, caillou0, n, result0, src00, src10);
            /* transfer loop generated by PIPS from result0 to result */
l99988:
            for(i0 = 1; i0 <= MIN(8*jt, n+6)-8*jt+9; i0 += 1)
l99989:
               for(i1 = 1; i1 <= MIN(128*it, n+126)-128*it+129; i1 += 1)
                  result[i1+128*it-129][i0+8*jt-9] = result0[i1-1][i0-1];
         }
      }
}

//  <caillou0[PHI1]-R-MAY-{0<=PHI1, PHI1<=4, 1<=I_1, I_1<=9, I_1<=n+7,
//    1<=it, 128it<=n+254}>
//  <result0[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>
//  <src00[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>
//  <src10[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>

void launcher_0(int I_1, unsigned int it, int caillou0[5], int n, short result0[129][9], short src00[129][9], short src10[129][9])
{
   //PIPS generated variable
   unsigned int i, j;

//  <caillou0[PHI1]-R-MAY-{0<=PHI1, PHI1<=4, 1<=I_1, I_1<=9, I_1<=n+7,
//    1<=it, 128it<=n+254}>
//  <result0[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>
//  <src00[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>
//  <src10[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=128, PHI1+128it<=n+254,
//    0<=PHI2, PHI2+1<=I_1, I_1<=9, I_1<=n+7, 1<=it}>

l99995:
   for(i = 1; i <= MIN(128*it, 128*((n+127)/128)-1)-128*it+129; i += 1)

//  <caillou0[PHI1]-R-MAY-{0<=PHI1, PHI1<=4, 1<=I_1, I_1<=9, I_1<=n+7,
//    1<=i, i<=129, i+128it<=n+255, 1<=it}>
//  <result0[PHI1][PHI2]-W-MAY-{PHI1==i-1, 0<=PHI2, PHI2+1<=I_1,
//    I_1<=9, I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it}>
//  <src00[PHI1][PHI2]-R-MAY-{PHI1==i-1, 0<=PHI2, PHI2+1<=I_1, I_1<=9,
//    I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it}>
//  <src10[PHI1][PHI2]-R-MAY-{PHI1==i-1, 0<=PHI2, PHI2+1<=I_1, I_1<=9,
//    I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it}>

l99996:
      for(j = 1; j <= I_1; j += 1)

//  <caillou0[PHI1]-R-MAY-{0<=PHI1, PHI1<=4, I_1<=9, j<=I_1, I_1<=n+7,
//    1<=i, i<=129, i+128it<=n+255, 1<=it, 1<=j}>
//  <result0[PHI1][PHI2]-W-EXACT-{PHI1==i-1, PHI2==j-1, I_1<=9,
//    j<=I_1, I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it, 1<=j}>
//  <src00[PHI1][PHI2]-R-EXACT-{PHI1==i-1, PHI2==j-1, I_1<=9, j<=I_1,
//    I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it, 1<=j}>
//  <src10[PHI1][PHI2]-R-EXACT-{PHI1==i-1, PHI2==j-1, I_1<=9, j<=I_1,
//    I_1<=n+7, 1<=i, i<=129, i+128it<=n+255, 1<=it, 1<=j}>

         result0[i-1][j-1] = (caillou0[3]*src00[i-1][j-1]+caillou0[4]*src10[i-1][j-1])*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
}
outlining to microcode
label: l99996
void launcher_0(int I_1, unsigned int it, int caillou0[5], int n, short result0[129][9], short src00[129][9], short src10[129][9])
{
   //PIPS generated variable
   unsigned int i, j;
l99995:
   for(i = 1; i <= MIN(128*it, 128*((n+127)/128)-1)-128*it+129; i += 1)
l99996:      launcher_0_microcode(I_1, caillou0, &result0[-1+i], &src00[-1+i], &src10[-1+i]);
}
void launcher_0_microcode(int I_1, int caillou0[5], short (*result00)[9], short (*src000)[9], short (*src100)[9])
{
   //PIPS generated variable
   unsigned int j;
l99996:
   for(j = 1; j <= I_1; j += 1)
      (*result00)[j-1] = (caillou0[3]*(*src000)[j-1]+caillou0[4]*(*src100)[j-1])*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
}
normalize microcode launcher_0_microcode
void launcher_0_microcode(int I_1, int caillou0[5], short (*result00)[9], short (*src000)[9], short (*src100)[9])
{
   //PIPS generated variable
   unsigned int j;
l99996:
   for(j = 0; j <= -1+I_1; j += 1)
      (*result00)[j+1-1] = (caillou0[3]*(*src000)[j+1-1]+caillou0[4]*(*src100)[j+1-1])*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
}
void launcher_0_microcode(int I_1, int caillou0[5], short (*result00)[9], short (*src000)[9], short (*src100)[9])
{
   //PIPS generated variable
   unsigned int j;
l99996:
   for(j = 0; j <= -1+I_1; j += 1)
      (*result00)[j+1-1] = (caillou0[3]*(*src000)[j+1-1]+caillou0[4]*(*src100)[j+1-1])*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
}
void launcher_0_microcode(int I_1, int *caillou0, short *result00, short *src000, short *src100)
{
   //PIPS generated variable
   unsigned int j;
l99996:
   for(j = 0; j <= -1+I_1; j += 1)
      *(result00+j+1-1) = (caillou0[3]**(src000+j+1-1)+caillou0[4]**(src100+j+1-1))*(caillou0[0]/caillou0[1]<<caillou0[2])>>caillou0[2];
}
I_1 belongs to a loop bound
caillou0 seems a mask
result00 seems a mask
src000 seems a mask
src100 seems a mask
void launcher_0_microcode(int N0, int *FIFO0, short *FIFO1, short *FIFO2, short *FIFO3)
{
   //PIPS generated variable
   unsigned int j;
   //PIPS generated variable
   char * re0, re1;
   //PIPS generated variable
   int *caillou0, *ma0;
   //PIPS generated variable
   short *result00, *ma1, *src000, *ma2, *src100, *ma3;
   //PIPS generated variable
   unsigned int re2, re3;
   //PIPS generated variable
   int *im4;
   //PIPS generated variable
   short *im5, *im6, *im7;
   ma3 = FIFO3;
   ma2 = FIFO2;
   ma1 = FIFO1;
   ma0 = FIFO0;
l99996:   ;
   re2 = 1;
   while (re2<=N0) {
      *(ma1+re2+1-1) = (ma0[3]**(ma2+re2+1-1)+ma0[4]**(ma3+re2+1-1))*(ma0[0]/ma0[1]<<ma0[2])>>ma0[2];
      re2 = 1+re2;
   }
}
void launcher_0_microcode(int N0, int *FIFO0, short *FIFO1, short *FIFO2, short *FIFO3)
{
   //PIPS generated variable
   unsigned int j;
   //PIPS generated variable
   char * re0, re1;
   //PIPS generated variable
   int *caillou0, *ma0;
   //PIPS generated variable
   short *result00, *ma1, *src000, *ma2, *src100, *ma3;
   //PIPS generated variable
   unsigned int re2, re3;
   //PIPS generated variable
   int *im4;
   //PIPS generated variable
   short *im5, *im6, *im7;
   //PIPS generated variable
   int I_2, I_3;
   //PIPS generated variable
   short *P_0;
   //PIPS generated variable
   int I_4, I_5, I_6;
   //PIPS generated variable
   short *P_1;
   //PIPS generated variable
   int I_7, I_8, I_9, I_10, I_11, I_12, I_13;
   //PIPS generated variable
   short *P_2;
   ma3 = FIFO3;
   ma2 = FIFO2;
   ma1 = FIFO1;
   ma0 = FIFO0;
l99996:   ;
   re2 = 1;
   while (re2<=N0) {
      I_2 = re2+1;
      I_3 = I_2-1;
      P_0 = ma2+I_3;
      I_4 = ma0[3]**P_0;
      I_5 = re2+1;
      I_6 = I_5-1;
      P_1 = ma3+I_6;
      I_7 = ma0[4]**P_1;
      I_8 = I_4+I_7;
      I_9 = ma0[0]/ma0[1];
      I_10 = I_9<<ma0[2];
      I_11 = I_8*I_10;
      I_12 = re2+1;
      I_13 = I_12-1;
      P_2 = ma1+I_13;
      *P_2 = I_11>>ma0[2];
      re2 = 1+re2;
   }
}
void launcher_0_microcode(int N0, int *FIFO0, short *FIFO1, short *FIFO2, short *FIFO3)
{
   //PIPS generated variable
   unsigned int j;
   //PIPS generated variable
   char * re0, re1;
   //PIPS generated variable
   int *caillou0, *ma0;
   //PIPS generated variable
   short *result00, *ma1, *src000, *ma2, *src100, *ma3;
   //PIPS generated variable
   unsigned int re2, re3;
   //PIPS generated variable
   int *im4;
   //PIPS generated variable
   short *im5, *im6, *im7;
   //PIPS generated variable
   int I_2, I_3;
   //PIPS generated variable
   short *P_0;
   //PIPS generated variable
   int I_4, I_5, I_6;
   //PIPS generated variable
   short *P_1;
   //PIPS generated variable
   int I_7, I_8, I_9, I_10, I_11, I_12, I_13;
   //PIPS generated variable
   short *P_2;
   ma3 = FIFO3;
   ma2 = FIFO2;
   ma1 = FIFO1;
   ma0 = FIFO0;
l99996:   ;
   re2 = 1;
   while (re2<=N0) {
      I_2 = re2;
      I_2 = I_2+1;
      I_3 = I_2;
      I_3 = I_3-1;
      P_0 = ma2;
      P_0 = P_0+I_3;
      I_4 = ma0[3];
      I_4 = I_4**P_0;
      I_5 = re2;
      I_5 = I_5+1;
      I_6 = I_5;
      I_6 = I_6-1;
      P_1 = ma3;
      P_1 = P_1+I_6;
      I_7 = ma0[4];
      I_7 = I_7**P_1;
      I_8 = I_4;
      I_8 = I_8+I_7;
      I_9 = ma0[0];
      I_9 = I_9/ma0[1];
      I_10 = I_9;
      I_10 = I_10<<ma0[2];
      I_11 = I_8;
      I_11 = I_11*I_10;
      I_12 = re2;
      I_12 = I_12+1;
      I_13 = I_12;
      I_13 = I_13-1;
      P_2 = ma1;
      P_2 = P_2+I_13;
      *P_2 = I_11;
      *P_2 = *P_2>>ma0[2];
      re2 = 1;
      re2 = re2+re2;
   }
}
void launcher_0_microcode(int N0, int *FIFO0, short *FIFO1, short *FIFO2, short *FIFO3)
{
   //PIPS generated variable
   int *ma0;
   //PIPS generated variable
   short *ma1, *ma2, *ma3;
   //PIPS generated variable
   unsigned int re2;
   //PIPS generated variable
   int I_2, I_3;
   //PIPS generated variable
   short *P_0;
   //PIPS generated variable
   int I_4, I_5, I_6;
   //PIPS generated variable
   short *P_1;
   //PIPS generated variable
   int I_7, I_8, I_9, I_10, I_11, I_12, I_13;
   //PIPS generated variable
   short *P_2;
   seti(ma3, FIFO3);
   seti(ma2, FIFO2);
   seti(ma1, FIFO1);
   seti(ma0, FIFO0);
l99996:   ;
   seti(re2, 1);
   while (re2<=N0) {
      seti(I_2, re2);
      addi(I_2, 1);
      seti(I_3, I_2);
      subi(I_3, 1);
      seti(P_0, ma2);
      paddi(P_0, I_3);
      seti(I_4, ma0[3]);
      mulri(I_4, P_0);
      seti(I_5, re2);
      addi(I_5, 1);
      seti(I_6, I_5);
      subi(I_6, 1);
      seti(P_1, ma3);
      paddi(P_1, I_6);
      seti(I_7, ma0[4]);
      mulri(I_7, P_1);
      seti(I_8, I_4);
      paddi(I_8, I_7);
      seti(I_9, ma0[0]);
      I_9 = I_9/ma0[1];
      seti(I_10, I_9);
      lshifti(I_10, ma0[2]);
      seti(I_11, I_8);
      muli(I_11, I_10);
      seti(I_12, re2);
      addi(I_12, 1);
      seti(I_13, I_12);
      subi(I_13, 1);
      seti(P_2, ma1);
      paddi(P_2, I_13);
      pseti(P_2, I_11);
      prshifti(P_2, ma0[2]);
      seti(re2, 1);
      addi(re2, re2);
   }
}
