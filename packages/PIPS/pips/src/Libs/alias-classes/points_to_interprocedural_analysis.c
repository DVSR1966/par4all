#include <stdlib.h>
#include <stdio.h>
/* For strdup: */
#define _GNU_SOURCE
#include <string.h>

#include "genC.h"
#include "linear.h"
#include "ri.h"
#include "effects.h"
#include "database.h"
#include "ri-util.h"
#include "effects-util.h"
#include "constants.h"
#include "misc.h"
#include "parser_private.h"
#include "top-level.h"
#include "text-util.h"
#include "text.h"
#include "properties.h"
#include "effects-generic.h"
#include "effects-simple.h"
#include "effects-convex.h"
#include "pipsdbm.h"
#include "resources.h"
#include "newgen_set.h"
#include "points_to_private.h"
#include "alias-classes.h"
/* Points-to interprocedural analysis is inspired by the work of Wilson[95]. The documentation 
   of this phase is a chapter of Amira Mensi thesis. */



/*  Foreach real argument r and its corresponding formal one f  create the assignment f = r
    then compute points-to set s generated by the assignment.
    The result is the union of pt_caller and s
*/
set pt_binded(entity called_func, list real_args, set pt_caller)
{ 
  set s = set_generic_make(set_private, points_to_equal_p,
			   points_to_rank);
  set pt_binded = set_generic_make(set_private, points_to_equal_p,
				   points_to_rank);

  cons *pc;
  int ipc;
  s = set_assign(s, pt_caller);
  for (ipc = 1, pc = real_args; pc != NIL; pc = CDR(pc), ipc++) {
    expression rhs = EXPRESSION(CAR(pc));
    entity pf = find_ith_parameter(called_func, ipc);
    expression lhs = entity_to_expression(pf);
    statement stmt = make_assign_statement(lhs, rhs);
    s = set_assign(s, points_to_assignment(stmt, lhs, rhs, s));	
  }

  SET_FOREACH(points_to, pt, s) {
    reference r = cell_any_reference(points_to_sink(pt));
    entity e = reference_variable(r);
    if(entity_stub_sink_p(e))
      s = set_del_element(s,s,(void*)pt);
  }
  pt_binded = set_union(pt_binded, s, pt_caller);
  return pt_binded;
}


/* Filter out written effects on pointers */
list written_pointers(list eff) {
  list written_l = NIL;
  list wr_eff = effects_write_effects(eff);
  FOREACH(effect, ef, wr_eff) {
    if(effect_pointer_type_p(ef)){
      cell c = effect_cell(ef);
      written_l = gen_nconc(CONS(CELL, c, NIL), written_l);
    }
  }

  return written_l; 

}



/* Translate each element of E into the caller's scope */
list caller_addresses(cell c, list args, set pt_in, set pt_binded)
{
  
  cell c_f = formal_access_paths(c, args, pt_in);
  list a_p = actual_access_paths(c_f, pt_binded);
  return a_p;
}


/* For each stub cell e  find its formal corresponding parameter and add to it a dereferencing dimension */
cell formal_access_paths(cell e, list args, set pt_in)
{
  cell f_a = cell_undefined;
  bool find_p = false;
  SET_FOREACH(points_to, pt, pt_in) {
    FOREACH(CELL, c, args) {
      if(cell_equal_p(c, points_to_source(pt)) && cell_equal_p(e, points_to_sink(pt)))
	{
	  find_p = true;
	  f_a = add_array_dimension(c);
	}
    }
    if(!find_p && cell_equal_p(e, points_to_sink(pt)))
      {
	cell new_e = points_to_source(pt);
	cell c  = formal_access_paths(new_e, args, pt_in);
	f_a = add_array_dimension(c);
      }
    }

  
  if(cell_undefined_p(f_a)) 
    pips_user_error("Formal acces paths undefined \n");

  return f_a;
}

/* Evalute c using points-to relation already computed */ 
list actual_access_paths(cell c, set pt_binded)
{
  bool exact_p = false;
  set_methods_for_proper_simple_effects();
  list l_in = set_to_sorted_list(pt_binded,
				 (int(*)(const void*, const void*))
				 points_to_compare_location);
  list l = eval_cell_with_points_to(c, l_in, &exact_p);
  generic_effects_reset_all_methods();
  return l;
}


/* Translate the out set into the scope of the caller */ 
set pt_kill(list written, set pt_caller, list args, set pt_in, set pt_binded)
{
  set kill = set_generic_make(set_private,
			     points_to_equal_p,points_to_rank);
  list written_cs = NIL, tmp = NIL;
  /* Translate written cells at the level of the call site */
  FOREACH(CELL, c, written) {
    reference r1 = cell_any_reference(c);
    list ind1 = reference_indices(r1);
    reference_indices_(r1) = NIL;
    tmp = caller_addresses(c, args, pt_in, pt_binded);
    FOREACH(CELL, cel, tmp) {
      r1 = cell_any_reference(cel);
      reference_indices_(r1) = gen_nconc(ind1, NIL);
      cel = make_cell_reference(r1);
      written_cs = gen_nconc(CONS(CELL, cel, NIL), written_cs);
    }
  }

  FOREACH(CELL, c, written_cs) {
    SET_FOREACH(points_to, pt, pt_caller) {
      if(cell_equal_p(c, points_to_source(pt)))
	set_add_element(kill, kill, (void*)pt);
    }
  }
  return kill;
}



set pt_gen(list args, set pt_out, set pt_in, set pt_binded)
{
  set gen = set_generic_make(set_private,
 			     points_to_equal_p,points_to_rank);
  list addr_l1 = NIL;  list addr_l2 = NIL, new_addr_l1 = NIL, new_addr_l2 = NIL ;

  SET_FOREACH(points_to, pt, pt_out) {
    reference r1 = cell_any_reference(points_to_source(pt));
    list ind1 = reference_indices(r1);
    reference r2 = cell_any_reference(points_to_sink(pt));
    entity e1 = reference_variable(r1);
    entity e2 = reference_variable(r2);
    bool stub_p1 = entity_stub_sink_p(e1);
    bool stub_p2 = entity_stub_sink_p(e2);
    if(stub_p1) {
      reference_indices_(r1) = NIL;
      cell e = make_cell_reference(r1);
      addr_l1 = caller_addresses(e, args, pt_in, pt_binded);
      FOREACH(CELL, c, addr_l1) {
	reference nr = cell_any_reference(c);
	reference_indices_(nr) = gen_nconc(ind1, NIL);
	c = make_cell_reference(nr);
	new_addr_l1 = gen_nconc(CONS(CELL, c, NIL), new_addr_l1);	
      }      
    }
    
    if(stub_p2) {
      reference_indices_(r2) = NIL;
      cell e = make_cell_reference(r2);
      addr_l2 = caller_addresses(e, args, pt_in, pt_binded);
      FOREACH(CELL, c, addr_l1) {
	reference nr = cell_any_reference(c);
	reference_indices_(nr) = gen_nconc(ind1, NIL);
	c = make_cell_reference(nr);
	new_addr_l2 = gen_nconc(CONS(CELL, c, NIL), new_addr_l2);	
      }    
    }
    
    if( (!stub_p1 && !stub_p2 ) || 
	(ENDP(new_addr_l1) && ENDP(new_addr_l2)) )
      set_add_element(gen, gen, (void*)pt);
    if(!ENDP(new_addr_l1)) {
      FOREACH(CELL, c_source, addr_l1) {
	if(ENDP(new_addr_l2)) {
	  points_to  new_pt = make_points_to(c_source, points_to_sink(pt), points_to_approximation(pt), make_descriptor_none());
	  set_add_element(gen, gen, (void*)new_pt);
	}
	else {
	  FOREACH(CELL, c_sink, addr_l2) {
	    points_to new_pt = make_points_to(c_source, c_sink, points_to_approximation(pt), make_descriptor_none());
	    set_add_element(gen, gen, (void*)new_pt);
	  }
	}
      }
    }
  }
  return gen;  
}



/* /\* computing the points-to of a call, user_functions not yet implemented. *\/ */
/* set points_to_call(statement s, call c, set pt_in, bool store __attribute__ ((__unused__))) { */
/*   entity e = call_function(c); */
/*   cons* pc = call_arguments(c); */
/*   tag tt; */
/*   set pt_out = set_generic_make(set_private, points_to_equal_p, */
/*                                 points_to_rank); */

/*   set pt_in_callee = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */
/*  set pt_out_callee = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */
/*   set pts_binded = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */

/*   set pt_written = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */
/*   set pts_gen = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */
/*  set pts_kill = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */

/*  set pt_end = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */
/*  set tmp = set_generic_make(set_private, points_to_equal_p, */
/*   				points_to_rank); */

/*   pt_in = points_to_init(s, pt_in); */
/*   switch (tt = value_tag(entity_initial(e))) { */
/*   case is_value_code:{ */
    
/*     /\* reset_current_module_entity(); *\/ */
/*     /\* call to an external function; preliminary version*\/ */
/*     pips_user_warning("The function call to \"%s\" is ignored\n" */
/*                       "On going implementation...\n", entity_user_name(e)); */
/*     set_assign(pt_out, pt_in); */
    
    
/*     set_current_module_entity(e); */
/*     const char* module_name = entity_module_name(e); */
/*     type t = entity_type(e); */
/*     if(type_functional_p(t)){ */
/*       list dl = code_declarations(value_code(entity_initial(e))); */
/*       FOREACH(ENTITY, fp, dl) { */
/*     	if(formal_parameter_p(fp)) { */
/*     	  reference r = make_reference(fp, NIL); */
/*     	  cell c = make_cell_reference(r); */
/*     	  formal_param = gen_nconc(CONS(CELL, c, NULL), formal_param); */
/*     	} */
/*       } */
/*     } */
/*     l_effect =  load_summary_effects(e); */
/*     points_to_list pts_to_in = (points_to_list) */
/*       db_get_memory_resource(DBR_POINTS_TO_IN, module_local_name(e), true); */
/*     points_to_list pts_to_out = (points_to_list) */
/*       db_get_memory_resource(DBR_POINTS_TO_OUT, module_local_name(e), true); */
/*     list l_pt_to_in = gen_full_copy_list(points_to_list_list(pts_to_in)); */
/*     pt_in_callee = set_assign_list(pt_in_callee, l_pt_to_in); */
/*     list l_pt_to_out = gen_full_copy_list(points_to_list_list(pts_to_out)); */
/*     pt_out_callee = set_assign_list(pt_out_callee, l_pt_to_out); */
/*     list effs = written_pointers(l_effect); */
/*     pts_binded = pt_binded(e,pc , pt_in); */
/*     print_points_to_set("pt_binded", pts_binded); */
/*     pts_kill = pt_kill(effs, pt_in, formal_param, pt_in_callee, pts_binded); */
/*     print_points_to_set("pt_kill", pts_kill); */
/*     pts_gen = pt_gen(formal_param, pt_out_callee, pt_in_callee, pts_binded); */
/*     print_points_to_set("pt_gen", pts_gen); */
/*     tmp = set_difference(tmp,pt_in_callee, pts_kill); */
/*     pt_end = set_union(pt_end, tmp, pts_gen); */
/*     print_points_to_set("pt_end =",pt_end); */
/*   } */
/*     break; */
/*   case is_value_symbolic:{ */
/*     SET_FOREACH(points_to, pt, pt_in) { */
/*       pt_out = set_add_element(pt_out, pt_out, (void*)pt); */
/*     } */
/*   } */
/*     break; */
/*   case is_value_constant:{ */
/*     SET_FOREACH(points_to, pt, pt_in) { */
/*       pt_out = set_add_element(pt_out, pt_out, (void*)pt); */
/*     } */
/*   } */
/*     /\* pt_out = set_assign(pt_out, pt_in); *\/ */
/*     break; */
/*   case is_value_unknown: */
/*     pips_internal_error("function %s has an unknown value\n", */
/*                         entity_name(e)); */
/*     break; */
/*   case is_value_intrinsic: { */
/*     set_methods_for_proper_simple_effects(); */
/*     list el = call_to_proper_effects(c); */
/*     generic_effects_reset_all_methods(); */
/*     pips_debug(5, "intrinsic function %s\n", entity_name(e)); */
/*     pt_out = points_to_intrinsic(s, c, e, pc, pt_in, el); */
/*   } */
/*     break; */
/*   default: */
/*     pips_internal_error("unknown tag %d\n", tt); */
/*     break; */
/*   } */

/*   return pt_out; */
/* } */



bool interprocedural_points_to_analysis(char * module_name)
{
  /* list pt_list = NIL; */
  /* set pts_to_set = set_generic_make(set_private, */
  /* 				    points_to_equal_p,points_to_rank); */

  set_current_module_entity(module_name_to_entity(module_name));
  //entity module = get_current_module_entity();

  //type t = entity_type(module);

  debug_on("POINTS_TO_DEBUG_LEVEL");

  pips_debug(1, "considering module %s\n", module_name);

  

  /* DB_PUT_MEMORY_RESOURCE */
  /*   (DBR_INIT_POINTS_TO_LIST, module_name, init_pts_to_list); */

  reset_current_module_entity();
  debug_off();

  bool good_result_p = true;
  return (good_result_p);
}
