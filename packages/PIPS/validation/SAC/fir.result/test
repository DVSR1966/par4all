
Initial code

void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   for(i = 0; i <= n-ksize+1-1; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= ksize-1; j += 1)
         out[i] += in[i+j]*kernel[j];
   }
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   for(i = 0; i <= n-ksize+1-1; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= ksize-1; j += 1)
         out[i] = out[i]+in[i+j]*kernel[j];
   }
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   for(i = 0; i <= n-ksize+1-1; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= ksize-1; j += 1)
         out[i] = out[i]+in[i+j]*kernel[j];
   }
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   for(i = 0; i <= n-ksize+1-1; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= ksize-1; j += 1)
         out[i] = out[i]+in[i+j]*kernel[j];
   }
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   //PIPS generated variable
   float F_0;
   for(i = 0; i <= n-ksize; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= ksize-1; j += 1) {
         F_0 = in[i+j]*kernel[j];
         out[i] = out[i]+F_0;
      }
   }
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   //PIPS generated variable
   float F_0;
   for(i = 0; i <= n-ksize; i += 1) {
      out[i] = 0.0;
      for(j = 0; j <= 4*(ksize/4)-1; j += 4) {
         F_0 = in[i+j]*kernel[j];
         out[i] = out[i]+F_0;
         F_0 = in[i+j+1]*kernel[j+1];
         out[i] = out[i]+F_0;
         F_0 = in[i+j+2]*kernel[j+2];
         out[i] = out[i]+F_0;
         F_0 = in[i+j+3]*kernel[j+3];
         out[i] = out[i]+F_0;
      }
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i+j]*kernel[j];
         out[i] = out[i]+F_0;
      }
   }
   ;
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t i, j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1];
   for(i = 0; i <= n-ksize; i += 1) {
      out[i] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      for(j = 0; j <= 4*(ksize/4)-1; j += 4) {
         F_0 = in[i+j]*kernel[j];
         RED0[0] = RED0[0]+F_0;
         F_0 = in[i+j+1]*kernel[j+1];
         RED0[1] = RED0[1]+F_0;
         F_0 = in[i+j+2]*kernel[j+2];
         RED0[2] = RED0[2]+F_0;
         F_0 = in[i+j+3]*kernel[j+3];
         RED0[3] = RED0[3]+F_0;
      }
      out[i] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i] = RED1[0]+out[i];
   }
   ;
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1], F_00, F_01, F_02, F_03;
   //PIPS generated variable
   size_t i0, j0;
   for(i0 = 0; i0 <= n-ksize; i0 += 1) {
      out[i0] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      for(j0 = 0; j0 <= 4*(ksize/4)-1; j0 += 4) {
         F_00 = in[i0+j0]*kernel[j0];
         RED0[0] = RED0[0]+F_00;
         F_01 = in[i0+j0+1]*kernel[j0+1];
         RED0[1] = RED0[1]+F_01;
         F_02 = in[i0+j0+2]*kernel[j0+2];
         RED0[2] = RED0[2]+F_02;
         F_03 = in[i0+j0+3]*kernel[j0+3];
         RED0[3] = RED0[3]+F_03;
      }
      out[i0] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i0];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i0+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i0] = RED1[0]+out[i0];
   }
   ;
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1], F_00, F_01, F_02, F_03;
   //PIPS generated variable
   size_t i0, j0;
   //SAC generated temporary array
   a4sf pdata0 = {0, 0, 0, 0};
   for(i0 = 0; i0 <= n-ksize; i0 += 1) {
      out[i0] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      for(j0 = 0; j0 <= 4*(ksize/4)-1; j0 += 4) {
         //PIPS:SAC generated v4sf vector(s)
         v4sf vec00, vec10, vec20, vec30, vec40;
         SIMD_LOAD_V4SF(vec20, &kernel[j0]);
         SIMD_LOAD_V4SF(vec10, &in[i0+j0]);
         SIMD_MULPS(vec00, vec10, vec20);
         SIMD_STORE_V4SF(vec00, &pdata0[0]);
         SIMD_LOAD_V4SF(vec30, &RED0[0]);
         SIMD_ADDPS(vec30, vec30, vec00);
         SIMD_STORE_V4SF(vec30, &RED0[0]);
      }
      out[i0] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i0];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i0+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i0] = RED1[0]+out[i0];
   }
   ;
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1], F_00, F_01, F_02, F_03;
   //PIPS generated variable
   size_t i0, j0;
   //SAC generated temporary array
   a4sf pdata0 = {0, 0, 0, 0};
   for(i0 = 0; i0 <= n-ksize; i0 += 1) {
      out[i0] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      {
         //PIPS:SAC generated v4sf vector(s)
         v4sf vec00, vec30;
         SIMD_LOAD_V4SF(vec30, &RED0[0]);
         for(j0 = 0; j0 <= 4*(ksize/4)-1; j0 += 4) {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec10, vec20, vec40;
            SIMD_LOAD_V4SF(vec20, &kernel[j0]);
            SIMD_LOAD_V4SF(vec10, &in[i0+j0]);
            SIMD_MULPS(vec00, vec10, vec20);
            SIMD_ADDPS(vec30, vec30, vec00);
         }
         SIMD_STORE_V4SF(vec00, &pdata0[0]);
         SIMD_STORE_V4SF(vec30, &RED0[0]);
      }
      out[i0] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i0];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i0+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i0] = RED1[0]+out[i0];
   }
   ;
}
void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1];
   //PIPS generated variable
   size_t i0, j0;
   for(i0 = 0; i0 <= n-ksize; i0 += 1) {
      out[i0] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      {
         //PIPS:SAC generated v4sf vector(s)
         v4sf vec00, vec30;
         SIMD_LOAD_V4SF(vec30, &RED0[0]);
         for(j0 = 0; j0 <= 4*(ksize/4)-1; j0 += 4) {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec10, vec20, vec40;
            SIMD_LOAD_V4SF(vec20, &kernel[j0]);
            SIMD_LOAD_V4SF(vec10, &in[i0+j0]);
            SIMD_MULPS(vec00, vec10, vec20);
            SIMD_ADDPS(vec30, vec30, vec00);
         }
         SIMD_STORE_V4SF(vec30, &RED0[0]);
      }
      out[i0] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i0];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i0+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i0] = RED1[0]+out[i0];
   }
   ;
}

simdized code

void FIRFilter(size_t n, float in[n], float out[n], float kernel[n], size_t ksize)
{
   size_t j;
   //PIPS generated variable
   float F_0, RED0[4], RED1[1];
   //PIPS generated variable
   size_t i0, j0;
   for(i0 = 0; i0 <= n-ksize; i0 += 1) {
      out[i0] = 0.0;
      RED0[0] = 0.000000;
      RED0[1] = 0.000000;
      RED0[2] = 0.000000;
      RED0[3] = 0.000000;
      {
         //PIPS:SAC generated v4sf vector(s)
         v4sf vec00, vec30;
         SIMD_LOAD_V4SF(vec30, &RED0[0]);
         for(j0 = 0; j0 <= 4*(ksize/4)-1; j0 += 4) {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec10, vec20, vec40;
            SIMD_LOAD_V4SF(vec20, &kernel[j0]);
            SIMD_LOAD_V4SF(vec10, &in[i0+j0]);
            SIMD_MULPS(vec00, vec10, vec20);
            SIMD_ADDPS(vec30, vec30, vec00);
         }
         SIMD_STORE_V4SF(vec30, &RED0[0]);
      }
      out[i0] = RED0[3]+RED0[2]+RED0[1]+RED0[0]+out[i0];
      RED1[0] = 0.000000;
      for(j = 4*(ksize/4); j <= ksize-1; j += 1) {
         F_0 = in[i0+j]*kernel[j];
         RED1[0] = RED1[0]+F_0;
      }
      out[i0] = RED1[0]+out[i0];
   }
   ;
}
