
Initial code

int main()
{
   float image[512][512];
   float new_image[512][512];
   float kernel[3][3];

   int i, j, n;

   for(i = 0; i <= 2; i += 1)
      for(j = 0; j <= 2; j += 1)
         kernel[i][j] = 1;
   
   //     read *, image
   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         image[i][j] = 1.;
   
   
   for(n = 0; n <= 19; n += 1)

      convol(512, 512, new_image, image, kernel);

   for(i = 0; i <= 511; i += 1)
      for(j = 0; j <= 511; j += 1)
         printf("%f ", new_image[i][j]);
   //     print *, new_image
   //      print *, new_image (image_size/2, image_size/2)
   
   return 1;
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l400:
   for(i = 3/2; i <= isi-3/2-1; i += 1)
l300:
      for(j = 3/2; j <= isj-3/2-1; j += 1) {
         new_image[i][j] = 0.;
l200:
         for(ki = 0; ki <= 2; ki += 1)
l100:
            for(kj = 0; kj <= 2; kj += 1)
               
               
               new_image[i][j] = new_image[i][j]+image[i+ki-3/2][j+kj-3/2]*kernel[ki][kj];
         new_image[i][j] = new_image[i][j]/(3*3);
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

   for(i = 0; i <= isi-1; i += 1)
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

   for(i = 1; i <= isi-2; i += 1)
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i][j] = 0.;
         for(ki = 0; ki <= 2; ki += 1)
            for(kj = 0; kj <= 2; kj += 1)
               
               
               new_image[i][j] = new_image[i][j]+image[i+ki-1][j+kj-1]*kernel[ki][kj];
         new_image[i][j] = new_image[i][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;

l99998:
   for(i = 0; i <= isi-1; i += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l99994:
   for(i = 1; i <= isi-2; i += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i][j] = 0.;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
l99997:            ;
            new_image[i][j] = new_image[i][j]+image[i+ki-1][j-1]*kernel[ki][0];
            new_image[i][j] = new_image[i][j]+image[i+ki-1][j]*kernel[ki][1];
            new_image[i][j] = new_image[i][j]+image[i+ki-1][j+1]*kernel[ki][2];
            kj = 3;
         }
         new_image[i][j] = new_image[i][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;
   //PIPS generated variable
   float RED0[3];

l99998:
   for(i = 0; i <= isi-1; i += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l99994:
   for(i = 1; i <= isi-2; i += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
l99997:            ;
            RED0[0] = RED0[0]+image[i+ki-1][j-1]*kernel[ki][0];
            RED0[1] = RED0[1]+image[i+ki-1][j]*kernel[ki][1];
            RED0[2] = RED0[2]+image[i+ki-1][j+1]*kernel[ki][2];
            kj = 3;
         }
         new_image[i][j] = RED0[2]+RED0[1]+RED0[0]+new_image[i][j];
         new_image[i][j] = new_image[i][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int i, j, ki, kj;
   //PIPS generated variable
   float RED0[3], F_0, F_1, F_2, F_3, F_4;

l99998:
   for(i = 0; i <= isi-1; i += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i][j] = image[i][j];

l99994:
   for(i = 1; i <= isi-2; i += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
l99997:            ;
            F_0 = image[i+ki-1][j-1]*kernel[ki][0];
            RED0[0] = RED0[0]+F_0;
            F_1 = image[i+ki-1][j]*kernel[ki][1];
            RED0[1] = RED0[1]+F_1;
            F_2 = image[i+ki-1][j+1]*kernel[ki][2];
            RED0[2] = RED0[2]+F_2;
            kj = 3;
         }
         F_3 = RED0[0]+new_image[i][j];
         F_4 = RED0[1]+F_3;
         new_image[i][j] = RED0[2]+F_4;
         new_image[i][j] = new_image[i][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int j, ki, kj;
   //PIPS generated variable
   float RED0[3], F_0, F_1, F_2, F_3, F_4;
   //PIPS generated variable
   int i0, i1;

l99998:
   for(i0 = 0; i0 <= isi-1; i0 += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i0][j] = image[i0][j];

l99994:
   for(i1 = 1; i1 <= isi-2; i1 += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i1][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
l99997:            ;
            F_0 = image[i1+ki-1][j-1]*kernel[ki][0];
            RED0[0] = RED0[0]+F_0;
            F_1 = image[i1+ki-1][j]*kernel[ki][1];
            RED0[1] = RED0[1]+F_1;
            F_2 = image[i1+ki-1][j+1]*kernel[ki][2];
            RED0[2] = RED0[2]+F_2;
            kj = 3;
         }
         F_3 = RED0[0]+new_image[i1][j];
         F_4 = RED0[1]+F_3;
         new_image[i1][j] = RED0[2]+F_4;
         new_image[i1][j] = new_image[i1][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int j, ki, kj;
   //PIPS generated variable
   float RED0[3], F_0, F_1, F_2, F_3, F_4;
   //PIPS generated variable
   int i0, i1;
   //PIPS:SAC generated variable
   overloaded PADDING_VALUE;
   //SAC generated temporary array
   a4sf pdata0 = {0, 0, 0, 0};

l99998:
   for(i0 = 0; i0 <= isi-1; i0 += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i0][j] = image[i0][j];

l99994:
   for(i1 = 1; i1 <= isi-2; i1 += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i1][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec00, vec10, vec20, vec30, vec40;
l99997:            ;
            SIMD_LOAD_V4SF(vec20, &kernel[ki][0]);
            SIMD_LOAD_V4SF(vec10, &image[i1+ki-1][j-1]);
            SIMD_MULPS(vec00, vec10, vec20);
            SIMD_STORE_V4SF(vec00, &pdata0[0]);
            kj = 3;
            SIMD_LOAD_V4SF(vec30, &RED0[0]);
            SIMD_ADDPS(vec30, vec30, vec00);
            SIMD_STORE_MASKED_V4SF(vec30, &RED0[0]);
         }
         F_3 = RED0[0]+new_image[i1][j];
         F_4 = RED0[1]+F_3;
         new_image[i1][j] = RED0[2]+F_4;
         new_image[i1][j] = new_image[i1][j]/9;
      }
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int j, ki, kj;
   //PIPS generated variable
   float RED0[3], F_0, F_1, F_2, F_3, F_4;
   //PIPS generated variable
   int i0, i1;
   //PIPS:SAC generated variable
   overloaded PADDING_VALUE;
   //SAC generated temporary array
   a4sf pdata0 = {0, 0, 0, 0};
   //PIPS generated variable
   v4sf vec00_0, vec10_0, vec20_0, vec30_0, vec40_0;

l99998:
   for(i0 = 0; i0 <= isi-1; i0 += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i0][j] = image[i0][j];

l99994:
   for(i1 = 1; i1 <= isi-2; i1 += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i1][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
            //PIPS:SAC generated v4sf vector(s)
            SIMD_LOAD_V4SF(vec30_0, &RED0[0]);
            SIMD_LOAD_V4SF(vec10_0, &image[i1+ki-1][j-1]);
            SIMD_LOAD_V4SF(vec20_0, &kernel[ki][0]);
l99997:            ;
            SIMD_MULPS(vec00_0, vec10_0, vec20_0);
            kj = 3;
            SIMD_ADDPS(vec30_0, vec30_0, vec00_0);
            SIMD_STORE_MASKED_V4SF(vec30_0, &RED0[0]);
         }
         F_3 = RED0[0]+new_image[i1][j];
         F_4 = RED0[1]+F_3;
         new_image[i1][j] = RED0[2]+F_4;
         new_image[i1][j] = new_image[i1][j]/9;
      }
   SIMD_STORE_V4SF(vec00_0, &pdata0[0]);
}
void convol(int isi, int isj, float new_image[isi][isj], float image[isi][isj], float kernel[3][3])
{
   //     The convolution kernel is not applied on the outer part
   //     of the image
   
   int j, ki;
   //PIPS generated variable
   float RED0[3], F_3, F_4;
   //PIPS generated variable
   int i0, i1;
   //SAC generated temporary array
   a4sf pdata0 = {0, 0, 0, 0};
   //PIPS generated variable
   v4sf vec00_0, vec10_0, vec20_0, vec30_0;

l99998:
   for(i0 = 0; i0 <= isi-1; i0 += 1)
l99999:
      for(j = 0; j <= isj-1; j += 1)
         new_image[i0][j] = image[i0][j];

l99994:
   for(i1 = 1; i1 <= isi-2; i1 += 1)
l99995:
      for(j = 1; j <= isj-2; j += 1) {
         new_image[i1][j] = 0.;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         RED0[2] = 0.000000;
l99996:
         for(ki = 0; ki <= 2; ki += 1) {
            //PIPS:SAC generated v4sf vector(s)
            SIMD_LOAD_V4SF(vec30_0, &RED0[0]);
            SIMD_LOAD_V4SF(vec10_0, &image[i1+ki-1][j-1]);
            SIMD_LOAD_V4SF(vec20_0, &kernel[ki][0]);
l99997:            ;
            SIMD_MULPS(vec00_0, vec10_0, vec20_0);
            3;
            SIMD_ADDPS(vec30_0, vec30_0, vec00_0);
            SIMD_STORE_MASKED_V4SF(vec30_0, &RED0[0]);
         }
         F_3 = RED0[0]+new_image[i1][j];
         F_4 = RED0[1]+F_3;
         new_image[i1][j] = RED0[2]+F_4;
         new_image[i1][j] = new_image[i1][j]/9;
      }
   SIMD_STORE_V4SF(vec00_0, &pdata0[0]);
}

simdized code

