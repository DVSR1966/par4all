void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1) {
            F_0 = ptrin[th][rg][v].re*ptrin[th][rg][v].re;
            F_1 = ptrin[th][rg][v].im*ptrin[th][rg][v].im;
            F_2 = F_0+F_1;

            PP = PP+F_2;
         }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_2 = F_0+F_1;

            PP = PP+F_2;
         }
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            PP = PP+F_2;
         }
      }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[1], RED1[4], RED2[2];



   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         RED0[0] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_2 = F_0+F_1;

            RED0[0] = RED0[0]+F_2;
         }
         RED2[0] = RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            RED1[0] = RED1[0]+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            RED1[1] = RED1[1]+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            RED1[2] = RED1[2]+F_2;
            //c SIMD_COMMENT_0
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            F_2 = F_0+F_1;
            //c SIMD_COMMENT_3

            RED1[3] = RED1[3]+F_2;
         }
         RED2[1] = RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP = RED2[1]+RED2[0]+PP;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[1], RED1[4], RED2[2], PP0, F_20, F_10, F_00, F_21, F_11, F_01, F_22, F_12, F_02, F_23, F_13, F_03, F_24, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            F_04 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_14 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_24 = F_04+F_14;

            RED0[0] = RED0[0]+F_24;
         }
         RED2[0] = RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            //c SIMD_COMMENT_0
            F_03 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            //c SIMD_COMMENT_1
            F_13 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            //c SIMD_COMMENT_2
            F_23 = F_03+F_13;
            //c SIMD_COMMENT_3

            RED1[0] = RED1[0]+F_23;
            //c SIMD_COMMENT_0
            F_02 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            //c SIMD_COMMENT_1
            F_12 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            //c SIMD_COMMENT_2
            F_22 = F_02+F_12;
            //c SIMD_COMMENT_3

            RED1[1] = RED1[1]+F_22;
            //c SIMD_COMMENT_0
            F_01 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            //c SIMD_COMMENT_1
            F_11 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            //c SIMD_COMMENT_2
            F_21 = F_01+F_11;
            //c SIMD_COMMENT_3

            RED1[2] = RED1[2]+F_21;
            //c SIMD_COMMENT_0
            F_00 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            //c SIMD_COMMENT_1
            F_10 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            //c SIMD_COMMENT_2
            F_20 = F_00+F_10;
            //c SIMD_COMMENT_3

            RED1[3] = RED1[3]+F_20;
         }
         RED2[1] = RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+RED2[0]+PP;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[1], RED1[4], RED2[2], PP0, F_20, F_10, F_00, F_21, F_11, F_01, F_22, F_12, F_02, F_23, F_13, F_03, F_24, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            F_24 = aligned[0]+aligned[1];

            RED0[0] = F_24+RED0[0];
         }
         RED2[0] = RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec2[4], v4sf_vec3[4];
            //SAC generated temporary array
            float aligned0[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec4[4], v4sf_vec5[4];
            //SAC generated temporary array
            float aligned1[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4], v4sf_vec7[4], v4sf_vec8[4];
            //SAC generated temporary array
            float aligned2[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec9[4], v4sf_vec10[4];
            SIMD_LOAD_V4SF(v4sf_vec3, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPS(v4sf_vec2, v4sf_vec3, v4sf_vec3);
            SIMD_SAVE_V4SF(v4sf_vec2, &aligned0[0]);
            SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][2+LU_IND0].re);
            SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
            SIMD_SAVE_V4SF(v4sf_vec4, &aligned1[0]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, aligned0[1], aligned0[3], aligned1[1], aligned1[3]);
            SIMD_LOAD_GENERIC_V4SF(v4sf_vec7, aligned0[0], aligned0[2], aligned1[0], aligned1[2]);
            SIMD_ADDPS(v4sf_vec6, v4sf_vec7, v4sf_vec8);
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned2[0]);
            SIMD_LOAD_V4SF(v4sf_vec9, &RED1[0]);
            SIMD_ADDPS(v4sf_vec9, v4sf_vec6, v4sf_vec9);
            SIMD_SAVE_V4SF(v4sf_vec9, &RED1[0]);
         }
         RED2[1] = RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[1], RED1[4], RED2[2], PP0, F_20, F_10, F_00, F_21, F_11, F_01, F_22, F_12, F_02, F_23, F_13, F_03, F_24, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            F_24 = aligned[0]+aligned[1];

            RED0[0] = F_24+RED0[0];
         }
         RED2[0] = RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec9[4];
            //SAC generated temporary array
            float aligned2[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4];
            SIMD_LOAD_V4SF(v4sf_vec9, &RED1[0]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated float vector(s)
               float v4sf_vec2[4], v4sf_vec3[4];
               //SAC generated temporary array
               float aligned0[4] = {0, 0, 0, 0};
               //PIPS:SAC generated float vector(s)
               float v4sf_vec4[4], v4sf_vec5[4];
               //SAC generated temporary array
               float aligned1[4] = {0, 0, 0, 0};
               //PIPS:SAC generated float vector(s)
               float v4sf_vec7[4], v4sf_vec8[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec10[4];
               SIMD_LOAD_V4SF(v4sf_vec3, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(v4sf_vec2, v4sf_vec3, v4sf_vec3);
               SIMD_SAVE_V4SF(v4sf_vec2, &aligned0[0]);
               SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
               SIMD_SAVE_V4SF(v4sf_vec4, &aligned1[0]);
               SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, aligned0[1], aligned0[3], aligned1[1], aligned1[3]);
               SIMD_LOAD_GENERIC_V4SF(v4sf_vec7, aligned0[0], aligned0[2], aligned1[0], aligned1[2]);
               SIMD_ADDPS(v4sf_vec6, v4sf_vec7, v4sf_vec8);
               SIMD_ADDPS(v4sf_vec9, v4sf_vec6, v4sf_vec9);
            }
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned2[0]);
            SIMD_SAVE_V4SF(v4sf_vec9, &RED1[0]);
         }
         RED2[1] = RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   int LU_IND0;
   //PIPS generated variable
   float RED0[1], RED1[4], RED2[2], PP0, F_24;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   
   
   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated double vector(s)
            double v2df_vec0[2], v2df_vec1[2];
            //SAC generated temporary array
            float aligned[2] = {0, 0};
            SIMD_LOAD_V2SF_TO_V2DF(v2df_vec1, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(v2df_vec0, v2df_vec1, v2df_vec1);
            SIMD_SAVE_V2SF_TO_V2DF(v2df_vec0, &aligned[0]);
            F_24 = aligned[0]+aligned[1];

            RED0[0] = F_24+RED0[0];
         }
         RED2[0] = RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         {
            //PIPS:SAC generated float vector(s)
            float v4sf_vec9[4];
            //SAC generated temporary array
            float aligned2[4] = {0, 0, 0, 0};
            //PIPS:SAC generated float vector(s)
            float v4sf_vec6[4];
            SIMD_LOAD_V4SF(v4sf_vec9, &RED1[0]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated float vector(s)
               float v4sf_vec2[4], v4sf_vec3[4];
               //SAC generated temporary array
               float aligned0[4] = {0, 0, 0, 0};
               //PIPS:SAC generated float vector(s)
               float v4sf_vec4[4], v4sf_vec5[4];
               //SAC generated temporary array
               float aligned1[4] = {0, 0, 0, 0};
               //PIPS:SAC generated float vector(s)
               float v4sf_vec7[4], v4sf_vec8[4];
               //PIPS:SAC generated float vector(s)
               float v4sf_vec10[4];
               SIMD_LOAD_V4SF(v4sf_vec3, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(v4sf_vec2, v4sf_vec3, v4sf_vec3);
               SIMD_SAVE_V4SF(v4sf_vec2, &aligned0[0]);
               SIMD_LOAD_V4SF(v4sf_vec5, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(v4sf_vec4, v4sf_vec5, v4sf_vec5);
               SIMD_SAVE_V4SF(v4sf_vec4, &aligned1[0]);
               SIMD_LOAD_GENERIC_V4SF(v4sf_vec8, aligned0[1], aligned0[3], aligned1[1], aligned1[3]);
               SIMD_LOAD_GENERIC_V4SF(v4sf_vec7, aligned0[0], aligned0[2], aligned1[0], aligned1[2]);
               SIMD_ADDPS(v4sf_vec6, v4sf_vec7, v4sf_vec8);
               SIMD_ADDPS(v4sf_vec9, v4sf_vec6, v4sf_vec9);
            }
            SIMD_SAVE_V4SF(v4sf_vec6, &aligned2[0]);
            SIMD_SAVE_V4SF(v4sf_vec9, &RED1[0]);
         }
         RED2[1] = RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP+RED2[0];
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
seq-ok
sse-ok

