void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)

            PP = PP+ptrin[th][rg][v].re*ptrin[th][rg][v].re+ptrin[th][rg][v].im*ptrin[th][rg][v].im;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, v, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1)
         for(v = 0; v <= Nv-1; v += 1) {
            F_0 = ptrin[th][rg][v].re*ptrin[th][rg][v].re;
            F_1 = ptrin[th][rg][v].im*ptrin[th][rg][v].im;
            F_2 = F_0+F_1;

            PP = PP+F_2;
         }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_2 = F_0+F_1;
            PP = PP+F_2;
         }
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            F_2 = F_0+F_1;
            PP = PP+F_2;
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            F_2 = F_0+F_1;
            PP = PP+F_2;
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            F_2 = F_0+F_1;
            PP = PP+F_2;
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            F_2 = F_0+F_1;
            PP = PP+F_2;
         }
      }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            PP = PP+F_1;
            PP = PP+F_0;
         }
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            PP = PP+F_1;
            PP = PP+F_0;
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            PP = PP+F_1;
            PP = PP+F_0;
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            PP = PP+F_1;
            PP = PP+F_0;
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            PP = PP+F_1;
            PP = PP+F_0;
         }
      }
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2];

   for(th = 0; th <= Nth-1; th += 1) {
      PP = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB0 = Nv;
         LU_IB0 = MOD(LU_NUB0, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB0-1; LU_IND0 += 1) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED0[0] = RED0[0]+F_1;
            RED0[1] = RED0[1]+F_0;
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB0; LU_IND0 <= LU_NUB0-1; LU_IND0 += 4) {
            F_0 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_1 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED1[0] = RED1[0]+F_1;
            RED1[1] = RED1[1]+F_0;
            F_0 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            F_1 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            RED1[2] = RED1[2]+F_1;
            RED1[3] = RED1[3]+F_0;
            F_0 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            F_1 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            RED1[4] = RED1[4]+F_1;
            RED1[5] = RED1[5]+F_0;
            F_0 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            F_1 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            RED1[6] = RED1[6]+F_1;
            RED1[7] = RED1[7]+F_0;
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP = RED2[1]+RED2[0]+PP;
      Pow[th].re = (float) (PP/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   //PIPS generated variable
   float PP1;

   for(th = 0; th <= Nth-1; th += 1) {
      PP1 = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         LU_IB00 = MOD(LU_NUB00, 4);
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            F_04 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_14 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED0[0] = RED0[0]+F_14;
            RED0[1] = RED0[1]+F_04;
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            F_03 = ptrin[th][rg][LU_IND0].re*ptrin[th][rg][LU_IND0].re;
            F_13 = ptrin[th][rg][LU_IND0].im*ptrin[th][rg][LU_IND0].im;
            RED1[0] = RED1[0]+F_13;
            RED1[1] = RED1[1]+F_03;
            F_02 = ptrin[th][rg][LU_IND0+1].re*ptrin[th][rg][LU_IND0+1].re;
            F_12 = ptrin[th][rg][LU_IND0+1].im*ptrin[th][rg][LU_IND0+1].im;
            RED1[2] = RED1[2]+F_12;
            RED1[3] = RED1[3]+F_02;
            F_01 = ptrin[th][rg][LU_IND0+2].re*ptrin[th][rg][LU_IND0+2].re;
            F_11 = ptrin[th][rg][LU_IND0+2].im*ptrin[th][rg][LU_IND0+2].im;
            RED1[4] = RED1[4]+F_11;
            RED1[5] = RED1[5]+F_01;
            F_00 = ptrin[th][rg][LU_IND0+3].re*ptrin[th][rg][LU_IND0+3].re;
            F_10 = ptrin[th][rg][LU_IND0+3].im*ptrin[th][rg][LU_IND0+3].im;
            RED1[6] = RED1[6]+F_10;
            RED1[7] = RED1[7]+F_00;
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+RED2[0]+PP1;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
      Pow[th].im = 0.;
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   //PIPS generated variable
   float PP1;
   //SAC generated temporary array
   a2sf pdata0 = {0, 0};
   //SAC generated temporary array
   a4sf pdata1 = {0, 0, 0, 0}, pdata2 = {0, 0, 0, 0};

   for(th = 0; th <= Nth-1; th += 1) {
      PP1 = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         LU_IB00 = MOD(LU_NUB00, 4);
         for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
            //PIPS:SAC generated v2df vector(s)
            v2df vec00, vec10, vec20, vec30;
            SIMD_LOAD_V2SF_TO_V2DF(vec10, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPD(vec00, vec10, vec10);
            SIMD_STORE_V2DF_TO_V2SF(vec00, &pdata0[0]);
            SIMD_LOAD_GENERIC_V2DF(vec20, RED0[1], RED0[0]);
            SIMD_ADDPD(vec20, vec00, vec20);
            SIMD_STORE_GENERIC_V2DF(vec20, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec40, vec50, vec60, vec70, vec80, vec90, vec100, vec110;
            SIMD_LOAD_V4SF(vec50, &ptrin[th][rg][LU_IND0].re);
            SIMD_MULPS(vec40, vec50, vec50);
            SIMD_STORE_V4SF(vec40, &pdata1[0]);
            SIMD_LOAD_V4SF(vec70, &ptrin[th][rg][2+LU_IND0].re);
            SIMD_MULPS(vec60, vec70, vec70);
            SIMD_STORE_V4SF(vec60, &pdata2[0]);
            SIMD_LOAD_GENERIC_V4SF(vec80, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_ADDPS(vec80, vec40, vec80);
            SIMD_STORE_GENERIC_V4SF(vec80, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(vec100, RED1[5], RED1[4], RED1[7], RED1[6]);
            SIMD_ADDPS(vec100, vec60, vec100);
            SIMD_STORE_GENERIC_V4SF(vec100, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP1+RED2[0];
      Pow[th].im = 0.;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{

   float PP;
   int th, rg;
   //PIPS generated variable
   float F_0, F_1, F_2;
   //PIPS generated variable
   int LU_NUB0, LU_IB0, LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0, F_10, F_00, F_11, F_01, F_12, F_02, F_13, F_03, F_14, F_04;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   //PIPS generated variable
   float PP1;
   //SAC generated temporary array
   a2sf pdata0 = {0, 0};
   //SAC generated temporary array
   a4sf pdata1 = {0, 0, 0, 0}, pdata2 = {0, 0, 0, 0};

   for(th = 0; th <= Nth-1; th += 1) {
      PP1 = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         LU_IB00 = MOD(LU_NUB00, 4);
         {
            //PIPS:SAC generated v2df vector(s)
            v2df vec00, vec20;
            SIMD_LOAD_GENERIC_V2DF(vec20, RED0[1], RED0[0]);
            for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
               //PIPS:SAC generated v2df vector(s)
               v2df vec10, vec30;
               SIMD_LOAD_V2SF_TO_V2DF(vec10, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPD(vec00, vec10, vec10);
               SIMD_ADDPD(vec20, vec00, vec20);
            }
            SIMD_STORE_V2DF_TO_V2SF(vec00, &pdata0[0]);
            SIMD_STORE_GENERIC_V2DF(vec20, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec40, vec60, vec80, vec100;
            SIMD_LOAD_GENERIC_V4SF(vec80, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(vec100, RED1[5], RED1[4], RED1[7], RED1[6]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated v4sf vector(s)
               v4sf vec50, vec70, vec90, vec110;
               SIMD_LOAD_V4SF(vec50, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(vec40, vec50, vec50);
               SIMD_LOAD_V4SF(vec70, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(vec60, vec70, vec70);
               SIMD_ADDPS(vec80, vec40, vec80);
               SIMD_ADDPS(vec100, vec60, vec100);
            }
            SIMD_STORE_V4SF(vec40, &pdata1[0]);
            SIMD_STORE_V4SF(vec60, &pdata2[0]);
            SIMD_STORE_GENERIC_V4SF(vec80, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_STORE_GENERIC_V4SF(vec100, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP1+RED2[0];
      Pow[th].im = 0.;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
   }
   ;
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], Cplfloat Pow[Nth])
{
   int th, rg;
   //PIPS generated variable
   int LU_IND0;
   //PIPS generated variable
   float RED0[2], RED1[8], RED2[2], PP0;
   //PIPS generated variable
   int LU_IB00, LU_NUB00;
   //PIPS generated variable
   float PP1;

   for(th = 0; th <= Nth-1; th += 1) {
      PP1 = 0.;
      RED2[0] = 0.000000;
      RED2[1] = 0.000000;
      for(rg = 0; rg <= Nrg-1; rg += 1) {
         LU_NUB00 = Nv;
         RED0[0] = 0.000000;
         RED0[1] = 0.000000;
         LU_IB00 = MOD(LU_NUB00, 4);
         {
            //PIPS:SAC generated v2df vector(s)
            v2df vec00, vec20;
            SIMD_LOAD_GENERIC_V2DF(vec20, RED0[1], RED0[0]);
            for(LU_IND0 = 0; LU_IND0 <= LU_IB00-1; LU_IND0 += 1) {
               //PIPS:SAC generated v2df vector(s)
               v2df vec10, vec30;
               SIMD_LOAD_V2SF_TO_V2DF(vec10, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPD(vec00, vec10, vec10);
               SIMD_ADDPD(vec20, vec00, vec20);
            }
            SIMD_STORE_GENERIC_V2DF(vec20, &RED0[1], &RED0[0]);
         }
         RED2[0] = RED0[1]+RED0[0]+RED2[0];
         RED1[0] = 0.000000;
         RED1[1] = 0.000000;
         RED1[2] = 0.000000;
         RED1[3] = 0.000000;
         RED1[4] = 0.000000;
         RED1[5] = 0.000000;
         RED1[6] = 0.000000;
         RED1[7] = 0.000000;
         {
            //PIPS:SAC generated v4sf vector(s)
            v4sf vec40, vec60, vec80, vec100;
            SIMD_LOAD_GENERIC_V4SF(vec80, RED1[1], RED1[0], RED1[3], RED1[2]);
            SIMD_LOAD_GENERIC_V4SF(vec100, RED1[5], RED1[4], RED1[7], RED1[6]);
            for(LU_IND0 = LU_IB00; LU_IND0 <= LU_NUB00-1; LU_IND0 += 4) {
               //PIPS:SAC generated v4sf vector(s)
               v4sf vec50, vec70, vec90, vec110;
               SIMD_LOAD_V4SF(vec50, &ptrin[th][rg][LU_IND0].re);
               SIMD_MULPS(vec40, vec50, vec50);
               SIMD_LOAD_V4SF(vec70, &ptrin[th][rg][2+LU_IND0].re);
               SIMD_MULPS(vec60, vec70, vec70);
               SIMD_ADDPS(vec80, vec40, vec80);
               SIMD_ADDPS(vec100, vec60, vec100);
            }
            SIMD_STORE_GENERIC_V4SF(vec80, &RED1[1], &RED1[0], &RED1[3], &RED1[2]);
            SIMD_STORE_GENERIC_V4SF(vec100, &RED1[5], &RED1[4], &RED1[7], &RED1[6]);
         }
         RED2[1] = RED1[7]+RED1[6]+RED1[5]+RED1[4]+RED1[3]+RED1[2]+RED1[1]+RED1[0]+RED2[1];
      }
      PP0 = RED2[1]+PP1+RED2[0];
      Pow[th].im = 0.;
      Pow[th].re = (float) (PP0/((float) (Nv*Nrg)));
   }
   ;
}
seq-ok
sse-ok

