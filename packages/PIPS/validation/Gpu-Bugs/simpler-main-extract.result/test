Select some options to deal with the C Language:
Parse as C:
Prettyprint the source as C, of course
Do not display original number lines as comment:
If possible, transform simple for-loops into do-loop à la Fortran, simpler to analyze:
Desugaring other for-loops into plain while-loops fot the time we improve semantics ameliorations in PIPS:
Select the most precise analysis:
Compute the intraprocedural preconditions at the same time as
transformers and use them to improve the accuracy of expression
and statement transformers:
Try to restructure the code for more precision:
int main()
{
   int i, d, j, c, h, u, n;
   //Local variables
   //Sending...	
   int symbole_flow_user1[64];
   int ovsf_code_user1[16] = {1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1};
   int ovsf_code_ref[16] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int spreading_signal_user1[16*64];
   int spreading_signals[16*64+16];

   int I_user[16/2*64+16/2];
   int Q_user[16/2*64+16/2];
   float Signal_I[(16/2*64+16/2)*4];
   float Signal_Q[(16/2*64+16/2)*4];
   float FIR_COEFF[64];
   float FIR2_I_user1[(16/2*64+16/2)*4];
   float FIR2_Q_user1[(16/2*64+16/2)*4];
   int inv_qpsk_user1[16*64+16];
   int symbole_flow[64];

   int count_loop = 0;
   int max = 0;
   
   /********************************************************************************/
   /*										*/
   /*										*/
   /********************************************************************************/
   while (count_loop<10) {
      int channel_delay1, channel_delay2, channel_delay3, channel_delay4;
      float alpha = (float) 0.22;

      float x_buffer_user1[64];
      int ptr_x_buffer_user1 = 0;
      int found_error = 0;
      int retro_loop_count = 0;
      int finger_mat[64][16];
      int coeff[16];
      int coeff2[16];
      //for the temporary coeff calculated before retroaction loop
      int finger[16];
      int fingers;

      count_loop++;
      
      
      //#ifdef DEBUG
estimation:      ;
#pragma omp parallel for 
      for(d = 0; d <= 1039; d += 1)
         ;
      //#endif
      
      
#pragma omp parallel for private(d,i,j)
      for(c = 0; c <= 63; c += 1) {
#pragma omp parallel for 
         for(i = 0; i <= 15; i += 1)
            finger_mat[c][i] = 0;
#pragma omp parallel for private(d)
         for(j = 0; j <= 15; j += 1)
            for(d = 0; d <= 15; d += 1)
               finger_mat[c][j] += inv_qpsk_user1[c*16+d+j]*ovsf_code_ref[d];
      }

      for(c = 0; c <= 63; c += 1)
         for(j = 0; j <= 15; j += 1) {
            if (finger_mat[c][j]>=0) 
               printf("%3d\t", finger_mat[c][j]);
            if (finger_mat[c][j]<0) 
               printf("%3d\t", finger_mat[c][j]);
         }
#pragma omp parallel for private(c)
      for(j = 0; j <= 15; j += 1) {
         coeff2[j] = 0;
         for(c = 0; c <= 63; c += 1)
            if (symbole_flow_user1[c]==0)
               coeff2[j] += finger_mat[c][j]*(-1);
            else
               coeff2[j] += finger_mat[c][j]*1;
      }
      
      //display the channel coefficients
#pragma omp parallel for 
      for(j = 0; j <= 15; j += 1)
         if (j<16-1)
            ;
      
      //calculating max power received
      max = 0;
      for(j = 0; j <= 15; j += 1)
         if (coeff2[j]>max) 
            max = coeff2[j];

//max=max*100/(SF*NB_SYMBOL*80);

      if (max>=16*64) {
      }
      else {
         goto l99999;
      }
      j = 0;
l99997:      ;
//retroaction
      if (!(j<16)) goto break_13;
      if (retro_loop_count>16) goto break_13;
      if (coeff2[j]>=max) goto l99998;
      j++;
      goto l99997;
l99998:      ;
      coeff[j]++;
#pragma omp parallel for private(d)
      for(c = 0; c <= 63; c += 1)
#pragma omp parallel for 
         for(d = 0; d <= 15; d += 1)
            if (symbole_flow_user1[c]==1)
               inv_qpsk_user1[c*16+d+j] -= ovsf_code_ref[d];
            else
               inv_qpsk_user1[c*16+d+j] += ovsf_code_ref[d];

      retro_loop_count++;
      goto estimation;
break_13:      ;
l99999:      ;
   }
   return 0;
}
void P4A_accel_free(void *address)
{
   free(address);
}
void P4A_accel_malloc(void **address, size_t size)
{
   *address = malloc(size);
}
void P4A_copy_from_accel(size_t element_size, void *host_address, const void *accel_address)
{
   size_t i;
   char *cdest = host_address;
   const char *csrc = accel_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, const void *accel_address)
{
   size_t i;
   char *cdest = d1_offset*element_size+(char *) host_address;
   const char *csrc = accel_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, const void *accel_address)
{
   size_t i, j;
   char *cdest = d2_offset*element_size+(char *) host_address;
   char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)
         cdest[(i+d1_offset)*element_size*d2_size+j] = csrc[i*element_size*d2_block_size+j];
}
void P4A_copy_from_accel_3d(size_t element_size, size_t d1_size, size_t d2_size, size_t d3_size, size_t d1_block_size, size_t d2_block_size, size_t d3_block_size, size_t d1_offset, size_t d2_offset, size_t d3_offset, void *host_address, const void *accel_address)
{
   size_t i, j, k;
   char *cdest = d3_offset*element_size+(char *) host_address;
   const char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= -1+d2_block_size; j += 1)
         for(k = 0; k <= d3_block_size*element_size-1+1+-1; k += 1)
            cdest[((i+d1_offset)*d2_block_size+j+d2_offset)*element_size*d3_size+k] = csrc[(i*d2_block_size+j)*d3_block_size*element_size+k];
}
void P4A_copy_from_accel_4d(size_t element_size, size_t d1_size, size_t d2_size, size_t d3_size, size_t d4_size, size_t d1_block_size, size_t d2_block_size, size_t d3_block_size, size_t d4_block_size, size_t d1_offset, size_t d2_offset, size_t d3_offset, size_t d4_offset, void *host_address, const void *accel_address)
{
   size_t i, j, k, l;
   char *cdest = (char *) host_address;
   const char *csrc = (char *) accel_address;
   for(i = 0; i <= -1+d1_block_size; i += 1) {
      for(j = 0; j <= -1+d2_block_size; j += 1) {
         for(k = 0; k <= -1+d3_block_size; k += 1) {
            for(l = 0; l <= -1+d4_block_size; l += 1) {
               int h_index = (i+d1_offset)*d2_size*d3_size*d4_size+(j+d2_offset)*d3_size*d4_size+(k+d3_offset)*d4_size+l+d4_offset;
               
               
               
               int a_index = i*d2_block_size*d3_block_size*d4_block_size+j*d3_block_size*d4_block_size+k*d4_block_size+l;
               cdest[h_index] = csrc[a_index];
            }
         }
      }
   }
}
void P4A_copy_to_accel(size_t element_size, const void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   const char *csrc = host_address;
   for(i = 0; i <= -1+element_size; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, const void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   const char *csrc = d1_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size*element_size-1+1+-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, const void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = (char *) accel_address;
   const char *csrc = d2_offset*element_size+(char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1+1+-1; j += 1)

         cdest[i*element_size*d2_block_size+j] = csrc[(i+d1_offset)*element_size*d2_size+j];
}
void P4A_copy_to_accel_3d(size_t element_size, size_t d1_size, size_t d2_size, size_t d3_size, size_t d1_block_size, size_t d2_block_size, size_t d3_block_size, size_t d1_offset, size_t d2_offset, size_t d3_offset, const void *host_address, void *accel_address)
{
   size_t i, j, k;
   char *cdest = (char *) accel_address;
   const char *csrc = d3_offset*element_size+(char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1)
      for(j = 0; j <= -1+d2_block_size; j += 1)
         for(k = 0; k <= d3_block_size*element_size-1+1+-1; k += 1)
            cdest[(i*d2_block_size+j)*d3_block_size*element_size+k] = csrc[((i+d1_offset)*d2_block_size+j+d2_offset)*element_size*d3_size+k];
}
void P4A_copy_to_accel_4d(size_t element_size, size_t d1_size, size_t d2_size, size_t d3_size, size_t d4_size, size_t d1_block_size, size_t d2_block_size, size_t d3_block_size, size_t d4_block_size, size_t d1_offset, size_t d2_offset, size_t d3_offset, size_t d4_offset, const void *host_address, void *accel_address)
{
   size_t i, j, k, l;
   char *cdest = (char *) accel_address;
   const char *csrc = (char *) host_address;
   for(i = 0; i <= -1+d1_block_size; i += 1) {
      for(j = 0; j <= -1+d2_block_size; j += 1) {
         for(k = 0; k <= -1+d3_block_size; k += 1) {
            for(l = 0; l <= -1+d4_block_size; l += 1) {
               int h_index = (i+d1_offset)*d2_size*d3_size*d4_size+(j+d2_offset)*d3_size*d4_size+(k+d3_offset)*d4_size+l+d4_offset;
               
               
               
               int a_index = i*d2_block_size*d3_block_size*d4_block_size+j*d3_block_size*d4_block_size+k*d4_block_size+l;
               cdest[a_index] = csrc[h_index];
            }
         }
      }
   }
}
int main()
{
   int i, d, j, c, h, u, n;
   //Local variables
   //Sending...	
   int symbole_flow_user1[64];
   int ovsf_code_user1[16] = {1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1};
   int ovsf_code_ref[16] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int spreading_signal_user1[16*64];
   int spreading_signals[16*64+16];

   int I_user[16/2*64+16/2];
   int Q_user[16/2*64+16/2];
   float Signal_I[(16/2*64+16/2)*4];
   float Signal_Q[(16/2*64+16/2)*4];
   float FIR_COEFF[64];
   float FIR2_I_user1[(16/2*64+16/2)*4];
   float FIR2_Q_user1[(16/2*64+16/2)*4];
   int inv_qpsk_user1[16*64+16];
   int symbole_flow[64];

   int count_loop = 0;
   int max = 0;
   
   /********************************************************************************/
   /*										*/
   /*										*/
   /********************************************************************************/
   while (count_loop<10) {
      int channel_delay1, channel_delay2, channel_delay3, channel_delay4;
      float alpha = (float) 0.22;

      float x_buffer_user1[64];
      int ptr_x_buffer_user1 = 0;
      int found_error = 0;
      int retro_loop_count = 0;
      int finger_mat[64][16];
      int coeff[16];
      int coeff2[16];
      //for the temporary coeff calculated before retroaction loop
      int finger[16];
      int fingers;

      count_loop++;
      
      
      //#ifdef DEBUG
estimation:      ;
      p4a_kernel_launcher_0();
      //#endif
      
      
      p4a_kernel_launcher_1(finger_mat, inv_qpsk_user1, ovsf_code_ref);

      for(c = 0; c <= 63; c += 1)
         for(j = 0; j <= 15; j += 1) {
            if (finger_mat[c][j]>=0) 
               printf("%3d\t", finger_mat[c][j]);
            if (finger_mat[c][j]<0) 
               printf("%3d\t", finger_mat[c][j]);
         }
      p4a_kernel_launcher_2(coeff2, finger_mat, symbole_flow_user1);
      
      //display the channel coefficients
      p4a_kernel_launcher_3();
      
      //calculating max power received
      max = 0;
      for(j = 0; j <= 15; j += 1)
         if (coeff2[j]>max) 
            max = coeff2[j];

//max=max*100/(SF*NB_SYMBOL*80);

      if (max>=16*64) {
      }
      else {
         goto l99999;
      }
      j = 0;
l99997:      ;
//retroaction
      if (!(j<16)) goto break_13;
      if (retro_loop_count>16) goto break_13;
      if (coeff2[j]>=max) goto l99998;
      j++;
      goto l99997;
l99998:      ;
      coeff[j]++;
      p4a_kernel_launcher_4(inv_qpsk_user1, j, ovsf_code_ref, symbole_flow_user1);

      retro_loop_count++;
      goto estimation;
break_13:      ;
l99999:      ;
   }
   return 0;
}
void p4a_kernel_0()
{
}
void p4a_kernel_1(int finger_mat[64][16], int c, int inv_qpsk_user1[16*64+16], int ovsf_code_ref[16])
{
   //PIPS generated variable
   int d, i, j;
   for(i = 0; i <= 15; i += 1)
      finger_mat[c][i] = 0;
   for(j = 0; j <= 15; j += 1)
      for(d = 0; d <= 15; d += 1)
         finger_mat[c][j] += inv_qpsk_user1[c*16+d+j]*ovsf_code_ref[d];
}
void p4a_kernel_2(int coeff2[16], int finger_mat[64][16], int j, int symbole_flow_user1[64])
{
   //PIPS generated variable
   int c;
   coeff2[j] = 0;
   for(c = 0; c <= 63; c += 1)
      if (symbole_flow_user1[c]==0)
         coeff2[j] += finger_mat[c][j]*(-1);
      else
         coeff2[j] += finger_mat[c][j]*1;
}
void p4a_kernel_3(int j)
{
   if (j<16-1)
      ;
}
void p4a_kernel_4(int c, int d, int inv_qpsk_user1[16*64+16], int j, int ovsf_code_ref[16], int symbole_flow_user1[64])
{
   if (symbole_flow_user1[c]==1)
      inv_qpsk_user1[c*16+d+j] -= ovsf_code_ref[d];
   else
      inv_qpsk_user1[c*16+d+j] += ovsf_code_ref[d];
}
void p4a_kernel_launcher_0()
{
   //PIPS generated variable
   int d;
   for(d = 0; d <= 1039; d += 1)
      // To be assigned to a call to P4A_vp_0: d
      p4a_kernel_wrapper_0();
}
void p4a_kernel_launcher_1(int finger_mat[64][16], int inv_qpsk_user1[16*64+16], int ovsf_code_ref[16])
{
   //PIPS generated variable
   int c, d, i, j;
   //#endif
   
   
   for(c = 0; c <= 63; c += 1)
      // To be assigned to a call to P4A_vp_0: c
      p4a_kernel_wrapper_1(finger_mat, c, inv_qpsk_user1, ovsf_code_ref);
}
void p4a_kernel_launcher_2(int coeff2[16], int finger_mat[64][16], int symbole_flow_user1[64])
{
   //PIPS generated variable
   int c, j;
   for(j = 0; j <= 15; j += 1)
      // To be assigned to a call to P4A_vp_0: j
      p4a_kernel_wrapper_2(coeff2, finger_mat, j, symbole_flow_user1);
}
void p4a_kernel_launcher_3()
{
   //PIPS generated variable
   int j;
   
   //display the channel coefficients
   for(j = 0; j <= 15; j += 1)
      // To be assigned to a call to P4A_vp_0: j
      p4a_kernel_wrapper_3(j);
}
void p4a_kernel_launcher_4(int inv_qpsk_user1[16*64+16], int j, int ovsf_code_ref[16], int symbole_flow_user1[64])
{
   //PIPS generated variable
   int c, d;
   for(c = 0; c <= 63; c += 1)
      for(d = 0; d <= 15; d += 1)
         // To be assigned to a call to P4A_vp_0: c
         // To be assigned to a call to P4A_vp_1: d
         p4a_kernel_wrapper_4(c, d, inv_qpsk_user1, j, ovsf_code_ref, symbole_flow_user1);
}
void p4a_kernel_wrapper_0()
{
   // To be assigned to a call to P4A_vp_0: d
   p4a_kernel_0();
}
void p4a_kernel_wrapper_1(int finger_mat[64][16], int c, int inv_qpsk_user1[16*64+16], int ovsf_code_ref[16])
{
   // To be assigned to a call to P4A_vp_0: c
   p4a_kernel_1(finger_mat, c, inv_qpsk_user1, ovsf_code_ref);
}
void p4a_kernel_wrapper_2(int coeff2[16], int finger_mat[64][16], int j, int symbole_flow_user1[64])
{
   // To be assigned to a call to P4A_vp_0: j
   p4a_kernel_2(coeff2, finger_mat, j, symbole_flow_user1);
}
void p4a_kernel_wrapper_3(int j)
{
   // To be assigned to a call to P4A_vp_0: j
   p4a_kernel_3(j);
}
void p4a_kernel_wrapper_4(int c, int d, int inv_qpsk_user1[16*64+16], int j, int ovsf_code_ref[16], int symbole_flow_user1[64])
{
   // To be assigned to a call to P4A_vp_0: c
   // To be assigned to a call to P4A_vp_1: d
   p4a_kernel_4(c, d, inv_qpsk_user1, j, ovsf_code_ref, symbole_flow_user1);
}
