void jacobi()
{
   int i, j;
   
   /* Use 2 array in flip-flop to have dataparallel forall semantics. I
        could use also a flip-flop dimension instead... */
kernel1:
   for(i = 1; i <= 830; i += 1)
      for(j = 1; j <= 830; j += 1)

         save[i][j] = 0.25*(space[i-1][j]+space[i+1][j]+space[i][j-1]+space[i][j+1]);
   for(i = 1; i <= 830; i += 1)
      for(j = 1; j <= 830; j += 1)

         space[i][j] = 0.25*(save[i-1][j]+save[i+1][j]+save[i][j-1]+save[i][j+1]);
}
void jacobi()
{
   int i;
   //PIPS generated variable
   int LU_IND0, LU_IND1;
   //PIPS generated variable
   float F_54, F_44, F_34, F_24, F_14, F_04;
   //SAC generated temporary array
   a4sf pdata3 = {0.25, 0.25, 0.25, 0.25}, pdata7 = {0.25, 0.25, 0.25, 0.25};
   //PIPS generated variable
   v4sf vec00_0, vec10_0, vec20_0, vec30_0, vec50_0, vec60_0, vec80_0, vec90_0, vec100_0, vec120_0, vec130_0, vec140_0, vec150_0, vec170_0, vec180_0, vec200_0, vec210_0, vec220_0;
   
   /* Use 2 array in flip-flop to have dataparallel forall semantics. I
        could use also a flip-flop dimension instead... */
kernel1:   ;
   SIMD_LOAD_V4SF(vec100_0, &pdata3[0]);
   for(i = 1; i <= 830; i += 1) {
      for(LU_IND0 = 0; LU_IND0 <= 1; LU_IND0 += 1) {
         F_04 = space[i-1][1+LU_IND0]+space[1+i][1+LU_IND0];
         F_14 = F_04+space[i][LU_IND0];
         F_24 = F_14+space[i][2+LU_IND0];
         save[i][1+LU_IND0] = 0.25*F_24;
      }
      for(LU_IND0 = 2; LU_IND0 <= 829; LU_IND0 += 4) {
         //PIPS:SAC generated v4sf vector(s)
         SIMD_LOAD_V4SF(vec20_0, &space[1+i][1+LU_IND0]);
         SIMD_LOAD_V4SF(vec10_0, &space[i-1][1+LU_IND0]);
         SIMD_ADDPS(vec00_0, vec10_0, vec20_0);
         SIMD_LOAD_V4SF(vec50_0, &space[i][LU_IND0]);
         SIMD_ADDPS(vec30_0, vec00_0, vec50_0);
         SIMD_LOAD_V4SF(vec80_0, &space[i][2+LU_IND0]);
         SIMD_ADDPS(vec60_0, vec30_0, vec80_0);
         SIMD_MULPS(vec90_0, vec100_0, vec60_0);
         SIMD_STORE_V4SF(vec90_0, &save[i][1+LU_IND0]);
      }
   }
   SIMD_LOAD_V4SF(vec220_0, &pdata7[0]);
   for(i = 1; i <= 830; i += 1) {
      for(LU_IND1 = 0; LU_IND1 <= 1; LU_IND1 += 1) {
         F_34 = save[i-1][1+LU_IND1]+save[1+i][1+LU_IND1];
         F_44 = F_34+save[i][LU_IND1];
         F_54 = F_44+save[i][2+LU_IND1];
         space[i][1+LU_IND1] = 0.25*F_54;
      }
      for(LU_IND1 = 2; LU_IND1 <= 829; LU_IND1 += 4) {
         //PIPS:SAC generated v4sf vector(s)
         SIMD_LOAD_V4SF(vec140_0, &save[1+i][1+LU_IND1]);
         SIMD_LOAD_V4SF(vec130_0, &save[i-1][1+LU_IND1]);
         SIMD_ADDPS(vec120_0, vec130_0, vec140_0);
         SIMD_LOAD_V4SF(vec170_0, &save[i][LU_IND1]);
         SIMD_ADDPS(vec150_0, vec120_0, vec170_0);
         SIMD_LOAD_V4SF(vec200_0, &save[i][2+LU_IND1]);
         SIMD_ADDPS(vec180_0, vec150_0, vec200_0);
         SIMD_MULPS(vec210_0, vec220_0, vec180_0);
         SIMD_STORE_V4SF(vec210_0, &space[i][1+LU_IND1]);
      }
   }
   ;
}
