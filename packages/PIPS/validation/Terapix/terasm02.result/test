
Initial code

void microcode(short (*image)[512], short kernel[1], short (*new_image)[512], short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      (*new_image)[-1+j] = kernel[0]*(*image)[-1+j];
}

After flattening

void microcode(short (*image)[512], short kernel[1], short (*new_image)[512], short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      (*new_image)[-1+j] = kernel[0]*(*image)[-1+j];
}

Microcode After array conversion

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      *(*new_image+-1+j) = kernel[0]**(*image+-1+j);
}
void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      *(*new_image+j-1) = kernel[0]**(*image+j-1);
}

Microcode after CSE

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      *(*new_image+j-1) = kernel[0]**(*image+j-1);
   ;
}

Microcode after ICM

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   for(j = 1; j <= iter; j += 1)
      *(*new_image+j-1) = kernel[0]**(*image+j-1);
   ;
}

Microcode After atomization

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   for(j = 1; j <= iter; j += 1) {
      I_4 = j-1;
      P_2 = *image+I_4;
      I_5 = j-1;
      P_3 = *new_image+I_5;
      *P_3 = kernel[0]**P_2;
   }
   ;
}

Atomized code

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   for(j = 1; j <= iter; j += 1) {
      I_4 = j-1;
      P_2 = *image+I_4;
      I_5 = j-1;
      P_3 = *new_image+I_5;
      *P_3 = kernel[0]**P_2;
   }
   ;
}

Tidy code

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   //PIPS generated variable
   int I_6;
   //PIPS generated variable
   short *P_4, *P_5, *P_6, *P_7;
   //PIPS generated variable
   short I_7, I_8, I_9;
   for(j = 1; j <= iter; j += 1) {
      I_6 = j-1;
      I_4 = I_6;
      P_2 = *image+I_4;
      I_5 = I_6;
      P_3 = *new_image+I_5;
      *P_3 = kernel[0]**P_2;
   }
   ;
}

Code in a two adress fashion

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   //PIPS generated variable
   int I_6;
   //PIPS generated variable
   short *P_4, *P_5, *P_6, *P_7;
   //PIPS generated variable
   short I_7, I_8, I_9;
   for(j = 1; j <= iter; j += 1) {
      I_6 = j;
      I_6 = I_6-1;
      I_4 = I_6;
      P_2 = *image;
      P_2 = P_2+I_4;
      I_5 = I_6;
      P_3 = *new_image;
      P_3 = P_3+I_5;
      *P_3 = kernel[0];
      *P_3 = *P_3**P_2;
   }
   ;
}

Code after flattening

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   //PIPS generated variable
   int I_6;
   //PIPS generated variable
   short *P_4, *P_5, *P_6, *P_7;
   //PIPS generated variable
   short I_7, I_8, I_9;
   for(j = 1; j <= iter; j += 1) {
      I_6 = j;
      I_6 = I_6-1;
      I_4 = I_6;
      P_2 = *image;
      P_2 = P_2+I_4;
      I_5 = I_6;
      P_3 = *new_image;
      P_3 = P_3+I_5;
      *P_3 = kernel[0];
      *P_3 = *P_3**P_2;
   }
   ;
}

Code after some cleaning

void microcode(short **image, short *kernel, short **new_image, short iter)
{
   short j;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   short *P_2;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   short *P_3;
   //PIPS generated variable
   int I_6;
   for(j = 1; j <= iter; j += 1) {
      I_6 = j;
      I_6 = I_6-1;
      I_4 = I_6;
      P_2 = *image;
      P_2 = P_2+I_4;
      I_5 = I_6;
      P_3 = *new_image;
      P_3 = P_3+I_5;
      *P_3 = kernel[0];
      *P_3 = *P_3**P_2;
   }
   ;
}

Microcode after normalization

image seems an image
kernel seems a mask
new_image seems an image
iter belongs to a loop bound
void microcode(short **FIFO0, short *FIFO1, short **FIFO2, short N0)
{
   //PIPS generated variable
   int re0;
   //PIPS generated variable
   short *re1;
   //PIPS generated variable
   int re2;
   //PIPS generated variable
   short *re3;
   //PIPS generated variable
   int re4;
   //PIPS generated variable
   short *im0, *ma1;
   //PIPS generated variable
   short *im2;
   //PIPS generated variable
   short re5;
   im2 = *FIFO2;
   ma1 = FIFO1;
   im0 = *FIFO0;
   re5 = 1;
   while (re5<=N0) {
      re0 = re5;
      re0 = re0-1;
      re4 = re0;
      re3 = im0;
      re3 = re3+re4;
      re2 = re0;
      re1 = im2;
      re1 = re1+re2;
      *re1 = ma1[0];
      *re1 = *re1**re3;
      re5 = 1+re5;
   }
   ;
}

Code after expression substitution

void microcode(short **FIFO0, short *FIFO1, short **FIFO2, short N0)
{
   //PIPS generated variable
   int re0;
   //PIPS generated variable
   short *re1;
   //PIPS generated variable
   int re2;
   //PIPS generated variable
   short *re3;
   //PIPS generated variable
   int re4;
   //PIPS generated variable
   short *im0, *ma1;
   //PIPS generated variable
   short *im2;
   //PIPS generated variable
   short re5;
   im2 = *FIFO2;
   seti(ma1, FIFO1);
   im0 = *FIFO0;
   seti(re5, 1);
   while (re5<=N0) {
      seti(re0, re5);
      subi(re0, 1);
      seti(re4, re0);
      seti(re3, im0);
      re3 = re3+re4;
      seti(re2, re0);
      seti(re1, im2);
      re1 = re1+re2;
      *re1 = ma1[0];
      *re1 = *re1**re3;
      addi(re5, 1);
   }
   ;
}

Unsplit resulting code

