tidy the code just in case of
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   for(y = 0; y <= n-1; y += 1)
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   for(y = 0; y <= n-1; y += 1)
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   for(y = 0; y <= n-1; y += 1)
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
tiling
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0;
l99998:
   for(y = 0; y <= n-1; y += 1)
l99999:
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement to check
   for(y = n; y <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; y += 1)
l99997:
      for(x0 = 2; x0 <= n-3; x0 += 1)
         img_out[y][x0-2] = MIN(MIN(MIN(MIN(img[y][x0-2], img[y][x0-1]), img[y][x0]), img[y][x0+1]), img[y][x0+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0;
l99998:
   for(y = 0; y <= n-1; y += 1)
l99999:
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement
   for(y = n; y <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; y += 1)
l99997:
      for(x0 = 2; x0 <= n-3; x0 += 1)
         img_out[y][x0-2] = MIN(MIN(MIN(MIN(img[y][x0-2], img[y][x0-1]), img[y][x0]), img[y][x0+1]), img[y][x0+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1)
l99999:
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1)
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1) {
l99996:
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement to check
      for(x = n-2; x <= 2+__TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT)-1; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
   }

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1) {
l99996:
      for(x = 2; x <= n-3; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement
      for(x = n-2; x <= 2+__TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT)-1; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
   }

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1) {
l99996:
      for(x = 2; x <= 2+__TERAPYPS_HEIGHT*I_1-1; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);

   }

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(y = 0; y <= __TERAPYPS_WIDTH*I_0-1; y += 1)
      for(x = 2; x <= __TERAPYPS_HEIGHT*I_1+1; x += 1)
         img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);

}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 0; yt <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1+1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; y += 1)
#pragma omp parallel for 
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1+1+1)-1; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 0; yt <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1+1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; y += 1)
#pragma omp parallel for 
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1+1+1)-1; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
group constants and isolate

//  <img[PHI1][PHI2]-R-MAY-{4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{4<=n}>

void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;

//  <img[PHI1][PHI2]-R-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{1<=__TERAPYPS_HEIGHT,
//    1<=__TERAPYPS_WIDTH, 4<=n}>

l99998:
   for(yt = 0; yt <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)

//  <img[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+yt, yt<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+yt, yt<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 4<=n}>

#pragma omp parallel for private(x)
l99993:
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1+1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)

//  <img[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+yt, yt<=PHI1,
//    PHI2<=__TERAPYPS_HEIGHT+xt+1, xt<=PHI2+2, 1<=__TERAPYPS_HEIGHT,
//    4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+yt, yt<=PHI1,
//    PHI2+3<=__TERAPYPS_HEIGHT+xt, xt<=PHI2+2, 4<=n}>

#pragma omp parallel for 
l99994:
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; y += 1)

//  <img[PHI1][PHI2]-R-MAY-{PHI1==y, PHI2<=__TERAPYPS_HEIGHT+xt+1,
//    xt<=PHI2+2, 1<=__TERAPYPS_HEIGHT, y+1<=__TERAPYPS_WIDTH+yt,
//    yt<=y, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1==y, PHI2+3<=__TERAPYPS_HEIGHT+xt,
//    xt<=PHI2+2, y+1<=__TERAPYPS_WIDTH+yt, yt<=y, 4<=n}>

#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1+1+1)-1; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, x<=PHI2+2, PHI2<=x+2,
//    x+1<=__TERAPYPS_HEIGHT+xt, y+1<=__TERAPYPS_WIDTH+yt, xt<=x,
//    yt<=y, 4<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x-2,
//    x+1<=__TERAPYPS_HEIGHT+xt, y+1<=__TERAPYPS_WIDTH+yt, xt<=x,
//    yt<=y, 4<=n}>

               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(yt = 0; yt <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); yt += __TERAPYPS_WIDTH)
#pragma omp parallel for private(x)
l99993:
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1+1-(__TERAPYPS_HEIGHT-1); xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= MIN(yt+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(xt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1+1+1)-1; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(yt = 0; yt <= 128*I_0-128; yt += 128)
#pragma omp parallel for private(x)
l99993:
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT+2; xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= yt+127; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1+2)-1; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         n  -4 >= 0
         128I_0 - yt  -128 >= 0
         yt  >= 0
         128I_0 - n  >= 0
         -128I_0 + n + 127 >= 0

Vertices:
[ yt+127,  xt-2 ]
[ yt+127,  __TERAPYPS_HEIGHT+xt-3 ]
[ yt,  xt-2 ]
[ yt,  __TERAPYPS_HEIGHT+xt-3 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         128I_0 - n  >= 0
         __TERAPYPS_HEIGHT  -1 >= 0
         yt  >= 0
         128I_0 - yt  -128 >= 0
         n  -4 >= 0
         -128I_0 + n + 127 >= 0

Vertices:
[ yt+127,  xt-2 ]
[ yt+127,  __TERAPYPS_HEIGHT+xt+1 ]
[ yt,  xt-2 ]
[ yt,  __TERAPYPS_HEIGHT+xt+1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 512 )

void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
#pragma psolve '-65536+( 128 * __TERAPYPS_HEIGHT + 0 ) +( 128 * __TERAPYPS_HEIGHT + 512 ) ' '__TERAPYPS_HEIGHT'

   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(yt = 0; yt <= 128*I_0-128; yt += 128)
#pragma omp parallel for private(x)
l99993:
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT+2; xt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(y = yt; y <= yt+127; y += 1)
#pragma omp parallel for 
l99995:
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1+2)-1; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 4<=n}>

void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 254;

   I_1 = (__TERAPYPS_HEIGHT+n-5)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2<=254I_1+3, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    n<=128I_0, 128I_0<=n+127, 1<=I_1, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=254I_1, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    n<=128I_0, 128I_0<=n+127, 1<=I_1, 4<=n}>

l99998:
   for(yt = 0; yt <= 128*I_0-128; yt += 128)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=254I_1+3, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    yt+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=yt, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2+1<=254I_1, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    yt+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=yt, 4<=n}>

l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT+2; xt += __TERAPYPS_HEIGHT)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+255, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    yt+128<=128I_0, n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, 2<=xt,
//    0<=yt, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+251, __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128,
//    yt+128<=128I_0, n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, 2<=xt,
//    0<=yt, 4<=n}>

l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-MAY-{PHI1==y, xt<=PHI2+2, PHI2<=xt+255,
//    __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128, yt+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, 2<=xt, yt<=y,
//    y<=yt+127, 0<=yt, 4<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{PHI1==y, xt<=PHI2+2, PHI2<=xt+251,
//    __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128, yt+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, 2<=xt, yt<=y,
//    y<=yt+127, 0<=yt, 4<=n}>

l99995:
#pragma  omp parallel for 
            for(x = xt; x <= MIN(__TERAPYPS_HEIGHT+xt, __TERAPYPS_HEIGHT*I_1+2)-1; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, x<=PHI2+2, PHI2<=x+2,
//    __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128, yt+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, xt<=x, x<=xt+253,
//    2<=xt, yt<=y, y<=yt+127, 0<=yt, 4<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x-2,
//    __TERAPYPS_HEIGHT==254, __TERAPYPS_WIDTH==128, yt+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, xt+252<=254I_1, xt<=x, x<=xt+253,
//    2<=xt, yt<=y, y<=yt+127, 0<=yt, 4<=n}>

               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 254;

   I_1 = (n+249)/254;
   I_0 = (n+127)/128;
l99998:
   for(yt = 0; yt <= 128*I_0-128; yt += 128)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*I_1-252; xt += 254)
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int x, y;
   //PIPS generated variable
   int x0, I_0, I_1, yt, xt;
   __TERAPYPS_HEIGHT = 254;

   I_1 = (n+249)/254;
   I_0 = (n+127)/128;
l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;





//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+252, 0<=yt, yt+1<=n, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+248, 0<=yt, yt+1<=n, 5<=n}>

l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+251, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>

l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    xt<=PHI2+2, PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, xt<=PHI2+2, PHI2<=xt+251,
//    2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    x<=PHI2+2, PHI2<=x+2, xt<=x, x<=xt+253, 2<=xt, xt+3<=n, 0<=yt,
//    yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x-2, xt<=x,
//    x<=xt+253, 2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;




l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement to check
         for(y = yt+128; y <= yt+127; y += 1)
l99999:
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
      }
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt;




l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
#pragma pips inserted statement
         for(y = yt+128; y <= yt+127; y += 1)
l99999:
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
      }
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;
   I_2 = 1;




l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99993:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254) {
l99994:
#pragma  omp parallel for 
         for(y = yt; y <= 128*I_2+yt-1; y += 1)
l99995:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);

      }
}
void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

void runner(int n, int img_out[n][n-4], int img[n][n])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;






//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+252, 0<=yt, yt+1<=n, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+248, 0<=yt, yt+1<=n, 5<=n}>

#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+251, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>

#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    xt<=PHI2+2, PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, xt<=PHI2+2, PHI2<=xt+251,
//    2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    x<=PHI2+2, PHI2<=x+2, xt<=x, x<=xt+253, 2<=xt, xt+3<=n, 0<=yt,
//    yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x-2, xt<=x,
//    x<=xt+253, 2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1}>
//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

int main(int argc, char **argv)
{

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1, 4<=n}>

   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n][n-4], in[n][n];

//  <in[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         in[i][j] = j;

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+252,
//    n<=i, 5<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, n<=i, 5<=n}>

   runner(n, out, in);
   check = 0;

//  <out[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+5<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2+5<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-4-1; j += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+5<=n}>

         check += out[i][j];

//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

   printf("%d\n", check);
   return 0;
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+126+1][n+248+1], in[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in[i][j] = j;
   runner(n, out, in);
   check = 0;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-4-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******

//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;






//  <img[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+252, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+248, 5<=n}>

l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)

//  <img[PHI1][PHI2]-R-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+252, 0<=yt, yt+1<=n, 5<=n}>
//  <img_out[PHI1][PHI2]-W-MAY-{yt<=PHI1, PHI1<=yt+127, 0<=PHI2,
//    PHI2<=n+248, 0<=yt, yt+1<=n, 5<=n}>

l99992:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)

//  <img[PHI1][PHI2]-R-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{yt<=PHI1, PHI1<=yt+127, xt<=PHI2+2,
//    PHI2<=xt+251, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>

l99996:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    xt<=PHI2+2, PHI2<=xt+255, 2<=xt, xt+3<=n, 0<=yt, yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, xt<=PHI2+2, PHI2<=xt+251,
//    2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

l99997:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)

//  <img[PHI1][PHI2]-R-EXACT-{PHI1==y, yt<=PHI1, PHI1<=yt+127,
//    x<=PHI2+2, PHI2<=x+2, xt<=x, x<=xt+253, 2<=xt, xt+3<=n, 0<=yt,
//    yt+1<=n}>
//  <img_out[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x-2, xt<=x,
//    x<=xt+253, 2<=xt, xt+3<=n, yt<=y, y<=yt+127, 0<=yt, yt+1<=n}>

               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254)
l99996:
#pragma  omp parallel for 
         for(y = yt; y <= yt+127; y += 1)
l99997:
#pragma  omp parallel for 
            for(x = xt; x <= xt+253; x += 1)
               img_out[y][x-2] = MIN(MIN(MIN(MIN(img[y][x-2], img[y][x-1]), img[y][x]), img[y][x+1]), img[y][x+2]);
}
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= 128*((n+127)/128)-128; yt += 128)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 2; xt <= 254*((n+249)/254)-252; xt += 254) {
         {
            //PIPS generated variable
            int (*img0)[128][258] = (int (*)[128][258]) 0, (*img_out0)[128][254] = (int (*)[128][254]) 0;
            P4A_accel_malloc((void **) &img_out0, sizeof(int)*32512);
            P4A_accel_malloc((void **) &img0, sizeof(int)*33024);
            P4A_copy_to_accel_2d(sizeof(int), MIN((131*n-131)/4, n+126)+1, MIN((257*n-257)/4, n+252)+1, 128, 258, yt, xt-2, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = yt; y <= yt+127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = xt; x <= xt+253; x += 1)
                  (*img_out0)[y-yt][x-2-(xt-2)] = MIN(MIN(MIN(MIN((*img0)[y-yt][x-2-(xt-2)], (*img0)[y-yt][x-1-(xt-2)]), (*img0)[y-yt][x-(xt-2)]), (*img0)[y-yt][x+1-(xt-2)]), (*img0)[y-yt][x+2-(xt-2)]);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+249, 128, 254, yt, xt-2, &img_out[0][0], *img_out0);
            P4A_accel_free(img_out0);
            P4A_accel_free(img0);
         }
      }
}
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (128*((n+127)/128)-128+128)/128+-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (254*((n+249)/254)-252-2+254)/254+-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img0)[128][258] = (int (*)[128][258]) 0, (*img_out0)[128][254] = (int (*)[128][254]) 0;
            P4A_accel_malloc((void **) &img_out0, sizeof(int)*32512);
            P4A_accel_malloc((void **) &img0, sizeof(int)*33024);
            P4A_copy_to_accel_2d(sizeof(int), MIN((131*n-131)/4, n+126)+1, MIN((257*n-257)/4, n+252)+1, 128, 258, 128*yt, 254*xt+2-2, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = 0; y <= 127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = 0; x <= 253; x += 1)
                  (*img_out0)[y+128*yt-128*yt][x+254*xt+2-2-(254*xt+2-2)] = MIN(MIN(MIN(MIN((*img0)[y+128*yt-128*yt][x+254*xt+2-2-(254*xt+2-2)], (*img0)[y+128*yt-128*yt][x+254*xt+2-1-(254*xt+2-2)]), (*img0)[y+128*yt-128*yt][x+254*xt+2-(254*xt+2-2)]), (*img0)[y+128*yt-128*yt][x+254*xt+2+1-(254*xt+2-2)]), (*img0)[y+128*yt-128*yt][x+254*xt+2+2-(254*xt+2-2)]);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+249, 128, 254, 128*yt, 254*xt+2-2, &img_out[0][0], *img_out0);
            P4A_accel_free(img_out0);
            P4A_accel_free(img0);
         }
      }
}
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+127)/128-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+249)/254-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img0)[128][258] = (int (*)[128][258]) 0, (*img_out0)[128][254] = (int (*)[128][254]) 0;
            P4A_accel_malloc((void **) &img_out0, 32512*sizeof(int));
            P4A_accel_malloc((void **) &img0, 33024*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), MIN((131*n-131)/4, n+126)+1, MIN((257*n-257)/4, n+252)+1, 128, 258, 128*yt, 254*xt, &img[0][0], *img0);

l99996:
#pragma  omp parallel for 
            for(y = 0; y <= 127; y += 1)
l99997:
#pragma  omp parallel for 
               for(x = 0; x <= 253; x += 1)
                  (*img_out0)[y][x] = MIN(MIN(MIN(MIN((*img0)[y][x], (*img0)[y][x+1]), (*img0)[y][x+2]), (*img0)[y][x+3]), (*img0)[y][x+4]);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+249, 128, 254, 128*yt, 254*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img_out0);
            P4A_accel_free(img0);
         }
      }
}
outlining to launcher
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+127)/128-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+249)/254-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img0)[128][258] = (int (*)[128][258]) 0, (*img_out0)[128][254] = (int (*)[128][254]) 0;
            P4A_accel_malloc((void **) &img_out0, 32512*sizeof(int));
            P4A_accel_malloc((void **) &img0, 33024*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), MIN((131*n-131)/4, n+126)+1, MIN((257*n-257)/4, n+252)+1, 128, 258, 128*yt, 254*xt, &img[0][0], *img0);

l99996:            launcher_0(253+1, *img0, *img_out0);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+249, 128, 254, 128*yt, 254*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img_out0);
            P4A_accel_free(img0);
         }
      }
}

//  <img0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=257,
//    I_3==254}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2,
//    PHI2<=253, I_3==254}>

void launcher_0(int I_3, int img0[128][258], int img_out0[128][254])
{
   //PIPS generated variable
   int x, y;

//  <img0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=257,
//    I_3==254}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2,
//    PHI2<=253, I_3==254}>

l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)

//  <img0[PHI1][PHI2]-R-EXACT-{PHI1==y, 0<=PHI2, PHI2<=257, I_3==254,
//    0<=y, y<=127}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{PHI1==y, 0<=PHI2, PHI2<=253,
//    I_3==254, 0<=y, y<=127}>

l99997:
#pragma   omp parallel for 
      for(x = 0; x <= I_3-1; x += 1)

//  <img0[PHI1][PHI2]-R-EXACT-{PHI1==y, x<=PHI2, PHI2<=x+4, I_3==254,
//    0<=x, x<=253, 0<=y, y<=127}>
//  <img_out0[PHI1][PHI2]-W-EXACT-{PHI1==y, PHI2==x, I_3==254, 0<=x,
//    x<=253, 0<=y, y<=127}>

         img_out0[y][x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y][x+1]), img0[y][x+2]), img0[y][x+3]), img0[y][x+4]);
}
outlining to microcode
void launcher_0(int I_3, int img0[128][258], int img_out0[128][254])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:
#pragma   omp parallel for 
      for(x = 0; x <= I_3-1; x += 1)
         img_out0[y][x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y][x+1]), img0[y][x+2]), img0[y][x+3]), img0[y][x+4]);
}
void launcher_0(int I_3, int img0[128][258], int img_out0[128][254])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:
#pragma   omp parallel for 
      for(x = 0; x <= I_3-1; x += 1)
         img_out0[y][x] = MIN(MIN(MIN(MIN(img0[y][x], img0[y][x+1]), img0[y][x+2]), img0[y][x+3]), img0[y][x+4]);
}
label: l99997
void runner(int n, int img_out[n+126+1][n+248+1], int img[MIN((131*n-131)/4, n+126)+1][MIN((257*n-257)/4, n+252)+1])
{
   int x, y;
   //PIPS generated variable
   int yt, xt, I_2;





l99998:
   for(yt = 0; yt <= (n+127)/128-1; yt += 1)
l99992:
#pragma  omp parallel for private(x)
      for(xt = 0; xt <= (n+249)/254-1; xt += 1) {
         {
            //PIPS generated variable
            int (*img0)[128][258] = (int (*)[128][258]) 0, (*img_out0)[128][254] = (int (*)[128][254]) 0;
            P4A_accel_malloc((void **) &img_out0, 32512*sizeof(int));
            P4A_accel_malloc((void **) &img0, 33024*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), MIN((131*n-131)/4, n+126)+1, MIN((257*n-257)/4, n+252)+1, 128, 258, 128*yt, 254*xt, &img[0][0], *img0);

l99996:            launcher_0(253+1, *img0, *img_out0);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+249, 128, 254, 128*yt, 254*xt, &img_out[0][0], *img_out0);
            P4A_accel_free(img_out0);
            P4A_accel_free(img0);
         }
      }
}
void launcher_0(int I_3, int img0[128][258], int img_out0[128][254])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:      launcher_0_microcode(I_3, *&img0[y], *&img_out0[y]);
}
void launcher_0_microcode(int I_3, int img00[258], int img_out00[254])
{
   //PIPS generated variable
   int x;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1)
      img_out00[x] = MIN(MIN(MIN(MIN(img00[x], img00[x+1]), img00[x+2]), img00[x+3]), img00[x+4]);
}
**** check ok ******
refining microcode
void launcher_0_microcode(int I_3, int img00[258], int img_out00[254])
{
   //PIPS generated variable
   int x;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1)
      img_out00[x] = MIN(MIN(MIN(MIN(img00[x], img00[x+1]), img00[x+2]), img00[x+3]), img00[x+4]);

}
void launcher_0_microcode(int I_3, int img00[258], int img_out00[254])
{
   //PIPS generated variable
   int x;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1)
      img_out00[x] = MIN(MIN(MIN(MIN(img00[x], img00[x+1]), img00[x+2]), img00[x+3]), img00[x+4]);
}
void launcher_0_microcode(int I_3, int *img00, int *img_out00)
{
   //PIPS generated variable
   int x;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1)
      *(img_out00+x) = MIN(MIN(MIN(MIN(*(img00+x), *(img00+x+1)), *(img00+x+2)), *(img00+x+3)), *(img00+x+4));
}
void launcher_0_microcode(int I_3, int *img00, int *img_out00)
{
   //PIPS generated variable
   int x;
   //PIPS generated variable
   int *img_out000, *img000;
   img000 = img00;
   img_out000 = img_out00;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1) {
      *img_out000 = MIN(MIN(MIN(MIN(*img000, *(img000+1)), *(img000+2)), *(img000+3)), *(img000+4));
      img000 += 1;
      img_out000 += 1;
   }
}
**** check ok ******
void launcher_0_microcode(int I_3, int *img00, int *img_out00)
{
   //PIPS generated variable
   int x;
   //PIPS generated variable
   int *img_out000, *img000, *P_0;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   int *P_1;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   int *P_2;
   //PIPS generated variable
   int I_6;
   //PIPS generated variable
   int *P_3;
   img000 = img00;
   img_out000 = img_out00;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1) {
      P_0 = img000;
      P_0 = P_0+1;
      I_4 = *img000;
      I_4 = MIN(I_4, *P_0);
      P_1 = img000;
      P_1 = P_1+2;
      I_5 = I_4;
      I_5 = MIN(I_5, *P_1);
      P_2 = img000;
      P_2 = P_2+3;
      I_6 = I_5;
      I_6 = MIN(I_6, *P_2);
      P_3 = img000;
      P_3 = P_3+4;
      *img_out000 = I_6;
      *img_out000 = MIN(*img_out000, *P_3);
      img000 = img000+1;
      img_out000 = img_out000+1;
   }
}
void launcher_0_microcode(int I_3, int *img00, int *img_out00)
{
   //PIPS generated variable
   int x;
   //PIPS generated variable
   int *img_out000, *img000, *P_0;
   //PIPS generated variable
   int I_4;
   //PIPS generated variable
   int *P_1;
   //PIPS generated variable
   int I_5;
   //PIPS generated variable
   int *P_2;
   //PIPS generated variable
   int I_6;
   //PIPS generated variable
   int *P_3;
   img000 = img00;
   img_out000 = img_out00;
l99997:
#pragma    omp parallel for 
   for(x = 0; x <= I_3-1; x += 1) {
      P_0 = img000;
      P_0 = P_0+1;
      I_4 = *img000;
      I_4 = MIN(I_4, *P_0);
      P_1 = img000;
      P_1 = P_1+2;
      I_5 = I_4;
      I_5 = MIN(I_5, *P_1);
      P_2 = img000;
      P_2 = P_2+3;
      I_6 = I_5;
      I_6 = MIN(I_6, *P_2);
      P_3 = img000;
      P_3 = P_3+4;
      *img_out000 = I_6;
      *img_out000 = MIN(*img_out000, *P_3);
      img000 = img000+1;
      img_out000 = img_out000+1;
   }
}
**** check ok ******
I_3 belongs to a loop bound
img00 seems an image
img_out00 seems an image
void launcher_0_microcode(int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0;
   //PIPS generated variable
   int re0;
   //PIPS generated variable
   int *im1;
   //PIPS generated variable
   int re1;
   //PIPS generated variable
   int *im2;
   //PIPS generated variable
   int re2;
   //PIPS generated variable
   int *im3, *im4, *im5, *im6, *im7;
   //PIPS generated variable
   int re3;
   im7 = FIFO1;
   im6 = FIFO0;
   im4 = im6;
   im5 = im7;
   for(re3 = 0; re3 <= N0; re3 += 1) {
      im3 = im4;
      im3 = im3+1;
      re2 = *im4;
      re2 = MIN(re2, *im3);
      im2 = im4;
      im2 = im2+2;
      re1 = re2;
      re1 = MIN(re1, *im2);
      im1 = im4;
      im1 = im1+3;
      re0 = re1;
      re0 = MIN(re0, *im1);
      im0 = im4;
      im0 = im0+4;
      *im5 = re0;
      *im5 = MIN(*im5, *im0);
      im4 = im4+1;
      im5 = im5+1;
   }
}
void launcher_0(int I_3, int img0[128][258], int img_out0[128][254])
{
   //PIPS generated variable
   int x, y;
l99996:
#pragma   omp parallel for 
   for(y = 0; y <= 127; y += 1)
l99997:      launcher_0_microcode(*&img_out0[y], *&img0[y], I_3);
}
**** check ok ******
void launcher_0_microcode(int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0;
   //PIPS generated variable
   int re0;
   //PIPS generated variable
   int *im1;
   //PIPS generated variable
   int re1;
   //PIPS generated variable
   int *im2;
   //PIPS generated variable
   int re2;
   //PIPS generated variable
   int *im3, *im4, *im5, *im6, *im7;
   //PIPS generated variable
   int re3;
   im7 = FIFO1;
   im6 = FIFO0;
   im4 = im6;
   im5 = im7;
   for(re3 = 0; re3 <= N0; re3 += 1) {
      im3 = im4;
      im3 = im3+1;
      re2 = *im4;
      re2 = MIN(re2, *im3);
      im2 = im4;
      im2 = im2+2;
      re1 = re2;
      re1 = MIN(re1, *im2);
      im1 = im4;
      im1 = im1+3;
      re0 = re1;
      re0 = MIN(re0, *im1);
      im0 = im4;
      im0 = im0+4;
      *im5 = re0;
      *im5 = MIN(*im5, *im0);
      im4 = im4+1;
      im5 = im5+1;
   }
}
sub launcher_0_microcode
im7 = FIFO1
im6 = FIFO0
im4 = im6
im5 = im7
                        ||                        ||                        ||         do_N0          ||                        
im3 = im4
im3 = im3+1
re2 = *im4
re2 = MIN(re2, *im3)
im2 = im4
im2 = im2+2
re1 = re2
re1 = MIN(re1, *im2)
im1 = im4
im1 = im1+3
re0 = re1
re0 = MIN(re0, *im1)
im0 = im4
im0 = im0+4
*im5 = re0
*im5 = MIN(*im5, *im0)
im4 = im4+1
im5 = im5+1
                        ||                        ||                        ||          loop          ||                        
endsub
