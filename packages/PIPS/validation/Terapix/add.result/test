tidy the code just in case of
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
}
tiling
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
group constants and isolate
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 170;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+126+1][n+168+1], in0[n+126+1][n+168+1], in1[n+126+1][n+168+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in0[i][j] = 1, in1[i][j] = 1;

   runner(n, out, in0, in1);
   check = 0;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170) {
         //PIPS generated variable
         int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
         P4A_accel_malloc((void **) &out0, sizeof(int)*21760);
         P4A_accel_malloc((void **) &in10, sizeof(int)*21760);
         P4A_accel_malloc((void **) &in00, sizeof(int)*21760);
         P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &in1[0][0], *in10);
         P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &in0[0][0], *in00);

#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= jt+169; j += 1)
               (*out0)[i-it][j-jt] = (*in00)[i-it][j-jt]+(*in10)[i-it][j-jt];
         P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &out[0][0], *out0);
         P4A_accel_free(out0);
         P4A_accel_free(in10);
         P4A_accel_free(in00);
      }
}
outlining to launcher
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt;



l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
#pragma omp parallel for 
l99993:
      for(jt = 0; jt <= (n+169)/170-1; jt += 1) {
         //PIPS generated variable
         int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
         P4A_accel_malloc((void **) &out0, 21760*sizeof(int));
         P4A_accel_malloc((void **) &in10, 21760*sizeof(int));
         P4A_accel_malloc((void **) &in00, 21760*sizeof(int));
         P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in1[0][0], *in10);
         P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in0[0][0], *in00);

l99994:         launcher_0(169+1, *in00, *in10, *out0);
         P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &out[0][0], *out0);
         P4A_accel_free(out0);
         P4A_accel_free(in10);
         P4A_accel_free(in00);
      }
}

//  <in00[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>
//  <in10[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>

void launcher_0(int I_2, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;

//  <in00[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>
//  <in10[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_2==170}>

l99994:
   for(i = 0; i <= 127; i += 1)

//  <in00[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_2==170,
//    0<=i, i<=127}>
//  <in10[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_2==170,
//    0<=i, i<=127}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_2==170,
//    0<=i, i<=127}>

l99995:
      for(j = 0; j <= I_2-1; j += 1)

//  <in00[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_2==170, 0<=i,
//    i<=127, 0<=j, j<=169}>
//  <in10[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_2==170, 0<=i,
//    i<=127, 0<=j, j<=169}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, I_2==170, 0<=i,
//    i<=127, 0<=j, j<=169}>

         out0[i][j] = in00[i][j]+in10[i][j];
}
outlining to microcode
void launcher_0(int I_2, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99994:
   for(i = 0; i <= 127; i += 1)
l99995:      launcher_0_microcode(I_2, *&in00[i], *&in10[i], *&out0[i]);
}
void launcher_0_microcode(int I_2, int in000[170], int in100[170], int out00[170])
{
   //PIPS generated variable
   int j;
l99995:
   for(j = 0; j <= I_2-1; j += 1)
      out00[j] = in000[j]+in100[j];
}
**** check ok ******
refining microcode
void launcher_0_microcode(int I_2, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
l99995:
   for(j = 0; j <= I_2-1; j += 1)
      *(out00+j) = *(in000+j)+*(in100+j);
}
**** check ok ******
void launcher_0_microcode(int I_2, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in0000, *in1000;
   in1000 = in100;
   in0000 = in000;
   out000 = out00;
l99995:
   for(j = 0; j <= I_2-1; j += 1) {
      *out000 = *in0000+*in1000;
      in1000 = in1000+1;
      in0000 = in0000+1;
      out000 = out000+1;
   }
}
**** check ok ******
I_2 belongs to a loop bound
in000 seems an image
in100 seems an image
out00 seems an image
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *im4, *im5;
   //PIPS generated variable
   int re0;
   im5 = FIFO2;
   im4 = FIFO1;
   im3 = FIFO0;
   im0 = im4;
   im1 = im3;
   im2 = im5;
   for(re0 = 0; re0 <= N0; re0 += 1) {
      *im2 = *im1+*im0;
      im0 = im0+1;
      im1 = im1+1;
      im2 = im2+1;
   }
}
void launcher_0(int I_2, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99994:
   for(i = 0; i <= 127; i += 1)
l99995:      launcher_0_microcode(*&out0[i], *&in10[i], *&in00[i], I_2);
}
**** check ok ******
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *im4, *im5;
   //PIPS generated variable
   int re0;
   seti(im5, FIFO2);
   seti(im4, FIFO1);
   seti(im3, FIFO0);
   seti(im0, im4);
   seti(im1, im3);
   seti(im2, im5);
   for(re0 = 0; re0 <= N0; re0 += 1) {
      addi(*im2, *im1, *im0);
      paddi(im0, im0, 1);
      paddi(im1, im1, 1);
      paddi(im2, im2, 1);
   }
}
sub launcher_0_microcode
      im,im5=FIFO2      ||                        ||                        ||                        ||                        
      im,im4=FIFO1      ||                        ||                        ||                        ||                        
      im,im3=FIFO0      ||                        ||                        ||                        ||                        
       im,im0=im4       ||                        ||                        ||                        ||                        
       im,im1=im3       ||                        ||                        ||                        ||                        
       im,im2=im5       ||                        ||                        ||                        ||                        
                        ||                        ||                        ||         do_N0          ||                        
                        ||                        ||       P,im0=im0        ||                        ||                        
                        ||                        ||      P,im2=P+im1       ||                        ||                        
      im,im0=im0+E      ||                        ||                        ||                        ||                        
      im,im1=im1+E      ||                        ||                        ||                        ||                        
      im,im2=im2+E      ||                        ||                        ||                        ||                        
                        ||                        ||                        ||          loop          ||                        
endsub
