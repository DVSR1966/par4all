tidy the code just in case of
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
}
tiling
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement to check
   for(i = n; i <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; i += 1)
l99997:
      for(j0 = 0; j0 <= n-1; j0 += 1)
         out[i][j0] = in0[i][j0]+in1[i][j0];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement
   for(i = n; i <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; i += 1)
l99997:
      for(j0 = 0; j0 <= n-1; j0 += 1)
         out[i][j0] = in0[i][j0]+in1[i][j0];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement to check
      for(j = n; j <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
   }

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement
      for(j = n; j <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];
   }

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

   }

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in0[i][j]+in1[i][j];

}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
group constants and isolate

//  <in0[PHI1][PHI2]-R-MAY-{0<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=n}>

void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;

//  <in0[PHI1][PHI2]-R-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    0<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    0<=n}>

l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)

//  <in0[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 0<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 0<=n}>

#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)

//  <in0[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    PHI2+1<=__TERAPYPS_HEIGHT+jt, jt<=PHI2, 0<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    PHI2+1<=__TERAPYPS_HEIGHT+jt, jt<=PHI2, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    PHI2+1<=__TERAPYPS_HEIGHT+jt, jt<=PHI2, 0<=n}>

#pragma omp parallel for 
l99994:
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)

//  <in0[PHI1][PHI2]-R-MAY-{PHI1==i, PHI2+1<=__TERAPYPS_HEIGHT+jt,
//    jt<=PHI2, i+1<=__TERAPYPS_WIDTH+it, it<=i, 0<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{PHI1==i, PHI2+1<=__TERAPYPS_HEIGHT+jt,
//    jt<=PHI2, i+1<=__TERAPYPS_WIDTH+it, it<=i, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1==i, PHI2+1<=__TERAPYPS_HEIGHT+jt,
//    jt<=PHI2, i+1<=__TERAPYPS_WIDTH+it, it<=i, 0<=n}>

#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j,
//    j+1<=__TERAPYPS_HEIGHT+jt, i+1<=__TERAPYPS_WIDTH+it, it<=i,
//    jt<=j, 0<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j,
//    j+1<=__TERAPYPS_HEIGHT+jt, i+1<=__TERAPYPS_WIDTH+it, it<=i,
//    jt<=j, 0<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j,
//    j+1<=__TERAPYPS_HEIGHT+jt, i+1<=__TERAPYPS_WIDTH+it, it<=i,
//    jt<=j, 0<=n}>

               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -128I_0 + n + 127 >= 0
         128I_0 - it  -128 >= 0
         it  >= 0
         128I_0 - n  >= 0

Vertices:
[ it+127,  jt ]
[ it+127,  __TERAPYPS_HEIGHT+jt-1 ]
[ it,  jt ]
[ it,  __TERAPYPS_HEIGHT+jt-1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -128I_0 + n + 127 >= 0
         128I_0 - it  -128 >= 0
         it  >= 0
         128I_0 - n  >= 0

Vertices:
[ it+127,  jt ]
[ it+127,  __TERAPYPS_HEIGHT+jt-1 ]
[ it,  jt ]
[ it,  __TERAPYPS_HEIGHT+jt-1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -128I_0 + n + 127 >= 0
         128I_0 - it  -128 >= 0
         it  >= 0
         128I_0 - n  >= 0

Vertices:
[ it+127,  jt ]
[ it+127,  __TERAPYPS_HEIGHT+jt-1 ]
[ it,  jt ]
[ it,  __TERAPYPS_HEIGHT+jt-1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
#pragma psolve '-65536+( 128 * __TERAPYPS_HEIGHT + 0 ) +( 128 * __TERAPYPS_HEIGHT + 0 ) +( 128 * __TERAPYPS_HEIGHT + 0 ) ' '__TERAPYPS_HEIGHT'

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 1<=n}>

void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 512/3;

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    1<=I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    1<=I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    1<=I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1}>

l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)

//  <in0[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=it}>
//  <in1[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=it}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2+1<=170I_1, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=it}>

l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)

//  <in0[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, 0<=it,
//    0<=jt}>
//  <in1[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, 0<=it,
//    0<=jt}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, 0<=it,
//    0<=jt}>

l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in0[PHI1][PHI2]-R-MAY-{PHI1==i, jt<=PHI2, PHI2<=jt+169,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, 0<=jt}>
//  <in1[PHI1][PHI2]-R-MAY-{PHI1==i, jt<=PHI2, PHI2<=jt+169,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, 0<=jt}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1==i, jt<=PHI2, PHI2<=jt+169,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, 0<=jt}>

l99995:
#pragma  omp parallel for 
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, jt<=j, j<=jt+169, 0<=jt}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, jt<=j, j<=jt+169, 0<=jt}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j,
//    __TERAPYPS_HEIGHT==170, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+170<=170I_1, it<=i, i<=it+127,
//    0<=it, jt<=j, j<=jt+169, 0<=jt}>

               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 170;

   I_1 = (n+169)/170;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*I_1-170; jt += 170)
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 170;

   I_1 = (n+169)/170;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;





//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in0[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>

l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)

//  <in0[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>

               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement to check
         for(i = it+128; i <= it+127; i += 1)
l99999:
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
      }
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
#pragma pips inserted statement
         for(i = it+128; i <= it+127; i += 1)
l99999:
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
      }
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;
   I_2 = 1;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= 128*I_2+it-1; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];

      }
}
void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

void runner(int n, int out[n][n], int in0[n][n], int in1[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;






//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in0[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>

#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)

//  <in0[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>

               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1}>
//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

int main(int argc, char **argv)
{

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1, 0<=n}>

   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n][n], in0[n][n], in1[n][n];

//  <in0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>
//  <in1[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <in0[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>
//  <in1[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <in0[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>
//  <in1[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         in0[i][j] = 1, in1[i][j] = 1;

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, n<=i, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, n<=i, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, n<=i, 1<=n}>


   runner(n, out, in0, in1);
   check = 0;

//  <out[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         check += out[i][j];

//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

   printf("%d\n", check);
   return 0;
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+126+1][n+168+1], in0[n+126+1][n+168+1], in1[n+126+1][n+168+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in0[i][j] = 1, in1[i][j] = 1;

   runner(n, out, in0, in1);
   check = 0;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******

//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;






//  <in0[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+168, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in0[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <in1[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+168, 0<=it, it+1<=n}>

l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)

//  <in0[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+169, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99996:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+169, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99997:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)

//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <in1[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+169, 0<=jt, jt+1<=n}>

               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170)
l99996:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99997:
#pragma  omp parallel for 
            for(j = jt; j <= jt+169; j += 1)
               out[i][j] = in0[i][j]+in1[i][j];
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 170*((n+169)/170)-170; jt += 170) {
         {
            //PIPS generated variable
            int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
            P4A_accel_malloc((void **) &out0, sizeof(int)*21760);
            P4A_accel_malloc((void **) &in10, sizeof(int)*21760);
            P4A_accel_malloc((void **) &in00, sizeof(int)*21760);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &in1[0][0], *in10);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &in0[0][0], *in00);

l99996:
#pragma  omp parallel for 
            for(i = it; i <= it+127; i += 1)
l99997:
#pragma  omp parallel for 
               for(j = jt; j <= jt+169; j += 1)
                  (*out0)[i-it][j-jt] = (*in00)[i-it][j-jt]+(*in10)[i-it][j-jt];
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, it, jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(in10);
            P4A_accel_free(in00);
         }
      }
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (128*((n+127)/128)-128+128)/128+-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (170*((n+169)/170)-170+170)/170+-1; jt += 1) {
         {
            //PIPS generated variable
            int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
            P4A_accel_malloc((void **) &out0, sizeof(int)*21760);
            P4A_accel_malloc((void **) &in10, sizeof(int)*21760);
            P4A_accel_malloc((void **) &in00, sizeof(int)*21760);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in1[0][0], *in10);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in0[0][0], *in00);

l99996:
#pragma  omp parallel for 
            for(i = 0; i <= 127; i += 1)
l99997:
#pragma  omp parallel for 
               for(j = 0; j <= 169; j += 1)
                  (*out0)[i+128*it-128*it][j+170*jt-170*jt] = (*in00)[i+128*it-128*it][j+170*jt-170*jt]+(*in10)[i+128*it-128*it][j+170*jt-170*jt];
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(in10);
            P4A_accel_free(in00);
         }
      }
}
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+169)/170-1; jt += 1) {
         {
            //PIPS generated variable
            int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
            P4A_accel_malloc((void **) &out0, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in10, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in00, 21760*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in1[0][0], *in10);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in0[0][0], *in00);

l99996:
#pragma  omp parallel for 
            for(i = 0; i <= 127; i += 1)
l99997:
#pragma  omp parallel for 
               for(j = 0; j <= 169; j += 1)
                  (*out0)[i][j] = (*in00)[i][j]+(*in10)[i][j];
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(in10);
            P4A_accel_free(in00);
         }
      }
}
outlining to launcher
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+169)/170-1; jt += 1) {
         {
            //PIPS generated variable
            int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
            P4A_accel_malloc((void **) &out0, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in10, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in00, 21760*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in1[0][0], *in10);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in0[0][0], *in00);

l99996:            launcher_0(169+1, *in00, *in10, *out0);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(in10);
            P4A_accel_free(in00);
         }
      }
}

//  <in00[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>
//  <in10[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>

void launcher_0(int I_3, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;

//  <in00[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>
//  <in10[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=169,
//    I_3==170}>

l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)

//  <in00[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_3==170,
//    0<=i, i<=127}>
//  <in10[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_3==170,
//    0<=i, i<=127}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2<=169, I_3==170,
//    0<=i, i<=127}>

l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)

//  <in00[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_3==170, 0<=i,
//    i<=127, 0<=j, j<=169}>
//  <in10[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_3==170, 0<=i,
//    i<=127, 0<=j, j<=169}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, I_3==170, 0<=i,
//    i<=127, 0<=j, j<=169}>

         out0[i][j] = in00[i][j]+in10[i][j];
}
outlining to microcode
void launcher_0(int I_3, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)
         out0[i][j] = in00[i][j]+in10[i][j];
}
void launcher_0(int I_3, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)
         out0[i][j] = in00[i][j]+in10[i][j];
}
label: l99997
void runner(int n, int out[n+126+1][n+168+1], int in0[n+126+1][n+168+1], int in1[n+126+1][n+168+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+169)/170-1; jt += 1) {
         {
            //PIPS generated variable
            int (*in00)[128][170] = (int (*)[128][170]) 0, (*in10)[128][170] = (int (*)[128][170]) 0, (*out0)[128][170] = (int (*)[128][170]) 0;
            P4A_accel_malloc((void **) &out0, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in10, 21760*sizeof(int));
            P4A_accel_malloc((void **) &in00, 21760*sizeof(int));
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in1[0][0], *in10);
            P4A_copy_to_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &in0[0][0], *in00);

l99996:            launcher_0(169+1, *in00, *in10, *out0);
            P4A_copy_from_accel_2d(sizeof(int), n+127, n+169, 128, 170, 128*it, 170*jt, &out[0][0], *out0);
            P4A_accel_free(out0);
            P4A_accel_free(in10);
            P4A_accel_free(in00);
         }
      }
}
void launcher_0(int I_3, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:      launcher_0_microcode(I_3, *&in00[i], *&in10[i], *&out0[i]);
}
void launcher_0_microcode(int I_3, int in000[170], int in100[170], int out00[170])
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in000[j]+in100[j];
}
**** check ok ******
refining microcode
void launcher_0_microcode(int I_3, int in000[170], int in100[170], int out00[170])
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in000[j]+in100[j];

}
void launcher_0_microcode(int I_3, int in000[170], int in100[170], int out00[170])
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in000[j]+in100[j];
}
void launcher_0_microcode(int I_3, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      *(out00+j) = *(in000+j)+*(in100+j);
}
void launcher_0_microcode(int I_3, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in0000, *in1000;
   in1000 = in100;
   in0000 = in000;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in0000+*in1000;
      in1000 += 1;
      in0000 += 1;
      out000 += 1;
   }
}
**** check ok ******
void launcher_0_microcode(int I_3, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in0000, *in1000;
   in1000 = in100;
   in0000 = in000;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in0000;
      *out000 = *out000+*in1000;
      in1000 = in1000+1;
      in0000 = in0000+1;
      out000 = out000+1;
   }
}
void launcher_0_microcode(int I_3, int *in000, int *in100, int *out00)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in0000, *in1000;
   in1000 = in100;
   in0000 = in000;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in0000;
      *out000 = *out000+*in1000;
      in1000 = in1000+1;
      in0000 = in0000+1;
      out000 = out000+1;
   }
}
**** check ok ******
I_3 belongs to a loop bound
in000 seems an image
in100 seems an image
out00 seems an image
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *im4, *im5;
   //PIPS generated variable
   int re0;
   im5 = FIFO2;
   im4 = FIFO1;
   im3 = FIFO0;
   im0 = im4;
   im1 = im3;
   im2 = im5;
   for(re0 = 0; re0 <= N0; re0 += 1) {
      *im2 = *im1;
      *im2 = *im2+*im0;
      im0 = im0+1;
      im1 = im1+1;
      im2 = im2+1;
   }
}
void launcher_0(int I_3, int in00[128][170], int in10[128][170], int out0[128][170])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:      launcher_0_microcode(*&out0[i], *&in10[i], *&in00[i], I_3);
}
**** check ok ******
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *im4, *im5;
   //PIPS generated variable
   int re0;
   seti(im5, FIFO2);
   seti(im4, FIFO1);
   seti(im3, FIFO0);
   seti(im0, im4);
   seti(im1, im3);
   seti(im2, im5);
   for(re0 = 0; re0 <= N0; re0 += 1) {
      psetpi(im2, im1);
      addi(*im2, *im0);
      paddi(im0, 1);
      paddi(im1, 1);
      paddi(im2, 1);
   }
}
sub launcher_0_microcode
      im,im5=FIFO2      ||                        ||                        ||                        ||                        
      im,im4=FIFO1      ||                        ||                        ||                        ||                        
      im,im3=FIFO0      ||                        ||                        ||                        ||                        
       im,im0=im4       ||                        ||                        ||                        ||                        
       im,im1=im3       ||                        ||                        ||                        ||                        
       im,im2=im5       ||                        ||                        ||                        ||                        
                        ||                        ||                        ||         do_N0          ||                        
                        ||                        ||       P,im2=im1        ||                        ||                        
addi(*im2, *im0)
paddi(im0, 1)
paddi(im1, 1)
paddi(im2, 1)
                        ||                        ||                        ||          loop          ||                        
endsub
