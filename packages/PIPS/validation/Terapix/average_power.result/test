tidy the code just in case of
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   for(th = 0; th <= 11; th += 1)
      for(rg = 0; rg <= 12; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   for(th = 0; th <= 11; th += 1)
      for(rg = 0; rg <= 12; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   for(th = 0; th <= 11; th += 1)
      for(rg = 0; rg <= 12; rg += 1)
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
tiling
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0;
l99997:
   for(th = 0; th <= 11; th += 1)
l99998:
      for(rg = 0; rg <= 12; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
#pragma pips inserted statement to check
   for(th = 12; th <= 127; th += 1)
l99996:
      for(rg0 = 0; rg0 <= 12; rg0 += 1)
l99995:
         for(v0 = 0; v0 <= Nv-1; v0 += 1)
            Pow[th] += CplAbs(&ptrin[th][rg0][v0]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0;
l99997:
   for(th = 0; th <= 11; th += 1)
l99998:
      for(rg = 0; rg <= 12; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
#pragma pips inserted statement to check
   for(th = 12; th <= 127; th += 1)
l99996:
      for(rg0 = 0; rg0 <= 12; rg0 += 1)
l99995:
         for(v0 = 0; v0 <= Nv-1; v0 += 1)
            Pow[th] += CplAbs(&ptrin[th][rg0][v0]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0;
   I_0 = 1;
l99997:
   for(th = 0; th <= 128*I_0-1; th += 1)
l99998:
      for(rg = 0; rg <= 12; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);

}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1;
   I_0 = 1;
l99997:
   for(th = 0; th <= 128*I_0-1; th += 1) {
l99998:
      for(rg = 0; rg <= 12; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
#pragma pips inserted statement to check
      for(rg = 13; rg <= N*((N+12)/N)-1; rg += 1)
l99994:
         for(v1 = 0; v1 <= Nv-1; v1 += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v1]);
   }

}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1;
   I_0 = 1;
l99997:
   for(th = 0; th <= 128*I_0-1; th += 1) {
l99998:
      for(rg = 0; rg <= 12; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);
#pragma pips inserted statement to check
      for(rg = 13; rg <= N*((N+12)/N)-1; rg += 1)
l99994:
         for(v1 = 0; v1 <= Nv-1; v1 += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v1]);
   }

}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1;
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(th = 0; th <= 128*I_0-1; th += 1) {
l99998:
      for(rg = 0; rg <= N*I_1-1; rg += 1)
l99999:
         for(v = 0; v <= Nv-1; v += 1)
            Pow[th] += CplAbs(&ptrin[th][rg][v]);

   }

}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)
l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N)
#pragma omp parallel for 
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)
#pragma omp parallel for 
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)
l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N)
#pragma omp parallel for 
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)
#pragma omp parallel for 
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
group constants and isolate

//  <Pow[PHI1]-R-MAY-{0<=PHI1, PHI1<=127, Nrg==13, Nth==12, 1<=N,
//    1<=Nv}>
//  <Pow[PHI1]-W-MAY-{0<=PHI1, PHI1<=127, Nrg==13, Nth==12, 1<=N,
//    1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, Nrg==13, Nth==12, 1<=N}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, Nrg==13, Nth==12, 1<=N}>

void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   I_1 = (N+12)/N;
   I_0 = 1;

//  <Pow[PHI1]-R-MAY-{0<=PHI1, PHI1<=127, I_0==1, Nrg==13, Nth==12,
//    1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{0<=PHI1, PHI1<=127, I_0==1, Nrg==13, Nth==12,
//    1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, 1<=N}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, 1<=N}>

l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)

//  <Pow[PHI1]-R-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1<=127, tht<=PHI1, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, 1<=N}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1<=127, tht<=PHI1, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, 1<=N}>

l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N)

//  <Pow[PHI1]-R-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1<=127, tht<=PHI1,
//    PHI2+1<=N+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0,
//    Nrg==13, Nth==12}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1<=127, tht<=PHI1,
//    PHI2+1<=N+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0,
//    Nrg==13, Nth==12}>

#pragma omp parallel for 
l99992:
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)

//  <Pow[PHI1]-R-MAY-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    1<=N, 0<=th, th<=127, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    1<=N, 0<=th, th<=127, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1==th, PHI2+1<=N+rgt,
//    rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0, Nrg==13,
//    Nth==12, 0<=th, th<=127}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1==th, PHI2+1<=N+rgt,
//    rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0, Nrg==13,
//    Nth==12, 0<=th, th<=127}>

#pragma omp parallel for 
l99993:
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)

//  <Pow[PHI1]-R-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 1<=Nv}>
//  <Pow[PHI1]-W-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-EXACT-{PHI1==th, PHI2==rg, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt,
//    rgt<=rg, 0<=th, th<=127}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-EXACT-{PHI1==th, PHI2==rg, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt,
//    rgt<=rg, 0<=th, th<=127}>

l99999:
               for(v = 0; v <= Nv-1; v += 1)

//  <Pow[PHI1]-R-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <Pow[PHI1]-W-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-EXACT-{PHI1==th, PHI2==rg, PHI3==v,
//    I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt, rgt<=rg, 0<=th,
//    th<=127, 0<=v, v+1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-EXACT-{PHI1==th, PHI2==rg, PHI3==v,
//    I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt, rgt<=rg, 0<=th,
//    th<=127, 0<=v, v+1<=Nv}>

                  Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)
l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N)
#pragma omp parallel for 
l99992:
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)
#pragma omp parallel for 
l99993:
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  Pow[th] += CplAbs(&ptrin[th][rg][v]);
}

//  <Pow[PHI1]-R-MAY-{0<=PHI1, PHI1<=127, Nrg==13, Nth==12, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{0<=PHI1, PHI1<=127, Nrg==13, Nth==12, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, Nrg==13, Nth==12}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, Nrg==13, Nth==12}>

void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;

//  <Pow[PHI1]-R-MAY-{0<=PHI1, PHI1<=127, I_0==1, Nrg==13, Nth==12,
//    1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{0<=PHI1, PHI1<=127, I_0==1, Nrg==13, Nth==12,
//    1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, 1<=N}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{0<=PHI1, PHI1<=127, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, 1<=N}>

l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)

//  <Pow[PHI1]-R-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1<=127, tht<=PHI1, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, 1<=N}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1<=127, tht<=PHI1, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, 1<=N}>

l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N)

//  <Pow[PHI1]-R-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1<=127, tht<=PHI1, I_0==1, tht==0, Nrg==13,
//    Nth==12, 1<=N, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1<=127, tht<=PHI1,
//    PHI2+1<=N+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0,
//    Nrg==13, Nth==12}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1<=127, tht<=PHI1,
//    PHI2+1<=N+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0,
//    Nrg==13, Nth==12}>

#pragma omp parallel for 
l99992:
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)

//  <Pow[PHI1]-R-MAY-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    1<=N, 0<=th, th<=127, 1<=Nv}>
//  <Pow[PHI1]-W-MAY-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    1<=N, 0<=th, th<=127, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-MAY-{PHI1==th, PHI2+1<=N+rgt,
//    rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0, Nrg==13,
//    Nth==12, 0<=th, th<=127}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-MAY-{PHI1==th, PHI2+1<=N+rgt,
//    rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, tht==0, Nrg==13,
//    Nth==12, 0<=th, th<=127}>

#pragma omp parallel for 
l99993:
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)

//  <Pow[PHI1]-R-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 1<=Nv}>
//  <Pow[PHI1]-W-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-EXACT-{PHI1==th, PHI2==rg, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt,
//    rgt<=rg, 0<=th, th<=127}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-EXACT-{PHI1==th, PHI2==rg, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt,
//    rgt<=rg, 0<=th, th<=127}>

l99999:
               for(v = 0; v <= Nv-1; v += 1)

//  <Pow[PHI1]-R-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <Pow[PHI1]-W-EXACT-{PHI1==th, I_0==1, tht==0, Nrg==13, Nth==12,
//    rg+1<=N+rgt, rgt<=rg, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].im-R-EXACT-{PHI1==th, PHI2==rg, PHI3==v,
//    I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt, rgt<=rg, 0<=th,
//    th<=127, 0<=v, v+1<=Nv}>
//  <ptrin[PHI1][PHI2][PHI3].re-R-EXACT-{PHI1==th, PHI2==rg, PHI3==v,
//    I_0==1, tht==0, Nrg==13, Nth==12, rg+1<=N+rgt, rgt<=rg, 0<=th,
//    th<=127, 0<=v, v+1<=Nv}>

                  Pow[th] += CplAbs(&ptrin[th][rg][v]);
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 128*I_0-1-(128-1); tht += 128)
l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N) {
         //PIPS generated variable
         Cplfloat (*ptrin0)[Nth][Nrg][Nv] = (Cplfloat (*)[Nth][Nrg][Nv]) 0;
         //PIPS generated variable
         float (*Pow0)[Nth] = (float (*)[Nth]) 0;
         P4A_accel_malloc((void **) &Pow0, sizeof(float)*Nth);
         P4A_accel_malloc((void **) &ptrin0, sizeof(ptrin[0][0][0])*Nth*Nrg*Nv);
         P4A_copy_to_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_copy_to_accel_3d(sizeof(ptrin[0][0][0]), Nth, Nrg, Nv, Nth, Nrg, Nv, 0, 0, 0, &ptrin[0][0][0], *ptrin0);

#pragma omp parallel for 
l99992:
         for(th = tht; th <= MIN(tht+128, 128*I_0-1+1)-1; th += 1)
#pragma omp parallel for 
l99993:
            for(rg = rgt; rg <= MIN(rgt+N, N*I_1-1+1)-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  (*Pow0)[th-0] += CplAbs(&(*ptrin0)[th-0][rg-0][v-0]);
         P4A_copy_from_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_accel_free(Pow0);
         P4A_accel_free(ptrin0);
      }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 128*I_0/128+-1; tht += 1)
l99998:
      for(rgt = 0; rgt <= N*I_1-1-(N-1); rgt += N) {
         //PIPS generated variable
         Cplfloat (*ptrin0)[Nth][Nrg][Nv] = (Cplfloat (*)[Nth][Nrg][Nv]) 0;
         //PIPS generated variable
         float (*Pow0)[Nth] = (float (*)[Nth]) 0;
         P4A_accel_malloc((void **) &Pow0, sizeof(float)*Nth);
         P4A_accel_malloc((void **) &ptrin0, sizeof(ptrin[0][0][0])*Nth*Nrg*Nv);
         P4A_copy_to_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_copy_to_accel_3d(sizeof(ptrin[0][0][0]), Nth, Nrg, Nv, Nth, Nrg, Nv, 0, 0, 0, &ptrin[0][0][0], *ptrin0);

#pragma omp parallel for 
l99992:
         for(th = 0; th <= MIN(128*tht+128, 128*I_0-1+1)-1-128*tht+1+-1; th += 1)
#pragma omp parallel for 
l99993:
            for(rg = 0; rg <= MIN(rgt+N, N*I_1-1+1)-1-rgt+1+-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  (*Pow0)[th+128*tht-0] += CplAbs(&(*ptrin0)[th+128*tht-0][rg+rgt-0][v-0]);
         P4A_copy_from_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_accel_free(Pow0);
         P4A_accel_free(ptrin0);
      }
}
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 0; tht += 1)
l99998:
      for(rgt = 0; rgt <= N*I_1-N; rgt += N) {
         //PIPS generated variable
         Cplfloat (*ptrin0)[Nth][Nrg][Nv] = (Cplfloat (*)[Nth][Nrg][Nv]) 0;
         //PIPS generated variable
         float (*Pow0)[Nth] = (float (*)[Nth]) 0;
         P4A_accel_malloc((void **) &Pow0, sizeof(float)*Nth);
         P4A_accel_malloc((void **) &ptrin0, sizeof(ptrin[0][0][0])*Nth*Nrg*Nv);
         P4A_copy_to_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_copy_to_accel_3d(sizeof(ptrin[0][0][0]), Nth, Nrg, Nv, Nth, Nrg, Nv, 0, 0, 0, &ptrin[0][0][0], *ptrin0);

#pragma omp parallel for 
l99992:
         for(th = 0; th <= MIN(128*tht+128, 128*I_0)-128*tht-1; th += 1)
#pragma omp parallel for 
l99993:
            for(rg = 0; rg <= MIN(N+rgt, N*I_1)-rgt-1; rg += 1)
l99999:
               for(v = 0; v <= Nv-1; v += 1)
                  (*Pow0)[th+128*tht] += CplAbs(&(*ptrin0)[th+128*tht][rg+rgt][v]);
         P4A_copy_from_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_accel_free(Pow0);
         P4A_accel_free(ptrin0);
      }
}
outlining to launcher
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 0; tht += 1)
l99998:
      for(rgt = 0; rgt <= N*I_1-N; rgt += N) {
         //PIPS generated variable
         Cplfloat (*ptrin0)[Nth][Nrg][Nv] = (Cplfloat (*)[Nth][Nrg][Nv]) 0;
         //PIPS generated variable
         float (*Pow0)[Nth] = (float (*)[Nth]) 0;
         P4A_accel_malloc((void **) &Pow0, sizeof(float)*Nth);
         P4A_accel_malloc((void **) &ptrin0, sizeof(ptrin[0][0][0])*Nth*Nrg*Nv);
         P4A_copy_to_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_copy_to_accel_3d(sizeof(ptrin[0][0][0]), Nth, Nrg, Nv, Nth, Nrg, Nv, 0, 0, 0, &ptrin[0][0][0], *ptrin0);

l99992:         launcher_0(Nrg, Nth, Nv, I_0, MIN(N+rgt, N*I_1)-rgt-1+1, *Pow0, *ptrin0, rgt, tht);
         P4A_copy_from_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_accel_free(Pow0);
         P4A_accel_free(ptrin0);
      }
}

//  <Pow0[PHI1]-R-MAY-{128tht<=PHI1, PHI1<=128tht+127, I_0==1,
//    Nrg==13, Nth==12, tht==0, 1<=I_2, 1<=Nv}>
//  <Pow0[PHI1]-W-MAY-{128tht<=PHI1, PHI1<=128tht+127, I_0==1,
//    Nrg==13, Nth==12, tht==0, 1<=I_2, 1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].im-R-MAY-{128tht<=PHI1,
//    PHI1<=128tht+127, PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, tht==0}>
//  <ptrin0[PHI1][PHI2][PHI3].re-R-MAY-{128tht<=PHI1,
//    PHI1<=128tht+127, PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, tht==0}>

void launcher_0(int Nrg, int Nth, int Nv, int I_0, int I_2, float Pow0[Nth], Cplfloat ptrin0[Nth][Nrg][Nv], int rgt, int tht)
{
   //PIPS generated variable
   int rg, th, v;

//  <Pow0[PHI1]-R-MAY-{128tht<=PHI1, PHI1<=128tht+127, I_0==1,
//    Nrg==13, Nth==12, tht==0, 1<=I_2, 1<=Nv}>
//  <Pow0[PHI1]-W-MAY-{128tht<=PHI1, PHI1<=128tht+127, I_0==1,
//    Nrg==13, Nth==12, tht==0, 1<=I_2, 1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].im-R-MAY-{128tht<=PHI1,
//    PHI1<=128tht+127, PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, tht==0}>
//  <ptrin0[PHI1][PHI2][PHI3].re-R-MAY-{128tht<=PHI1,
//    PHI1<=128tht+127, PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3,
//    PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12, tht==0}>

l99992:
   for(th = 0; th <= MIN(128*tht+128, 128*I_0)-128*tht-1; th += 1)

//  <Pow0[PHI1]-R-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=th, th<=127, 1<=I_2, 1<=Nv}>
//  <Pow0[PHI1]-W-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=th, th<=127, 1<=I_2, 1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].im-R-EXACT-{th+128tht==PHI1,
//    PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1,
//    Nrg==13, Nth==12, tht==0, 0<=th, th<=127}>
//  <ptrin0[PHI1][PHI2][PHI3].re-R-EXACT-{th+128tht==PHI1,
//    PHI2+1<=I_2+rgt, rgt<=PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1,
//    Nrg==13, Nth==12, tht==0, 0<=th, th<=127}>

l99993:
      for(rg = 0; rg <= I_2-1; rg += 1)

//  <Pow0[PHI1]-R-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127, 1<=Nv}>
//  <Pow0[PHI1]-W-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127, 1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].im-R-EXACT-{th+128tht==PHI1,
//    rg+rgt==PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127}>
//  <ptrin0[PHI1][PHI2][PHI3].re-R-EXACT-{th+128tht==PHI1,
//    rg+rgt==PHI2, 0<=PHI3, PHI3+1<=Nv, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127}>

l99999:
         for(v = 0; v <= Nv-1; v += 1)

//  <Pow0[PHI1]-R-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <Pow0[PHI1]-W-EXACT-{th+128tht==PHI1, I_0==1, Nrg==13, Nth==12,
//    tht==0, 0<=rg, rg+1<=I_2, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].im-R-EXACT-{th+128tht==PHI1,
//    rg+rgt==PHI2, PHI3==v, I_0==1, Nrg==13, Nth==12, tht==0, 0<=rg,
//    rg+1<=I_2, 0<=th, th<=127, 0<=v, v+1<=Nv}>
//  <ptrin0[PHI1][PHI2][PHI3].re-R-EXACT-{th+128tht==PHI1,
//    rg+rgt==PHI2, PHI3==v, I_0==1, Nrg==13, Nth==12, tht==0, 0<=rg,
//    rg+1<=I_2, 0<=th, th<=127, 0<=v, v+1<=Nv}>

            Pow0[th+128*tht] += CplAbs(&ptrin0[th+128*tht][rg+rgt][v]);
}
outlining to microcode
label: l99993
void average_power(int Nth, int Nrg, int Nv, Cplfloat ptrin[Nth][Nrg][Nv], float Pow[Nth])
{
   int th, v, rg;
   //PIPS generated variable
   int rg0, v0, I_0, v1, I_1, tht, rgt;
   N = 127*1/Nv*(1/N);
   I_1 = (N+12)/N;
   I_0 = 1;
l99997:
   for(tht = 0; tht <= 0; tht += 1)
l99998:
      for(rgt = 0; rgt <= N*I_1-N; rgt += N) {
         //PIPS generated variable
         Cplfloat (*ptrin0)[Nth][Nrg][Nv] = (Cplfloat (*)[Nth][Nrg][Nv]) 0;
         //PIPS generated variable
         float (*Pow0)[Nth] = (float (*)[Nth]) 0;
         P4A_accel_malloc((void **) &Pow0, sizeof(float)*Nth);
         P4A_accel_malloc((void **) &ptrin0, sizeof(ptrin[0][0][0])*Nth*Nrg*Nv);
         P4A_copy_to_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_copy_to_accel_3d(sizeof(ptrin[0][0][0]), Nth, Nrg, Nv, Nth, Nrg, Nv, 0, 0, 0, &ptrin[0][0][0], *ptrin0);

l99992:         launcher_0(Nrg, Nth, Nv, I_0, MIN(N+rgt, N*I_1)-rgt-1+1, *Pow0, *ptrin0, rgt, tht);
         P4A_copy_from_accel_1d(sizeof(float), Nth, Nth, 0, &Pow[0], *Pow0);
         P4A_accel_free(Pow0);
         P4A_accel_free(ptrin0);
      }
}
void launcher_0(int Nrg, int Nth, int Nv, int I_0, int I_2, float Pow0[Nth], Cplfloat ptrin0[Nth][Nrg][Nv], int rgt, int tht)
{
   //PIPS generated variable
   int rg, th, v;
l99992:
   for(th = 0; th <= MIN(128*tht+128, 128*I_0)-128*tht-1; th += 1)
l99993:      launcher_0_microcode(Nrg, Nv, I_2, rgt, &Pow0[th+128*tht], *&ptrin0[th+128*tht]);
}
void launcher_0_microcode(int Nrg, int Nv, int I_2, int rgt, float *Pow00, Cplfloat ptrin00[Nrg][Nv])
{
   //PIPS generated variable
   int rg, v;
l99993:
   for(rg = 0; rg <= I_2-1; rg += 1)
l99999:
      for(v = 0; v <= Nv-1; v += 1)
         *Pow00 += CplAbs(&ptrin00[rg+rgt][v]);
}
