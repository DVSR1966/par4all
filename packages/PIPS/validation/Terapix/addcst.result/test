tidy the code just in case of
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
}
tiling
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
#pragma pips inserted statement to check
   for(i = n; i <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; i += 1)
l99997:
      for(j0 = 0; j0 <= n-1; j0 += 1)
         out[i][j0] = in[i][j0]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0;
l99998:
   for(i = 0; i <= n-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
#pragma pips inserted statement
   for(i = n; i <= __TERAPYPS_WIDTH*((__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH)-1; i += 1)
l99997:
      for(j0 = 0; j0 <= n-1; j0 += 1)
         out[i][j0] = in[i][j0]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
l99999:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
#pragma pips inserted statement to check
      for(j = n; j <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; j += 1)
         out[i][j] = in[i][j]+2;
   }

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= n-1; j += 1)
         out[i][j] = in[i][j]+2;
#pragma pips inserted statement
      for(j = n; j <= __TERAPYPS_HEIGHT*((__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT)-1; j += 1)
         out[i][j] = in[i][j]+2;
   }

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1) {
l99996:
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in[i][j]+2;

   }

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(i = 0; i <= __TERAPYPS_WIDTH*I_0-1; i += 1)
      for(j = 0; j <= __TERAPYPS_HEIGHT*I_1-1; j += 1)
         out[i][j] = in[i][j]+2;

}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
group constants and isolate

//  <in[PHI1][PHI2]-R-MAY-{0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=n}>

void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;

//  <in[PHI1][PHI2]-R-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{1<=__TERAPYPS_HEIGHT, 1<=__TERAPYPS_WIDTH,
//    0<=n}>

l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)

//  <in[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    1<=__TERAPYPS_HEIGHT, 0<=n}>

#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)

//  <in[PHI1][PHI2]-R-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    PHI2+1<=__TERAPYPS_HEIGHT+jt, jt<=PHI2, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1+1<=__TERAPYPS_WIDTH+it, it<=PHI1,
//    PHI2+1<=__TERAPYPS_HEIGHT+jt, jt<=PHI2, 0<=n}>

#pragma omp parallel for 
l99994:
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)

//  <in[PHI1][PHI2]-R-MAY-{PHI1==i, PHI2+1<=__TERAPYPS_HEIGHT+jt,
//    jt<=PHI2, i+1<=__TERAPYPS_WIDTH+it, it<=i, 0<=n}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1==i, PHI2+1<=__TERAPYPS_HEIGHT+jt,
//    jt<=PHI2, i+1<=__TERAPYPS_WIDTH+it, it<=i, 0<=n}>

#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j,
//    j+1<=__TERAPYPS_HEIGHT+jt, i+1<=__TERAPYPS_WIDTH+it, it<=i,
//    jt<=j, 0<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j,
//    j+1<=__TERAPYPS_HEIGHT+jt, i+1<=__TERAPYPS_WIDTH+it, it<=i,
//    jt<=j, 0<=n}>

               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (__TERAPYPS_WIDTH+n-1)/__TERAPYPS_WIDTH;
l99998:
   for(it = 0; it <= __TERAPYPS_WIDTH*I_0-1-(__TERAPYPS_WIDTH-1); it += __TERAPYPS_WIDTH)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-1-(__TERAPYPS_HEIGHT-1); jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= MIN(it+__TERAPYPS_WIDTH, __TERAPYPS_WIDTH*I_0-1+1)-1; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(jt+__TERAPYPS_HEIGHT, __TERAPYPS_HEIGHT*I_1-1+1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}
---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -128I_0 + n + 127 >= 0
         128I_0 - it  -128 >= 0
         it  >= 0
         128I_0 - n  >= 0

Vertices:
[ it+127,  jt ]
[ it+127,  __TERAPYPS_HEIGHT+jt-1 ]
[ it,  jt ]
[ it,  __TERAPYPS_HEIGHT+jt-1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

---------------------------------------
Domain:
         __TERAPYPS_WIDTH  -128 = 0
         __TERAPYPS_HEIGHT  -1 >= 0
         -128I_0 + n + 127 >= 0
         128I_0 - it  -128 >= 0
         it  >= 0
         128I_0 - n  >= 0

Vertices:
[ it+127,  jt ]
[ it+127,  __TERAPYPS_HEIGHT+jt-1 ]
[ it,  jt ]
[ it,  __TERAPYPS_HEIGHT+jt-1 ]

Ehrhart Polynomial:
( 128 * __TERAPYPS_HEIGHT + 0 )

void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
#pragma psolve '-65536+( 128 * __TERAPYPS_HEIGHT + 0 ) +( 128 * __TERAPYPS_HEIGHT + 0 ) ' '__TERAPYPS_HEIGHT'

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
#pragma omp parallel for private(j)
l99993:
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)
#pragma omp parallel for 
l99994:
         for(i = it; i <= it+127; i += 1)
#pragma omp parallel for 
l99995:
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)
               out[i][j] = in[i][j]+2;
}

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, 1<=n}>

void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 256;

   I_1 = (__TERAPYPS_HEIGHT+n-1)/__TERAPYPS_HEIGHT;
   I_0 = (n+127)/128;

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=256I_1, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    1<=I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1+1<=128I_0, 0<=PHI2,
//    PHI2+1<=256I_1, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    1<=I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1}>

l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)

//  <in[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2+1<=256I_1, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=it}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2+1<=256I_1, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, 1<=I_1, 0<=it}>

l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= __TERAPYPS_HEIGHT*I_1-__TERAPYPS_HEIGHT; jt += __TERAPYPS_HEIGHT)

//  <in[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, jt+256<=256I_1, 0<=it,
//    0<=jt}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128,
//    it+128<=128I_0, n<=128I_0, 128I_0<=n+127, jt+256<=256I_1, 0<=it,
//    0<=jt}>

l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in[PHI1][PHI2]-R-MAY-{PHI1==i, jt<=PHI2, PHI2<=jt+255,
//    __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+256<=256I_1, it<=i, i<=it+127,
//    0<=it, 0<=jt}>
//  <out[PHI1][PHI2]-W-MAY-{PHI1==i, jt<=PHI2, PHI2<=jt+255,
//    __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+256<=256I_1, it<=i, i<=it+127,
//    0<=it, 0<=jt}>

l99995:
#pragma  omp parallel for 
            for(j = jt; j <= MIN(__TERAPYPS_HEIGHT+jt, __TERAPYPS_HEIGHT*I_1)-1; j += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, __TERAPYPS_HEIGHT==256,
//    __TERAPYPS_WIDTH==128, it+128<=128I_0, n<=128I_0, 128I_0<=n+127,
//    jt+256<=256I_1, it<=i, i<=it+127, 0<=it, jt<=j, j<=jt+255,
//    0<=jt}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j,
//    __TERAPYPS_HEIGHT==256, __TERAPYPS_WIDTH==128, it+128<=128I_0,
//    n<=128I_0, 128I_0<=n+127, jt+256<=256I_1, it<=i, i<=it+127,
//    0<=it, jt<=j, j<=jt+255, 0<=jt}>

               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 256;

   I_1 = (n+255)/256;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*I_0-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*I_1-256; jt += 256)
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   unsigned int __TERAPYPS_WIDTH = 128, __TERAPYPS_HEIGHT;
   int i, j;
   //PIPS generated variable
   int j0, I_0, I_1, it, jt;
   __TERAPYPS_HEIGHT = 256;

   I_1 = (n+255)/256;
   I_0 = (n+127)/128;
l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
}

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;





//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>

l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)

//  <in[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>

               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
#pragma pips inserted statement to check
         for(i = it+128; i <= it+127; i += 1)
l99999:
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
      }
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
#pragma pips inserted statement
         for(i = it+128; i <= it+127; i += 1)
l99999:
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
      }
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;
   I_2 = 1;




l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99993:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
l99994:
#pragma  omp parallel for 
         for(i = it; i <= 128*I_2+it-1; i += 1)
l99995:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;

      }
}
void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
}

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

void runner(int n, int out[n][n], int in[n][n])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;






//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>

#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)

//  <in[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>

               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)
               out[i][j] = in[i][j]+2;
}

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1}>
//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

int main(int argc, char **argv)
{

//  <argv-R-MAY-{}>
//  <argv[PHI1]-R-MAY-{PHI1==1, 0<=n}>

   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n][n], in[n][n];

//  <in[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <in[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         in[i][j] = 1;

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    n<=i, 1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, n<=i, 1<=n}>

   runner(n, out, in);
   check = 0;

//  <out[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1+1<=n, 0<=PHI2, PHI2+1<=n}>

   for(i = 0; i <= n-1; i += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2+1<=n, 0<=i,
//    i+1<=n}>

      for(j = 0; j <= n-1; j += 1)

//  <out[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, 0<=i, i+1<=n, 0<=j,
//    j+1<=n}>

         check += out[i][j];

//  <stdout-R-EXACT-{}>
//  <stdout[PHI1]-R-MAY-{PHI1==0}>
//  <stdout[PHI1]-W-MAY-{PHI1==0}>
//  <__IO_EFFECTS:LUNS[PHI1]-R-EXACT-{PHI1==1}>
//  <__IO_EFFECTS:LUNS[PHI1]-W-EXACT-{PHI1==1}>

   printf("%d\n", check);
   return 0;
}
int main(int argc, char **argv)
{
   int check, i, j, n = argc>1?atoi(argv[1]):200;
   int out[n+126+1][n+254+1], in[n+126+1][n+254+1];
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         in[i][j] = 1;
   runner(n, out, in);
   check = 0;
   for(i = 0; i <= n-1; i += 1)
      for(j = 0; j <= n-1; j += 1)
         check += out[i][j];
   printf("%d\n", check);
   return 0;
}
**** check ok ******

//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;






//  <in[PHI1][PHI2]-R-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2, PHI2<=n+254,
//    1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{0<=PHI1, PHI1<=n+126, 0<=PHI2,
//    PHI2<=n+254, 1<=n}>

l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)

//  <in[PHI1][PHI2]-R-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>
//  <out[PHI1][PHI2]-W-MAY-{it<=PHI1, PHI1<=it+127, 0<=PHI2,
//    PHI2<=n+254, 0<=it, it+1<=n}>

l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256)

//  <in[PHI1][PHI2]-R-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{it<=PHI1, PHI1<=it+127, jt<=PHI2,
//    PHI2<=jt+255, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99996:
#pragma  omp parallel for 
         for(i = it; i <= it+127; i += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, jt<=PHI2, PHI2<=jt+255, it<=i,
//    i<=it+127, 0<=it, it+1<=n, 0<=jt, jt+1<=n}>

l99997:
#pragma  omp parallel for 
            for(j = jt; j <= jt+255; j += 1)

//  <in[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>
//  <out[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, it<=i, i<=it+127,
//    0<=it, it+1<=n, jt<=j, j<=jt+255, 0<=jt, jt+1<=n}>

               out[i][j] = in[i][j]+2;
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

l99996:
#pragma  omp parallel for 
            for(i = it; i <= it+127; i += 1)
l99997:
#pragma  omp parallel for 
               for(j = jt; j <= jt+255; j += 1)
                  out[i][j] = in[i][j]+caillou[0];
         }
      }
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= 128*((n+127)/128)-128; it += 128)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= 256*((n+255)/256)-256; jt += 256) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

            {
               //PIPS generated variable
               int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
               P4A_accel_malloc((void **) &out0, sizeof(int)*32768);
               P4A_accel_malloc((void **) &caillou0, sizeof(int)*1);
               P4A_accel_malloc((void **) &in0, sizeof(int)*32768);
               P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
               P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, it, jt, &in[0][0], *in0);

l99996:
#pragma  omp parallel for 
               for(i = it; i <= it+127; i += 1)
l99997:
#pragma  omp parallel for 
                  for(j = jt; j <= jt+255; j += 1)
                     (*out0)[i-it][j-jt] = (*in0)[i-it][j-jt]+(*caillou0)[0-0];
               P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, it, jt, &out[0][0], *out0);
               P4A_accel_free(out0);
               P4A_accel_free(caillou0);
               P4A_accel_free(in0);
            }
         }
      }
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (128*((n+127)/128)-128+128)/128+-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (256*((n+255)/256)-256+256)/256+-1; jt += 1) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

            {
               //PIPS generated variable
               int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
               P4A_accel_malloc((void **) &out0, sizeof(int)*32768);
               P4A_accel_malloc((void **) &caillou0, sizeof(int)*1);
               P4A_accel_malloc((void **) &in0, sizeof(int)*32768);
               P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
               P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &in[0][0], *in0);

l99996:
#pragma  omp parallel for 
               for(i = 0; i <= 127; i += 1)
l99997:
#pragma  omp parallel for 
                  for(j = 0; j <= 255; j += 1)
                     (*out0)[i+128*it-128*it][j+256*jt-256*jt] = (*in0)[i+128*it-128*it][j+256*jt-256*jt]+(*caillou0)[0-0];
               P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &out[0][0], *out0);
               P4A_accel_free(out0);
               P4A_accel_free(caillou0);
               P4A_accel_free(in0);
            }
         }
      }
}
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+255)/256-1; jt += 1) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

            {
               //PIPS generated variable
               int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
               P4A_accel_malloc((void **) &out0, 32768*sizeof(int));
               P4A_accel_malloc((void **) &caillou0, sizeof(int));
               P4A_accel_malloc((void **) &in0, 32768*sizeof(int));
               P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
               P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &in[0][0], *in0);

l99996:
#pragma  omp parallel for 
               for(i = 0; i <= 127; i += 1)
l99997:
#pragma  omp parallel for 
                  for(j = 0; j <= 255; j += 1)
                     (*out0)[i][j] = (*in0)[i][j]+(*caillou0)[0];
               P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &out[0][0], *out0);
               P4A_accel_free(out0);
               P4A_accel_free(caillou0);
               P4A_accel_free(in0);
            }
         }
      }
}
outlining to launcher
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+255)/256-1; jt += 1) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

            {
               //PIPS generated variable
               int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
               P4A_accel_malloc((void **) &out0, 32768*sizeof(int));
               P4A_accel_malloc((void **) &caillou0, sizeof(int));
               P4A_accel_malloc((void **) &in0, 32768*sizeof(int));
               P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
               P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &in[0][0], *in0);

l99996:               launcher_0(255+1, *caillou0, *in0, *out0);
               P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &out[0][0], *out0);
               P4A_accel_free(out0);
               P4A_accel_free(caillou0);
               P4A_accel_free(in0);
            }
         }
      }
}

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_3==256}>
//  <in0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_3==256}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_3==256}>

void launcher_0(int I_3, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_3==256}>
//  <in0[PHI1][PHI2]-R-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_3==256}>
//  <out0[PHI1][PHI2]-W-EXACT-{0<=PHI1, PHI1<=127, 0<=PHI2, PHI2<=255,
//    I_3==256}>

l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_3==256, 0<=i, i<=127}>
//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, 0<=PHI2, PHI2<=255, I_3==256,
//    0<=i, i<=127}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, 0<=PHI2, PHI2<=255, I_3==256,
//    0<=i, i<=127}>

l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)

//  <caillou0[PHI1]-R-EXACT-{PHI1==0, I_3==256, 0<=i, i<=127, 0<=j,
//    j<=255}>
//  <in0[PHI1][PHI2]-R-EXACT-{PHI1==i, PHI2==j, I_3==256, 0<=i,
//    i<=127, 0<=j, j<=255}>
//  <out0[PHI1][PHI2]-W-EXACT-{PHI1==i, PHI2==j, I_3==256, 0<=i,
//    i<=127, 0<=j, j<=255}>

         out0[i][j] = in0[i][j]+caillou0[0];
}
outlining to microcode
void launcher_0(int I_3, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)
         out0[i][j] = in0[i][j]+caillou0[0];
}
void launcher_0(int I_3, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:
#pragma   omp parallel for 
      for(j = 0; j <= I_3-1; j += 1)
         out0[i][j] = in0[i][j]+caillou0[0];
}
label: l99997
void runner(int n, int out[n+126+1][n+254+1], int in[n+126+1][n+254+1])
{
   int i, j;
   //PIPS generated variable
   int it, jt, I_2;





l99998:
   for(it = 0; it <= (n+127)/128-1; it += 1)
l99992:
#pragma  omp parallel for private(j)
      for(jt = 0; jt <= (n+255)/256-1; jt += 1) {
         {
            //PIPS generated variable
            int caillou[1];
            caillou[0] = 2;

            {
               //PIPS generated variable
               int (*in0)[128][256] = (int (*)[128][256]) 0, (*caillou0)[1] = (int (*)[1]) 0, (*out0)[128][256] = (int (*)[128][256]) 0;
               P4A_accel_malloc((void **) &out0, 32768*sizeof(int));
               P4A_accel_malloc((void **) &caillou0, sizeof(int));
               P4A_accel_malloc((void **) &in0, 32768*sizeof(int));
               P4A_copy_to_accel_1d(sizeof(int), 1, 1, 0, &caillou[0], *caillou0);
               P4A_copy_to_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &in[0][0], *in0);

l99996:               launcher_0(255+1, *caillou0, *in0, *out0);
               P4A_copy_from_accel_2d(sizeof(int), n+127, n+255, 128, 256, 128*it, 256*jt, &out[0][0], *out0);
               P4A_accel_free(out0);
               P4A_accel_free(caillou0);
               P4A_accel_free(in0);
            }
         }
      }
}
void launcher_0(int I_3, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:      launcher_0_microcode(I_3, *&in0[i], *&out0[i], caillou0[0]);
}
void launcher_0_microcode(int I_3, int in00[256], int out00[256], int caillou0)
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in00[j]+caillou0;
}
**** check ok ******
refining microcode
void launcher_0_microcode(int I_3, int in00[256], int out00[256], int caillou0)
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in00[j]+caillou0;

}
void launcher_0_microcode(int I_3, int in00[256], int out00[256], int caillou0)
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      out00[j] = in00[j]+caillou0;
}
void launcher_0_microcode(int I_3, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1)
      *(out00+j) = *(in00+j)+caillou0;
}
void launcher_0_microcode(int I_3, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in000;
   in000 = in00;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in000+caillou0;
      in000 += 1;
      out000 += 1;
   }
}
**** check ok ******
void launcher_0_microcode(int I_3, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in000;
   in000 = in00;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in000;
      *out000 = *out000+caillou0;
      in000 = in000+1;
      out000 = out000+1;
   }
}
void launcher_0_microcode(int I_3, int *in00, int *out00, int caillou0)
{
   //PIPS generated variable
   int j;
   //PIPS generated variable
   int *out000, *in000;
   in000 = in00;
   out000 = out00;
l99997:
#pragma    omp parallel for 
   for(j = 0; j <= I_3-1; j += 1) {
      *out000 = *in000;
      *out000 = *out000+caillou0;
      in000 = in000+1;
      out000 = out000+1;
   }
}
**** check ok ******
I_3 belongs to a loop bound
in00 seems an image
out00 seems an image
caillou0 seems a mask
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *ma4;
   //PIPS generated variable
   int re0;
   ma4 = FIFO2;
   im3 = FIFO1;
   im2 = FIFO0;
   im0 = im2;
   im1 = im3;
   for(re0 = 0; re0 <= N0; re0 += 1) {
      *im1 = *im0;
      *im1 = *im1+*ma4;
      im0 = im0+1;
      im1 = im1+1;
   }
}
void launcher_0(int I_3, int caillou0[1], int in0[128][256], int out0[128][256])
{
   //PIPS generated variable
   int i, j;
l99996:
#pragma   omp parallel for 
   for(i = 0; i <= 127; i += 1)
l99997:      launcher_0_microcode(&caillou0[0], *&out0[i], *&in0[i], I_3);
}
**** check ok ******
void launcher_0_microcode(int *FIFO2, int *FIFO1, int *FIFO0, int N0)
{
   //PIPS generated variable
   int *im0, *im1, *im2, *im3, *ma4;
   //PIPS generated variable
   int re0;
   seti(ma4, FIFO2);
   seti(im3, FIFO1);
   seti(im2, FIFO0);
   seti(im0, im2);
   seti(im1, im3);
   for(re0 = 0; re0 <= N0; re0 += 1) {
      psetpi(im1, im0);
      addi(*im1, *ma4);
      paddi(im0, 1);
      paddi(im1, 1);
   }
}
sub launcher_0_microcode
                        ||       ma4=FIFO2        ||                        ||                        ||                        
      im,im3=FIFO1      ||                        ||                        ||                        ||                        
      im,im2=FIFO0      ||                        ||                        ||                        ||                        
       im,im0=im2       ||                        ||                        ||                        ||                        
       im,im1=im3       ||                        ||                        ||                        ||                        
                        ||                        ||                        ||         do_N0          ||                        
                        ||                        ||       P,im1=im0        ||                        ||                        
addi(*im1, *ma4)
paddi(im0, 1)
paddi(im1, 1)
                        ||                        ||                        ||          loop          ||                        
endsub
