setenv WKS matmul03
setenv WKS_bis matmul03_bis

delete $WKS

setenv CPRETTYPRINTER_DEBUG_LEVEL 9

setproperty ABORT_ON_USER_ERROR TRUE

create $WKS $WKS.f include/p4a_stubs.f

setproperty PRETTYPRINT_STATEMENT_NUMBER FALSE
setproperty ISOLATE_STATEMENT_EVEN_NON_LOCAL TRUE
setproperty EVAL_SYMBOLIC_CONSTANT FALSE
setproperty GPU_LAUNCHER_PREFIX "P4A_KERNEL_LAUNCHER"
setproperty GPU_WRAPPER_PREFIX "P4A_KERNEL_WRAPPER"
setproperty GPU_KERNEL_PREFIX "P4A_KERNEL"
setproperty KERNEL_LOAD_STORE_ALLOCATE_FUNCTION "P4A_ACCEL_MALLOC"
setproperty KERNEL_LOAD_STORE_DEALLOCATE_FUNCTION "P4A_ACCEL_FREE"
setproperty KERNEL_LOAD_STORE_LOAD_FUNCTION_2D "P4A_COPY_TO_ACCEL_2D"
setproperty KERNEL_LOAD_STORE_STORE_FUNCTION_2D "P4A_COPY_FROM_ACCEL_2D"
setproperty NESTED_PARALLELISM_THRESHOLD 2
setproperty OUTLINE_INDEPENDENT_COMPILATION_UNIT TRUE

activate MUST_REGIONS
activate TRANSFORMERS_INTER_FULL
activate INTERPROCEDURAL_SUMMARY_PRECONDITION
activate PRECONDITIONS_INTER_FULL

# Loop normalize for the C language and GPU friendly
setproperty LOOP_NORMALIZE_ONE_INCREMENT TRUE
setproperty LOOP_NORMALIZE_LOWER_BOUND 0
# It is legal in the following by construction:
setproperty LOOP_NORMALIZE_SKIP_INDEX_SIDE_EFFECT TRUE
# If we do this here, the side effect at the end of a loop on the index
# break parallelization. It would require to apply USE_DEF_ELIM...
apply LOOP_NORMALIZE[MATMUL03]

apply PRIVATIZE_MODULE[MATMUL03]

apply COARSE_GRAIN_PARALLELIZATION[MATMUL03]

setproperty GPU_USE_FORTRAN_WRAPPER TRUE
setproperty GPU_USE_LAUNCHER TRUE
setproperty GPU_USE_WRAPPER FALSE
setproperty GPU_USE_KERNEL FALSE

apply GPU_IFY[MATMUL03]

apply LOOP_NORMALIZE [P4A_KERNEL_LAUNCHER_0]
apply LOOP_NORMALIZE [P4A_KERNEL_LAUNCHER_1]

apply PRIVATIZE_MODULE [P4A_KERNEL_LAUNCHER_0]
apply PRIVATIZE_MODULE [P4A_KERNEL_LAUNCHER_1]

apply COARSE_GRAIN_PARALLELIZATION [P4A_KERNEL_LAUNCHER_0]
apply COARSE_GRAIN_PARALLELIZATION [P4A_KERNEL_LAUNCHER_1]

apply LIMIT_NESTED_PARALLELISM [P4A_KERNEL_LAUNCHER_0]
apply LIMIT_NESTED_PARALLELISM [P4A_KERNEL_LAUNCHER_1]

apply GPU_LOOP_NEST_ANNOTATE [P4A_KERNEL_LAUNCHER_0]
apply GPU_LOOP_NEST_ANNOTATE [P4A_KERNEL_LAUNCHER_1]

setproperty GPU_USE_LAUNCHER FALSE
setproperty GPU_USE_WRAPPER TRUE
setproperty GPU_USE_KERNEL TRUE

apply GPU_IFY [P4A_KERNEL_LAUNCHER_0]
apply GPU_IFY [P4A_KERNEL_LAUNCHER_1]

setproperty PRETTYPRINT_C_FUNCTION_NAME_WITH_UNDERSCORE TRUE
display C_PRINTED_FILE [P4A_FORTRAN_WRAPPER_0]
display C_PRINTED_FILE [P4A_FORTRAN_WRAPPER_1]

setproperty PRETTYPRINT_C_FUNCTION_NAME_WITH_UNDERSCORE FALSE
display C_PRINTED_FILE [P4A_KERNEL_0]
display C_PRINTED_FILE [P4A_KERNEL_1]
display C_PRINTED_FILE [P4A_KERNEL_WRAPPER_0]
display C_PRINTED_FILE [P4A_KERNEL_WRAPPER_1]
display C_PRINTED_FILE [P4A_KERNEL_LAUNCHER_0]
display C_PRINTED_FILE [P4A_KERNEL_LAUNCHER_1]

apply UNSPLIT
close $WKS

# 2nd phase on C genberated files
delete $WKS_bis
create $WKS_bis $WKS.database/P4A_KERNEL_LAUNCHER_0/P4A_KERNEL_LAUNCHER_0.c $WKS.database/P4A_KERNEL_LAUNCHER_1/P4A_KERNEL_LAUNCHER_1.c $WKS.database/P4A_KERNEL_WRAPPER_0/P4A_KERNEL_WRAPPER_0.c $WKS.database/P4A_KERNEL_WRAPPER_1/P4A_KERNEL_WRAPPER_1.c  $WKS.database/P4A_KERNEL_0/P4A_KERNEL_0.c $WKS.database/P4A_KERNEL_1/P4A_KERNEL_1.c $WKS.database/P4A_FORTRAN_WRAPPER_0/P4A_FORTRAN_WRAPPER_0.c $WKS.database/P4A_FORTRAN_WRAPPER_1/P4A_FORTRAN_WRAPPER_1.c include/p4a_stubs.c

apply KERNEL_LOAD_STORE [p4a_kernel_launcher_0]
apply KERNEL_LOAD_STORE [p4a_kernel_launcher_1]

apply UNSPLIT

close $WKS_bis
quit
