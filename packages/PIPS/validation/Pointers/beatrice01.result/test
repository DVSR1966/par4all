
Proper effects for "main"

int main()
{
   int i, j, k;
   float x, y;
   syst *my_syst;
   part *curr_part1, *curr_part2;
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: my_syst _MALLOC_EFFECTS:_MALLOC_
   
   // initializations
   my_syst = (syst *) malloc(sizeof(syst));
//             <    is written>: i
   for(i = 0; i <= 9; i += 1) {
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: i my_syst _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      (my_syst->tab_dom)[i] = (dom *) malloc(sizeof(dom));
//             <    is written>: j
      for(j = 0; j <= 99; j += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
         ((my_syst->tab_dom)[i]->tab_part)[j] = (part *) malloc(sizeof(part));
   }
//             <    is written>: x
   x = 0;
//             <    is written>: y
   y = 0;
//             <    is written>: i
   
   // computations
   for(i = 0; i <= 9; i += 1) {
      dom *curr_dom;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: curr_dom
      curr_dom = (my_syst->tab_dom)[i];
//             <    is written>: j

      for(j = 0; j <= 99; j += 1) {
         part *curr_part1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`3`curr_part1
         curr_part1 = (curr_dom->tab_part)[j];
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: 0`2`3`curr_part1 j x

         curr_part1->x = x+0.01*(float) j;
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: 0`2`3`curr_part1 j y
         curr_part1->y = y+0.01*(float) j;
      }
//             <    is written>: j

      for(j = 0; j <= 99; j += 1) {
         part *curr_part1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`4`curr_part1
         curr_part1 = (curr_dom->tab_part)[j];
//             <    is read   >: j
//             <    is written>: k

         for(k = j+1; k <= 99; k += 1) {
            part *curr_part2;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`4`5`curr_part2
            curr_part2 = (curr_dom->tab_part)[k];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*

            if (dist(curr_part1, curr_part2)<0.1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               curr_part1->x_new = curr_part1->x-0.1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               curr_part1->y_new = curr_part1->y-0.1;
            }
         }
      }
   }
   
   // final IOs (& free()...)
   
   return 0;
}

POINTS TO for "main"


// Points To IN: none


// Points To OUT: none

int main()
{

// Points To: none

   int i, j, k;

// Points To: none

   float x, y;

// Points To: none

   syst *my_syst;

// Points To:
// my_syst -> *ANY_MODULE*:*NOWHERE* , EXACT

   part *curr_part1, *curr_part2;

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , EXACT
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , EXACT
// my_syst -> *ANY_MODULE*:*NOWHERE* , EXACT

   
   // initializations
   my_syst = (syst *) malloc(sizeof(syst));

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , EXACT
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , EXACT
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

   for(i = 0; i <= 9; i += 1) {

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

      (my_syst->tab_dom)[i] = (dom *) malloc(sizeof(dom));

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

      for(j = 0; j <= 99; j += 1)

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , EXACT
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         ((my_syst->tab_dom)[i]->tab_part)[j] = (part *) malloc(sizeof(part));
   }

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

   x = 0;

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

   y = 0;

// Points To:
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

   
   // computations
   for(i = 0; i <= 9; i += 1) {

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

      dom *curr_dom;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

      curr_dom = (my_syst->tab_dom)[i];

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT


      for(j = 0; j <= 99; j += 1) {

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`3`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         part *curr_part1;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`3`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         curr_part1 = (curr_dom->tab_part)[j];

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`3`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT


         curr_part1->x = x+0.01*(float) j;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`3`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         curr_part1->y = y+0.01*(float) j;
      }

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT


      for(j = 0; j <= 99; j += 1) {

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         part *curr_part1;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

         curr_part1 = (curr_dom->tab_part)[j];

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT


         for(k = j+1; k <= 99; k += 1) {

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`2`4`5`curr_part2 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

            part *curr_part2;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`2`4`5`curr_part2 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

            curr_part2 = (curr_dom->tab_part)[k];

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`2`4`5`curr_part2 -> *ANY_MODULE*:*ANYWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT


            if (dist(curr_part1, curr_part2)<0.1) {

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`2`4`5`curr_part2 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

               curr_part1->x_new = curr_part1->x-0.1;

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`2`4`curr_part1 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`2`4`5`curr_part2 -> *ANY_MODULE*:*ANYWHERE* , EXACT
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

               curr_part1->y_new = curr_part1->y-0.1;
            }
         }
      }
   }

// Points To:
// curr_dom -> *ANY_MODULE*:*HEAP* , MAY
// 0`curr_part1 -> *ANY_MODULE*:*NOWHERE* , MAY
// 0`curr_part2 -> *ANY_MODULE*:*NOWHERE* , MAY
// my_syst[0].tab_dom[*][0].tab_part[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst[0].tab_dom[*] -> *ANY_MODULE*:*HEAP* , MAY
// my_syst -> *ANY_MODULE*:*HEAP* , EXACT

   
   // final IOs (& free()...)
   
   return 0;
}

Proper effects using points_to

int main()
{
   int i, j, k;
   float x, y;
   syst *my_syst;
   part *curr_part1, *curr_part2;
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: my_syst _MALLOC_EFFECTS:_MALLOC_
   
   // initializations
   my_syst = (syst *) malloc(sizeof(syst));
//             <    is written>: i
   for(i = 0; i <= 9; i += 1) {
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: i my_syst _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      (my_syst->tab_dom)[i] = (dom *) malloc(sizeof(dom));
//             <    is written>: j
      for(j = 0; j <= 99; j += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
         ((my_syst->tab_dom)[i]->tab_part)[j] = (part *) malloc(sizeof(part));
   }
//             <    is written>: x
   x = 0;
//             <    is written>: y
   y = 0;
//             <    is written>: i
   
   // computations
   for(i = 0; i <= 9; i += 1) {
      dom *curr_dom;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: curr_dom
      curr_dom = (my_syst->tab_dom)[i];
//             <    is written>: j

      for(j = 0; j <= 99; j += 1) {
         part *curr_part1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`3`curr_part1
         curr_part1 = (curr_dom->tab_part)[j];
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: 0`2`3`curr_part1 j x

         curr_part1->x = x+0.01*(float) j;
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: 0`2`3`curr_part1 j y
         curr_part1->y = y+0.01*(float) j;
      }
//             <    is written>: j

      for(j = 0; j <= 99; j += 1) {
         part *curr_part1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`4`curr_part1
         curr_part1 = (curr_dom->tab_part)[j];
//             <    is read   >: j
//             <    is written>: k

         for(k = j+1; k <= 99; k += 1) {
            part *curr_part2;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <    is written>: 0`2`4`5`curr_part2
            curr_part2 = (curr_dom->tab_part)[k];
//             <    is read   >: 0`2`4`curr_part1 0`2`4`5`curr_part2 j
//                               dist:_p1_1.x dist:_p1_1.y 
//                               dist:_p2_2.x dist:_p2_2.y

            if (dist(curr_part1, curr_part2)<0.1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               curr_part1->x_new = curr_part1->x-0.1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               curr_part1->y_new = curr_part1->y-0.1;
            }
         }
      }
   }
   
   // final IOs (& free()...)
   
   return 0;
}

