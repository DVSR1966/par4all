
Parsed printed file for "a_m_serial"

ATOM * a_m_serial(int serial)
{
   static ATOM *ap = (void *) 0;
   static ATOM *lastmatched = (void *) 0;
   int i, n, a_number();
   if (atomUPDATE)
      n = a_number();
   else
      n = atomNUMBER;

   ap = first;
   if (ap==(void *) 0)
      return (void *) 0;
   if (lastmatched==(void *) 0)
      lastmatched = first;

   if (serial==lastmatched->serial)
      return lastmatched;
   if (serial>lastmatched->serial)
      ap = lastmatched;
   for (i = 0;i<n;i++) {
      if (ap->serial==serial) {
         lastmatched = ap;
         return ap;
      }
      if (ap==ap->next)
         ap = first;
      else
         ap = ap->next;
   }
   return (void *) 0;
}

Proper effects for "a_m_serial"

ATOM * a_m_serial(int serial)
{
   static ATOM *ap = (void *) 0;
   static ATOM *lastmatched = (void *) 0;
   int i, n, a_number();
//             <    is read   >: atomUPDATE
   if (atomUPDATE)
//             <may be read   >: first
//             <may be written>: atomNUMBER atomUPDATE
//             <    is read   >: atomNUMBER atomUPDATE
//             <    is written>: n
      n = a_number();
   else
//             <    is read   >: atomNUMBER
//             <    is written>: n
      n = atomNUMBER;
//             <    is read   >: first
//             <    is written>: ap

   ap = first;
//             <    is read   >: ap
   if (ap==(void *) 0)
      return (void *) 0;
//             <    is read   >: lastmatched
   if (lastmatched==(void *) 0)
//             <    is read   >: first
//             <    is written>: lastmatched
      lastmatched = first;
//             <    is read   >: lastmatched lastmatched[0].serial 
//                               serial

   if (serial==lastmatched->serial)
//             <    is read   >: lastmatched
      return lastmatched;
//             <    is read   >: lastmatched lastmatched[0].serial 
//                               serial
   if (serial>lastmatched->serial)
//             <    is read   >: lastmatched
//             <    is written>: ap
      ap = lastmatched;
//             <    is read   >: n
//             <    is written>: i
   for(i = 0; i <= n-1; i += 1) {
//             <    is read   >: ap ap[0].serial n serial
      if (ap->serial==serial) {
//             <    is read   >: ap n
//             <    is written>: lastmatched
         lastmatched = ap;
//             <    is read   >: ap n
         return ap;
      }
//             <    is read   >: ap ap[0].next n
      if (ap==ap->next)
//             <    is read   >: first n
//             <    is written>: ap
         ap = first;
      else
//             <    is read   >: ap ap[0].next n
//             <    is written>: ap
         ap = ap->next;
   }
   return (void *) 0;
}
POINTS TO
