void P4A_scmp_dealloc(void *dest)
{
}
void * P4A_scmp_flow(void **flow)
{
}
void P4A_scmp_kernel_0(int32_t *channel_delay1, int32_t *channel_delay2, int32_t *channel_delay3, int32_t *channel_delay4, int32_t *data, unsigned char image_in[512*1024], int32_t img_index, int32_t ovsf_code_user1[8], int32_t pilot[8*sizeof(int32_t)], int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t symbole_flow_user1[8*sizeof(int32_t)], int32_t t)
{
   //PIPS generated variable
   int32_t data_bit, i, j, write;
   {
      int task;
#pragma   scmp task
      task = 0;
      if (t%10!=0) {
         *data = image_in[img_index]<<0|image_in[img_index+1]<<8|image_in[img_index+2]<<16|image_in[img_index+3]<<24;
         //put 4 pixels in a frame (data)
         for(i = 0; i <= 8*sizeof(int32_t)-1; i += 1) {
            data_bit = *data>>i&0x01;
            symbole_flow_user1[i] = data_bit;
         }
         
         //---- Spreading
         
         for(i = 0; i <= 8*sizeof(int32_t)-1; i += 1)
            for(j = 0; j <= 7; j += 1)
               if (symbole_flow_user1[i]==0)
                  spreading_signal1[i*8+j] = -ovsf_code_user1[j];
               else
                  spreading_signal1[i*8+j] = ovsf_code_user1[j];
      }
      else {
         *channel_delay1 = (int32_t) (rand()%6);
         *channel_delay2 = (int32_t) (rand()%6);
         *channel_delay3 = (int32_t) (rand()%6);
         *channel_delay4 = (int32_t) (rand()%6);
         /* pdebug_info("path 4 delay: %i\n",channel_delay4); */
         //printf("%d %d %d %d\n",channel_delay1,channel_delay2,channel_delay3,channel_delay4);		
         for(i = 0; i <= 8*sizeof(int32_t)-1; i += 1) {
            write = pilot[i]==0?-1:1;
            for(j = 0; j <= 7; j += 1)
               spreading_signal1[i*8+j] = write;
         }
      }
   }
}
void P4A_scmp_kernel_1(int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //generate multipath
   //main path
   for(i = 0; i <= 8*8*sizeof(int32_t)-1; i += 1)
      spreading_signals[i] = spreading_signal1[i];
}
void P4A_scmp_kernel_10(float channel_I[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t u;
   
   
   //---- FIR for I and Q before channel
   
   
   //initialisation
   for(u = 0; u <= (8/2*8*sizeof(int32_t)+6/2)*4-1; u += 1)
      channel_I[u] = 0;
}
void P4A_scmp_kernel_11(int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t u;
   {
      int task;
#pragma   scmp task
      task = 0;
      for(u = 0; u <= 7; u += 1)
         x_buffer_user1[u] = 0;
      *ptr_x_buffer_user1 = 0;
   }
}
void P4A_scmp_kernel_12(float FIR_COEFF[8], float Signal_I[(8/2*8*sizeof(int32_t)+6/2)*4], float channel_I[(8/2*8*sizeof(int32_t)+6/2)*4], int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t i, n;
   
   //convolution par la réponse impultionelle du filtre (FIR_COEFF)
   for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 1) {
      x_buffer_user1[(*ptr_x_buffer_user1)++] = Signal_I[i];
      *ptr_x_buffer_user1 %= 8;
      for(n = 8-1; n >= 0; n += -1) {
         channel_I[i] += FIR_COEFF[n]*x_buffer_user1[(*ptr_x_buffer_user1)++];
         *ptr_x_buffer_user1 %= 8;
      }
   }
}
void P4A_scmp_kernel_13(float channel_Q[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t u;
   
   //initialisation
   for(u = 0; u <= (8/2*8*sizeof(int32_t)+6/2)*4-1; u += 1)
      channel_Q[u] = 0;
}
void P4A_scmp_kernel_14(int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t u;
   {
      int task;
#pragma   scmp task
      task = 0;
      for(u = 0; u <= 7; u += 1)
         x_buffer_user1[u] = 0;
      *ptr_x_buffer_user1 = 0;
   }
}
void P4A_scmp_kernel_15(float FIR_COEFF[8], float Signal_Q[(8/2*8*sizeof(int32_t)+6/2)*4], float channel_Q[(8/2*8*sizeof(int32_t)+6/2)*4], int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t i, n;
   for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 1) {
      x_buffer_user1[(*ptr_x_buffer_user1)++] = Signal_Q[i];
      *ptr_x_buffer_user1 %= 8;
      for(n = 8-1; n >= 0; n += -1) {
         channel_Q[i] += FIR_COEFF[n]*x_buffer_user1[(*ptr_x_buffer_user1)++];
         *ptr_x_buffer_user1 %= 8;
      }
   }
}
void P4A_scmp_kernel_16(float FIR2_I_user1[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t u;
   
   
   
   //------------------------------------------ RECEPT FRAME -----------------------------------------------
   
   //---- FIR for I and Q after channel
   
   for(u = 0; u <= (8/2*8*sizeof(int32_t)+6/2)*4-1; u += 1)
      FIR2_I_user1[u] = 0;
}
void P4A_scmp_kernel_17(float FIR2_Q_user1[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t u;
   for(u = 0; u <= (8/2*8*sizeof(int32_t)+6/2)*4-1; u += 1)
      FIR2_Q_user1[u] = 0;
}
void P4A_scmp_kernel_18(int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t u;
   {

      int task;
#pragma   scmp task
      task = 0;
      for(u = 0; u <= 7; u += 1)
         x_buffer_user1[u] = 0;
      *ptr_x_buffer_user1 = 0;
   }
}
void P4A_scmp_kernel_19(float FIR2_I_user1[(8/2*8*sizeof(int32_t)+6/2)*4], float FIR_COEFF[8], float channel_I[(8/2*8*sizeof(int32_t)+6/2)*4], int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t i, n;
   //convolution par la réponse impultionelle du filtre (FIR_COEFF)
   for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 1) {
      x_buffer_user1[(*ptr_x_buffer_user1)++] = channel_I[i];
      *ptr_x_buffer_user1 %= 8;
      for(n = 8-1; n >= 0; n += -1) {
         FIR2_I_user1[i] += FIR_COEFF[n]*x_buffer_user1[(*ptr_x_buffer_user1)++];
         *ptr_x_buffer_user1 %= 8;
      }
   }
}
void P4A_scmp_kernel_2(int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   //initialisation
   for(i = 8*8*sizeof(int32_t); i <= 8*8*sizeof(int32_t)+6-1; i += 1)
      spreading_signals[i] = 0;
}
void P4A_scmp_kernel_20(int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t u;
   {

      int task;
#pragma   scmp task
      task = 0;
      for(u = 0; u <= 7; u += 1)
         x_buffer_user1[u] = 0;
      *ptr_x_buffer_user1 = 0;
   }
}
void P4A_scmp_kernel_21(float FIR2_Q_user1[(8/2*8*sizeof(int32_t)+6/2)*4], float FIR_COEFF[8], float channel_Q[(8/2*8*sizeof(int32_t)+6/2)*4], int32_t *ptr_x_buffer_user1, float x_buffer_user1[8])
{
   //PIPS generated variable
   int32_t i, n;
   for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 1) {
      x_buffer_user1[(*ptr_x_buffer_user1)++] = channel_Q[i];
      *ptr_x_buffer_user1 %= 8;
      for(n = 8-1; n >= 0; n += -1) {
         FIR2_Q_user1[i] += FIR_COEFF[n]*x_buffer_user1[(*ptr_x_buffer_user1)++];
         *ptr_x_buffer_user1 %= 8;
      }
   }
}
void P4A_scmp_kernel_22(float FIR2_I_user1[(8/2*8*sizeof(int32_t)+6/2)*4], float FIR2_Q_user1[(8/2*8*sizeof(int32_t)+6/2)*4], int32_t R_pilot[8*8*sizeof(int32_t)+6], int32_t inv_qpsk_user1[8*8*sizeof(int32_t)+6], int32_t *j, int32_t t)
{
   //PIPS generated variable
   int32_t i;
   {
      
      
      
      //---- QPSK-1 (+ parallel to serial)
      int task;
#pragma   scmp task
      task = 0;
      if (t%10==0) {
         *j = 0;
         for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 4) {
            //It is a cosinus, so the first bit out of 4 sampled gives
            //the sign of the symbol and the amplitude of the signal.
            R_pilot[*j] = (int32_t) FIR2_I_user1[i];
            R_pilot[*j+1] = (int32_t) FIR2_Q_user1[i];
            *j += 2;
         }
      }
      else {
         *j = 0;
         for(i = 0; i <= (8/2*8*sizeof(int32_t)+6/2)*4-1; i += 4) {
            //It is a cosinus, so the first bit out of 4 sampled gives
            //the sign of the symbol and the amplitude of the signal.
            inv_qpsk_user1[*j] = (int32_t) FIR2_I_user1[i];
            inv_qpsk_user1[*j+1] = (int32_t) FIR2_Q_user1[i];
            *j += 2;
         }
      }
   }
}
void P4A_scmp_kernel_23(int32_t R_pilot[8*8*sizeof(int32_t)+6], int32_t S_pilot[8*sizeof(int32_t)], int32_t coeff[6], int32_t coeff2[6], int32_t finger_mat[8*sizeof(int32_t)][6], int *flag, int *j_bkp, int32_t *max, int32_t *retro_loop_count, int32_t t)
{
   //PIPS generated variable
   int32_t c, d, i;
   {
      int task, j;
#pragma   scmp task
      task = 0;
      if (t%10==0) {
         //initialisation
         for(j = 0; j <= 5; j += 1) {
            coeff[j] = 0;
            coeff2[j] = 0;
         }

         *retro_loop_count = 0;
         *flag = 1;
         while (*flag==1) {
            //estimation:
            *flag = 0;
            
            //create matrix
            for(c = 0; c <= 8*sizeof(int32_t)-1; c += 1) {
               for(i = 0; i <= 5; i += 1)
                  finger_mat[c][i] = 0;
               //initialisation
               for(j = 0; j <= 5; j += 1)
                  //for each finger... (code on the signal shifted to the right)
                  for(d = 0; d <= 7; d += 1)
                     finger_mat[c][j] += R_pilot[c*8+d+j];
            }
            
            //calculate the channel coefficients
            for(j = 0; j <= 5; j += 1) {
               coeff2[j] = 0;
               for(c = 0; c <= 8*sizeof(int32_t)-1; c += 1)
                  if (S_pilot[c]==0)
                     coeff2[j] += finger_mat[c][j]*(-1);
                  else
                     coeff2[j] += finger_mat[c][j]*1;
            }
            
            //calculating max power received
            *max = 0;
            for(j = 0; j <= 5; j += 1)
               if (coeff2[j]>*max) 
                  *max = coeff2[j];
            if (*max>=8*8*sizeof(int32_t)) {
               
               //retroaction
               j = 0;
               while (j<6) {

                  if (*retro_loop_count>6) {

                     *j_bkp = j;
                     j = 6;
                  }
                  else if (coeff2[j]>=*max) {
                     coeff[j]++;
                     for(c = 0; c <= 8*sizeof(int32_t)-1; c += 1)
                        for(d = 0; d <= 7; d += 1)
                           if (S_pilot[c]==1)
                              R_pilot[c*8+d+j] -= 1;
                           else
                              R_pilot[c*8+d+j] += 1;
                     (*retro_loop_count)++;
                     *flag = 1;
                     *j_bkp = j;
                     j = 6;
                  }
                  j++;
               }
               j = *j_bkp;
            }
         }
      }
   }
}
void P4A_scmp_kernel_24(int32_t coeff[6], int32_t *data, int32_t finger[6], int32_t inv_qpsk_user1[8*8*sizeof(int32_t)+6], int32_t ovsf_code_user1[8], int32_t symbole_flow[8*sizeof(int32_t)], int32_t t)
{
   //PIPS generated variable
   int32_t c, d, data_bit, fingers, i, j;
   {
      int task;
#pragma   scmp task
      task = 0;
      if (t%10!=0) {
         *data = 0;
         for(c = 0; c <= 8*sizeof(int32_t)-1; c += 1) {
            fingers = 0;
            for(i = 0; i <= 5; i += 1)
               finger[i] = 0;
            for(j = 0; j <= 5; j += 1)
               //for each finger... (code on the signal shifted to the right)
               for(d = 0; d <= 7; d += 1)
                  finger[j] += inv_qpsk_user1[c*8+d+j]*ovsf_code_user1[d];
            //cout<<endl;
            for(i = 0; i <= 5; i += 1)
               fingers += coeff[i]*finger[i];
            if (fingers>0)
               data_bit = 1;
            else
               data_bit = 0;
            *data = *data|data_bit<<c;
            symbole_flow[c] = data_bit;
         }
      }
   }
}
void P4A_scmp_kernel_3(int32_t channel_delay1, int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   
   //other path
   for(i = channel_delay1; i <= 8*8*sizeof(int32_t)+channel_delay1-1; i += 1)
      spreading_signals[i] += spreading_signal1[i-channel_delay1];
}
void P4A_scmp_kernel_4(int32_t channel_delay2, int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   for(i = channel_delay2; i <= 8*8*sizeof(int32_t)+channel_delay2-1; i += 1)
      spreading_signals[i] += spreading_signal1[i-channel_delay2];
}
void P4A_scmp_kernel_5(int32_t channel_delay3, int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   for(i = channel_delay3; i <= 8*8*sizeof(int32_t)+channel_delay3-1; i += 1)
      spreading_signals[i] += spreading_signal1[i-channel_delay3];
}
void P4A_scmp_kernel_6(int32_t channel_delay4, int32_t spreading_signal1[8*8*sizeof(int32_t)+6], int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   
   
   for(i = channel_delay4; i <= 8*8*sizeof(int32_t)+channel_delay4-1; i += 1)
      spreading_signals[i] += spreading_signal1[i-channel_delay4];
}
void P4A_scmp_kernel_7(int32_t I_user[8/2*8*sizeof(int32_t)+6/2], int32_t Q_user[8/2*8*sizeof(int32_t)+6/2], int32_t *j, int32_t spreading_signals[8*8*sizeof(int32_t)+6])
{
   //PIPS generated variable
   int32_t i;
   //printf("\n");
   
   
   
   //------------------------------------------ SEND FRAME -----------------------------------------------
   //---- Conversion serial to parallel
   for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 2) {
      I_user[*j] = spreading_signals[i];
      Q_user[*j] = spreading_signals[i+1];
      (*j)++;
   }
}
void P4A_scmp_kernel_8(int32_t I_user[8/2*8*sizeof(int32_t)+6/2], float Signal_I[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t h, i;
   //---- Modulation QPSK on I
   for(i = 0; i <= 8/2*8*sizeof(int32_t)+6/2-1; i += 1)
      //Phase = Sign of I_user
      for(h = 0; h <= 3; h += 1)
         Signal_I[i*4+h] = 1.0*I_user[i]*cos(h*2*3.14159265358979323846/(4-1));
}
void P4A_scmp_kernel_9(int32_t Q_user[8/2*8*sizeof(int32_t)+6/2], float Signal_Q[(8/2*8*sizeof(int32_t)+6/2)*4])
{
   //PIPS generated variable
   int32_t h, i;
   
   //---- Modulation QPSK on Q -- we suppose that we dephase it after of PI/2
   for(i = 0; i <= 8*8*sizeof(int32_t)/2+6/2-1; i += 1)
      //Phase = Sign of Q_user
      for(h = 0; h <= 3; h += 1)
         Signal_Q[i*4+h] = 1.0*Q_user[i]*cos(h*2*3.14159265358979323846/(4-1));
}
void P4A_scmp_malloc(void **dest, size_t n)
{

   if (*dest==(void *) 0) 
      *dest = malloc(n);
}
void P4A_scmp_read(const int *in_address, int *out_address, size_t n)
{
   memcpy(in_address, out_address, n);
}
void P4A_scmp_write(void *out_address, const void *buffer_address, size_t n)
{
   memcpy(out_address, buffer_address, n);
}
int main()
{

   unsigned char image_in[512*1024];
   unsigned char image_out[512*1024];

   int32_t img_index = 0;
   
   //Local variables
   //loop counter
   int32_t i, j, d, c, h, u, n, t;
   
   //Sending...	
   //generate frame
   int32_t data = 0, data_bit;
   int32_t symbole_flow_user1[8*sizeof(int32_t)];
   
   //spreading
   int32_t ovsf_code_user1[8] = {-1, -1, 1, 1, -1, -1, 1, 1};
   //user code
   int32_t pilot[8*sizeof(int32_t)] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   int32_t spreading_signal1[8*8*sizeof(int32_t)+6];
   int32_t spreading_signals[8*8*sizeof(int32_t)+6];
   int32_t channel_delay1 = 0, channel_delay2 = 0, channel_delay3 = 0, channel_delay4 = 0;
   
   //demux
   int32_t I_user[8/2*8*sizeof(int32_t)+6/2];
   int32_t Q_user[8/2*8*sizeof(int32_t)+6/2];
   float Signal_I[(8/2*8*sizeof(int32_t)+6/2)*4];
   float Signal_Q[(8/2*8*sizeof(int32_t)+6/2)*4];
   
   //filter
   float FIR_COEFF[8] = {1, 0, 0, 0, 0, 0, 0, 0};
   //filter coeff
   float x_buffer_user1[8];
   //buffer for convolution
   int32_t ptr_x_buffer_user1;
   float channel_I[(8/2*8*sizeof(int32_t)+6/2)*4];
   float channel_Q[(8/2*8*sizeof(int32_t)+6/2)*4];
   float FIR2_I_user1[(8/2*8*sizeof(int32_t)+6/2)*4];
   float FIR2_Q_user1[(8/2*8*sizeof(int32_t)+6/2)*4];
   
   //inv qpsk
   int32_t *destination;
   int32_t inv_qpsk_user1[8*8*sizeof(int32_t)+6];
   int32_t R_pilot[8*8*sizeof(int32_t)+6];
   
   //channel estimation
   int32_t retro_loop_count = 0;
   int32_t finger_mat[8*sizeof(int32_t)][6];
   int32_t coeff[6];
   int32_t coeff2[6];
   //for the temporary coeff calculated before retroaction loop
   int32_t max;
   int32_t S_pilot[8*sizeof(int32_t)] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   //sent pilots
   
   //rake receiver
   int32_t finger[6];
   int32_t fingers;
   int32_t symbole_flow[8*sizeof(int32_t)];

   int32_t found_error;
   
   //for read & write
   int32_t write;
   int flag = 1;
   int j_bkp;
   unsigned char init = 0;
   //PIPS generated variable
   int32_t (*P_0)[8*sizeof(int32_t)] = (int32_t (*)[8*sizeof(int32_t)]) 0, (*P_1)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_2)[8*sizeof(int32_t)] = (int32_t (*)[8*sizeof(int32_t)]) 0, (*P_3)[8] = (int32_t (*)[8]) 0;
   //PIPS generated variable
   unsigned char (*P_4)[512*1024] = (unsigned char (*)[512*1024]) 0;
   //PIPS generated variable
   int32_t (*P_5)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_6)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0;
   //PIPS generated variable
   float (*P_7)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_8)[8] = (float (*)[8]) 0, (*P_9)[8] = (float (*)[8]) 0, (*P_10)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_11)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_12)[8] = (float (*)[8]) 0, (*P_13)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_14)[8] = (float (*)[8]) 0, (*P_15)[8] = (float (*)[8]) 0, (*P_16)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_17)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_18)[8] = (float (*)[8]) 0, (*P_19)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_20)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_21)[8] = (float (*)[8]) 0, (*P_22)[8] = (float (*)[8]) 0, (*P_23)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_24)[8] = (float (*)[8]) 0, (*P_25)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0;
   //PIPS generated variable
   int32_t (*P_26)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0;
   //PIPS generated variable
   float (*P_27)[8] = (float (*)[8]) 0, (*P_28)[8] = (float (*)[8]) 0, (*P_29)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_30)[8] = (float (*)[8]) 0, (*P_31)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0;
   //PIPS generated variable
   int32_t (*P_32)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_33)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0;
   //PIPS generated variable
   float (*P_34)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0, (*P_35)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0;
   //PIPS generated variable
   int32_t (*P_36)[8*sizeof(int32_t)][6] = (int32_t (*)[8*sizeof(int32_t)][6]) 0, (*P_37)[6] = (int32_t (*)[6]) 0, (*P_38)[6] = (int32_t (*)[6]) 0, (*P_39)[8*sizeof(int32_t)] = (int32_t (*)[8*sizeof(int32_t)]) 0, (*P_40)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_41)[8*sizeof(int32_t)] = (int32_t (*)[8*sizeof(int32_t)]) 0, (*P_42)[8] = (int32_t (*)[8]) 0, (*P_43)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_44)[6] = (int32_t (*)[6]) 0, (*P_45)[6] = (int32_t (*)[6]) 0, (*P_46)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_47)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_48)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_49)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_50)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_51)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_52)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_53)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_54)[8*8*sizeof(int32_t)+6] = (int32_t (*)[8*8*sizeof(int32_t)+6]) 0, (*P_55)[8/2*8*sizeof(int32_t)+6/2] = (int32_t (*)[8/2*8*sizeof(int32_t)+6/2]) 0, (*P_56)[8/2*8*sizeof(int32_t)+6/2] = (int32_t (*)[8/2*8*sizeof(int32_t)+6/2]) 0;
   //PIPS generated variable
   float (*P_57)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0;
   //PIPS generated variable
   int32_t (*P_58)[8/2*8*sizeof(int32_t)+6/2] = (int32_t (*)[8/2*8*sizeof(int32_t)+6/2]) 0;
   //PIPS generated variable
   float (*P_59)[(8/2*8*sizeof(int32_t)+6/2)*4] = (float (*)[(8/2*8*sizeof(int32_t)+6/2)*4]) 0;
   //PIPS generated variable
   int32_t (*P_60)[8/2*8*sizeof(int32_t)+6/2] = (int32_t (*)[8/2*8*sizeof(int32_t)+6/2]) 0;
   srand(0);
   //init the input image
   for(i = 0; i <= 524287; i += 1)
      ((unsigned char *) P4A_scmp_flow(image_in))[i] = init++;
   //(unsigned char) (rand()%256);
   
   
   //Loop on the number of frame. The number of frame is made of "nb data frame" + "nb pilot frame". 
   //Pilot frames are added to initial frames for the channel estimation.
   for(t = 0; t <= 512*1024/sizeof(int32_t)+512*1024/sizeof(int32_t)/(10-1)+1-1; t += 1) {
      P4A_scmp_malloc(&P_4, sizeof(unsigned char[512*1024])-1+1);
      P4A_scmp_malloc(&P_3, sizeof(int32_t[8])-1+1);
      P4A_scmp_malloc(&P_2, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_malloc(&P_1, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_0, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_read(image_in, *P_4, sizeof(unsigned char[512*1024])-1+1);
      P4A_scmp_read(ovsf_code_user1, *P_3, sizeof(int32_t[8])-1+1);
      P4A_scmp_read(pilot, *P_2, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_read(spreading_signal1, *P_1, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(symbole_flow_user1, *P_0, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_kernel_0(&channel_delay1, &channel_delay2, &channel_delay3, &channel_delay4, &data, *P_4, img_index, *P_3, *P_2, *P_1, *P_0, t);
      P4A_scmp_write(spreading_signal1, *P_1, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_write(symbole_flow_user1, *P_0, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_malloc(&P_6, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_5, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signal1, *P_6, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_5, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //generate multipath
      //main path
      P4A_scmp_kernel_1(*P_6, *P_5);
      P4A_scmp_write(spreading_signals, *P_5, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);

      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      P4A_scmp_malloc(&P_26, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_26, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      //initialisation
      P4A_scmp_kernel_2(*P_26);
      P4A_scmp_write(spreading_signals, *P_26, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);

      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      P4A_scmp_malloc(&P_47, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_46, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signal1, *P_47, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_46, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      
      //other path
      P4A_scmp_kernel_3(channel_delay1, *P_47, *P_46);
      P4A_scmp_write(spreading_signals, *P_46, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);

      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      P4A_scmp_malloc(&P_49, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_48, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signal1, *P_49, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_48, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      P4A_scmp_kernel_4(channel_delay2, *P_49, *P_48);
      P4A_scmp_write(spreading_signals, *P_48, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);

      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      P4A_scmp_malloc(&P_51, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_50, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signal1, *P_51, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_50, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      P4A_scmp_kernel_5(channel_delay3, *P_51, *P_50);
      P4A_scmp_write(spreading_signals, *P_50, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      P4A_scmp_malloc(&P_53, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_52, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signal1, *P_53, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(spreading_signals, *P_52, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      
      
      P4A_scmp_kernel_6(channel_delay4, *P_53, *P_52);
      P4A_scmp_write(spreading_signals, *P_52, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);

      for(i = 0; i <= 8*8*sizeof(int32_t)+6-1; i += 1)
         ;
      j = 0;
      P4A_scmp_malloc(&P_56, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_malloc(&P_55, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_malloc(&P_54, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(I_user, *P_56, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_read(Q_user, *P_55, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_read(spreading_signals, *P_54, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      //printf("\n");
      
      
      
      //------------------------------------------ SEND FRAME -----------------------------------------------
      //---- Conversion serial to parallel
      P4A_scmp_kernel_7(*P_56, *P_55, &j, *P_54);
      P4A_scmp_write(I_user, *P_56, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_write(Q_user, *P_55, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_malloc(&P_58, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_malloc(&P_57, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(I_user, *P_58, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_read(Signal_I, *P_57, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      //---- Modulation QPSK on I
      P4A_scmp_kernel_8(*P_58, *P_57);
      P4A_scmp_write(Signal_I, *P_57, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_60, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_malloc(&P_59, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(Q_user, *P_60, sizeof(int32_t[8/2*8*sizeof(int32_t)+6/2])-1+1);
      P4A_scmp_read(Signal_Q, *P_59, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      
      //---- Modulation QPSK on Q -- we suppose that we dephase it after of PI/2
      P4A_scmp_kernel_9(*P_60, *P_59);
      P4A_scmp_write(Signal_Q, *P_59, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_7, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(channel_I, *P_7, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      
      
      //---- FIR for I and Q before channel
      
      
      //initialisation
      P4A_scmp_kernel_10(*P_7);
      P4A_scmp_write(channel_I, *P_7, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_8, sizeof(float[8])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_8, sizeof(float[8])-1+1);
      P4A_scmp_kernel_11(&ptr_x_buffer_user1, *P_8);
      P4A_scmp_write(x_buffer_user1, *P_8, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_12, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_11, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_10, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_9, sizeof(float[8])-1+1);
      P4A_scmp_read(FIR_COEFF, *P_12, sizeof(float[8])-1+1);
      P4A_scmp_read(Signal_I, *P_11, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(channel_I, *P_10, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_9, sizeof(float[8])-1+1);
      
      //convolution par la réponse impultionelle du filtre (FIR_COEFF)
      P4A_scmp_kernel_12(*P_12, *P_11, *P_10, &ptr_x_buffer_user1, *P_9);
      P4A_scmp_write(channel_I, *P_10, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_write(x_buffer_user1, *P_9, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_13, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(channel_Q, *P_13, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      
      //initialisation
      P4A_scmp_kernel_13(*P_13);
      P4A_scmp_write(channel_Q, *P_13, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_14, sizeof(float[8])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_14, sizeof(float[8])-1+1);
      P4A_scmp_kernel_14(&ptr_x_buffer_user1, *P_14);
      P4A_scmp_write(x_buffer_user1, *P_14, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_18, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_17, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_16, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_15, sizeof(float[8])-1+1);
      P4A_scmp_read(FIR_COEFF, *P_18, sizeof(float[8])-1+1);
      P4A_scmp_read(Signal_Q, *P_17, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(channel_Q, *P_16, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_15, sizeof(float[8])-1+1);
      P4A_scmp_kernel_15(*P_18, *P_17, *P_16, &ptr_x_buffer_user1, *P_15);
      P4A_scmp_write(channel_Q, *P_16, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_write(x_buffer_user1, *P_15, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_19, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(FIR2_I_user1, *P_19, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      
      
      
      //------------------------------------------ RECEPT FRAME -----------------------------------------------
      
      //---- FIR for I and Q after channel
      
      P4A_scmp_kernel_16(*P_19);
      P4A_scmp_write(FIR2_I_user1, *P_19, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_20, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(FIR2_Q_user1, *P_20, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_kernel_17(*P_20);
      P4A_scmp_write(FIR2_Q_user1, *P_20, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_21, sizeof(float[8])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_21, sizeof(float[8])-1+1);
      P4A_scmp_kernel_18(&ptr_x_buffer_user1, *P_21);
      P4A_scmp_write(x_buffer_user1, *P_21, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_25, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_24, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_23, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_22, sizeof(float[8])-1+1);
      P4A_scmp_read(FIR2_I_user1, *P_25, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(FIR_COEFF, *P_24, sizeof(float[8])-1+1);
      P4A_scmp_read(channel_I, *P_23, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_22, sizeof(float[8])-1+1);
      //convolution par la réponse impultionelle du filtre (FIR_COEFF)
      P4A_scmp_kernel_19(*P_25, *P_24, *P_23, &ptr_x_buffer_user1, *P_22);
      P4A_scmp_write(FIR2_I_user1, *P_25, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_write(x_buffer_user1, *P_22, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_27, sizeof(float[8])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_27, sizeof(float[8])-1+1);
      P4A_scmp_kernel_20(&ptr_x_buffer_user1, *P_27);
      P4A_scmp_write(x_buffer_user1, *P_27, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_31, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_30, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_29, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_28, sizeof(float[8])-1+1);
      P4A_scmp_read(FIR2_Q_user1, *P_31, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(FIR_COEFF, *P_30, sizeof(float[8])-1+1);
      P4A_scmp_read(channel_Q, *P_29, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(x_buffer_user1, *P_28, sizeof(float[8])-1+1);
      P4A_scmp_kernel_21(*P_31, *P_30, *P_29, &ptr_x_buffer_user1, *P_28);
      P4A_scmp_write(FIR2_Q_user1, *P_31, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_write(x_buffer_user1, *P_28, sizeof(float[8])-1+1);
      P4A_scmp_malloc(&P_35, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_34, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_malloc(&P_33, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_32, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(FIR2_I_user1, *P_35, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(FIR2_Q_user1, *P_34, sizeof(float[(8/2*8*sizeof(int32_t)+6/2)*4])-1+1);
      P4A_scmp_read(R_pilot, *P_33, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(inv_qpsk_user1, *P_32, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_kernel_22(*P_35, *P_34, *P_33, *P_32, &j, t);
      P4A_scmp_write(R_pilot, *P_33, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_write(inv_qpsk_user1, *P_32, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_40, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_39, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_malloc(&P_38, sizeof(int32_t[6])-1+1);
      P4A_scmp_malloc(&P_37, sizeof(int32_t[6])-1+1);
      P4A_scmp_malloc(&P_36, sizeof(int32_t[8*sizeof(int32_t)][6])-1+1);
      P4A_scmp_read(R_pilot, *P_40, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(S_pilot, *P_39, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_read(coeff, *P_38, sizeof(int32_t[6])-1+1);
      P4A_scmp_read(coeff2, *P_37, sizeof(int32_t[6])-1+1);
      P4A_scmp_read(finger_mat, *P_36, sizeof(int32_t[8*sizeof(int32_t)][6])-1+1);
      P4A_scmp_kernel_23(*P_40, *P_39, *P_38, *P_37, *P_36, &flag, &j_bkp, &max, &retro_loop_count, t);
      P4A_scmp_write(R_pilot, *P_40, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_write(coeff, *P_38, sizeof(int32_t[6])-1+1);
      P4A_scmp_write(coeff2, *P_37, sizeof(int32_t[6])-1+1);
      P4A_scmp_write(finger_mat, *P_36, sizeof(int32_t[8*sizeof(int32_t)][6])-1+1);
      P4A_scmp_malloc(&P_45, sizeof(int32_t[6])-1+1);
      P4A_scmp_malloc(&P_44, sizeof(int32_t[6])-1+1);
      P4A_scmp_malloc(&P_43, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_malloc(&P_42, sizeof(int32_t[8])-1+1);
      P4A_scmp_malloc(&P_41, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_read(coeff, *P_45, sizeof(int32_t[6])-1+1);
      P4A_scmp_read(finger, *P_44, sizeof(int32_t[6])-1+1);
      P4A_scmp_read(inv_qpsk_user1, *P_43, sizeof(int32_t[8*8*sizeof(int32_t)+6])-1+1);
      P4A_scmp_read(ovsf_code_user1, *P_42, sizeof(int32_t[8])-1+1);
      P4A_scmp_read(symbole_flow, *P_41, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      P4A_scmp_kernel_24(*P_45, &data, *P_44, *P_43, *P_42, *P_41, t);
      P4A_scmp_write(finger, *P_44, sizeof(int32_t[6])-1+1);
      P4A_scmp_write(symbole_flow, *P_41, sizeof(int32_t[8*sizeof(int32_t)])-1+1);
      
      //---- Store result
      if (t%10!=0) {
         //store received frame in image_out
         image_out[img_index] = (data&0x000000FF)>>0;
         image_out[img_index+1] = (data&0x0000FF00)>>8;
         image_out[img_index+2] = (data&0x00FF0000)>>16;
         image_out[img_index+3] = (data&0xFF000000)>>24;

         img_index += 4;
         //for next frame, increment index by size of frame
         
         for(d = 0; d <= 8*sizeof(int32_t)-1; d += 1)
            ;
      }
   }
   return 0;
}
