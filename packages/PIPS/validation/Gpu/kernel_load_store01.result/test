void give()
{
//               <must be written>: j
   int j = 3;
   double array[N];
//               <may be written >: array[*]
//               <must be read   >: j
//               <must be written>: j

   change(&j, array);
}
//               <may be written >: array[*]
//               <must be read   >: i i[0]
//               <must be written>: i[0]
void change(int *i, double array[N])
{
   int k;
//               <must be read   >: i i[0]
//               <must be written>: i[0]

   (*i)++;
//               <may be read    >: k
//               <may be written >: array[*]
//               <must be written>: k

   for(k = 0; k <= 99; k += 1)
//               <may be written >: array[*]
//               <must be read   >: k
      array[k] = 0;
}
void give()
{
//               <must be written>: j
   int j = 3;
   double array[N];
//               <may be written >: array[*]
//               <must be read   >: j
//               <must be written>: j

   change(&j, array);
}
//               <may be written >: array[*]
//               <must be read   >: i i[0]
//               <must be written>: i[0]
void change(int *i, double array[N])
{
   int k;
//               <must be read   >: i i[0]
//               <must be written>: i[0]

   (*i)++;
//               <may be read    >: k
//               <may be written >: array[*]
//               <must be written>: k

   for(k = 0; k <= 99; k += 1)
//               <may be written >: array[*]
//               <must be read   >: k
      array[k] = 0;
}
void P4A_accel_free(void **ptr)
{
   free(*ptr);
   *ptr = (void *) 0;
}
void P4A_accel_malloc(void **ptr, size_t n)
{
   if (n)
      *ptr = malloc(n);
   else
      *ptr = (void *) 0;
}
void * P4A_copy_from_accel(void *dest, const void *src, size_t size, size_t d1_length, size_t d1_offset, size_t d1_block_length)
{
   size_t i, l;

   char *cdest = (char *) dest, *csrc = (char *) src;
   for(i = 0; i <= d1_block_length-1; i += 1)
      for(l = 0; l <= size-1; l += 1)
         cdest[(i+d1_offset)*size+l] = csrc[i*size+l];
   return dest;
}
void * P4A_copy_from_accel2d(void *dest, const void *src, size_t size, size_t d1_length, size_t d2_length, size_t d1_offset, size_t d2_offset, size_t d1_block_length, size_t d2_block_length)
{
   size_t i, j, l;

   char *cdest = (char *) dest, *csrc = (char *) src;
   for(i = 0; i <= d1_block_length-1; i += 1)
      for(j = 0; j <= d2_block_length-1; j += 1)
         for(l = 0; l <= size-1; l += 1)
            cdest[(i+d1_offset)*size*d2_length+(j+d2_offset)*size+l] = csrc[i*size*d2_block_length+j*size+l];
   return dest;
}
void * P4A_copy_to_accel(void *dest, const void *src, size_t size, size_t d1_length, size_t d1_offset, size_t d1_block_length)
{
   size_t i, l;

   char *cdest = (char *) dest, *csrc = (char *) src;
   for(i = 0; i <= d1_block_length-1; i += 1)
      for(l = 0; l <= size-1; l += 1)
         cdest[i*size+l] = csrc[(i+d1_offset)*size+l];
   return dest;
}
void * P4A_copy_to_accel2d(void *dest, const void *src, size_t size, size_t d1_length, size_t d2_length, size_t d1_offset, size_t d2_offset, size_t d1_block_length, size_t d2_block_length)
{
   size_t i, j, l;

   char *cdest = (char *) dest, *csrc = (char *) src;
   for(i = 0; i <= d1_block_length-1; i += 1)
      for(j = 0; j <= d2_block_length-1; j += 1)
         for(l = 0; l <= size-1; l += 1)
            cdest[i*size*d2_block_length+j*size+l] = csrc[(i+d1_offset)*size*d2_length+(j+d2_offset)*size+l];
   return dest;
}
void change(int *i, double array[N])
{
   int k;

   (*i)++;

   for(k = 0; k <= 99; k += 1)
      array[k] = 0;
}
void give()
{
   int j = 3;
   double array[N];
   {
      //PIPS generated variable
      double (*array0)[N] = (double (*)[N]) 0;
      P4A_accel_malloc((void **) &array0, sizeof(double)*100);


      change(&j, (*array0));
      P4A_copy_from_accel(&array[0], *array0, sizeof(double), 100, 0, 100);
      P4A_accel_free((void **) &array0);
   }
}

Unsplit resulting code

/*
 * file for kernel_load_store01.c
 */
/* Test kernel_load_store on a scalar modification.

   Assume that only the pointed scalar is touched, since it is often the
   case for generated code given to kernel_load_store
*/
enum {N=100};

void change(int *i, double array[N]);

void give();
//PIPS generated variable
typedef unsigned int size_t;
//PIPS generated variable
void P4A_accel_malloc(void **ptr, size_t n);
//PIPS generated variable
void *P4A_copy_from_accel(void *dest, const void *src, size_t size, size_t d1_length, size_t d1_offset, size_t d1_block_length);
//PIPS generated variable
void P4A_accel_free(void **ptr);
void change(int *i, double array[N])
{
   int k;

   (*i)++;

   for(k = 0; k <= 99; k += 1)
      array[k] = 0;
}
void give()
{
   int j = 3;
   double array[N];
   {
      //PIPS generated variable
      double (*array0)[N] = (double (*)[N]) 0;
      P4A_accel_malloc((void **) &array0, sizeof(double)*100);


      change(&j, (*array0));
      P4A_copy_from_accel(&array[0], *array0, sizeof(double), 100, 0, 100);
      P4A_accel_free((void **) &array0);
   }
}
