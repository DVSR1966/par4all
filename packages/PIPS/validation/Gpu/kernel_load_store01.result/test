void give()
{
//               <must be written>: j
   int j = 3;
   double array[N];
//               <may be written >: array[*]
//               <must be read   >: j
//               <must be written>: j

   change(&j, array);
}
//               <may be written >: array[*]
//               <must be read   >: i i[0]
//               <must be written>: i[0]
void change(int *i, double array[N])
{
   int k;
//               <must be read   >: i i[0]
//               <must be written>: i[0]

   (*i)++;
//               <may be read    >: k
//               <may be written >: array[*]
//               <must be written>: k

   for(k = 0; k <= 99; k += 1)
//               <may be written >: array[*]
//               <must be read   >: k
      array[k] = 0;
}
void give()
{
//               <must be written>: j
   int j = 3;
   double array[N];
//               <may be written >: array[*]
//               <must be read   >: j
//               <must be written>: j

   change(&j, array);
}
//               <may be written >: array[*]
//               <must be read   >: i i[0]
//               <must be written>: i[0]
void change(int *i, double array[N])
{
   int k;
//               <must be read   >: i i[0]
//               <must be written>: i[0]

   (*i)++;
//               <may be read    >: k
//               <may be written >: array[*]
//               <must be written>: k

   for(k = 0; k <= 99; k += 1)
//               <may be written >: array[*]
//               <must be read   >: k
      array[k] = 0;
}
void P4A_accel_free(void *ptr)
{
   free(ptr);
}
void P4A_accel_malloc(void **ptr, size_t n)
{
   if (n)
      *ptr = malloc(n);
   else
      *ptr = (void *) 0;
}
void P4A_copy_from_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = host_address;
   char *csrc = accel_address;
   for(i = 0; i <= element_size-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = d1_offset*element_size+(char *) host_address;
   char *csrc = accel_address;
   for(i = 0; i <= d1_block_size*element_size-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_from_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = d2_offset*element_size+(char *) host_address;
   char *csrc = (char *) accel_address;
   for(i = 0; i <= d1_block_size-1; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1; j += 1)
         cdest[(i+d1_offset)*element_size*d2_size+j] = csrc[i*element_size*d2_block_size+j];
}
void P4A_copy_to_accel(size_t element_size, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = host_address;
   for(i = 0; i <= element_size-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address)
{
   size_t i;
   char *cdest = accel_address;
   char *csrc = d1_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size*element_size-1; i += 1)
      cdest[i] = csrc[i];
}
void P4A_copy_to_accel_2d(size_t element_size, size_t d1_size, size_t d2_size, size_t d1_block_size, size_t d2_block_size, size_t d1_offset, size_t d2_offset, void *host_address, void *accel_address)
{
   size_t i, j;
   char *cdest = (char *) accel_address;
   char *csrc = d2_offset*element_size+(char *) host_address;
   for(i = 0; i <= d1_block_size-1; i += 1)
      for(j = 0; j <= d2_block_size*element_size-1; j += 1)

         cdest[i*element_size*d2_block_size+j] = csrc[(i+d1_offset)*element_size*d2_size+j];
}
void change(int *i, double array[N])
{
   int k;

   (*i)++;

   for(k = 0; k <= 99; k += 1)
      array[k] = 0;
}
void give()
{
   int j = 3;
   double array[N];
   {
      //PIPS generated variable
      double (*array0)[N] = (double (*)[N]) 0;
      P4A_accel_malloc((void **) &array0, sizeof(double)*100);


      change(&j, (*array0));
      P4A_copy_from_accel_1d(sizeof(double), 100, 100, 0, &array[0], *array0);
      P4A_accel_free(array0);
   }
}

Unsplit resulting code

/*
 * file for kernel_load_store01.c
 */
/* Test kernel_load_store on a scalar modification.

   Assume that only the pointed scalar is touched, since it is often the
   case for generated code given to kernel_load_store
*/
enum {N=100};

void change(int *i, double array[N]);

void give();
//PIPS generated variable
typedef unsigned int size_t;
//PIPS generated variable
void P4A_accel_malloc(void **ptr, size_t n), P4A_copy_from_accel_1d(size_t element_size, size_t d1_size, size_t d1_block_size, size_t d1_offset, void *host_address, void *accel_address), P4A_accel_free(void *ptr);
void change(int *i, double array[N])
{
   int k;

   (*i)++;

   for(k = 0; k <= 99; k += 1)
      array[k] = 0;
}
void give()
{
   int j = 3;
   double array[N];
   {
      //PIPS generated variable
      double (*array0)[N] = (double (*)[N]) 0;
      P4A_accel_malloc((void **) &array0, sizeof(double)*100);


      change(&j, (*array0));
      P4A_copy_from_accel_1d(sizeof(double), 100, 100, 0, &array[0], *array0);
      P4A_accel_free(array0);
   }
}
