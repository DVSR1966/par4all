

Source files copied in : md/Source/
Generated source files : md/src
###################### md/src/COMPUTE_PARDO1_HYBRID.f ######################
!!
!! file for COMPUTE_PARDO1_HYBRID.f
!!
      SUBROUTINE COMPUTE_PARDO1_HYBRID(I_DUMMY, I_L, I_U, L, ND, NP, 
     &F, J, BOX, POS, RIJ, D, POT, PI2, K, KIN, VEL)
      implicit none
      include "STEP.h"
      REAL*8 DOTR8
      EXTERNAL DOTR8
      INTEGER*4 MAX_NB_REQUEST
      PARAMETER (MAX_NB_REQUEST = 96)
      INTEGER I_DUMMY, I, I_L, I_U, L, ND, NP, J, K, IDX, I_LOW, I_UP
     &, STEP_I_LOW, STEP_I_UP
      INTEGER STEP_I_LOOPSLICES(IDX_SLICE_LOW:IDX_SLICE_UP, 1:
     &MAX_NB_LOOPSLICES), STEP_SR_F(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 
     &0:MAX_NB_LOOPSLICES), STEP_REQUESTS(1:MAX_NB_REQUEST)
      REAL*8 STEP_POT_REDUC, STEP_KIN_REDUC, F(1:ND, 1:NP), BOX(1:ND)
     &, POS(1:ND, 1:NP), RIJ(1:ND), D, POT, PI2, KIN, VEL(1:ND, 1:NP)
      CALL STEP_GET_SIZE(STEP_COMM_SIZE)                                0130
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0131
      CALL STEP_INITREDUCTION(POT, STEP_POT_REDUC, STEP_SUM,            0132
     &STEP_REAL8)                                                       0132
      CALL STEP_INITREDUCTION(KIN, STEP_KIN_REDUC, STEP_SUM,            0134
     &STEP_REAL8)                                                       0134

      CALL STEP_COMPUTELOOPSLICES(I_L, I_U, 1, STEP_COMM_SIZE,          0137
     &MAX_NB_LOOPSLICES, STEP_I_LOOPSLICES)                             0137

C     Put array boundaries into region arrays (SR: Send region)
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

C     The first element stores initial boundaries,
C     then one element for each process
      STEP_SR_F(IDX_SLICE_LOW,1,0) = 1                                  0147
      STEP_SR_F(IDX_SLICE_UP,1,0) = ND                                  0148
      STEP_SR_F(IDX_SLICE_LOW,2,0) = 1                                  0149
      STEP_SR_F(IDX_SLICE_UP,2,0) = NP                                  0150

C     Region computation
      DO IDX = 1, STEP_COMM_SIZE                                        0153
         I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,IDX)                   0154
         I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,IDX)                     0155
C  <F(PHI1,PHI2)-write-MAY-{1<=PHI1, PHI1<=ND, PHI1<=3, I_LOW<=PHI2,
C    1<=PHI2, PHI2<=I_UP, PHI2<=500}>
         STEP_SR_F(IDX_SLICE_LOW,1,IDX) = 1                             0158
         STEP_SR_F(IDX_SLICE_UP,1,IDX) = MIN(ND, 3)                     0159
         STEP_SR_F(IDX_SLICE_LOW,2,IDX) = MAX(I_LOW, 1)                 0160
         STEP_SR_F(IDX_SLICE_UP,2,IDX) = MIN(I_UP, 500)                 0161
      ENDDO

C     Where work is done...
      STEP_I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,STEP_COMM_RANK+1)    0165
      STEP_I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,STEP_COMM_RANK+1)      0166
!$OMP parallel do reduction(+ : KIN) reduction(+ : POT) private(I, J, K,
!$OMP& RIJ, D)

      DO I = STEP_I_LOW, STEP_I_UP                                      0170
! compute potential energy and forces

!!        f(1:nd,i) = 0.0
         DO L = 1, ND                                                   0174
            F(L,I) = 0.0                                                0175
         ENDDO


         DO J = 1, NP                                                   0179
            IF (I.NE.J) THEN                                            0180
               CALL DIST(ND, BOX, POS(1,I), POS(1,J), RIJ, D)           0181
! attribute half of the potential energy to particle 'j'

               POT = POT+0.5*SIN(MIN(D, PI2))**2.                       0184
               DO K = 1, ND                                             0185
                  F(K,I) = F(K,I)-RIJ(K)*2.*SIN(MIN(D, PI2))*COS(MIN(   0186
     &            D, PI2))/D                                            0186
               ENDDO
            ENDIF
         ENDDO
! compute kinetic energy

         KIN = KIN+DOTR8(ND, VEL(1,I), VEL(1,I))                        0193
      ENDDO
!$OMP end parallel do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
C     A nonblocking algo increment STEP_Nb_Request.
      STEP_NBREQUEST = 0                                                0203
      CALL STEP_ALLTOALLREGION(2, STEP_COMM_SIZE, STEP_SR_F,            0204
     &STEP_SIZEREGION(2, STEP_SR_F(IDX_SLICE_LOW,1,0)), F,              0204
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0204
     &, STEP_NBLOCKING_ALG, STEP_REAL8)                                 0204
C     If STEP_Nb_Request equals 0, STEP_WAITALL does nothing
      CALL STEP_WAITALL(STEP_NBREQUEST, STEP_REQUESTS)                  0209
      CALL STEP_REDUCTION(POT, STEP_POT_REDUC, STEP_SUM, STEP_REAL8)    0210
      CALL STEP_REDUCTION(KIN, STEP_KIN_REDUC, STEP_SUM, STEP_REAL8)    0211

!$omp end master
!$omp barrier

      END
###################### md/src/MD_MASTER1_HYBRID.f ######################
!!
!! file for MD_MASTER1_HYBRID.f
!!
      SUBROUTINE MD_MASTER1_HYBRID(POTENTIAL, KINETIC, E0)
      implicit none
      include "STEP.h"
      REAL*8 POTENTIAL, KINETIC, E0

!$omp master
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0121
      IF (STEP_COMM_RANK.EQ.0) PRINT *, POTENTIAL, KINETIC, (           0122
     &POTENTIAL+KINETIC-E0)/E0                                          0122

!$omp end master
!$omp barrier

      END
###################### md/src/Makefile ######################
#Default Makefile to compile generated files

BIN=a.out

FC=mpif77
CC=mpicc

OpenMP_FLAG = -fopenmp

FLAGS = -g -O2
LDFLAGS = 


CSOURCES= *.c
FSOURCES= *.f
OBJFILES= *.o

LIB_STEP=libstep.a
RUNTIME=c
DIR_STEP=step_rt


$(BIN) : $(DIR_STEP)/$(LIB_STEP) $(OBJFILES)
	if ls  >/dev/null 2>&1 *.o ; then $(FC) $(OBJFILES) $(OpenMP_FLAG) $(LDFLAGS) -lstep -L$(DIR_STEP) -o $@; fi

$(OBJFILES):
	if ls  >/dev/null 2>&1 *.c ; then $(CC) $(OpenMP_FLAG) $(FLAGS) -c $(CSOURCES); fi
	if ls  >/dev/null 2>&1 *.f ; then $(FC) $(OpenMP_FLAG) $(FLAGS) -fno-underscoring -c $(FSOURCES); fi

$(DIR_STEP)/$(LIB_STEP):
	$(MAKE) -C $(DIR_STEP) $(LIB_STEP)

clean:
	$(MAKE) -C $(DIR_STEP) $@
	rm -f *.o *~


.IGNORE: clean###################### md/src/STEP.h ######################
      INCLUDE 'steprt_f.h'

      INTEGER STEP_MAX_NBNODE
      PARAMETER (STEP_MAX_NBNODE = 16)

      INTEGER max_nb_loopslices
      INTEGER step_nbrequest

      INTEGER STEP_COMM_SIZE, STEP_COMM_RANK

      PARAMETER (MAX_NB_LOOPSLICES = STEP_MAX_NBNODE)
      
      ! Globals
       INTEGER STEP_SizeRegion
       INTEGER IDX_SLICE_LOW,IDX_SLICE_UP,STEP_IDX
       PARAMETER (IDX_SLICE_LOW = 1,IDX_SLICE_UP=2)

###################### md/src/UPDATE_PARDO1_HYBRID.f ######################
!!
!! file for UPDATE_PARDO1_HYBRID.f
!!
      SUBROUTINE UPDATE_PARDO1_HYBRID(I_DUMMY, I_L, I_U, J, ND, NP, 
     &POS, VEL, DT, A, F, RMASS)
      implicit none
      include "STEP.h"
      INTEGER*4 MAX_NB_REQUEST
      PARAMETER (MAX_NB_REQUEST = 96)
      INTEGER I_DUMMY, I, I_L, I_U, J, ND, NP, IDX, I_LOW, I_UP, 
     &STEP_I_LOW, STEP_I_UP
      INTEGER STEP_I_LOOPSLICES(IDX_SLICE_LOW:IDX_SLICE_UP, 1:
     &MAX_NB_LOOPSLICES), STEP_SR_POS(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2
     &, 0:MAX_NB_LOOPSLICES), STEP_SR_VEL(IDX_SLICE_LOW:IDX_SLICE_UP
     &, 1:2, 0:MAX_NB_LOOPSLICES), STEP_SR_A(IDX_SLICE_LOW:
     &IDX_SLICE_UP, 1:2, 0:MAX_NB_LOOPSLICES), STEP_REQUESTS(1:
     &MAX_NB_REQUEST)
      REAL*8 POS(1:ND, 1:NP), VEL(1:ND, 1:NP), DT, A(1:ND, 1:NP), F(1
     &:ND, 1:NP), RMASS
      CALL STEP_GET_SIZE(STEP_COMM_SIZE)                                0131
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0132

      CALL STEP_COMPUTELOOPSLICES(I_L, I_U, 1, STEP_COMM_SIZE,          0134
     &MAX_NB_LOOPSLICES, STEP_I_LOOPSLICES)                             0134

C     Put array boundaries into region arrays (SR: Send region)
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

C     The first element stores initial boundaries,
C     then one element for each process
      STEP_SR_POS(IDX_SLICE_LOW,1,0) = 1                                0144
      STEP_SR_POS(IDX_SLICE_UP,1,0) = ND                                0145
      STEP_SR_POS(IDX_SLICE_LOW,2,0) = 1                                0146
      STEP_SR_POS(IDX_SLICE_UP,2,0) = NP                                0147
      STEP_SR_VEL(IDX_SLICE_LOW,1,0) = 1                                0148
      STEP_SR_VEL(IDX_SLICE_UP,1,0) = ND                                0149
      STEP_SR_VEL(IDX_SLICE_LOW,2,0) = 1                                0150
      STEP_SR_VEL(IDX_SLICE_UP,2,0) = NP                                0151
      STEP_SR_A(IDX_SLICE_LOW,1,0) = 1                                  0152
      STEP_SR_A(IDX_SLICE_UP,1,0) = ND                                  0153
      STEP_SR_A(IDX_SLICE_LOW,2,0) = 1                                  0154
      STEP_SR_A(IDX_SLICE_UP,2,0) = NP                                  0155

C     Region computation
      DO IDX = 1, STEP_COMM_SIZE                                        0158
         I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,IDX)                   0159
         I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,IDX)                     0160
C  <POS(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=ND, PHI1<=3,
C    I_LOW<=PHI2, 1<=PHI2, PHI2<=I_UP}>
         STEP_SR_POS(IDX_SLICE_LOW,1,IDX) = 1                           0163
         STEP_SR_POS(IDX_SLICE_UP,1,IDX) = MIN(ND, 3)                   0164
         STEP_SR_POS(IDX_SLICE_LOW,2,IDX) = MAX(I_LOW, 1)               0165
         STEP_SR_POS(IDX_SLICE_UP,2,IDX) = I_UP                         0166
C  <VEL(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=ND, PHI1<=3,
C    I_LOW<=PHI2, 1<=PHI2, PHI2<=I_UP}>
         STEP_SR_VEL(IDX_SLICE_LOW,1,IDX) = 1                           0169
         STEP_SR_VEL(IDX_SLICE_UP,1,IDX) = MIN(ND, 3)                   0170
         STEP_SR_VEL(IDX_SLICE_LOW,2,IDX) = MAX(I_LOW, 1)               0171
         STEP_SR_VEL(IDX_SLICE_UP,2,IDX) = I_UP                         0172
C  <A(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=ND, PHI1<=3, I_LOW<=PHI2,
C    1<=PHI2, PHI2<=I_UP}>
         STEP_SR_A(IDX_SLICE_LOW,1,IDX) = 1                             0175
         STEP_SR_A(IDX_SLICE_UP,1,IDX) = MIN(ND, 3)                     0176
         STEP_SR_A(IDX_SLICE_LOW,2,IDX) = MAX(I_LOW, 1)                 0177
         STEP_SR_A(IDX_SLICE_UP,2,IDX) = I_UP                           0178
      ENDDO

C     Where work is done...
      STEP_I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,STEP_COMM_RANK+1)    0182
      STEP_I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,STEP_COMM_RANK+1)      0183
!$OMP parallel do private(I, J)
      DO I = STEP_I_LOW, STEP_I_UP                                      0185
         DO J = 1, ND                                                   0186
            POS(J,I) = POS(J,I)+VEL(J,I)*DT+0.5*DT*DT*A(J,I)            0187
            VEL(J,I) = VEL(J,I)+0.5*DT*(F(J,I)*RMASS+A(J,I))            0188
            A(J,I) = F(J,I)*RMASS                                       0189
         ENDDO
      ENDDO
!$OMP end parallel do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
C     A nonblocking algo increment STEP_Nb_Request.
      STEP_NBREQUEST = 0                                                0200
      CALL STEP_ALLTOALLREGION(2, STEP_COMM_SIZE, STEP_SR_POS,          0201
     &STEP_SIZEREGION(2, STEP_SR_POS(IDX_SLICE_LOW,1,0)), POS,          0201
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0201
     &, STEP_NBLOCKING_ALG, STEP_REAL8)                                 0201
      CALL STEP_ALLTOALLREGION(2, STEP_COMM_SIZE, STEP_SR_VEL,          0205
     &STEP_SIZEREGION(2, STEP_SR_VEL(IDX_SLICE_LOW,1,0)), VEL,          0205
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0205
     &, STEP_NBLOCKING_ALG, STEP_REAL8)                                 0205
      CALL STEP_ALLTOALLREGION(2, STEP_COMM_SIZE, STEP_SR_A,            0209
     &STEP_SIZEREGION(2, STEP_SR_A(IDX_SLICE_LOW,1,0)), A,              0209
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0209
     &, STEP_NBLOCKING_ALG, STEP_REAL8)                                 0209
C     If STEP_Nb_Request equals 0, STEP_WAITALL does nothing
      CALL STEP_WAITALL(STEP_NBREQUEST, STEP_REQUESTS)                  0214

!$omp end master
!$omp barrier

      END
###################### md/src/md.f ######################
!!
!! file for md.f
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This program implements a simple molecular dynamics simulation,
!   using the velocity Verlet time integration scheme. The particles
!   interact with a central pair potential.
!
! Author:   Bill Magro, Kuck and Associates, Inc. (KAI), 1998
!
! Parallelism is implemented via OpenMP directives.
! THIS PROGRAM USES THE FORTRAN90 RANDOM_NUMBER FUNCTION AND ARRAY 
!   SYNTAX
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      PROGRAM MD
      implicit none

! simulation parameters
      
! dimensionality of the physical space
      INTEGER NDIM       
! number of particles
      INTEGER NPARTS     
! number of time steps in the simulation
      INTEGER NSTEPS     
      PARAMETER(NDIM=3,NPARTS=500,NSTEPS=500)
! mass of the particles
      REAL*8 MASS        
! time step
      REAL*8 DT          
! dimensions of the simulation box
      REAL*8 BOX(NDIM)   
      PARAMETER(MASS=1.0,DT=1.0E-4)

! simulation variables
      
      REAL*8 POSITION(NDIM,NPARTS)
      REAL*8 VELOCITY(NDIM,NPARTS)
      REAL*8 FORCE(NDIM,NPARTS)
      REAL*8 ACCEL(NDIM,NPARTS)
      REAL*8 POTENTIAL, KINETIC, E0
      INTEGER I , L
      CALL STEP_INIT_FORTRAN_ORDER

!!      box(1:ndim) = 10.
      DO L = 1, NDIM                                                    0044
         BOX(L) = 10.                                                   0045
      ENDDO

! set initial positions, velocities, and accelerations

      CALL INITIALIZE(NPARTS, NDIM, BOX, POSITION, VELOCITY, ACCEL)     0050

! compute the forces and energies

      CALL COMPUTE(NPARTS, NDIM, BOX, POSITION, VELOCITY, MASS, FORCE   0054
     &, POTENTIAL, KINETIC)                                             0054
      E0 = POTENTIAL+KINETIC                                            0056

! This is the main time stepping loop

      DO I = 1, NSTEPS                                                  0060
         CALL COMPUTE(NPARTS, NDIM, BOX, POSITION, VELOCITY, MASS,      0061
     &   FORCE, POTENTIAL, KINETIC)                                     0061
C$STEP !$omp master
         CALL MD_MASTER1_HYBRID(POTENTIAL, KINETIC, E0)
C$STEP !$omp end master
         CALL UPDATE(NPARTS, NDIM, POSITION, VELOCITY, FORCE, ACCEL,    0066
     &   MASS, DT)                                                      0066
      ENDDO
      CALL STEP_FINALIZE

      END

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Compute the forces and energies, given positions, masses,
! and velocities
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      SUBROUTINE COMPUTE(NP,ND,BOX,POS,VEL,MASS,F,POT,KIN)
      implicit none

      INTEGER NP
      INTEGER ND
      REAL*8  BOX(ND)
      REAL*8  POS(ND,NP)
      REAL*8  VEL(ND,NP)
      REAL*8  F(ND,NP)
      REAL*8  MASS
      REAL*8  POT
      REAL*8  KIN

      REAL*8 DOTR8
      EXTERNAL DOTR8
      REAL*8 V, DV, X

      INTEGER I, J, K, L
      REAL*8  RIJ(ND)
      REAL*8  D
      REAL*8  PI2
      PARAMETER(PI2=3.14159265D0/2.0D0)

! statement function for the pair potential and its derivative

! This potential is a harmonic well which smoothly saturates to a

! maximum value at PI/2.

C$PIPS STATEMENT FUNCTION V SUBSTITUTED
C$PIPS STATEMENT FUNCTION DV SUBSTITUTED

      POT = 0.0                                                         0039
      KIN = 0.0                                                         0040
C$STEP !$omp parallel do default(shared) private(i,j,k,rij,d) reduction(+ : pot, kin)
      CALL COMPUTE_PARDO1_HYBRID(I, 1, NP, L, ND, NP, F, J, BOX, POS
     &, RIJ, D, POT, PI2, K, KIN, VEL)
      KIN = KIN*0.5*MASS                                                0072

      END
       
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Initialize the positions, velocities, and accelerations.
! The Fortran90 random_number function is used to choose positions.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      SUBROUTINE INITIALIZE(NP,ND,BOX,POS,VEL,ACC)
      implicit none

      INTEGER NP
      INTEGER ND
      REAL*8  BOX(ND)
      REAL*8  POS(ND,NP)
      REAL*8  VEL(ND,NP)
      REAL*8  ACC(ND,NP)

      INTEGER I, J
      REAL*8 X

      DO I = 1, NP                                                      0020
         DO J = 1, ND                                                   0021
            CALL RANDOM_NUMBER(X)                                       0022
            POS(J,I) = BOX(J)*X                                         0023
            VEL(J,I) = 0.0                                              0024
            ACC(J,I) = 0.0                                              0025
         ENDDO
      ENDDO

      END

	SUBROUTINE   RANDOM_NUMBER(X)
	REAL*8 X
      X = 0.0                                                           0004
      END

! Compute the displacement vector (and its norm) between two particles.
      SUBROUTINE DIST(ND,BOX,R1,R2,DR,D)
      implicit none

      INTEGER ND
      REAL*8 BOX(ND)
      REAL*8 R1(ND)
      REAL*8 R2(ND)
      REAL*8 DR(ND)
      REAL*8 D

      INTEGER I

      D = 0.0                                                           0016
      DO I = 1, ND                                                      0017
         DR(I) = R1(I)-R2(I)                                            0018
         D = D+DR(I)**2.                                                0019
      ENDDO
      D = SQRT(D)                                                       0021

      END

! Return the dot product between two vectors of type real*8 and length n
      REAL*8 FUNCTION DOTR8(N,X,Y)
      implicit none

      INTEGER N
      REAL*8 X(N)
      REAL*8 Y(N)

      INTEGER I

      DOTR8 = 0.0                                                       0013
      DO I = 1, N                                                       0014
         DOTR8 = DOTR8+X(I)*Y(I)                                        0015
      ENDDO

      END

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Perform the time integration, using a velocity Verlet algorithm
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      SUBROUTINE UPDATE(NP,ND,POS,VEL,F,A,MASS,DT)
      implicit none

      INTEGER NP
      INTEGER ND
      REAL*8  POS(ND,NP)
      REAL*8  VEL(ND,NP)
      REAL*8  F(ND,NP)
      REAL*8  A(ND,NP)
      REAL*8  MASS
      REAL*8  DT

      INTEGER I, J
      REAL*8  RMASS

      RMASS = 1.0/MASS                                                  0021
C$STEP !$omp parallel do default(shared) private(i,j)
      CALL UPDATE_PARDO1_HYBRID(I, 1, NP, J, ND, NP, POS, VEL, DT, A
     &, F, RMASS)

      END
###################### md/src/step_rt ######################
###################### md/src/steprt_f.h ######################
!*******************************************************************************
!*                                                                             *
!*   Authors 	        :       Abdellah. Kouadri                              *
!*				Daniel Millot                          	       *
!*                              Frederique Silber-Chaussumier                  *
!*				                                               *
!*   Date		:       25/06/2009                                     *
!*						                               *
!*   File		:	steprt_f.h                                     *
!*							                       *
!*   Version		:       1.1				               *
!*   Description	:	Fortran runtime interface                      *
! ******************************************************************************



! Datatype
      INTEGER STEP_INTEGER1
      INTEGER STEP_INTEGER2
      INTEGER STEP_INTEGER4
      INTEGER STEP_INTEGER8
      INTEGER STEP_REAL4
      INTEGER STEP_REAL8
      INTEGER STEP_REAL16
      INTEGER STEP_COMPLEX8
      INTEGER STEP_COMPLEX16
      INTEGER STEP_COMPLEX32
      INTEGER STEP_INTEGER
      INTEGER STEP_REAL
      INTEGER STEP_COMPLEX
      INTEGER STEP_DOUBLE_PRECISION
!
      PARAMETER (STEP_INTEGER1 = 1)
      PARAMETER (STEP_INTEGER2 = 2)
      PARAMETER (STEP_INTEGER4 = 3)
      PARAMETER (STEP_INTEGER8 = 4)
      PARAMETER (STEP_REAL4 = 5)
      PARAMETER (STEP_REAL8 = 6)
      PARAMETER (STEP_REAL16 = 7)
      PARAMETER (STEP_COMPLEX8 = 8)
      PARAMETER (STEP_COMPLEX16 = 9)
      PARAMETER (STEP_COMPLEX32 = 10)
      PARAMETER (STEP_INTEGER = 11)
      PARAMETER (STEP_REAL = 12)
      PARAMETER (STEP_COMPLEX = 13)
      PARAMETER (STEP_DOUBLE_PRECISION = 14)

! Communication tag
      INTEGER   STEP_TAG_DEFAULT
!
      PARAMETER (STEP_TAG_DEFAULT = 0)

! Communication algorithms
      INTEGER 	STEP_NBLOCKING_ALG 
      INTEGER	STEP_BLOCKING_ALG_1
      INTEGER	STEP_BLOCKING_ALG_2
      INTEGER	STEP_BLOCKING_ALG_3
      INTEGER	STEP_BLOCKING_ALG_4
! reduction operators 
      INTEGER STEP_SUM	
      INTEGER STEP_MAX_
      INTEGER STEP_MIN_
      INTEGER STEP_PROD
      INTEGER STEP_LAND	
      INTEGER STEP_BAND
      INTEGER STEP_LOR	
      INTEGER STEP_BOR	
      INTEGER STEP_LXOR	
      INTEGER STEP_BXOR	
      INTEGER STEP_MINLOC
      INTEGER STEP_MAXLOC
!
      PARAMETER (STEP_NBLOCKING_ALG  = 0)
      PARAMETER (STEP_BLOCKING_ALG_1 = 1)
      PARAMETER (STEP_BLOCKING_ALG_2 = 2)
      PARAMETER (STEP_BLOCKING_ALG_3 = 3)
      PARAMETER (STEP_BLOCKING_ALG_4 = 4)
!
      PARAMETER (STEP_SUM  =	3)
      PARAMETER (STEP_MAX_ =	1)
      PARAMETER (STEP_MIN_ =	2)
      PARAMETER (STEP_PROD =	0)
      PARAMETER (STEP_LAND =	4)
      PARAMETER (STEP_BAND =	5)
      PARAMETER (STEP_LOR  =	6)
      PARAMETER (STEP_BOR  =	7)
      PARAMETER (STEP_LXOR =	8)
      PARAMETER (STEP_BXOR =	9)
      PARAMETER (STEP_MINLOC =	10)
      PARAMETER (STEP_MAXLOC =	11)

