

Source files copied in : matmul/Source/
Generated source files : matmul/src
###################### matmul/src/MATMULT_PAR1_DO10_HYBRID.f ######################
!!
!! file for MATMULT_PAR1_DO10_HYBRID.f
!!
      SUBROUTINE MATMULT_PAR1_DO10_HYBRID(J, J_L, J_U, I, N, A, B, C)
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      include "STEP.h"
      INTEGER STEP_J_UP, STEP_J_LOW, J_UP, J_LOW, IDX, J, J_L, J_U, I
     &, N
      INTEGER STEP_SR_C(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 1:
     &MAX_NB_LOOPSLICES), STEP_SR_B(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 
     &1:MAX_NB_LOOPSLICES), STEP_SR_A(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2
     &, 1:MAX_NB_LOOPSLICES)
      REAL*8 A(1:N, 1:N), B(1:N, 1:N), C(1:N, 1:N)

!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_DO)                                0112
      CALL STEP_GET_COMMSIZE(STEP_COMM_SIZE)                            0113
      CALL STEP_COMPUTE_LOOPSLICES(J_L, J_U, 1, STEP_COMM_SIZE)         0114

C     Put array boundaries into SEND region arrays
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

      DO IDX = 1, STEP_COMM_SIZE                                        0121
         CALL STEP_GET_LOOPBOUNDS(IDX-1, J_LOW, J_UP)                   0122
C  <A(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=N, 1<=PHI2, J_LOW<=PHI2,
C    PHI2<=J_UP, PHI2<=N}>
         STEP_SR_A(IDX_SLICE_LOW,1,IDX) = 1                             0125
         STEP_SR_A(IDX_SLICE_UP,1,IDX) = N                              0126
         STEP_SR_A(IDX_SLICE_LOW,2,IDX) = MAX(J_LOW, 1)                 0127
         STEP_SR_A(IDX_SLICE_UP,2,IDX) = MIN(J_UP, N)                   0128
C  <B(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=N, 1<=PHI2, J_LOW<=PHI2,
C    PHI2<=J_UP, PHI2<=N}>
         STEP_SR_B(IDX_SLICE_LOW,1,IDX) = 1                             0131
         STEP_SR_B(IDX_SLICE_UP,1,IDX) = N                              0132
         STEP_SR_B(IDX_SLICE_LOW,2,IDX) = MAX(J_LOW, 1)                 0133
         STEP_SR_B(IDX_SLICE_UP,2,IDX) = MIN(J_UP, N)                   0134
C  <C(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=N, 1<=PHI2, J_LOW<=PHI2,
C    PHI2<=J_UP, PHI2<=N}>
         STEP_SR_C(IDX_SLICE_LOW,1,IDX) = 1                             0137
         STEP_SR_C(IDX_SLICE_UP,1,IDX) = N                              0138
         STEP_SR_C(IDX_SLICE_LOW,2,IDX) = MAX(J_LOW, 1)                 0139
         STEP_SR_C(IDX_SLICE_UP,2,IDX) = MIN(J_UP, N)                   0140
      ENDDO
      CALL STEP_SET_SENDREGIONS(A, STEP_COMM_SIZE, STEP_SR_A)           0142
      CALL STEP_SET_SENDREGIONS(B, STEP_COMM_SIZE, STEP_SR_B)           0143
      CALL STEP_SET_SENDREGIONS(C, STEP_COMM_SIZE, STEP_SR_C)           0144

!$omp end master
!$omp barrier


C     Where work is done...
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0151
      CALL STEP_GET_LOOPBOUNDS(STEP_COMM_RANK, STEP_J_LOW, STEP_J_UP)   0152
!$OMP do
      DO 10 J = STEP_J_LOW, STEP_J_UP                                   0154
         DO 10 I = 1, N                                                 0155
            A(I,J) = 2.0                                                0156
            B(I,J) = 3.0                                                0157
            C(I,J) = 0                                                  0158
10          CONTINUE                                                    0159
!$OMP end do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
      CALL STEP_ALLTOALL_PARTIAL(A, STEP_NBLOCKING_ALG,                 0167
     &STEP_TAG_DEFAULT)                                                 0167
      CALL STEP_ALLTOALL_PARTIAL(B, STEP_NBLOCKING_ALG,                 0169
     &STEP_TAG_DEFAULT)                                                 0169
      CALL STEP_ALLTOALL_PARTIAL(C, STEP_NBLOCKING_ALG,                 0171
     &STEP_TAG_DEFAULT)                                                 0171
      CALL STEP_WAITALL                                                 0173
      CALL STEP_CONSTRUCT_END(STEP_DO)                                  0174

!$omp end master
!$omp barrier

      END
###################### matmul/src/MATMULT_PAR1_DO20_HYBRID.f ######################
!!
!! file for MATMULT_PAR1_DO20_HYBRID.f
!!
      SUBROUTINE MATMULT_PAR1_DO20_HYBRID(J, J_L, J_U, I, N, K, C, A
     &, B)
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      include "STEP.h"
      INTEGER STEP_J_UP, STEP_J_LOW, J_UP, J_LOW, IDX, J, J_L, J_U, I
     &, N, K
      INTEGER STEP_RR_C(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 1:
     &MAX_NB_LOOPSLICES), STEP_RR_B(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 
     &1:MAX_NB_LOOPSLICES), STEP_RR_A(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2
     &, 1:MAX_NB_LOOPSLICES), STEP_SR_C(IDX_SLICE_LOW:IDX_SLICE_UP, 1
     &:2, 1:MAX_NB_LOOPSLICES)
      REAL*8 C(1:N, 1:N), A(1:N, 1:N), B(1:N, 1:N)

!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_DO)                                0114
      CALL STEP_GET_COMMSIZE(STEP_COMM_SIZE)                            0115
      CALL STEP_COMPUTE_LOOPSLICES(J_L, J_U, 1, STEP_COMM_SIZE)         0116

C     Put array boundaries into RECV region arrays
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

      DO IDX = 1, STEP_COMM_SIZE                                        0123
         CALL STEP_GET_LOOPBOUNDS(IDX-1, J_LOW, J_UP)                   0124
C  <A(PHI1,PHI2)-read-EXACT-{1<=PHI1, PHI1<=N, 1<=PHI2, PHI2<=N,
C    J_LOW<=J_UP}>
         STEP_RR_A(IDX_SLICE_LOW,1,IDX) = 1                             0127
         STEP_RR_A(IDX_SLICE_UP,1,IDX) = N                              0128
         STEP_RR_A(IDX_SLICE_LOW,2,IDX) = 1                             0129
         STEP_RR_A(IDX_SLICE_UP,2,IDX) = N                              0130
C  <B(PHI1,PHI2)-read-EXACT-{1<=PHI1, PHI1<=N, J_LOW<=PHI2,
C    PHI2<=J_UP}>
         STEP_RR_B(IDX_SLICE_LOW,1,IDX) = 1                             0133
         STEP_RR_B(IDX_SLICE_UP,1,IDX) = N                              0134
         STEP_RR_B(IDX_SLICE_LOW,2,IDX) = J_LOW                         0135
         STEP_RR_B(IDX_SLICE_UP,2,IDX) = J_UP                           0136
C  <C(PHI1,PHI2)-read-EXACT-{1<=PHI1, PHI1<=N, J_LOW<=PHI2,
C    PHI2<=J_UP}>
         STEP_RR_C(IDX_SLICE_LOW,1,IDX) = 1                             0139
         STEP_RR_C(IDX_SLICE_UP,1,IDX) = N                              0140
         STEP_RR_C(IDX_SLICE_LOW,2,IDX) = J_LOW                         0141
         STEP_RR_C(IDX_SLICE_UP,2,IDX) = J_UP                           0142
      ENDDO
      CALL STEP_SET_RECVREGIONS(A, STEP_COMM_SIZE, STEP_RR_A)           0144
      CALL STEP_SET_RECVREGIONS(B, STEP_COMM_SIZE, STEP_RR_B)           0145
      CALL STEP_SET_RECVREGIONS(C, STEP_COMM_SIZE, STEP_RR_C)           0146

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
      CALL STEP_ALLTOALL_PARTIAL(A, STEP_NBLOCKING_ALG,                 0151
     &STEP_TAG_DEFAULT)                                                 0151
      CALL STEP_ALLTOALL_PARTIAL(B, STEP_NBLOCKING_ALG,                 0153
     &STEP_TAG_DEFAULT)                                                 0153
      CALL STEP_ALLTOALL_PARTIAL(C, STEP_NBLOCKING_ALG,                 0155
     &STEP_TAG_DEFAULT)                                                 0155
      CALL STEP_WAITALL                                                 0157

C     Put array boundaries into SEND region arrays
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

      DO IDX = 1, STEP_COMM_SIZE                                        0164
         CALL STEP_GET_LOOPBOUNDS(IDX-1, J_LOW, J_UP)                   0165
C  <C(PHI1,PHI2)-write-EXACT-{1<=PHI1, PHI1<=N, 1<=PHI2, J_LOW<=PHI2,
C    PHI2<=J_UP, PHI2<=N}>
         STEP_SR_C(IDX_SLICE_LOW,1,IDX) = 1                             0168
         STEP_SR_C(IDX_SLICE_UP,1,IDX) = N                              0169
         STEP_SR_C(IDX_SLICE_LOW,2,IDX) = MAX(J_LOW, 1)                 0170
         STEP_SR_C(IDX_SLICE_UP,2,IDX) = MIN(J_UP, N)                   0171
      ENDDO
      CALL STEP_SET_SENDREGIONS(C, STEP_COMM_SIZE, STEP_SR_C)           0173

!$omp end master
!$omp barrier


C     Where work is done...
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0180
      CALL STEP_GET_LOOPBOUNDS(STEP_COMM_RANK, STEP_J_LOW, STEP_J_UP)   0181
!$OMP do
      DO 20 J = STEP_J_LOW, STEP_J_UP                                   0183
         DO 20 I = 1, N                                                 0184
            DO 20 K = 1, N                                              0185
               C(I,J) = C(I,J)+A(I,K)*B(K,J)                            0186
20             CONTINUE                                                 0187
!$OMP end do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
      CALL STEP_ALLTOALL_PARTIAL(C, STEP_NBLOCKING_ALG,                 0195
     &STEP_TAG_DEFAULT)                                                 0195
      CALL STEP_WAITALL                                                 0197
      CALL STEP_CONSTRUCT_END(STEP_DO)                                  0198

!$omp end master
!$omp barrier

      END
###################### matmul/src/MATMULT_PAR1_HYBRID.f ######################
!!
!! file for MATMULT_PAR1_HYBRID.f
!!
      SUBROUTINE MATMULT_PAR1_HYBRID(J, N, I, A, B, C, K)
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      include "STEP.h"
      INTEGER J, N, I, K
      REAL*8 A(1:N, 1:N), B(1:N, 1:N), C(1:N, 1:N)

!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_PARALLEL)                          0107
      CALL STEP_INIT_ARRAYREGIONS(A, STEP_REAL8, 2, 1, N, 1, N)         0108
      CALL STEP_INIT_ARRAYREGIONS(B, STEP_REAL8, 2, 1, N, 1, N)         0109
      CALL STEP_INIT_ARRAYREGIONS(C, STEP_REAL8, 2, 1, N, 1, N)         0110

!$omp end master
!$omp barrier

!$OMP parallel
C$STEP !$omp do
      CALL MATMULT_PAR1_DO10_HYBRID(J, 1, N, I, N, A, B, C)             0117
C$STEP !$omp master
      CALL MATMULT_PAR1_MASTER1_HYBRID                                  0119
C$STEP !$omp end master
C$STEP !$omp do
      CALL MATMULT_PAR1_DO20_HYBRID(J, 1, N, I, N, K, C, A, B)          0122
C$STEP !$omp master
      CALL MATMULT_PAR1_MASTER2_HYBRID(I, N, J, C)                      0124
C$STEP !$omp end master
!$OMP end parallel

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
      CALL STEP_ALLTOALL_FULL(C, STEP_NBLOCKING_ALG, STEP_TAG_DEFAULT   0133
     &)                                                                 0133
      CALL STEP_ALLTOALL_FULL(B, STEP_NBLOCKING_ALG, STEP_TAG_DEFAULT   0135
     &)                                                                 0135
      CALL STEP_ALLTOALL_FULL(A, STEP_NBLOCKING_ALG, STEP_TAG_DEFAULT   0137
     &)                                                                 0137
      CALL STEP_WAITALL                                                 0139
      CALL STEP_CONSTRUCT_END(STEP_PARALLEL)                            0140

!$omp end master
!$omp barrier

      END
###################### matmul/src/MATMULT_PAR1_MASTER1_HYBRID.f ######################
!!
!! file for MATMULT_PAR1_MASTER1_HYBRID.f
!!
      SUBROUTINE MATMULT_PAR1_MASTER1_HYBRID
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      include "STEP.h"

!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_MASTER)                            0105
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0106
      IF (STEP_COMM_RANK.EQ.0) THEN                                     0107
         PRINT *,                                                       0108
     &   '******************************************************'       0108
         PRINT *, 'Matrices initialized'                                0110
         PRINT *,                                                       0111
     &   '******************************************************'       0111
      ENDIF
      CALL STEP_CONSTRUCT_END(STEP_MASTER)                              0114

!$omp end master
!$omp barrier

      END
###################### matmul/src/MATMULT_PAR1_MASTER2_HYBRID.f ######################
!!
!! file for MATMULT_PAR1_MASTER2_HYBRID.f
!!
      SUBROUTINE MATMULT_PAR1_MASTER2_HYBRID(I, N, J, C)
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      include "STEP.h"
      INTEGER I, N, J
      INTEGER STEP_RR_C(IDX_SLICE_LOW:IDX_SLICE_UP, 1:2)
      REAL*8 C(1:N, 1:N)

!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_MASTER)                            0108
      STEP_RR_C(IDX_SLICE_LOW,1) = 1                                    0109
      STEP_RR_C(IDX_SLICE_UP,1) = N                                     0110
      STEP_RR_C(IDX_SLICE_LOW,2) = 1                                    0111
      STEP_RR_C(IDX_SLICE_UP,2) = N                                     0112
      CALL STEP_SET_RECVREGIONS(C, 1, STEP_RR_C)                        0113

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
      CALL STEP_ALLTOMASTERREGION(C, STEP_NBLOCKING_ALG)                0118
      CALL STEP_WAITALL                                                 0119
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0120
      IF (STEP_COMM_RANK.EQ.0) THEN                                     0121
         PRINT *,                                                       0122
     &   '******************************************************'       0122
         PRINT *, 'Result Matrix:'                                      0124
         DO 50 I = 1, N                                                 0125
            DO 40 J = 1, N                                              0126
               WRITE (*, 30) C(I,J)                                     0127
30             FORMAT(2X,F8.2,$)                                        0128
40             CONTINUE                                                 0129
            PRINT *, ' '                                                0130
50          CONTINUE                                                    0131
         PRINT *,                                                       0132
     &   '******************************************************'       0132
         PRINT *, 'Done.'                                               0134
      ENDIF
      CALL STEP_CONSTRUCT_END(STEP_MASTER)                              0136

!$omp end master
!$omp barrier

      END
###################### matmul/src/Makefile ######################
#Default Makefile to compile generated files

BIN=a.out

FC=mpif77
CC=mpicc


FLAGS = -g -O2

export COMPILER = gnu
export STEP_KIND = 4

ifeq ($(COMPILER) , gnu)
   OpenMP_FLAG = -fopenmp
   export CFLAGS = $(FLAGS) -Wall
   export FFLAGS = $(FLAGS) -Wall -Wno-line-truncation -Wno-unused-variable
   ifeq ($(STEP_KIND), 8)
      FFLAGS += -fdefault-integer-8
   endif
   LDFLAGS = 
endif

ifeq ($(COMPILER) , intel)
   OpenMP_FLAG = -openmp
   export CFLAGS = $(FLAGS) -Wall
   export FFLAGS = $(FLAGS) -warn all -warn notruncated_source -warn nounused
   ifeq ($(STEP_KIND), 8)
      FFLAGS += -i8
   endif
   LDFLAGS = 
endif



CSOURCES= *.c
FSOURCES= *.f
OBJFILES= *.o

LIB_STEP=libstep.a
HEADER_F=steprt_f.h
HEADER_C=steprt_c.h
RUNTIME=c
DIR_STEP=step_rt

all: gnu 

$(BIN) : $(DIR_STEP)/$(LIB_STEP) $(OBJFILES) BIN_CRITICAL_PCOORD
	if ls  >/dev/null 2>&1 *.o ; then $(FC) $(OBJFILES) $(OpenMP_FLAG) $(LDFLAGS) -lstep -L$(DIR_STEP) -o $@; fi

BIN_CRITICAL_PCOORD: $(DIR_STEP)/critical_pcoord_program.c
	$(CC) -o $(DIR_STEP)/critical_pcoord_program  $^ 	


$(OBJFILES):
	ln -sf $(DIR_STEP)/$(HEADER_F) $(HEADER_F)
	ln -sf $(DIR_STEP)/$(HEADER_C) $(HEADER_C)
	for f in `ls *_MPI.c` ; do \
		echo $$f; \
		echo >tmp "#include \"STEP_C.h\""; \
		cat >>tmp $$f; \
		mv tmp $$f; \
	done;
	if ls  >/dev/null 2>&1 *.c ; then $(CC) $(OpenMP_FLAG) $(CFLAGS) -c $(CSOURCES); fi
	if ls  >/dev/null 2>&1 *.f ; then $(FC) $(OpenMP_FLAG) $(FFLAGS) -c $(FSOURCES); fi

$(DIR_STEP)/$(LIB_STEP):
	$(MAKE) -C $(DIR_STEP) $(LIB_STEP)

clean:
	$(MAKE) -C $(DIR_STEP) $@
	rm -f $(HEADER_F) *.o *~ *__genmod.*

clear: clean
	rm -f $(BIN)

gnu:	clear 
	export OMPI_F77=gfortran; export OMPI_FC=gfortran; export OMPI_CC=gcc; export LANG=C;  $(MAKE) $(BIN) COMPILER=gnu

intel:	clear
	export OMPI_F77=ifort; export OMPI_FC=ifort; export OMPI_CC=icc; export LANG=C;  make $(BIN) COMPILER=intel

.IGNORE: clean clear
###################### matmul/src/STEP.h ######################
      INCLUDE 'steprt_f.h'

      INTEGER STEP_COMM_SIZE, STEP_COMM_RANK

      INTEGER MAX_NB_LOOPSLICES
      PARAMETER (MAX_NB_LOOPSLICES = 16)
      
      INTEGER IDX_SLICE_LOW,IDX_SLICE_UP,STEP_IDX
      PARAMETER (IDX_SLICE_LOW = 1,IDX_SLICE_UP=2)

###################### matmul/src/matmul.f ######################
!!
!! file for matmul.f
!!
	PROGRAM MATMULT
! MIL-STD-1753 Fortran extension not in PIPS
! 	implicit none
	INTEGER  N, I, J, K
	PARAMETER (N=10)
	REAL*8 A(N,N), B(N,N), C(N,N)
      CALL STEP_INIT_FORTRAN_ORDER
C$STEP !$omp parallel
      CALL MATMULT_PAR1_HYBRID(J, N, I, A, B, C, K)
C$STEP !$omp end parallel
      CALL STEP_FINALIZE

      END
###################### matmul/src/step_directives.f ######################
!!
!! file for step_directives.f
!!
      SUBROUTINE MATMULT_PAR1(J, N, I, A, B, C, K)
      INTEGER J, N, I, K
      REAL*8 A(1:N, 1:N), B(1:N, 1:N), C(1:N, 1:N)
C$STEP !$omp do
      CALL MATMULT_PAR1_DO10_HYBRID(J, 1, N, I, N, A, B, C)             0005
C$STEP !$omp master
      CALL MATMULT_PAR1_MASTER1_HYBRID                                  0007
C$STEP !$omp end master
C$STEP !$omp do
      CALL MATMULT_PAR1_DO20_HYBRID(J, 1, N, I, N, K, C, A, B)          0010
C$STEP !$omp master
      CALL MATMULT_PAR1_MASTER2_HYBRID(I, N, J, C)                      0012
C$STEP !$omp end master
      END
      SUBROUTINE MATMULT_PAR1_MASTER2(I, N, J, C)
      INTEGER I, N, J
      REAL*8 C(1:N, 1:N)
      PRINT *,                                                          0004
     &'******************************************************'          0004
      PRINT *, 'Result Matrix:'                                         0006
      DO 50 I = 1, N                                                    0007
         DO 40 J = 1, N                                                 0008
            WRITE (*, 30) C(I,J)                                        0009
30          FORMAT(2X,F8.2,$)                                           0010
40          CONTINUE                                                    0011
         PRINT *, ' '                                                   0012
50       CONTINUE                                                       0013
      PRINT *,                                                          0014
     &'******************************************************'          0014
      PRINT *, 'Done.'                                                  0016
      END
      SUBROUTINE MATMULT_PAR1_DO20(J, J_L, J_U, I, N, K, C, A, B)
      INTEGER J, J_L, J_U, I, N, K
      REAL*8 C(1:N, 1:N), A(1:N, 1:N), B(1:N, 1:N)
      DO 20 J = J_L, J_U                                                0004
         DO 20 I = 1, N                                                 0005
            DO 20 K = 1, N                                              0006
               C(I,J) = C(I,J)+A(I,K)*B(K,J)                            0007
20             CONTINUE                                                 0008
      END
      SUBROUTINE MATMULT_PAR1_MASTER1
      PRINT *,                                                          0002
     &'******************************************************'          0002
      PRINT *, 'Matrices initialized'                                   0004
      PRINT *,                                                          0005
     &'******************************************************'          0005
      END
      SUBROUTINE MATMULT_PAR1_DO10(J, J_L, J_U, I, N, A, B, C)
      INTEGER J, J_L, J_U, I, N
      REAL*8 A(1:N, 1:N), B(1:N, 1:N), C(1:N, 1:N)
      DO 10 J = J_L, J_U                                                0004
         DO 10 I = 1, N                                                 0005
            A(I,J) = 2.0                                                0006
            B(I,J) = 3.0                                                0007
            C(I,J) = 0                                                  0008
10          CONTINUE                                                    0009
      END
###################### matmul/src/step_rt ######################
###################### matmul/src/steprt_f.h ######################
!
!   Genereted file from c/step_common.h
! 
       INTEGER STEP_C
       PARAMETER (STEP_C = 0)

       INTEGER STEP_FORTRAN
       PARAMETER (STEP_FORTRAN = 1)

       INTEGER STEP_PARALLEL
       PARAMETER (STEP_PARALLEL = 0)

       INTEGER STEP_DO
       PARAMETER (STEP_DO = 1)

       INTEGER STEP_PARALLEL_DO
       PARAMETER (STEP_PARALLEL_DO = 2)

       INTEGER STEP_NOWAIT
       PARAMETER (STEP_NOWAIT = 0)

       INTEGER STEP_WAIT
       PARAMETER (STEP_WAIT = 1)

       INTEGER STEP_INTEGER
       PARAMETER (STEP_INTEGER = 0)

       INTEGER STEP_REAL
       PARAMETER (STEP_REAL = 1)

       INTEGER STEP_DOUBLE_PRECISION
       PARAMETER (STEP_DOUBLE_PRECISION = 2)

       INTEGER STEP_COMPLEX
       PARAMETER (STEP_COMPLEX = 3)

       INTEGER STEP_INTEGER1
       PARAMETER (STEP_INTEGER1 = 4)

       INTEGER STEP_INTEGER2
       PARAMETER (STEP_INTEGER2 = 5)

       INTEGER STEP_INTEGER4
       PARAMETER (STEP_INTEGER4 = 6)

       INTEGER STEP_INTEGER8
       PARAMETER (STEP_INTEGER8 = 7)

       INTEGER STEP_REAL4
       PARAMETER (STEP_REAL4 = 8)

       INTEGER STEP_REAL8
       PARAMETER (STEP_REAL8 = 9)

       INTEGER STEP_REAL16
       PARAMETER (STEP_REAL16 = 10)

       INTEGER STEP_COMPLEX8
       PARAMETER (STEP_COMPLEX8 = 11)

       INTEGER STEP_COMPLEX16
       PARAMETER (STEP_COMPLEX16 = 12)

       INTEGER STEP_TYPE_UNDEFINED
       PARAMETER (STEP_TYPE_UNDEFINED = 13)

       INTEGER STEP_TAG_DEFAULT
       PARAMETER (STEP_TAG_DEFAULT = 0)

       INTEGER STEP_NBLOCKING_ALG
       PARAMETER (STEP_NBLOCKING_ALG = 0)

       INTEGER STEP_PROD
       PARAMETER (STEP_PROD = 0)

       INTEGER STEP_MAX
       PARAMETER (STEP_MAX = 1)

       INTEGER STEP_MIN
       PARAMETER (STEP_MIN = 2)

       INTEGER STEP_SUM
       PARAMETER (STEP_SUM = 3)

