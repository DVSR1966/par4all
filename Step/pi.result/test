###################### pi/pi.database/Src/Makefile ######################
#Default Makefile to compile generated files

BIN=a.out

FC=mpif77
CC=mpicc


FLAGS = -g -O2 -I$(DIR_STEP)

export COMPILER = gnu
export STEP_KIND = 4

ifeq ($(COMPILER) , gnu)
   OpenMP_FLAG = -fopenmp
   export CFLAGS = $(FLAGS) -Wall
   export FFLAGS = $(FLAGS) -Wall -Wno-line-truncation -Wno-unused-variable
   ifeq ($(STEP_KIND), 8)
      FFLAGS += -fdefault-integer-8
   endif
   LDFLAGS =
endif

ifeq ($(COMPILER) , intel)
   OpenMP_FLAG = -openmp
   export CFLAGS = $(FLAGS) -Wall
   export FFLAGS = $(FLAGS) -warn all -warn notruncated_source -warn nounused
   ifeq ($(STEP_KIND), 8)
      FFLAGS += -i8
   endif
   LDFLAGS =
endif



CSOURCES= *.c
FSOURCES= *.f
OBJFILES= *.o

LIB_STEP=libstep.so
DIR_STEP=step_rt

all: gnu

$(BIN) : $(DIR_STEP)/$(LIB_STEP) compile_c compile_f
	if ls  >/dev/null 2>&1 *.o ; then $(FC) $(OBJFILES) $(OpenMP_FLAG) $(LDFLAGS) -lstep -L$(DIR_STEP) -Wl,-rpath=$(DIR_STEP) -o $@; fi

compile_c: $(DIR_STEP)/step_api.h
	if ls  >/dev/null 2>&1 *.c ; then $(CC) $(OpenMP_FLAG) $(CFLAGS) -c $(CSOURCES); fi

compile_f: $(DIR_STEP)/STEP.h
	if ls  >/dev/null 2>&1 *.f ; then $(FC) $(OpenMP_FLAG) $(FFLAGS) -c $(FSOURCES); fi

$(DIR_STEP)/$(LIB_STEP):
	$(MAKE) -C $(DIR_STEP) $(LIB_STEP) STEP.h critical_pcoord_program

clean:
	$(MAKE) -C $(DIR_STEP) $@
	rm -f *.o *~ *__genmod.*

clear: clean
	rm -f $(BIN)

gnu:	clear
	export OMPI_F77=gfortran; export OMPI_FC=gfortran; export OMPI_CC=gcc; export LANG=C;  $(MAKE) $(BIN) COMPILER=gnu

intel:	clear
	export OMPI_F77=ifort; export OMPI_FC=ifort; export OMPI_CC=icc; export LANG=C;  make $(BIN) COMPILER=intel

.IGNORE: clean clear
###################### pi/pi.database/Src/PI_PARDO_HYBRID.f ######################
      SUBROUTINE PI_PARDO_HYBRID(CONTRIB, I, ITER, NUM_ITER, X)
      implicit none
      include "STEP.h"
      INTEGER IDX, STEP_COMM_RANK, STEP_I_UP, STEP_I_LOW, 
     &STEP_COMM_SIZE, I, NUM_ITER
      REAL*8 CONTRIB, ITER, X
!$omp master
      CALL STEP_CONSTRUCT_BEGIN(STEP_PARALLEL_DO)
      CALL STEP_INITREDUCTION(CONTRIB, STEP_SUM, STEP_REAL8)
      CALL STEP_GET_COMMSIZE(STEP_COMM_SIZE)
      CALL STEP_COMPUTE_LOOPSLICES(1, NUM_ITER, 1, STEP_COMM_SIZE)
!$omp end master
!$omp barrier

C BEGIN WORK
      CALL STEP_GET_RANK(STEP_COMM_RANK)
      CALL STEP_GET_LOOPBOUNDS(STEP_COMM_RANK, STEP_I_LOW, STEP_I_UP)
!$omp parallel do reduction(+: CONTRIB)

      DO I = STEP_I_LOW, STEP_I_UP
         X = (I-0.5)*ITER
         CONTRIB = CONTRIB+4.0/(1.0+X*X)
         PRINT *, I, X, CONTRIB
      ENDDO
!$omp end parallel do
C END WORK
!$omp master
      CALL STEP_REDUCTION(CONTRIB)
      CALL STEP_CONSTRUCT_END(STEP_PARALLEL_DO)
!$omp end master
!$omp barrier
      END
###################### pi/pi.database/Src/pi.f ######################
      PROGRAM PI
! MIL-STD-1753 Fortran extension not in PIPS
      implicit none
      INTEGER I, NUM_ITER
      DOUBLE PRECISION X, MY_PI, CONTRIB, ITER
      CALL STEP_INIT_FORTRAN_ORDER
      CONTRIB = 0.0
      NUM_ITER = 10
      ITER = 1.0/NUM_ITER
      CALL PI_PARDO_HYBRID(CONTRIB, I, ITER, NUM_ITER, X)

      MY_PI = ITER*CONTRIB

      PRINT *, MY_PI
      CALL STEP_FINALIZE
      END
###################### pi/pi.database/Src/step_rt ######################
