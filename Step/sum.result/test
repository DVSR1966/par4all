

Source files copied in : sum/Source/
Generated source files : sum/src
###################### sum/src/Makefile ######################
#Default Makefile to compile generated files

BIN=a.out

FC=mpif77
CC=mpicc

OpenMP_FLAG = -fopenmp

FLAGS = -g -O2
LDFLAGS = 


CSOURCES= *.c
FSOURCES= *.f
OBJFILES= *.o

LIB_STEP=libstep.a
RUNTIME=c
DIR_STEP=step_rt


$(BIN) : $(DIR_STEP)/$(LIB_STEP) $(OBJFILES)
	if ls  >/dev/null 2>&1 *.o ; then $(FC) $(OBJFILES) $(OpenMP_FLAG) $(LDFLAGS) -lstep -L$(DIR_STEP) -o $@; fi

$(OBJFILES):
	if ls  >/dev/null 2>&1 *.c ; then $(CC) $(OpenMP_FLAG) $(FLAGS) -c $(CSOURCES); fi
	if ls  >/dev/null 2>&1 *.f ; then $(FC) $(OpenMP_FLAG) $(FLAGS) -fno-underscoring -c $(FSOURCES); fi

$(DIR_STEP)/$(LIB_STEP):
	$(MAKE) -C $(DIR_STEP) $(LIB_STEP)

clean:
	$(MAKE) -C $(DIR_STEP) $@
	rm -f *.o *~


.IGNORE: clean###################### sum/src/STEP.h ######################
      INCLUDE 'steprt_f.h'

      INTEGER STEP_MAX_NBNODE
      PARAMETER (STEP_MAX_NBNODE = 16)

      INTEGER max_nb_loopslices
      INTEGER step_nbrequest

      INTEGER STEP_COMM_SIZE, STEP_COMM_RANK

      PARAMETER (MAX_NB_LOOPSLICES = STEP_MAX_NBNODE)
      
      ! Globals
       INTEGER STEP_SizeRegion
       INTEGER IDX_SLICE_LOW,IDX_SLICE_UP,STEP_IDX
       PARAMETER (IDX_SLICE_LOW = 1,IDX_SLICE_UP=2)

###################### sum/src/SUM_PARDO10_HYBRID.f ######################
!!
!! file for SUM_PARDO10_HYBRID.f
!!
      SUBROUTINE SUM_PARDO10_HYBRID(I_DUMMY, I_L, I_U, N, A, B, C)
      implicit none
      include "STEP.h"
      INTEGER*4 MAX_NB_REQUEST
      PARAMETER (MAX_NB_REQUEST = 96)
      INTEGER I_DUMMY, I, I_L, I_U, N, IDX, I_LOW, I_UP, STEP_I_LOW, 
     &STEP_I_UP
      INTEGER A(1:N, 1:2), B(1:N), C(1:N), STEP_I_LOOPSLICES(
     &IDX_SLICE_LOW:IDX_SLICE_UP, 1:MAX_NB_LOOPSLICES), STEP_SR_A(
     &IDX_SLICE_LOW:IDX_SLICE_UP, 1:2, 0:MAX_NB_LOOPSLICES), 
     &STEP_SR_B(IDX_SLICE_LOW:IDX_SLICE_UP, 1:1, 0:MAX_NB_LOOPSLICES)
     &, STEP_SR_C(IDX_SLICE_LOW:IDX_SLICE_UP, 1:1, 0:
     &MAX_NB_LOOPSLICES), STEP_REQUESTS(1:MAX_NB_REQUEST)
      CALL STEP_GET_SIZE(STEP_COMM_SIZE)                                0128
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0129

      CALL STEP_COMPUTELOOPSLICES(I_L, I_U, 1, STEP_COMM_SIZE,          0131
     &MAX_NB_LOOPSLICES, STEP_I_LOOPSLICES)                             0131

C     Put array boundaries into region arrays (SR: Send region)
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

C     The first element stores initial boundaries,
C     then one element for each process
      STEP_SR_A(IDX_SLICE_LOW,1,0) = 1                                  0141
      STEP_SR_A(IDX_SLICE_UP,1,0) = N                                   0142
      STEP_SR_A(IDX_SLICE_LOW,2,0) = 1                                  0143
      STEP_SR_A(IDX_SLICE_UP,2,0) = 2                                   0144
      STEP_SR_B(IDX_SLICE_LOW,1,0) = 1                                  0145
      STEP_SR_B(IDX_SLICE_UP,1,0) = N                                   0146
      STEP_SR_C(IDX_SLICE_LOW,1,0) = 1                                  0147
      STEP_SR_C(IDX_SLICE_UP,1,0) = N                                   0148

C     Region computation
      DO IDX = 1, STEP_COMM_SIZE                                        0151
         I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,IDX)                   0152
         I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,IDX)                     0153
C  <A(PHI1,PHI2)-write-EXACT-{I_LOW<=PHI1, 1<=PHI1, PHI1<=I_UP,
C    PHI1<=10, 1<=PHI2, PHI2<=2}>
         STEP_SR_A(IDX_SLICE_LOW,1,IDX) = MAX(I_LOW, 1)                 0156
         STEP_SR_A(IDX_SLICE_UP,1,IDX) = MIN(I_UP, 10)                  0157
         STEP_SR_A(IDX_SLICE_LOW,2,IDX) = 1                             0158
         STEP_SR_A(IDX_SLICE_UP,2,IDX) = 2                              0159
C  <B(PHI1)-write-MAY-{I_LOW<=PHI1, 1<=PHI1, PHI1<=I_UP, PHI1<=10}>
         STEP_SR_B(IDX_SLICE_LOW,1,IDX) = MAX(I_LOW, 1)                 0161
         STEP_SR_B(IDX_SLICE_UP,1,IDX) = MIN(I_UP, 10)                  0162
C  <C(PHI1)-write-MAY-{I_LOW<=PHI1, 1<=PHI1, PHI1<=I_UP, PHI1<=10}>
         STEP_SR_C(IDX_SLICE_LOW,1,IDX) = MAX(I_LOW, 1)                 0164
         STEP_SR_C(IDX_SLICE_UP,1,IDX) = MIN(I_UP, 10)                  0165
      ENDDO

C     Where work is done...
      STEP_I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,STEP_COMM_RANK+1)    0169
      STEP_I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,STEP_COMM_RANK+1)      0170
!$OMP parallel do
      DO 10 I = STEP_I_LOW, STEP_I_UP                                   0172
         A(I,1) = I                                                     0173
         A(I,2) = 2*I                                                   0174
         B(I) = I*10                                                    0175
         C(I) = 0                                                       0176
10       CONTINUE                                                       0177
!$OMP end parallel do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
C     A nonblocking algo increment STEP_Nb_Request.
      STEP_NBREQUEST = 0                                                0186
      CALL STEP_ALLTOALLREGION(2, STEP_COMM_SIZE, STEP_SR_A,            0187
     &STEP_SIZEREGION(2, STEP_SR_A(IDX_SLICE_LOW,1,0)), A,              0187
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0187
     &, STEP_NBLOCKING_ALG, STEP_INTEGER4)                              0187
      CALL STEP_ALLTOALLREGION(1, STEP_COMM_SIZE, STEP_SR_B,            0191
     &STEP_SIZEREGION(1, STEP_SR_B(IDX_SLICE_LOW,1,0)), B,              0191
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0191
     &, STEP_NBLOCKING_ALG, STEP_INTEGER4)                              0191
      CALL STEP_ALLTOALLREGION(1, STEP_COMM_SIZE, STEP_SR_C,            0195
     &STEP_SIZEREGION(1, STEP_SR_C(IDX_SLICE_LOW,1,0)), C,              0195
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0195
     &, STEP_NBLOCKING_ALG, STEP_INTEGER4)                              0195
C     If STEP_Nb_Request equals 0, STEP_WAITALL does nothing
      CALL STEP_WAITALL(STEP_NBREQUEST, STEP_REQUESTS)                  0200

!$omp end master
!$omp barrier

      END
###################### sum/src/SUM_PARDO20_HYBRID.f ######################
!!
!! file for SUM_PARDO20_HYBRID.f
!!
      SUBROUTINE SUM_PARDO20_HYBRID(I_DUMMY, I_L, I_U, N, C, A, B)
      implicit none
      include "STEP.h"
      INTEGER*4 MAX_NB_REQUEST
      PARAMETER (MAX_NB_REQUEST = 32)
      INTEGER I_DUMMY, I, I_L, I_U, N, IDX, I_LOW, I_UP, STEP_I_LOW, 
     &STEP_I_UP
      INTEGER C(1:N), A(1:N, 1:2), B(1:N), STEP_I_LOOPSLICES(
     &IDX_SLICE_LOW:IDX_SLICE_UP, 1:MAX_NB_LOOPSLICES), STEP_SR_C(
     &IDX_SLICE_LOW:IDX_SLICE_UP, 1:1, 0:MAX_NB_LOOPSLICES), 
     &STEP_REQUESTS(1:MAX_NB_REQUEST)
      CALL STEP_GET_SIZE(STEP_COMM_SIZE)                                0126
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0127

      CALL STEP_COMPUTELOOPSLICES(I_L, I_U, 1, STEP_COMM_SIZE,          0129
     &MAX_NB_LOOPSLICES, STEP_I_LOOPSLICES)                             0129

C     Put array boundaries into region arrays (SR: Send region)
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

C     The first element stores initial boundaries,
C     then one element for each process
      STEP_SR_C(IDX_SLICE_LOW,1,0) = 1                                  0139
      STEP_SR_C(IDX_SLICE_UP,1,0) = N                                   0140

C     Region computation
      DO IDX = 1, STEP_COMM_SIZE                                        0143
         I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,IDX)                   0144
         I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,IDX)                     0145
C  <C(PHI1)-write-EXACT-{I_LOW<=PHI1, 2<=PHI1, PHI1<=I_UP, PHI1<=10}>
         STEP_SR_C(IDX_SLICE_LOW,1,IDX) = MAX(I_LOW, 2)                 0147
         STEP_SR_C(IDX_SLICE_UP,1,IDX) = MIN(I_UP, 10)                  0148
      ENDDO

C     Where work is done...
      STEP_I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,STEP_COMM_RANK+1)    0152
      STEP_I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,STEP_COMM_RANK+1)      0153
!$OMP parallel do
      DO 20 I = STEP_I_LOW, STEP_I_UP                                   0155
         C(I) = A(I-1,1)+A(I,1)+B(I)                                    0156
20       CONTINUE                                                       0157
!$OMP end parallel do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
C     A nonblocking algo increment STEP_Nb_Request.
      STEP_NBREQUEST = 0                                                0166
      CALL STEP_ALLTOALLREGION(1, STEP_COMM_SIZE, STEP_SR_C,            0167
     &STEP_SIZEREGION(1, STEP_SR_C(IDX_SLICE_LOW,1,0)), C,              0167
     &STEP_TAG_DEFAULT, MAX_NB_REQUEST, STEP_REQUESTS, STEP_NBREQUEST   0167
     &, STEP_NBLOCKING_ALG, STEP_INTEGER4)                              0167
C     If STEP_Nb_Request equals 0, STEP_WAITALL does nothing
      CALL STEP_WAITALL(STEP_NBREQUEST, STEP_REQUESTS)                  0172

!$omp end master
!$omp barrier

      END
###################### sum/src/SUM_PARDO30_HYBRID.f ######################
!!
!! file for SUM_PARDO30_HYBRID.f
!!
      SUBROUTINE SUM_PARDO30_HYBRID(I_DUMMY, I_L, I_U, N, B)
      implicit none
      include "STEP.h"
      INTEGER*4 MAX_NB_REQUEST
      PARAMETER (MAX_NB_REQUEST = 32)
      INTEGER I_DUMMY, I, I_L, I_U, N, IDX, I_LOW, I_UP, STEP_I_LOW, 
     &STEP_I_UP
      INTEGER B(1:N), STEP_INITIAL_B(1:N), STEP_BUFFER_B(1:N), 
     &STEP_I_LOOPSLICES(IDX_SLICE_LOW:IDX_SLICE_UP, 1:
     &MAX_NB_LOOPSLICES), STEP_SR_B(IDX_SLICE_LOW:IDX_SLICE_UP, 1:1, 
     &0:MAX_NB_LOOPSLICES), STEP_REQUESTS(1:MAX_NB_REQUEST)
      CALL STEP_GET_SIZE(STEP_COMM_SIZE)                                0126
      CALL STEP_GET_RANK(STEP_COMM_RANK)                                0127
      CALL STEP_INITINTERLACED(1*(N-1+1), B, STEP_INITIAL_B,            0128
     &STEP_BUFFER_B, STEP_INTEGER4)                                     0128

      CALL STEP_COMPUTELOOPSLICES(I_L, I_U, 1, STEP_COMM_SIZE,          0131
     &MAX_NB_LOOPSLICES, STEP_I_LOOPSLICES)                             0131

C     Put array boundaries into region arrays (SR: Send region)
C     First dimension: lower and upper bounds of each slice
C     Second dimension: for each dimension of the original array
C     Third dimension: store the boundaries of the local chunk.

C     The first element stores initial boundaries,
C     then one element for each process
      STEP_SR_B(IDX_SLICE_LOW,1,0) = 1                                  0141
      STEP_SR_B(IDX_SLICE_UP,1,0) = N                                   0142

C     Region computation
      DO IDX = 1, STEP_COMM_SIZE                                        0145
         I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,IDX)                   0146
         I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,IDX)                     0147
C  <B(PHI1)-write-MAY-{1<=PHI1, PHI1<=10}>
         STEP_SR_B(IDX_SLICE_LOW,1,IDX) = 1                             0149
         STEP_SR_B(IDX_SLICE_UP,1,IDX) = 10                             0150
      ENDDO

C     Where work is done...
      STEP_I_LOW = STEP_I_LOOPSLICES(IDX_SLICE_LOW,STEP_COMM_RANK+1)    0154
      STEP_I_UP = STEP_I_LOOPSLICES(IDX_SLICE_UP,STEP_COMM_RANK+1)      0155
!$OMP parallel do
      DO 30 I = STEP_I_LOW, STEP_I_UP                                   0157
         B(I) = I                                                       0158
         B(N+1-I) = I                                                   0159
30       CONTINUE                                                       0160
!$OMP end parallel do

!$omp master

C     Communicating data to other nodes
C     3 communication shemes for all-to-all personalized broadcast :
C     STEP_NONBLOCKING, STEP_BLOCKING1 and STEP_BLOCKING2.
C     A nonblocking algo increment STEP_Nb_Request.
      STEP_NBREQUEST = 0                                                0169
      CALL STEP_ALLTOALLREGION_MERGE(1, STEP_COMM_SIZE, STEP_SR_B,      0170
     &STEP_SIZEREGION(1, STEP_SR_B(IDX_SLICE_LOW,1,0)), B,              0170
     &STEP_INITIAL_B, STEP_BUFFER_B, STEP_TAG_DEFAULT, MAX_NB_REQUEST   0170
     &, STEP_REQUESTS, STEP_NBREQUEST, STEP_NBLOCKING_ALG,              0170
     &STEP_INTEGER4)                                                    0170
C     If STEP_Nb_Request equals 0, STEP_WAITALL does nothing
      CALL STEP_WAITALL(STEP_NBREQUEST, STEP_REQUESTS)                  0176

!$omp end master
!$omp barrier

      END
###################### sum/src/step_rt ######################
###################### sum/src/steprt_f.h ######################
!*******************************************************************************
!*                                                                             *
!*   Authors 	        :       Abdellah. Kouadri                              *
!*				Daniel Millot                          	       *
!*                              Frederique Silber-Chaussumier                  *
!*				                                               *
!*   Date		:       25/06/2009                                     *
!*						                               *
!*   File		:	steprt_f.h                                     *
!*							                       *
!*   Version		:       1.1				               *
!*   Description	:	Fortran runtime interface                      *
! ******************************************************************************



! Datatype
      INTEGER STEP_INTEGER1
      INTEGER STEP_INTEGER2
      INTEGER STEP_INTEGER4
      INTEGER STEP_INTEGER8
      INTEGER STEP_REAL4
      INTEGER STEP_REAL8
      INTEGER STEP_REAL16
      INTEGER STEP_COMPLEX8
      INTEGER STEP_COMPLEX16
      INTEGER STEP_COMPLEX32
      INTEGER STEP_INTEGER
      INTEGER STEP_REAL
      INTEGER STEP_COMPLEX
      INTEGER STEP_DOUBLE_PRECISION
!
      PARAMETER (STEP_INTEGER1 = 1)
      PARAMETER (STEP_INTEGER2 = 2)
      PARAMETER (STEP_INTEGER4 = 3)
      PARAMETER (STEP_INTEGER8 = 4)
      PARAMETER (STEP_REAL4 = 5)
      PARAMETER (STEP_REAL8 = 6)
      PARAMETER (STEP_REAL16 = 7)
      PARAMETER (STEP_COMPLEX8 = 8)
      PARAMETER (STEP_COMPLEX16 = 9)
      PARAMETER (STEP_COMPLEX32 = 10)
      PARAMETER (STEP_INTEGER = 11)
      PARAMETER (STEP_REAL = 12)
      PARAMETER (STEP_COMPLEX = 13)
      PARAMETER (STEP_DOUBLE_PRECISION = 14)

! Communication tag
      INTEGER   STEP_TAG_DEFAULT
!
      PARAMETER (STEP_TAG_DEFAULT = 0)

! Communication algorithms
      INTEGER 	STEP_NBLOCKING_ALG 
      INTEGER	STEP_BLOCKING_ALG_1
      INTEGER	STEP_BLOCKING_ALG_2
      INTEGER	STEP_BLOCKING_ALG_3
      INTEGER	STEP_BLOCKING_ALG_4
! reduction operators 
      INTEGER STEP_SUM	
      INTEGER STEP_MAX_
      INTEGER STEP_MIN_
      INTEGER STEP_PROD
      INTEGER STEP_LAND	
      INTEGER STEP_BAND
      INTEGER STEP_LOR	
      INTEGER STEP_BOR	
      INTEGER STEP_LXOR	
      INTEGER STEP_BXOR	
      INTEGER STEP_MINLOC
      INTEGER STEP_MAXLOC
!
      PARAMETER (STEP_NBLOCKING_ALG  = 0)
      PARAMETER (STEP_BLOCKING_ALG_1 = 1)
      PARAMETER (STEP_BLOCKING_ALG_2 = 2)
      PARAMETER (STEP_BLOCKING_ALG_3 = 3)
      PARAMETER (STEP_BLOCKING_ALG_4 = 4)
!
      PARAMETER (STEP_SUM  =	3)
      PARAMETER (STEP_MAX_ =	1)
      PARAMETER (STEP_MIN_ =	2)
      PARAMETER (STEP_PROD =	0)
      PARAMETER (STEP_LAND =	4)
      PARAMETER (STEP_BAND =	5)
      PARAMETER (STEP_LOR  =	6)
      PARAMETER (STEP_BOR  =	7)
      PARAMETER (STEP_LXOR =	8)
      PARAMETER (STEP_BXOR =	9)
      PARAMETER (STEP_MINLOC =	10)
      PARAMETER (STEP_MAXLOC =	11)

###################### sum/src/sum.f ######################
!!
!! file for sum.f
!!
!
! sum program
!
! Example of a do directive
!
! 2007,2008
! Creation: A. Muller, 2007
! Modification: F. Silber-Chaussumier

      PROGRAM SUM
      implicit none
      INTEGER N
      PARAMETER (N=10)
      INTEGER I,A(N,2),B(N),C(N)
      CALL STEP_INIT_FORTRAN_ORDER

      DO 5 I = 1, N                                                     0017
         A(I,1) = 0                                                     0018
         A(I,2) = 0                                                     0019
         B(I) = 0                                                       0020
         C(I) = -1                                                      0021
5        CONTINUE                                                       0022
C$STEP !$omp parallel do
      CALL SUM_PARDO10_HYBRID(I, 1, N, N, A, B, C)
C$STEP !$omp parallel do
      CALL SUM_PARDO20_HYBRID(I, 2, N, N, C, A, B)
C$STEP !$omp parallel do
      CALL SUM_PARDO30_HYBRID(I, 1, N/2, N, B)



      PRINT *, A                                                        0044
      PRINT *, B                                                        0045
      PRINT *, C                                                        0046
      CALL STEP_FINALIZE
      END
