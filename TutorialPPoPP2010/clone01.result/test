
Source code with transformers


C  T(clone01) {n<=clone01+1, clone01<=n+1}

int clone01(int n, int s)
{
   int r = n;                                                           /*0004*/

//  T(r) {n==r#init, r<=n+1, n<=r+1}

   if (s<0)                                                             /*0005*/

//  T(r) {n==r+1, n==r#init, s+1<=0}

      r = n-1;                                                          /*0006*/
   else if (s>0)                                                        /*0005*/

//  T(r) {n==r-1, n==r#init, 1<=s}

      r = n+1;                                                          /*0008*/

//  T(clone01) {clone01==r, n<=clone01+1, clone01<=n+1}


   return r;                                                            /*0010*/
}

Source code with preconditions


//  P() {}

int main()
{
   int i = 1;                                                           /*0014*/

//  P() {i==1}

   i = clone01(i, -1);                                                  /*0015*/

//  P(i) {0<=i, i<=2}

   i = clone01(i, 1);                                                   /*0016*/

//  P(i) {0<=i+1, i<=3}

   i = clone01(i, 0);                                                   /*0017*/
}
# new callgraph
 main
     clone01_0
     clone01_1
     clone01_2
# new codes.

//  P() {0==-1}

int clone01(int n, int s)
{
   int r = n;                                                           /*0004*/

//  P() {0==-1}

   if (s<0)                                                             /*0005*/

//  P() {0==-1}

      r = n-1;                                                          /*0006*/
   else if (s>0)                                                        /*0005*/

//  P() {0==-1}

      r = n+1;                                                          /*0008*/

//  P() {0==-1}


   return r;                                                            /*0010*/
}

//  P() {n==1, s==-1}

int clone01_0(int n, int s)
{

//  P() {n==1, r==1, s==-1}

   //!! PIPS: s is assumed a constant reaching value
   if (s!=-1)                                                           /*0013*/

//  P() {0==-1}

      exit(0);                                                          /*0014*/
   {
      int r = n;                                                        /*0016*/

//  P() {n==1, r==1, s==-1}

      /*0004*/
      if (s<0)                                                          /*0017*/

//  P() {n==1, r==1, s==-1}

         /*0005*/
         r = n-1;                                                       /*0018*/
      else if (s>0)                                                     /*0017*/

//  P() {0==-1}

         /*0005*/
         r = n+1;                                                       /*0020*/

//  P(r) {n==1, r==0, s==-1}

      /*0008*/
      
      return r;                                                         /*0022*/
   }
}

//  P() {n==0, s==1}

int clone01_1(int n, int s)
{

//  P() {n==0, r==0, s==1}

   //!! PIPS: s is assumed a constant reaching value
   if (s!=1)                                                            /*0013*/

//  P() {0==-1}

      exit(0);                                                          /*0014*/
   {
      int r = n;                                                        /*0016*/

//  P() {n==0, r==0, s==1}

      /*0004*/
      if (s<0)                                                          /*0017*/

//  P() {0==-1}

         /*0005*/
         r = n-1;                                                       /*0018*/
      else if (s>0)                                                     /*0017*/

//  P() {n==0, r==0, s==1}

         /*0005*/
         r = n+1;                                                       /*0020*/

//  P(r) {n==0, r==1, s==1}

      /*0008*/
      
      return r;                                                         /*0022*/
   }
}

//  P() {n==1, s==0}

int clone01_2(int n, int s)
{

//  P() {n==1, r==1, s==0}

   //!! PIPS: s is assumed a constant reaching value
   if (s!=0)                                                            /*0013*/

//  P() {0==-1}

      exit(0);                                                          /*0014*/
   {
      int r = n;                                                        /*0016*/

//  P() {n==1, r==1, s==0}

      /*0004*/
      if (s<0)                                                          /*0017*/

//  P() {0==-1}

         /*0005*/
         r = n-1;                                                       /*0018*/
      else if (s>0)                                                     /*0017*/

//  P() {0==-1}

         /*0005*/
         r = n+1;                                                       /*0020*/

//  P() {n==1, r==1, s==0}

      /*0008*/
      
      return r;                                                         /*0022*/
   }
}

//  P() {}

int main()
{
   int i = 1;                                                           /*0014*/

//  P() {i==1}

   i = clone01_0(i, -1);                                                /*0015*/

//  P(i) {i==0}

   i = clone01_1(i, 1);                                                 /*0016*/

//  P(i) {i==1}

   i = clone01_2(i, 0);                                                 /*0017*/
}
# applying partial evaluation...
# applying dead code elimination...

//  P() {0==-1}

int clone01(int n, int s)
{
   ;
}

//  P() {}

int clone01_0(int n, int s)
{
   {
      //!! PIPS: s is assumed a constant reaching value
      /*0004*/
      /*0005*/
      int r = 1;                                                        /*0016*/

//  P() {r==1}

      //êìÛ
      r = 0;                                                            /*0018*/

//  P(r) {r==0}

      /*0008*/
      
      return 0;                                                         /*0022*/
   }
}

//  P() {}

int clone01_1(int n, int s)
{
   {
      //!! PIPS: s is assumed a constant reaching value
      /*0004*/
      /*0005*/
      int r = 0;                                                        /*0016*/

//  P() {r==0}

      //F
      r = 1;                                                            /*0020*/

//  P(r) {r==1}

      /*0008*/
      
      return 1;                                                         /*0022*/
   }
}

//  P() {}

int clone01_2(int n, int s)
{
   {
      //!! PIPS: s is assumed a constant reaching value
      /*0004*/
      /*0008*/
      
      int r = 1;                                                        /*0016*/

//  P() {r==1}

      //V
      return 1;                                                         /*0022*/
   }
}

//  P() {}

int main()
{
   int i = 1;                                                           /*0014*/

//  P() {i==1}

   i = clone01_0(i, -1);                                                /*0015*/

//  P(i) {i==0}

   i = clone01_1(i, 1);                                                 /*0016*/

//  P(i) {i==1}

   i = clone01_2(i, 0);                                                 /*0017*/
   ;
}
